var k8 = Object.defineProperty;
var _8 = (n, e, t) =>
  e in n
    ? k8(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
    : (n[e] = t);
var $ = (n, e, t) => (_8(n, typeof e != "symbol" ? e + "" : e, t), t),
  vy = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  };
var rl = (n, e, t) => (
    vy(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  al = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  il = (n, e, t, r) => (
    vy(n, e, "write to private field"), r ? r.call(n, t) : e.set(n, t), t
  );
import {
  k as O,
  l as z,
  v as S8,
  m as Ue,
  n as P8,
  o as ae,
  p as w2,
  q as xn,
  t as nt,
  w as pe,
  x as ht,
  y as Ge,
  z as Ve,
  A as Mt,
  C as ir,
  D as Te,
  E as ai,
  G as sa,
  H as _h,
  I as Yo,
  J as Zn,
  K as T2,
  M as Nc,
  O as au,
  P as Ie,
  R as Bd,
  S as Ff,
  r as C,
  j as I,
  T as Fl,
  U as C2,
  B as aa,
  V as wy,
  W as vo,
  X as fi,
  b as A2,
  Y as Fc,
  Z as Ae,
  _ as Re,
  $ as Lc,
  a0 as dp,
  a1 as Sh,
  a2 as I8,
  a3 as Xt,
  a4 as R8,
  a5 as M8,
  a6 as wo,
} from "./index-aff6404b.js";
import { z as M, I as B8 } from "./index-35d0d874.js";
import { a as Ty, b as Ba } from "./constants-ed7a1b25.js";
import "./hoist-non-react-statics.cjs-434f601a.js";
import { p as E2 } from "./Helmet-bfad690c.js";
const fn = new z(S8),
  jo = {},
  k2 = O.from(0),
  _2 = O.from(-1);
function S2(n, e, t, r) {
  const a = { fault: e, operation: t };
  return (
    r !== void 0 && (a.value = r), fn.throwError(n, z.errors.NUMERIC_FAULT, a)
  );
}
let zo = "0";
for (; zo.length < 256; ) zo += zo;
function Ph(n) {
  if (typeof n != "number")
    try {
      n = O.from(n).toNumber();
    } catch {}
  return typeof n == "number" && n >= 0 && n <= 256 && !(n % 1)
    ? "1" + zo.substring(0, n)
    : fn.throwArgumentError("invalid decimal size", "decimals", n);
}
function Ll(n, e) {
  e == null && (e = 0);
  const t = Ph(e);
  n = O.from(n);
  const r = n.lt(k2);
  r && (n = n.mul(_2));
  let a = n.mod(t).toString();
  for (; a.length < t.length - 1; ) a = "0" + a;
  a = a.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const i = n.div(t).toString();
  return t.length === 1 ? (n = i) : (n = i + "." + a), r && (n = "-" + n), n;
}
function Ar(n, e) {
  e == null && (e = 0);
  const t = Ph(e);
  (typeof n != "string" || !n.match(/^-?[0-9.]+$/)) &&
    fn.throwArgumentError("invalid decimal value", "value", n);
  const r = n.substring(0, 1) === "-";
  r && (n = n.substring(1)),
    n === "." && fn.throwArgumentError("missing value", "value", n);
  const a = n.split(".");
  a.length > 2 && fn.throwArgumentError("too many decimal points", "value", n);
  let i = a[0],
    s = a[1];
  for (i || (i = "0"), s || (s = "0"); s[s.length - 1] === "0"; )
    s = s.substring(0, s.length - 1);
  for (
    s.length > t.length - 1 &&
      S2("fractional component exceeds decimals", "underflow", "parseFixed"),
      s === "" && (s = "0");
    s.length < t.length - 1;

  )
    s += "0";
  const o = O.from(i),
    c = O.from(s);
  let l = o.mul(t).add(c);
  return r && (l = l.mul(_2)), l;
}
class Ts {
  constructor(e, t, r, a) {
    e !== jo &&
      fn.throwError(
        "cannot use FixedFormat constructor; use FixedFormat.from",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "new FixedFormat" },
      ),
      (this.signed = t),
      (this.width = r),
      (this.decimals = a),
      (this.name = (t ? "" : "u") + "fixed" + String(r) + "x" + String(a)),
      (this._multiplier = Ph(a)),
      Object.freeze(this);
  }
  static from(e) {
    if (e instanceof Ts) return e;
    typeof e == "number" && (e = `fixed128x${e}`);
    let t = !0,
      r = 128,
      a = 18;
    if (typeof e == "string") {
      if (e !== "fixed")
        if (e === "ufixed") t = !1;
        else {
          const i = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          i || fn.throwArgumentError("invalid fixed format", "format", e),
            (t = i[1] !== "u"),
            (r = parseInt(i[2])),
            (a = parseInt(i[3]));
        }
    } else if (e) {
      const i = (s, o, c) =>
        e[s] == null
          ? c
          : (typeof e[s] !== o &&
              fn.throwArgumentError(
                "invalid fixed format (" + s + " not " + o + ")",
                "format." + s,
                e[s],
              ),
            e[s]);
      (t = i("signed", "boolean", t)),
        (r = i("width", "number", r)),
        (a = i("decimals", "number", a));
    }
    return (
      r % 8 &&
        fn.throwArgumentError(
          "invalid fixed format width (not byte aligned)",
          "format.width",
          r,
        ),
      a > 80 &&
        fn.throwArgumentError(
          "invalid fixed format (decimals too large)",
          "format.decimals",
          a,
        ),
      new Ts(jo, t, r, a)
    );
  }
}
class $t {
  constructor(e, t, r, a) {
    e !== jo &&
      fn.throwError(
        "cannot use FixedNumber constructor; use FixedNumber.from",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "new FixedFormat" },
      ),
      (this.format = a),
      (this._hex = t),
      (this._value = r),
      (this._isFixedNumber = !0),
      Object.freeze(this);
  }
  _checkFormat(e) {
    this.format.name !== e.format.name &&
      fn.throwArgumentError(
        "incompatible format; use fixedNumber.toFormat",
        "other",
        e,
      );
  }
  addUnsafe(e) {
    this._checkFormat(e);
    const t = Ar(this._value, this.format.decimals),
      r = Ar(e._value, e.format.decimals);
    return $t.fromValue(t.add(r), this.format.decimals, this.format);
  }
  subUnsafe(e) {
    this._checkFormat(e);
    const t = Ar(this._value, this.format.decimals),
      r = Ar(e._value, e.format.decimals);
    return $t.fromValue(t.sub(r), this.format.decimals, this.format);
  }
  mulUnsafe(e) {
    this._checkFormat(e);
    const t = Ar(this._value, this.format.decimals),
      r = Ar(e._value, e.format.decimals);
    return $t.fromValue(
      t.mul(r).div(this.format._multiplier),
      this.format.decimals,
      this.format,
    );
  }
  divUnsafe(e) {
    this._checkFormat(e);
    const t = Ar(this._value, this.format.decimals),
      r = Ar(e._value, e.format.decimals);
    return $t.fromValue(
      t.mul(this.format._multiplier).div(r),
      this.format.decimals,
      this.format,
    );
  }
  floor() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let t = $t.from(e[0], this.format);
    const r = !e[1].match(/^(0*)$/);
    return (
      this.isNegative() && r && (t = t.subUnsafe(Cy.toFormat(t.format))), t
    );
  }
  ceiling() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let t = $t.from(e[0], this.format);
    const r = !e[1].match(/^(0*)$/);
    return (
      !this.isNegative() && r && (t = t.addUnsafe(Cy.toFormat(t.format))), t
    );
  }
  round(e) {
    e == null && (e = 0);
    const t = this.toString().split(".");
    if (
      (t.length === 1 && t.push("0"),
      (e < 0 || e > 80 || e % 1) &&
        fn.throwArgumentError("invalid decimal count", "decimals", e),
      t[1].length <= e)
    )
      return this;
    const r = $t.from("1" + zo.substring(0, e), this.format),
      a = D8.toFormat(this.format);
    return this.mulUnsafe(r).addUnsafe(a).floor().divUnsafe(r);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(e) {
    if (e == null) return this._hex;
    e % 8 && fn.throwArgumentError("invalid byte width", "width", e);
    const t = O.from(this._hex)
      .fromTwos(this.format.width)
      .toTwos(e)
      .toHexString();
    return Ue(t, e / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(e) {
    return $t.fromString(this._value, e);
  }
  static fromValue(e, t, r) {
    return (
      r == null && t != null && !P8(t) && ((r = t), (t = null)),
      t == null && (t = 0),
      r == null && (r = "fixed"),
      $t.fromString(Ll(e, t), Ts.from(r))
    );
  }
  static fromString(e, t) {
    t == null && (t = "fixed");
    const r = Ts.from(t),
      a = Ar(e, r.decimals);
    !r.signed &&
      a.lt(k2) &&
      S2("unsigned value cannot be negative", "overflow", "value", e);
    let i = null;
    r.signed
      ? (i = a.toTwos(r.width).toHexString())
      : ((i = a.toHexString()), (i = Ue(i, r.width / 8)));
    const s = Ll(a, r.decimals);
    return new $t(jo, i, s, r);
  }
  static fromBytes(e, t) {
    t == null && (t = "fixed");
    const r = Ts.from(t);
    if (ae(e).length > r.width / 8) throw new Error("overflow");
    let a = O.from(e);
    r.signed && (a = a.fromTwos(r.width));
    const i = a.toTwos((r.signed ? 0 : 1) + r.width).toHexString(),
      s = Ll(a, r.decimals);
    return new $t(jo, i, s, r);
  }
  static from(e, t) {
    if (typeof e == "string") return $t.fromString(e, t);
    if (w2(e)) return $t.fromBytes(e, t);
    try {
      return $t.fromValue(e, 0, t);
    } catch (r) {
      if (r.code !== z.errors.INVALID_ARGUMENT) throw r;
    }
    return fn.throwArgumentError("invalid FixedNumber value", "value", e);
  }
  static isFixedNumber(e) {
    return !!(e && e._isFixedNumber);
  }
}
const Cy = $t.from(1),
  D8 = $t.from("0.5"),
  O8 = "properties/5.7.0";
var N8 =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const iu = new z(O8);
function Q(n, e, t) {
  Object.defineProperty(n, e, { enumerable: !0, value: t, writable: !1 });
}
function tn(n, e) {
  for (let t = 0; t < 32; t++) {
    if (n[e]) return n[e];
    if (!n.prototype || typeof n.prototype != "object") break;
    n = Object.getPrototypeOf(n.prototype).constructor;
  }
  return null;
}
function bt(n) {
  return N8(this, void 0, void 0, function* () {
    const e = Object.keys(n).map((r) => {
      const a = n[r];
      return Promise.resolve(a).then((i) => ({ key: r, value: i }));
    });
    return (yield Promise.all(e)).reduce(
      (r, a) => ((r[a.key] = a.value), r),
      {},
    );
  });
}
function P2(n, e) {
  (!n || typeof n != "object") &&
    iu.throwArgumentError("invalid object", "object", n),
    Object.keys(n).forEach((t) => {
      e[t] ||
        iu.throwArgumentError(
          "invalid object key - " + t,
          "transaction:" + t,
          n,
        );
    });
}
function rt(n) {
  const e = {};
  for (const t in n) e[t] = n[t];
  return e;
}
const F8 = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function I2(n) {
  if (n == null || F8[typeof n]) return !0;
  if (Array.isArray(n) || typeof n == "object") {
    if (!Object.isFrozen(n)) return !1;
    const e = Object.keys(n);
    for (let t = 0; t < e.length; t++) {
      let r = null;
      try {
        r = n[e[t]];
      } catch {
        continue;
      }
      if (!I2(r)) return !1;
    }
    return !0;
  }
  return iu.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n);
}
function L8(n) {
  if (I2(n)) return n;
  if (Array.isArray(n)) return Object.freeze(n.map((e) => hn(e)));
  if (typeof n == "object") {
    const e = {};
    for (const t in n) {
      const r = n[t];
      r !== void 0 && Q(e, t, hn(r));
    }
    return e;
  }
  return iu.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n);
}
function hn(n) {
  return L8(n);
}
class ji {
  constructor(e) {
    for (const t in e) this[t] = hn(e[t]);
  }
}
const $c = "abi/5.7.0",
  De = new z($c),
  Ri = {};
let Ay = { calldata: !0, memory: !0, storage: !0 },
  $8 = { calldata: !0, memory: !0 };
function sl(n, e) {
  if (n === "bytes" || n === "string") {
    if (Ay[e]) return !0;
  } else if (n === "address") {
    if (e === "payable") return !0;
  } else if ((n.indexOf("[") >= 0 || n === "tuple") && $8[e]) return !0;
  return (
    (Ay[e] || e === "payable") &&
      De.throwArgumentError("invalid modifier", "name", e),
    !1
  );
}
function W8(n, e) {
  let t = n;
  function r(o) {
    De.throwArgumentError(`unexpected character at position ${o}`, "param", n);
  }
  n = n.replace(/\s/g, " ");
  function a(o) {
    let c = { type: "", name: "", parent: o, state: { allowType: !0 } };
    return e && (c.indexed = !1), c;
  }
  let i = { type: "", name: "", state: { allowType: !0 } },
    s = i;
  for (let o = 0; o < n.length; o++) {
    let c = n[o];
    switch (c) {
      case "(":
        s.state.allowType && s.type === ""
          ? (s.type = "tuple")
          : s.state.allowParams || r(o),
          (s.state.allowType = !1),
          (s.type = ds(s.type)),
          (s.components = [a(s)]),
          (s = s.components[0]);
        break;
      case ")":
        delete s.state,
          s.name === "indexed" && (e || r(o), (s.indexed = !0), (s.name = "")),
          sl(s.type, s.name) && (s.name = ""),
          (s.type = ds(s.type));
        let l = s;
        (s = s.parent),
          s || r(o),
          delete l.parent,
          (s.state.allowParams = !1),
          (s.state.allowName = !0),
          (s.state.allowArray = !0);
        break;
      case ",":
        delete s.state,
          s.name === "indexed" && (e || r(o), (s.indexed = !0), (s.name = "")),
          sl(s.type, s.name) && (s.name = ""),
          (s.type = ds(s.type));
        let u = a(s.parent);
        s.parent.components.push(u), delete s.parent, (s = u);
        break;
      case " ":
        s.state.allowType &&
          s.type !== "" &&
          ((s.type = ds(s.type)),
          delete s.state.allowType,
          (s.state.allowName = !0),
          (s.state.allowParams = !0)),
          s.state.allowName &&
            s.name !== "" &&
            (s.name === "indexed"
              ? (e || r(o), s.indexed && r(o), (s.indexed = !0), (s.name = ""))
              : sl(s.type, s.name)
              ? (s.name = "")
              : (s.state.allowName = !1));
        break;
      case "[":
        s.state.allowArray || r(o),
          (s.type += c),
          (s.state.allowArray = !1),
          (s.state.allowName = !1),
          (s.state.readArray = !0);
        break;
      case "]":
        s.state.readArray || r(o),
          (s.type += c),
          (s.state.readArray = !1),
          (s.state.allowArray = !0),
          (s.state.allowName = !0);
        break;
      default:
        s.state.allowType
          ? ((s.type += c),
            (s.state.allowParams = !0),
            (s.state.allowArray = !0))
          : s.state.allowName
          ? ((s.name += c), delete s.state.allowArray)
          : s.state.readArray
          ? (s.type += c)
          : r(o);
    }
  }
  return (
    s.parent && De.throwArgumentError("unexpected eof", "param", n),
    delete i.state,
    s.name === "indexed"
      ? (e || r(t.length - 7),
        s.indexed && r(t.length - 7),
        (s.indexed = !0),
        (s.name = ""))
      : sl(s.type, s.name) && (s.name = ""),
    (i.type = ds(i.type)),
    i
  );
}
function $l(n, e) {
  for (let t in e) Q(n, t, e[t]);
}
const We = Object.freeze({
    sighash: "sighash",
    minimal: "minimal",
    full: "full",
    json: "json",
  }),
  U8 = new RegExp(/^(.*)\[([0-9]*)\]$/);
class kt {
  constructor(e, t) {
    e !== Ri &&
      De.throwError("use fromString", z.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()",
      }),
      $l(this, t);
    let r = this.type.match(U8);
    r
      ? $l(this, {
          arrayLength: parseInt(r[2] || "-1"),
          arrayChildren: kt.fromObject({
            type: r[1],
            components: this.components,
          }),
          baseType: "array",
        })
      : $l(this, {
          arrayLength: null,
          arrayChildren: null,
          baseType: this.components != null ? "tuple" : this.type,
        }),
      (this._isParamType = !0),
      Object.freeze(this);
  }
  format(e) {
    if (
      (e || (e = We.sighash),
      We[e] || De.throwArgumentError("invalid format type", "format", e),
      e === We.json)
    ) {
      let r = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0,
      };
      return (
        typeof this.indexed == "boolean" && (r.indexed = this.indexed),
        this.components &&
          (r.components = this.components.map((a) => JSON.parse(a.format(e)))),
        JSON.stringify(r)
      );
    }
    let t = "";
    return (
      this.baseType === "array"
        ? ((t += this.arrayChildren.format(e)),
          (t +=
            "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]"))
        : this.baseType === "tuple"
        ? (e !== We.sighash && (t += this.type),
          (t +=
            "(" +
            this.components
              .map((r) => r.format(e))
              .join(e === We.full ? ", " : ",") +
            ")"))
        : (t += this.type),
      e !== We.sighash &&
        (this.indexed === !0 && (t += " indexed"),
        e === We.full && this.name && (t += " " + this.name)),
      t
    );
  }
  static from(e, t) {
    return typeof e == "string" ? kt.fromString(e, t) : kt.fromObject(e);
  }
  static fromObject(e) {
    return kt.isParamType(e)
      ? e
      : new kt(Ri, {
          name: e.name || null,
          type: ds(e.type),
          indexed: e.indexed == null ? null : !!e.indexed,
          components: e.components ? e.components.map(kt.fromObject) : null,
        });
  }
  static fromString(e, t) {
    function r(a) {
      return kt.fromObject({
        name: a.name,
        type: a.type,
        indexed: a.indexed,
        components: a.components,
      });
    }
    return r(W8(e, !!t));
  }
  static isParamType(e) {
    return !!(e != null && e._isParamType);
  }
}
function Jo(n, e) {
  return z8(n).map((t) => kt.fromString(t, e));
}
class ia {
  constructor(e, t) {
    e !== Ri &&
      De.throwError(
        "use a static from method",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "new Fragment()" },
      ),
      $l(this, t),
      (this._isFragment = !0),
      Object.freeze(this);
  }
  static from(e) {
    return ia.isFragment(e)
      ? e
      : typeof e == "string"
      ? ia.fromString(e)
      : ia.fromObject(e);
  }
  static fromObject(e) {
    if (ia.isFragment(e)) return e;
    switch (e.type) {
      case "function":
        return Ir.fromObject(e);
      case "event":
        return ra.fromObject(e);
      case "constructor":
        return Pr.fromObject(e);
      case "error":
        return Pa.fromObject(e);
      case "fallback":
      case "receive":
        return null;
    }
    return De.throwArgumentError("invalid fragment object", "value", e);
  }
  static fromString(e) {
    return (
      (e = e.replace(/\s/g, " ")),
      (e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")),
      (e = e.trim()),
      e.split(" ")[0] === "event"
        ? ra.fromString(e.substring(5).trim())
        : e.split(" ")[0] === "function"
        ? Ir.fromString(e.substring(8).trim())
        : e.split("(")[0].trim() === "constructor"
        ? Pr.fromString(e.trim())
        : e.split(" ")[0] === "error"
        ? Pa.fromString(e.substring(5).trim())
        : De.throwArgumentError("unsupported fragment", "value", e)
    );
  }
  static isFragment(e) {
    return !!(e && e._isFragment);
  }
}
class ra extends ia {
  format(e) {
    if (
      (e || (e = We.sighash),
      We[e] || De.throwArgumentError("invalid format type", "format", e),
      e === We.json)
    )
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
      });
    let t = "";
    return (
      e !== We.sighash && (t += "event "),
      (t +=
        this.name +
        "(" +
        this.inputs.map((r) => r.format(e)).join(e === We.full ? ", " : ",") +
        ") "),
      e !== We.sighash && this.anonymous && (t += "anonymous "),
      t.trim()
    );
  }
  static from(e) {
    return typeof e == "string" ? ra.fromString(e) : ra.fromObject(e);
  }
  static fromObject(e) {
    if (ra.isEventFragment(e)) return e;
    e.type !== "event" &&
      De.throwArgumentError("invalid event object", "value", e);
    const t = {
      name: Xo(e.name),
      anonymous: e.anonymous,
      inputs: e.inputs ? e.inputs.map(kt.fromObject) : [],
      type: "event",
    };
    return new ra(Ri, t);
  }
  static fromString(e) {
    let t = e.match(Zo);
    t || De.throwArgumentError("invalid event string", "value", e);
    let r = !1;
    return (
      t[3].split(" ").forEach((a) => {
        switch (a.trim()) {
          case "anonymous":
            r = !0;
            break;
          case "":
            break;
          default:
            De.warn("unknown modifier: " + a);
        }
      }),
      ra.fromObject({
        name: t[1].trim(),
        anonymous: r,
        inputs: Jo(t[2], !0),
        type: "event",
      })
    );
  }
  static isEventFragment(e) {
    return e && e._isFragment && e.type === "event";
  }
}
function R2(n, e) {
  e.gas = null;
  let t = n.split("@");
  return t.length !== 1
    ? (t.length > 2 &&
        De.throwArgumentError(
          "invalid human-readable ABI signature",
          "value",
          n,
        ),
      t[1].match(/^[0-9]+$/) ||
        De.throwArgumentError(
          "invalid human-readable ABI signature gas",
          "value",
          n,
        ),
      (e.gas = O.from(t[1])),
      t[0])
    : n;
}
function M2(n, e) {
  (e.constant = !1),
    (e.payable = !1),
    (e.stateMutability = "nonpayable"),
    n.split(" ").forEach((t) => {
      switch (t.trim()) {
        case "constant":
          e.constant = !0;
          break;
        case "payable":
          (e.payable = !0), (e.stateMutability = "payable");
          break;
        case "nonpayable":
          (e.payable = !1), (e.stateMutability = "nonpayable");
          break;
        case "pure":
          (e.constant = !0), (e.stateMutability = "pure");
          break;
        case "view":
          (e.constant = !0), (e.stateMutability = "view");
          break;
        case "external":
        case "public":
        case "":
          break;
        default:
          console.log("unknown modifier: " + t);
      }
    });
}
function B2(n) {
  let e = { constant: !1, payable: !0, stateMutability: "payable" };
  return (
    n.stateMutability != null
      ? ((e.stateMutability = n.stateMutability),
        (e.constant =
          e.stateMutability === "view" || e.stateMutability === "pure"),
        n.constant != null &&
          !!n.constant !== e.constant &&
          De.throwArgumentError(
            "cannot have constant function with mutability " +
              e.stateMutability,
            "value",
            n,
          ),
        (e.payable = e.stateMutability === "payable"),
        n.payable != null &&
          !!n.payable !== e.payable &&
          De.throwArgumentError(
            "cannot have payable function with mutability " + e.stateMutability,
            "value",
            n,
          ))
      : n.payable != null
      ? ((e.payable = !!n.payable),
        n.constant == null &&
          !e.payable &&
          n.type !== "constructor" &&
          De.throwArgumentError(
            "unable to determine stateMutability",
            "value",
            n,
          ),
        (e.constant = !!n.constant),
        e.constant
          ? (e.stateMutability = "view")
          : (e.stateMutability = e.payable ? "payable" : "nonpayable"),
        e.payable &&
          e.constant &&
          De.throwArgumentError(
            "cannot have constant payable function",
            "value",
            n,
          ))
      : n.constant != null
      ? ((e.constant = !!n.constant),
        (e.payable = !e.constant),
        (e.stateMutability = e.constant ? "view" : "payable"))
      : n.type !== "constructor" &&
        De.throwArgumentError(
          "unable to determine stateMutability",
          "value",
          n,
        ),
    e
  );
}
class Pr extends ia {
  format(e) {
    if (
      (e || (e = We.sighash),
      We[e] || De.throwArgumentError("invalid format type", "format", e),
      e === We.json)
    )
      return JSON.stringify({
        type: "constructor",
        stateMutability:
          this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
      });
    e === We.sighash &&
      De.throwError(
        "cannot format a constructor for sighash",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "format(sighash)" },
      );
    let t =
      "constructor(" +
      this.inputs.map((r) => r.format(e)).join(e === We.full ? ", " : ",") +
      ") ";
    return (
      this.stateMutability &&
        this.stateMutability !== "nonpayable" &&
        (t += this.stateMutability + " "),
      t.trim()
    );
  }
  static from(e) {
    return typeof e == "string" ? Pr.fromString(e) : Pr.fromObject(e);
  }
  static fromObject(e) {
    if (Pr.isConstructorFragment(e)) return e;
    e.type !== "constructor" &&
      De.throwArgumentError("invalid constructor object", "value", e);
    let t = B2(e);
    t.constant &&
      De.throwArgumentError("constructor cannot be constant", "value", e);
    const r = {
      name: null,
      type: e.type,
      inputs: e.inputs ? e.inputs.map(kt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? O.from(e.gas) : null,
    };
    return new Pr(Ri, r);
  }
  static fromString(e) {
    let t = { type: "constructor" };
    e = R2(e, t);
    let r = e.match(Zo);
    return (
      (!r || r[1].trim() !== "constructor") &&
        De.throwArgumentError("invalid constructor string", "value", e),
      (t.inputs = Jo(r[2].trim(), !1)),
      M2(r[3].trim(), t),
      Pr.fromObject(t)
    );
  }
  static isConstructorFragment(e) {
    return e && e._isFragment && e.type === "constructor";
  }
}
class Ir extends Pr {
  format(e) {
    if (
      (e || (e = We.sighash),
      We[e] || De.throwArgumentError("invalid format type", "format", e),
      e === We.json)
    )
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability:
          this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        outputs: this.outputs.map((r) => JSON.parse(r.format(e))),
      });
    let t = "";
    return (
      e !== We.sighash && (t += "function "),
      (t +=
        this.name +
        "(" +
        this.inputs.map((r) => r.format(e)).join(e === We.full ? ", " : ",") +
        ") "),
      e !== We.sighash &&
        (this.stateMutability
          ? this.stateMutability !== "nonpayable" &&
            (t += this.stateMutability + " ")
          : this.constant && (t += "view "),
        this.outputs &&
          this.outputs.length &&
          (t +=
            "returns (" +
            this.outputs.map((r) => r.format(e)).join(", ") +
            ") "),
        this.gas != null && (t += "@" + this.gas.toString() + " ")),
      t.trim()
    );
  }
  static from(e) {
    return typeof e == "string" ? Ir.fromString(e) : Ir.fromObject(e);
  }
  static fromObject(e) {
    if (Ir.isFunctionFragment(e)) return e;
    e.type !== "function" &&
      De.throwArgumentError("invalid function object", "value", e);
    let t = B2(e);
    const r = {
      type: e.type,
      name: Xo(e.name),
      constant: t.constant,
      inputs: e.inputs ? e.inputs.map(kt.fromObject) : [],
      outputs: e.outputs ? e.outputs.map(kt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? O.from(e.gas) : null,
    };
    return new Ir(Ri, r);
  }
  static fromString(e) {
    let t = { type: "function" };
    e = R2(e, t);
    let r = e.split(" returns ");
    r.length > 2 &&
      De.throwArgumentError("invalid function string", "value", e);
    let a = r[0].match(Zo);
    if (
      (a || De.throwArgumentError("invalid function signature", "value", e),
      (t.name = a[1].trim()),
      t.name && Xo(t.name),
      (t.inputs = Jo(a[2], !1)),
      M2(a[3].trim(), t),
      r.length > 1)
    ) {
      let i = r[1].match(Zo);
      (i[1].trim() != "" || i[3].trim() != "") &&
        De.throwArgumentError("unexpected tokens", "value", e),
        (t.outputs = Jo(i[2], !1));
    } else t.outputs = [];
    return Ir.fromObject(t);
  }
  static isFunctionFragment(e) {
    return e && e._isFragment && e.type === "function";
  }
}
function Ey(n) {
  const e = n.format();
  return (
    (e === "Error(string)" || e === "Panic(uint256)") &&
      De.throwArgumentError(
        `cannot specify user defined ${e} error`,
        "fragment",
        n,
      ),
    n
  );
}
class Pa extends ia {
  format(e) {
    if (
      (e || (e = We.sighash),
      We[e] || De.throwArgumentError("invalid format type", "format", e),
      e === We.json)
    )
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
      });
    let t = "";
    return (
      e !== We.sighash && (t += "error "),
      (t +=
        this.name +
        "(" +
        this.inputs.map((r) => r.format(e)).join(e === We.full ? ", " : ",") +
        ") "),
      t.trim()
    );
  }
  static from(e) {
    return typeof e == "string" ? Pa.fromString(e) : Pa.fromObject(e);
  }
  static fromObject(e) {
    if (Pa.isErrorFragment(e)) return e;
    e.type !== "error" &&
      De.throwArgumentError("invalid error object", "value", e);
    const t = {
      type: e.type,
      name: Xo(e.name),
      inputs: e.inputs ? e.inputs.map(kt.fromObject) : [],
    };
    return Ey(new Pa(Ri, t));
  }
  static fromString(e) {
    let t = { type: "error" },
      r = e.match(Zo);
    return (
      r || De.throwArgumentError("invalid error signature", "value", e),
      (t.name = r[1].trim()),
      t.name && Xo(t.name),
      (t.inputs = Jo(r[2], !1)),
      Ey(Pa.fromObject(t))
    );
  }
  static isErrorFragment(e) {
    return e && e._isFragment && e.type === "error";
  }
}
function ds(n) {
  return (
    n.match(/^uint($|[^1-9])/)
      ? (n = "uint256" + n.substring(4))
      : n.match(/^int($|[^1-9])/) && (n = "int256" + n.substring(3)),
    n
  );
}
const j8 = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function Xo(n) {
  return (
    (!n || !n.match(j8)) &&
      De.throwArgumentError(`invalid identifier "${n}"`, "value", n),
    n
  );
}
const Zo = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function z8(n) {
  n = n.trim();
  let e = [],
    t = "",
    r = 0;
  for (let a = 0; a < n.length; a++) {
    let i = n[a];
    i === "," && r === 0
      ? (e.push(t), (t = ""))
      : ((t += i),
        i === "("
          ? r++
          : i === ")" &&
            (r--,
            r === -1 &&
              De.throwArgumentError("unbalanced parenthesis", "value", n)));
  }
  return t && e.push(t), e;
}
const Ih = new z($c);
function H8(n) {
  const e = [],
    t = function (r, a) {
      if (Array.isArray(a))
        for (let i in a) {
          const s = r.slice();
          s.push(i);
          try {
            t(s, a[i]);
          } catch (o) {
            e.push({ path: s, error: o });
          }
        }
    };
  return t([], n), e;
}
class ma {
  constructor(e, t, r, a) {
    (this.name = e), (this.type = t), (this.localName = r), (this.dynamic = a);
  }
  _throwError(e, t) {
    Ih.throwArgumentError(e, this.localName, t);
  }
}
class fp {
  constructor(e) {
    Q(this, "wordSize", e || 32),
      (this._data = []),
      (this._dataLength = 0),
      (this._padding = new Uint8Array(e));
  }
  get data() {
    return xn(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(e) {
    return this._data.push(e), (this._dataLength += e.length), e.length;
  }
  appendWriter(e) {
    return this._writeData(nt(e._data));
  }
  writeBytes(e) {
    let t = ae(e);
    const r = t.length % this.wordSize;
    return r && (t = nt([t, this._padding.slice(r)])), this._writeData(t);
  }
  _getValue(e) {
    let t = ae(O.from(e));
    return (
      t.length > this.wordSize &&
        Ih.throwError("value out-of-bounds", z.errors.BUFFER_OVERRUN, {
          length: this.wordSize,
          offset: t.length,
        }),
      t.length % this.wordSize &&
        (t = nt([this._padding.slice(t.length % this.wordSize), t])),
      t
    );
  }
  writeValue(e) {
    return this._writeData(this._getValue(e));
  }
  writeUpdatableValue() {
    const e = this._data.length;
    return (
      this._data.push(this._padding),
      (this._dataLength += this.wordSize),
      (t) => {
        this._data[e] = this._getValue(t);
      }
    );
  }
}
class su {
  constructor(e, t, r, a) {
    Q(this, "_data", ae(e)),
      Q(this, "wordSize", t || 32),
      Q(this, "_coerceFunc", r),
      Q(this, "allowLoose", a),
      (this._offset = 0);
  }
  get data() {
    return pe(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(e, t) {
    let r = e.match("^u?int([0-9]+)$");
    return r && parseInt(r[1]) <= 48 && (t = t.toNumber()), t;
  }
  coerce(e, t) {
    return this._coerceFunc ? this._coerceFunc(e, t) : su.coerce(e, t);
  }
  _peekBytes(e, t, r) {
    let a = Math.ceil(t / this.wordSize) * this.wordSize;
    return (
      this._offset + a > this._data.length &&
        (this.allowLoose && r && this._offset + t <= this._data.length
          ? (a = t)
          : Ih.throwError("data out-of-bounds", z.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + a,
            })),
      this._data.slice(this._offset, this._offset + a)
    );
  }
  subReader(e) {
    return new su(
      this._data.slice(this._offset + e),
      this.wordSize,
      this._coerceFunc,
      this.allowLoose,
    );
  }
  readBytes(e, t) {
    let r = this._peekBytes(0, e, !!t);
    return (this._offset += r.length), r.slice(0, e);
  }
  readValue() {
    return O.from(this.readBytes(this.wordSize));
  }
}
class q8 extends ma {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, t) {
    try {
      t = ht(t);
    } catch (r) {
      this._throwError(r.message, t);
    }
    return e.writeValue(t);
  }
  decode(e) {
    return ht(Ue(e.readValue().toHexString(), 20));
  }
}
class V8 extends ma {
  constructor(e) {
    super(e.name, e.type, void 0, e.dynamic), (this.coder = e);
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, t) {
    return this.coder.encode(e, t);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
const hs = new z($c);
function D2(n, e, t) {
  let r = null;
  if (Array.isArray(t)) r = t;
  else if (t && typeof t == "object") {
    let c = {};
    r = e.map((l) => {
      const u = l.localName;
      return (
        u ||
          hs.throwError(
            "cannot encode object for signature with missing names",
            z.errors.INVALID_ARGUMENT,
            { argument: "values", coder: l, value: t },
          ),
        c[u] &&
          hs.throwError(
            "cannot encode object for signature with duplicate names",
            z.errors.INVALID_ARGUMENT,
            { argument: "values", coder: l, value: t },
          ),
        (c[u] = !0),
        t[u]
      );
    });
  } else hs.throwArgumentError("invalid tuple value", "tuple", t);
  e.length !== r.length &&
    hs.throwArgumentError("types/value length mismatch", "tuple", t);
  let a = new fp(n.wordSize),
    i = new fp(n.wordSize),
    s = [];
  e.forEach((c, l) => {
    let u = r[l];
    if (c.dynamic) {
      let d = i.length;
      c.encode(i, u);
      let f = a.writeUpdatableValue();
      s.push((p) => {
        f(p + d);
      });
    } else c.encode(a, u);
  }),
    s.forEach((c) => {
      c(a.length);
    });
  let o = n.appendWriter(a);
  return (o += n.appendWriter(i)), o;
}
function O2(n, e) {
  let t = [],
    r = n.subReader(0);
  e.forEach((i) => {
    let s = null;
    if (i.dynamic) {
      let o = n.readValue(),
        c = r.subReader(o.toNumber());
      try {
        s = i.decode(c);
      } catch (l) {
        if (l.code === z.errors.BUFFER_OVERRUN) throw l;
        (s = l),
          (s.baseType = i.name),
          (s.name = i.localName),
          (s.type = i.type);
      }
    } else
      try {
        s = i.decode(n);
      } catch (o) {
        if (o.code === z.errors.BUFFER_OVERRUN) throw o;
        (s = o),
          (s.baseType = i.name),
          (s.name = i.localName),
          (s.type = i.type);
      }
    s != null && t.push(s);
  });
  const a = e.reduce((i, s) => {
    const o = s.localName;
    return o && (i[o] || (i[o] = 0), i[o]++), i;
  }, {});
  e.forEach((i, s) => {
    let o = i.localName;
    if (!o || a[o] !== 1 || (o === "length" && (o = "_length"), t[o] != null))
      return;
    const c = t[s];
    c instanceof Error
      ? Object.defineProperty(t, o, {
          enumerable: !0,
          get: () => {
            throw c;
          },
        })
      : (t[o] = c);
  });
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    s instanceof Error &&
      Object.defineProperty(t, i, {
        enumerable: !0,
        get: () => {
          throw s;
        },
      });
  }
  return Object.freeze(t);
}
class G8 extends ma {
  constructor(e, t, r) {
    const a = e.type + "[" + (t >= 0 ? t : "") + "]",
      i = t === -1 || e.dynamic;
    super("array", a, r, i), (this.coder = e), (this.length = t);
  }
  defaultValue() {
    const e = this.coder.defaultValue(),
      t = [];
    for (let r = 0; r < this.length; r++) t.push(e);
    return t;
  }
  encode(e, t) {
    Array.isArray(t) || this._throwError("expected array value", t);
    let r = this.length;
    r === -1 && ((r = t.length), e.writeValue(t.length)),
      hs.checkArgumentCount(
        t.length,
        r,
        "coder array" + (this.localName ? " " + this.localName : ""),
      );
    let a = [];
    for (let i = 0; i < t.length; i++) a.push(this.coder);
    return D2(e, a, t);
  }
  decode(e) {
    let t = this.length;
    t === -1 &&
      ((t = e.readValue().toNumber()),
      t * 32 > e._data.length &&
        hs.throwError("insufficient data length", z.errors.BUFFER_OVERRUN, {
          length: e._data.length,
          count: t,
        }));
    let r = [];
    for (let a = 0; a < t; a++) r.push(new V8(this.coder));
    return e.coerce(this.name, O2(e, r));
  }
}
class K8 extends ma {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, t) {
    return e.writeValue(t ? 1 : 0);
  }
  decode(e) {
    return e.coerce(this.type, !e.readValue().isZero());
  }
}
class N2 extends ma {
  constructor(e, t) {
    super(e, e, t, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, t) {
    t = ae(t);
    let r = e.writeValue(t.length);
    return (r += e.writeBytes(t)), r;
  }
  decode(e) {
    return e.readBytes(e.readValue().toNumber(), !0);
  }
}
class Q8 extends N2 {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return e.coerce(this.name, pe(super.decode(e)));
  }
}
class Y8 extends ma {
  constructor(e, t) {
    let r = "bytes" + String(e);
    super(r, r, t, !1), (this.size = e);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
      0,
      2 + this.size * 2,
    );
  }
  encode(e, t) {
    let r = ae(t);
    return (
      r.length !== this.size && this._throwError("incorrect data length", t),
      e.writeBytes(r)
    );
  }
  decode(e) {
    return e.coerce(this.name, pe(e.readBytes(this.size)));
  }
}
class J8 extends ma {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, t) {
    return t != null && this._throwError("not null", t), e.writeBytes([]);
  }
  decode(e) {
    return e.readBytes(0), e.coerce(this.name, null);
  }
}
const X8 = O.from(-1),
  F2 = O.from(0),
  Z8 = O.from(1),
  On = O.from(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
  ),
  L2 = "0x0000000000000000000000000000000000000000000000000000000000000000";
class e3 extends ma {
  constructor(e, t, r) {
    const a = (t ? "int" : "uint") + e * 8;
    super(a, a, r, !1), (this.size = e), (this.signed = t);
  }
  defaultValue() {
    return 0;
  }
  encode(e, t) {
    let r = O.from(t),
      a = On.mask(e.wordSize * 8);
    if (this.signed) {
      let i = a.mask(this.size * 8 - 1);
      (r.gt(i) || r.lt(i.add(Z8).mul(X8))) &&
        this._throwError("value out-of-bounds", t);
    } else
      (r.lt(F2) || r.gt(a.mask(this.size * 8))) &&
        this._throwError("value out-of-bounds", t);
    return (
      (r = r.toTwos(this.size * 8).mask(this.size * 8)),
      this.signed && (r = r.fromTwos(this.size * 8).toTwos(8 * e.wordSize)),
      e.writeValue(r)
    );
  }
  decode(e) {
    let t = e.readValue().mask(this.size * 8);
    return (
      this.signed && (t = t.fromTwos(this.size * 8)), e.coerce(this.name, t)
    );
  }
}
const t3 = "strings/5.7.0",
  $2 = new z(t3);
var Va;
(function (n) {
  (n.current = ""),
    (n.NFC = "NFC"),
    (n.NFD = "NFD"),
    (n.NFKC = "NFKC"),
    (n.NFKD = "NFKD");
})(Va || (Va = {}));
var Rn;
(function (n) {
  (n.UNEXPECTED_CONTINUE = "unexpected continuation byte"),
    (n.BAD_PREFIX = "bad codepoint prefix"),
    (n.OVERRUN = "string overrun"),
    (n.MISSING_CONTINUE = "missing continuation byte"),
    (n.OUT_OF_RANGE = "out of UTF-8 range"),
    (n.UTF16_SURROGATE = "UTF-16 surrogate"),
    (n.OVERLONG = "overlong representation");
})(Rn || (Rn = {}));
function n3(n, e, t, r, a) {
  return $2.throwArgumentError(
    `invalid codepoint at offset ${e}; ${n}`,
    "bytes",
    t,
  );
}
function W2(n, e, t, r, a) {
  if (n === Rn.BAD_PREFIX || n === Rn.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let s = e + 1; s < t.length && t[s] >> 6 === 2; s++) i++;
    return i;
  }
  return n === Rn.OVERRUN ? t.length - e - 1 : 0;
}
function r3(n, e, t, r, a) {
  return n === Rn.OVERLONG ? (r.push(a), 0) : (r.push(65533), W2(n, e, t));
}
const a3 = Object.freeze({ error: n3, ignore: W2, replace: r3 });
function U2(n, e) {
  e == null && (e = a3.error), (n = ae(n));
  const t = [];
  let r = 0;
  for (; r < n.length; ) {
    const a = n[r++];
    if (!(a >> 7)) {
      t.push(a);
      continue;
    }
    let i = null,
      s = null;
    if ((a & 224) === 192) (i = 1), (s = 127);
    else if ((a & 240) === 224) (i = 2), (s = 2047);
    else if ((a & 248) === 240) (i = 3), (s = 65535);
    else {
      (a & 192) === 128
        ? (r += e(Rn.UNEXPECTED_CONTINUE, r - 1, n, t))
        : (r += e(Rn.BAD_PREFIX, r - 1, n, t));
      continue;
    }
    if (r - 1 + i >= n.length) {
      r += e(Rn.OVERRUN, r - 1, n, t);
      continue;
    }
    let o = a & ((1 << (8 - i - 1)) - 1);
    for (let c = 0; c < i; c++) {
      let l = n[r];
      if ((l & 192) != 128) {
        (r += e(Rn.MISSING_CONTINUE, r, n, t)), (o = null);
        break;
      }
      (o = (o << 6) | (l & 63)), r++;
    }
    if (o !== null) {
      if (o > 1114111) {
        r += e(Rn.OUT_OF_RANGE, r - 1 - i, n, t, o);
        continue;
      }
      if (o >= 55296 && o <= 57343) {
        r += e(Rn.UTF16_SURROGATE, r - 1 - i, n, t, o);
        continue;
      }
      if (o <= s) {
        r += e(Rn.OVERLONG, r - 1 - i, n, t, o);
        continue;
      }
      t.push(o);
    }
  }
  return t;
}
function Ne(n, e = Va.current) {
  e != Va.current && ($2.checkNormalize(), (n = n.normalize(e)));
  let t = [];
  for (let r = 0; r < n.length; r++) {
    const a = n.charCodeAt(r);
    if (a < 128) t.push(a);
    else if (a < 2048) t.push((a >> 6) | 192), t.push((a & 63) | 128);
    else if ((a & 64512) == 55296) {
      r++;
      const i = n.charCodeAt(r);
      if (r >= n.length || (i & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const s = 65536 + ((a & 1023) << 10) + (i & 1023);
      t.push((s >> 18) | 240),
        t.push(((s >> 12) & 63) | 128),
        t.push(((s >> 6) & 63) | 128),
        t.push((s & 63) | 128);
    } else
      t.push((a >> 12) | 224),
        t.push(((a >> 6) & 63) | 128),
        t.push((a & 63) | 128);
  }
  return ae(t);
}
function i3(n) {
  return n
    .map((e) =>
      e <= 65535
        ? String.fromCharCode(e)
        : ((e -= 65536),
          String.fromCharCode(((e >> 10) & 1023) + 55296, (e & 1023) + 56320)),
    )
    .join("");
}
function zi(n, e) {
  return i3(U2(n, e));
}
function s3(n, e = Va.current) {
  return U2(Ne(n, e));
}
function ol(n) {
  const e = Ne(n);
  if (e.length > 31)
    throw new Error("bytes32 string must be less than 32 bytes");
  return pe(nt([e, L2]).slice(0, 32));
}
class o3 extends N2 {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, t) {
    return super.encode(e, Ne(t));
  }
  decode(e) {
    return zi(super.decode(e));
  }
}
class cl extends ma {
  constructor(e, t) {
    let r = !1;
    const a = [];
    e.forEach((s) => {
      s.dynamic && (r = !0), a.push(s.type);
    });
    const i = "tuple(" + a.join(",") + ")";
    super("tuple", i, t, r), (this.coders = e);
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((r) => {
      e.push(r.defaultValue());
    });
    const t = this.coders.reduce((r, a) => {
      const i = a.localName;
      return i && (r[i] || (r[i] = 0), r[i]++), r;
    }, {});
    return (
      this.coders.forEach((r, a) => {
        let i = r.localName;
        !i ||
          t[i] !== 1 ||
          (i === "length" && (i = "_length"), e[i] == null && (e[i] = e[a]));
      }),
      Object.freeze(e)
    );
  }
  encode(e, t) {
    return D2(e, this.coders, t);
  }
  decode(e) {
    return e.coerce(this.name, O2(e, this.coders));
  }
}
const ll = new z($c),
  c3 = new RegExp(/^bytes([0-9]*)$/),
  l3 = new RegExp(/^(u?int)([0-9]*)$/);
class u3 {
  constructor(e) {
    Q(this, "coerceFunc", e || null);
  }
  _getCoder(e) {
    switch (e.baseType) {
      case "address":
        return new q8(e.name);
      case "bool":
        return new K8(e.name);
      case "string":
        return new o3(e.name);
      case "bytes":
        return new Q8(e.name);
      case "array":
        return new G8(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
      case "tuple":
        return new cl(
          (e.components || []).map((r) => this._getCoder(r)),
          e.name,
        );
      case "":
        return new J8(e.name);
    }
    let t = e.type.match(l3);
    if (t) {
      let r = parseInt(t[2] || "256");
      return (
        (r === 0 || r > 256 || r % 8 !== 0) &&
          ll.throwArgumentError("invalid " + t[1] + " bit length", "param", e),
        new e3(r / 8, t[1] === "int", e.name)
      );
    }
    if (((t = e.type.match(c3)), t)) {
      let r = parseInt(t[1]);
      return (
        (r === 0 || r > 32) &&
          ll.throwArgumentError("invalid bytes length", "param", e),
        new Y8(r, e.name)
      );
    }
    return ll.throwArgumentError("invalid type", "type", e.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(e, t) {
    return new su(e, this._getWordSize(), this.coerceFunc, t);
  }
  _getWriter() {
    return new fp(this._getWordSize());
  }
  getDefaultValue(e) {
    const t = e.map((a) => this._getCoder(kt.from(a)));
    return new cl(t, "_").defaultValue();
  }
  encode(e, t) {
    e.length !== t.length &&
      ll.throwError("types/values length mismatch", z.errors.INVALID_ARGUMENT, {
        count: { types: e.length, values: t.length },
        value: { types: e, values: t },
      });
    const r = e.map((s) => this._getCoder(kt.from(s))),
      a = new cl(r, "_"),
      i = this._getWriter();
    return a.encode(i, t), i.data;
  }
  decode(e, t, r) {
    const a = e.map((s) => this._getCoder(kt.from(s)));
    return new cl(a, "_").decode(this._getReader(ae(t), r));
  }
}
const Ga = new u3();
function wn(n) {
  return Ge(Ne(n));
}
const j2 = "hash/5.7.0";
function z2(n) {
  n = atob(n);
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n.charCodeAt(t));
  return ae(e);
}
function H2(n) {
  n = ae(n);
  let e = "";
  for (let t = 0; t < n.length; t++) e += String.fromCharCode(n[t]);
  return btoa(e);
}
function q2(n, e) {
  e == null && (e = 1);
  const t = [],
    r = t.forEach,
    a = function (i, s) {
      r.call(i, function (o) {
        s > 0 && Array.isArray(o) ? a(o, s - 1) : t.push(o);
      });
    };
  return a(n, e), t;
}
function d3(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = n[t];
    e[r[0]] = r[1];
  }
  return e;
}
function f3(n) {
  let e = 0;
  function t() {
    return (n[e++] << 8) | n[e++];
  }
  let r = t(),
    a = 1,
    i = [0, 1];
  for (let A = 1; A < r; A++) i.push((a += t()));
  let s = t(),
    o = e;
  e += s;
  let c = 0,
    l = 0;
  function u() {
    return c == 0 && ((l = (l << 8) | n[e++]), (c = 8)), (l >> --c) & 1;
  }
  const d = 31,
    f = Math.pow(2, d),
    p = f >>> 1,
    m = p >> 1,
    y = f - 1;
  let h = 0;
  for (let A = 0; A < d; A++) h = (h << 1) | u();
  let g = [],
    v = 0,
    w = f;
  for (;;) {
    let A = Math.floor(((h - v + 1) * a - 1) / w),
      E = 0,
      _ = r;
    for (; _ - E > 1; ) {
      let D = (E + _) >>> 1;
      A < i[D] ? (_ = D) : (E = D);
    }
    if (E == 0) break;
    g.push(E);
    let S = v + Math.floor((w * i[E]) / a),
      W = v + Math.floor((w * i[E + 1]) / a) - 1;
    for (; !((S ^ W) & p); )
      (h = ((h << 1) & y) | u()), (S = (S << 1) & y), (W = ((W << 1) & y) | 1);
    for (; S & ~W & m; )
      (h = (h & p) | ((h << 1) & (y >>> 1)) | u()),
        (S = (S << 1) ^ p),
        (W = ((W ^ p) << 1) | p | 1);
    (v = S), (w = 1 + W - S);
  }
  let T = r - 4;
  return g.map((A) => {
    switch (A - T) {
      case 3:
        return T + 65792 + ((n[o++] << 16) | (n[o++] << 8) | n[o++]);
      case 2:
        return T + 256 + ((n[o++] << 8) | n[o++]);
      case 1:
        return T + n[o++];
      default:
        return A - 1;
    }
  });
}
function p3(n) {
  let e = 0;
  return () => n[e++];
}
function h3(n) {
  return p3(f3(n));
}
function m3(n) {
  return n & 1 ? ~n >> 1 : n >> 1;
}
function y3(n, e) {
  let t = Array(n);
  for (let r = 0; r < n; r++) t[r] = 1 + e();
  return t;
}
function ky(n, e) {
  let t = Array(n);
  for (let r = 0, a = -1; r < n; r++) t[r] = a += 1 + e();
  return t;
}
function g3(n, e) {
  let t = Array(n);
  for (let r = 0, a = 0; r < n; r++) t[r] = a += m3(e());
  return t;
}
function ou(n, e) {
  let t = ky(n(), n),
    r = n(),
    a = ky(r, n),
    i = y3(r, n);
  for (let s = 0; s < r; s++) for (let o = 0; o < i[s]; o++) t.push(a[s] + o);
  return e ? t.map((s) => e[s]) : t;
}
function b3(n) {
  let e = [];
  for (;;) {
    let t = n();
    if (t == 0) break;
    e.push(v3(t, n));
  }
  for (;;) {
    let t = n() - 1;
    if (t < 0) break;
    e.push(w3(t, n));
  }
  return d3(q2(e));
}
function x3(n) {
  let e = [];
  for (;;) {
    let t = n();
    if (t == 0) break;
    e.push(t);
  }
  return e;
}
function V2(n, e, t) {
  let r = Array(n)
    .fill(void 0)
    .map(() => []);
  for (let a = 0; a < e; a++) g3(n, t).forEach((i, s) => r[s].push(i));
  return r;
}
function v3(n, e) {
  let t = 1 + e(),
    r = e(),
    a = x3(e),
    i = V2(a.length, 1 + n, e);
  return q2(
    i.map((s, o) => {
      const c = s[0],
        l = s.slice(1);
      return Array(a[o])
        .fill(void 0)
        .map((u, d) => {
          let f = d * r;
          return [c + d * t, l.map((p) => p + f)];
        });
    }),
  );
}
function w3(n, e) {
  let t = 1 + e();
  return V2(t, 1 + n, e).map((a) => [a[0], a.slice(1)]);
}
function T3(n) {
  let e = ou(n).sort((r, a) => r - a);
  return t();
  function t() {
    let r = [];
    for (;;) {
      let l = ou(n, e);
      if (l.length == 0) break;
      r.push({ set: new Set(l), node: t() });
    }
    r.sort((l, u) => u.set.size - l.set.size);
    let a = n(),
      i = a % 3;
    a = (a / 3) | 0;
    let s = !!(a & 1);
    a >>= 1;
    let o = a == 1,
      c = a == 2;
    return { branches: r, valid: i, fe0f: s, save: o, check: c };
  }
}
function C3() {
  return h3(
    z2(
      "AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA==",
    ),
  );
}
const Dd = C3(),
  A3 = new Set(ou(Dd)),
  E3 = new Set(ou(Dd)),
  k3 = b3(Dd),
  _3 = T3(Dd),
  _y = 45,
  Sy = 95;
function G2(n) {
  return s3(n);
}
function S3(n) {
  return n.filter((e) => e != 65039);
}
function K2(n) {
  for (let e of n.split(".")) {
    let t = G2(e);
    try {
      for (let r = t.lastIndexOf(Sy) - 1; r >= 0; r--)
        if (t[r] !== Sy) throw new Error("underscore only allowed at start");
      if (
        t.length >= 4 &&
        t.every((r) => r < 128) &&
        t[2] === _y &&
        t[3] === _y
      )
        throw new Error("invalid label extension");
    } catch (r) {
      throw new Error(`Invalid label "${e}": ${r.message}`);
    }
  }
  return n;
}
function P3(n) {
  return K2(I3(n, S3));
}
function I3(n, e) {
  let t = G2(n).reverse(),
    r = [];
  for (; t.length; ) {
    let a = M3(t);
    if (a) {
      r.push(...e(a));
      continue;
    }
    let i = t.pop();
    if (A3.has(i)) {
      r.push(i);
      continue;
    }
    if (E3.has(i)) continue;
    let s = k3[i];
    if (s) {
      r.push(...s);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${i.toString(16).toUpperCase()}`);
  }
  return K2(R3(String.fromCodePoint(...r)));
}
function R3(n) {
  return n.normalize("NFC");
}
function M3(n, e) {
  var t;
  let r = _3,
    a,
    i,
    s = [],
    o = n.length;
  for (e && (e.length = 0); o; ) {
    let c = n[--o];
    if (
      ((r =
        (t = r.branches.find((l) => l.set.has(c))) === null || t === void 0
          ? void 0
          : t.node),
      !r)
    )
      break;
    if (r.save) i = c;
    else if (r.check && c === i) break;
    s.push(c),
      r.fe0f && (s.push(65039), o > 0 && n[o - 1] == 65039 && o--),
      r.valid &&
        ((a = s.slice()),
        r.valid == 2 && a.splice(1, 1),
        e && e.push(...n.slice(o).reverse()),
        (n.length = o));
  }
  return a;
}
const B3 = new z(j2),
  Q2 = new Uint8Array(32);
Q2.fill(0);
function Py(n) {
  if (n.length === 0) throw new Error("invalid ENS name; empty component");
  return n;
}
function Y2(n) {
  const e = Ne(P3(n)),
    t = [];
  if (n.length === 0) return t;
  let r = 0;
  for (let a = 0; a < e.length; a++)
    e[a] === 46 && (t.push(Py(e.slice(r, a))), (r = a + 1));
  if (r >= e.length) throw new Error("invalid ENS name; empty component");
  return t.push(Py(e.slice(r))), t;
}
function Wl(n) {
  typeof n != "string" &&
    B3.throwArgumentError("invalid ENS name; not a string", "name", n);
  let e = Q2;
  const t = Y2(n);
  for (; t.length; ) e = Ge(nt([e, Ge(t.pop())]));
  return pe(e);
}
function D3(n) {
  return (
    pe(
      nt(
        Y2(n).map((e) => {
          if (e.length > 63)
            throw new Error(
              "invalid DNS encoded entry; length exceeds 63 bytes",
            );
          const t = new Uint8Array(e.length + 1);
          return t.set(e, 1), (t[0] = t.length - 1), t;
        }),
      ),
    ) + "00"
  );
}
const O3 = `Ethereum Signed Message:
`;
function Od(n) {
  return (
    typeof n == "string" && (n = Ne(n)),
    Ge(nt([Ne(O3), Ne(String(n.length)), n]))
  );
}
var N3 =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const lt = new z(j2),
  J2 = new Uint8Array(32);
J2.fill(0);
const F3 = O.from(-1),
  X2 = O.from(0),
  Z2 = O.from(1),
  L3 = O.from(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
  );
function $3(n) {
  const e = ae(n),
    t = e.length % 32;
  return t ? xn([e, J2.slice(t)]) : pe(e);
}
const W3 = Ue(Z2.toHexString(), 32),
  U3 = Ue(X2.toHexString(), 32),
  Iy = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32",
  },
  Lf = ["name", "version", "chainId", "verifyingContract", "salt"];
function Ry(n) {
  return function (e) {
    return (
      typeof e != "string" &&
        lt.throwArgumentError(
          `invalid domain value for ${JSON.stringify(n)}`,
          `domain.${n}`,
          e,
        ),
      e
    );
  };
}
const j3 = {
  name: Ry("name"),
  version: Ry("version"),
  chainId: function (n) {
    try {
      return O.from(n).toString();
    } catch {}
    return lt.throwArgumentError(
      'invalid domain value for "chainId"',
      "domain.chainId",
      n,
    );
  },
  verifyingContract: function (n) {
    try {
      return ht(n).toLowerCase();
    } catch {}
    return lt.throwArgumentError(
      'invalid domain value "verifyingContract"',
      "domain.verifyingContract",
      n,
    );
  },
  salt: function (n) {
    try {
      const e = ae(n);
      if (e.length !== 32) throw new Error("bad length");
      return pe(e);
    } catch {}
    return lt.throwArgumentError(
      'invalid domain value "salt"',
      "domain.salt",
      n,
    );
  },
};
function $f(n) {
  {
    const e = n.match(/^(u?)int(\d*)$/);
    if (e) {
      const t = e[1] === "",
        r = parseInt(e[2] || "256");
      (r % 8 !== 0 || r > 256 || (e[2] && e[2] !== String(r))) &&
        lt.throwArgumentError("invalid numeric width", "type", n);
      const a = L3.mask(t ? r - 1 : r),
        i = t ? a.add(Z2).mul(F3) : X2;
      return function (s) {
        const o = O.from(s);
        return (
          (o.lt(i) || o.gt(a)) &&
            lt.throwArgumentError(`value out-of-bounds for ${n}`, "value", s),
          Ue(o.toTwos(256).toHexString(), 32)
        );
      };
    }
  }
  {
    const e = n.match(/^bytes(\d+)$/);
    if (e) {
      const t = parseInt(e[1]);
      return (
        (t === 0 || t > 32 || e[1] !== String(t)) &&
          lt.throwArgumentError("invalid bytes width", "type", n),
        function (r) {
          return (
            ae(r).length !== t &&
              lt.throwArgumentError(`invalid length for ${n}`, "value", r),
            $3(r)
          );
        }
      );
    }
  }
  switch (n) {
    case "address":
      return function (e) {
        return Ue(ht(e), 32);
      };
    case "bool":
      return function (e) {
        return e ? W3 : U3;
      };
    case "bytes":
      return function (e) {
        return Ge(e);
      };
    case "string":
      return function (e) {
        return wn(e);
      };
  }
  return null;
}
function My(n, e) {
  return `${n}(${e.map(({ name: t, type: r }) => r + " " + t).join(",")})`;
}
class Wt {
  constructor(e) {
    Q(this, "types", Object.freeze(hn(e))),
      Q(this, "_encoderCache", {}),
      Q(this, "_types", {});
    const t = {},
      r = {},
      a = {};
    Object.keys(e).forEach((o) => {
      (t[o] = {}), (r[o] = []), (a[o] = {});
    });
    for (const o in e) {
      const c = {};
      e[o].forEach((l) => {
        c[l.name] &&
          lt.throwArgumentError(
            `duplicate variable name ${JSON.stringify(
              l.name,
            )} in ${JSON.stringify(o)}`,
            "types",
            e,
          ),
          (c[l.name] = !0);
        const u = l.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        u === o &&
          lt.throwArgumentError(
            `circular type reference to ${JSON.stringify(u)}`,
            "types",
            e,
          ),
          !$f(u) &&
            (r[u] ||
              lt.throwArgumentError(
                `unknown type ${JSON.stringify(u)}`,
                "types",
                e,
              ),
            r[u].push(o),
            (t[o][u] = !0));
      });
    }
    const i = Object.keys(r).filter((o) => r[o].length === 0);
    i.length === 0
      ? lt.throwArgumentError("missing primary type", "types", e)
      : i.length > 1 &&
        lt.throwArgumentError(
          `ambiguous primary types or unused types: ${i
            .map((o) => JSON.stringify(o))
            .join(", ")}`,
          "types",
          e,
        ),
      Q(this, "primaryType", i[0]);
    function s(o, c) {
      c[o] &&
        lt.throwArgumentError(
          `circular type reference to ${JSON.stringify(o)}`,
          "types",
          e,
        ),
        (c[o] = !0),
        Object.keys(t[o]).forEach((l) => {
          r[l] &&
            (s(l, c),
            Object.keys(c).forEach((u) => {
              a[u][l] = !0;
            }));
        }),
        delete c[o];
    }
    s(this.primaryType, {});
    for (const o in a) {
      const c = Object.keys(a[o]);
      c.sort(),
        (this._types[o] = My(o, e[o]) + c.map((l) => My(l, e[l])).join(""));
    }
  }
  getEncoder(e) {
    let t = this._encoderCache[e];
    return t || (t = this._encoderCache[e] = this._getEncoder(e)), t;
  }
  _getEncoder(e) {
    {
      const a = $f(e);
      if (a) return a;
    }
    const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (t) {
      const a = t[1],
        i = this.getEncoder(a),
        s = parseInt(t[3]);
      return (o) => {
        s >= 0 &&
          o.length !== s &&
          lt.throwArgumentError(
            "array length mismatch; expected length ${ arrayLength }",
            "value",
            o,
          );
        let c = o.map(i);
        return this._types[a] && (c = c.map(Ge)), Ge(xn(c));
      };
    }
    const r = this.types[e];
    if (r) {
      const a = wn(this._types[e]);
      return (i) => {
        const s = r.map(({ name: o, type: c }) => {
          const l = this.getEncoder(c)(i[o]);
          return this._types[c] ? Ge(l) : l;
        });
        return s.unshift(a), xn(s);
      };
    }
    return lt.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  encodeType(e) {
    const t = this._types[e];
    return (
      t ||
        lt.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e),
      t
    );
  }
  encodeData(e, t) {
    return this.getEncoder(e)(t);
  }
  hashStruct(e, t) {
    return Ge(this.encodeData(e, t));
  }
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  _visit(e, t, r) {
    if ($f(e)) return r(e, t);
    const a = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (a) {
      const s = a[1],
        o = parseInt(a[3]);
      return (
        o >= 0 &&
          t.length !== o &&
          lt.throwArgumentError(
            "array length mismatch; expected length ${ arrayLength }",
            "value",
            t,
          ),
        t.map((c) => this._visit(s, c, r))
      );
    }
    const i = this.types[e];
    return i
      ? i.reduce(
          (s, { name: o, type: c }) => ((s[o] = this._visit(c, t[o], r)), s),
          {},
        )
      : lt.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  visit(e, t) {
    return this._visit(this.primaryType, e, t);
  }
  static from(e) {
    return new Wt(e);
  }
  static getPrimaryType(e) {
    return Wt.from(e).primaryType;
  }
  static hashStruct(e, t, r) {
    return Wt.from(t).hashStruct(e, r);
  }
  static hashDomain(e) {
    const t = [];
    for (const r in e) {
      const a = Iy[r];
      a ||
        lt.throwArgumentError(
          `invalid typed-data domain key: ${JSON.stringify(r)}`,
          "domain",
          e,
        ),
        t.push({ name: r, type: a });
    }
    return (
      t.sort((r, a) => Lf.indexOf(r.name) - Lf.indexOf(a.name)),
      Wt.hashStruct("EIP712Domain", { EIP712Domain: t }, e)
    );
  }
  static encode(e, t, r) {
    return xn(["0x1901", Wt.hashDomain(e), Wt.from(t).hash(r)]);
  }
  static hash(e, t, r) {
    return Ge(Wt.encode(e, t, r));
  }
  static resolveNames(e, t, r, a) {
    return N3(this, void 0, void 0, function* () {
      e = rt(e);
      const i = {};
      e.verifyingContract &&
        !Ve(e.verifyingContract, 20) &&
        (i[e.verifyingContract] = "0x");
      const s = Wt.from(t);
      s.visit(r, (o, c) => (o === "address" && !Ve(c, 20) && (i[c] = "0x"), c));
      for (const o in i) i[o] = yield a(o);
      return (
        e.verifyingContract &&
          i[e.verifyingContract] &&
          (e.verifyingContract = i[e.verifyingContract]),
        (r = s.visit(r, (o, c) => (o === "address" && i[c] ? i[c] : c))),
        { domain: e, value: r }
      );
    });
  }
  static getPayload(e, t, r) {
    Wt.hashDomain(e);
    const a = {},
      i = [];
    Lf.forEach((c) => {
      const l = e[c];
      l != null && ((a[c] = j3[c](l)), i.push({ name: c, type: Iy[c] }));
    });
    const s = Wt.from(t),
      o = rt(t);
    return (
      o.EIP712Domain
        ? lt.throwArgumentError(
            "types must not contain EIP712Domain type",
            "types.EIP712Domain",
            t,
          )
        : (o.EIP712Domain = i),
      s.encode(r),
      {
        types: o,
        domain: a,
        primaryType: s.primaryType,
        message: s.visit(r, (c, l) => {
          if (c.match(/^bytes(\d*)/)) return pe(ae(l));
          if (c.match(/^u?int/)) return O.from(l).toString();
          switch (c) {
            case "address":
              return l.toLowerCase();
            case "bool":
              return !!l;
            case "string":
              return (
                typeof l != "string" &&
                  lt.throwArgumentError("invalid string", "value", l),
                l
              );
          }
          return lt.throwArgumentError("unsupported type", "type", c);
        }),
      }
    );
  }
}
const ct = new z($c);
class z3 extends ji {}
class H3 extends ji {}
class q3 extends ji {}
class pp extends ji {
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const V3 = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: !0,
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
  },
};
function By(n, e) {
  const t = new Error(
    `deferred error during ABI decoding triggered accessing ${n}`,
  );
  return (t.error = e), t;
}
class ec {
  constructor(e) {
    let t = [];
    typeof e == "string" ? (t = JSON.parse(e)) : (t = e),
      Q(
        this,
        "fragments",
        t.map((r) => ia.from(r)).filter((r) => r != null),
      ),
      Q(this, "_abiCoder", tn(new.target, "getAbiCoder")()),
      Q(this, "functions", {}),
      Q(this, "errors", {}),
      Q(this, "events", {}),
      Q(this, "structs", {}),
      this.fragments.forEach((r) => {
        let a = null;
        switch (r.type) {
          case "constructor":
            if (this.deploy) {
              ct.warn("duplicate definition - constructor");
              return;
            }
            Q(this, "deploy", r);
            return;
          case "function":
            a = this.functions;
            break;
          case "event":
            a = this.events;
            break;
          case "error":
            a = this.errors;
            break;
          default:
            return;
        }
        let i = r.format();
        if (a[i]) {
          ct.warn("duplicate definition - " + i);
          return;
        }
        a[i] = r;
      }),
      this.deploy ||
        Q(this, "deploy", Pr.from({ payable: !1, type: "constructor" })),
      Q(this, "_isInterface", !0);
  }
  format(e) {
    e || (e = We.full),
      e === We.sighash &&
        ct.throwArgumentError(
          "interface does not support formatting sighash",
          "format",
          e,
        );
    const t = this.fragments.map((r) => r.format(e));
    return e === We.json ? JSON.stringify(t.map((r) => JSON.parse(r))) : t;
  }
  static getAbiCoder() {
    return Ga;
  }
  static getAddress(e) {
    return ht(e);
  }
  static getSighash(e) {
    return Mt(wn(e.format()), 0, 4);
  }
  static getEventTopic(e) {
    return wn(e.format());
  }
  getFunction(e) {
    if (Ve(e)) {
      for (const r in this.functions)
        if (e === this.getSighash(r)) return this.functions[r];
      ct.throwArgumentError("no matching function", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(),
        a = Object.keys(this.functions).filter((i) => i.split("(")[0] === r);
      return (
        a.length === 0
          ? ct.throwArgumentError("no matching function", "name", r)
          : a.length > 1 &&
            ct.throwArgumentError("multiple matching functions", "name", r),
        this.functions[a[0]]
      );
    }
    const t = this.functions[Ir.fromString(e).format()];
    return (
      t || ct.throwArgumentError("no matching function", "signature", e), t
    );
  }
  getEvent(e) {
    if (Ve(e)) {
      const r = e.toLowerCase();
      for (const a in this.events)
        if (r === this.getEventTopic(a)) return this.events[a];
      ct.throwArgumentError("no matching event", "topichash", r);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(),
        a = Object.keys(this.events).filter((i) => i.split("(")[0] === r);
      return (
        a.length === 0
          ? ct.throwArgumentError("no matching event", "name", r)
          : a.length > 1 &&
            ct.throwArgumentError("multiple matching events", "name", r),
        this.events[a[0]]
      );
    }
    const t = this.events[ra.fromString(e).format()];
    return t || ct.throwArgumentError("no matching event", "signature", e), t;
  }
  getError(e) {
    if (Ve(e)) {
      const r = tn(this.constructor, "getSighash");
      for (const a in this.errors) {
        const i = this.errors[a];
        if (e === r(i)) return this.errors[a];
      }
      ct.throwArgumentError("no matching error", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(),
        a = Object.keys(this.errors).filter((i) => i.split("(")[0] === r);
      return (
        a.length === 0
          ? ct.throwArgumentError("no matching error", "name", r)
          : a.length > 1 &&
            ct.throwArgumentError("multiple matching errors", "name", r),
        this.errors[a[0]]
      );
    }
    const t = this.errors[Ir.fromString(e).format()];
    return t || ct.throwArgumentError("no matching error", "signature", e), t;
  }
  getSighash(e) {
    if (typeof e == "string")
      try {
        e = this.getFunction(e);
      } catch (t) {
        try {
          e = this.getError(e);
        } catch {
          throw t;
        }
      }
    return tn(this.constructor, "getSighash")(e);
  }
  getEventTopic(e) {
    return (
      typeof e == "string" && (e = this.getEvent(e)),
      tn(this.constructor, "getEventTopic")(e)
    );
  }
  _decodeParams(e, t) {
    return this._abiCoder.decode(e, t);
  }
  _encodeParams(e, t) {
    return this._abiCoder.encode(e, t);
  }
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  decodeErrorResult(e, t) {
    typeof e == "string" && (e = this.getError(e));
    const r = ae(t);
    return (
      pe(r.slice(0, 4)) !== this.getSighash(e) &&
        ct.throwArgumentError(
          `data signature does not match error ${e.name}.`,
          "data",
          pe(r),
        ),
      this._decodeParams(e.inputs, r.slice(4))
    );
  }
  encodeErrorResult(e, t) {
    return (
      typeof e == "string" && (e = this.getError(e)),
      pe(nt([this.getSighash(e), this._encodeParams(e.inputs, t || [])]))
    );
  }
  decodeFunctionData(e, t) {
    typeof e == "string" && (e = this.getFunction(e));
    const r = ae(t);
    return (
      pe(r.slice(0, 4)) !== this.getSighash(e) &&
        ct.throwArgumentError(
          `data signature does not match function ${e.name}.`,
          "data",
          pe(r),
        ),
      this._decodeParams(e.inputs, r.slice(4))
    );
  }
  encodeFunctionData(e, t) {
    return (
      typeof e == "string" && (e = this.getFunction(e)),
      pe(nt([this.getSighash(e), this._encodeParams(e.inputs, t || [])]))
    );
  }
  decodeFunctionResult(e, t) {
    typeof e == "string" && (e = this.getFunction(e));
    let r = ae(t),
      a = null,
      i = "",
      s = null,
      o = null,
      c = null;
    switch (r.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(e.outputs, r);
        } catch {}
        break;
      case 4: {
        const l = pe(r.slice(0, 4)),
          u = V3[l];
        if (u)
          (s = this._abiCoder.decode(u.inputs, r.slice(4))),
            (o = u.name),
            (c = u.signature),
            u.reason && (a = s[0]),
            o === "Error"
              ? (i = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(
                  s[0],
                )}`)
              : o === "Panic" &&
                (i = `; VM Exception while processing transaction: reverted with panic code ${s[0]}`);
        else
          try {
            const d = this.getError(l);
            (s = this._abiCoder.decode(d.inputs, r.slice(4))),
              (o = d.name),
              (c = d.format());
          } catch {}
        break;
      }
    }
    return ct.throwError("call revert exception" + i, z.errors.CALL_EXCEPTION, {
      method: e.format(),
      data: pe(t),
      errorArgs: s,
      errorName: o,
      errorSignature: c,
      reason: a,
    });
  }
  encodeFunctionResult(e, t) {
    return (
      typeof e == "string" && (e = this.getFunction(e)),
      pe(this._abiCoder.encode(e.outputs, t || []))
    );
  }
  encodeFilterTopics(e, t) {
    typeof e == "string" && (e = this.getEvent(e)),
      t.length > e.inputs.length &&
        ct.throwError(
          "too many arguments for " + e.format(),
          z.errors.UNEXPECTED_ARGUMENT,
          { argument: "values", value: t },
        );
    let r = [];
    e.anonymous || r.push(this.getEventTopic(e));
    const a = (i, s) =>
      i.type === "string"
        ? wn(s)
        : i.type === "bytes"
        ? Ge(pe(s))
        : (i.type === "bool" &&
            typeof s == "boolean" &&
            (s = s ? "0x01" : "0x00"),
          i.type.match(/^u?int/) && (s = O.from(s).toHexString()),
          i.type === "address" && this._abiCoder.encode(["address"], [s]),
          Ue(pe(s), 32));
    for (
      t.forEach((i, s) => {
        let o = e.inputs[s];
        if (!o.indexed) {
          i != null &&
            ct.throwArgumentError(
              "cannot filter non-indexed parameters; must be null",
              "contract." + o.name,
              i,
            );
          return;
        }
        i == null
          ? r.push(null)
          : o.baseType === "array" || o.baseType === "tuple"
          ? ct.throwArgumentError(
              "filtering with tuples or arrays not supported",
              "contract." + o.name,
              i,
            )
          : Array.isArray(i)
          ? r.push(i.map((c) => a(o, c)))
          : r.push(a(o, i));
      });
      r.length && r[r.length - 1] === null;

    )
      r.pop();
    return r;
  }
  encodeEventLog(e, t) {
    typeof e == "string" && (e = this.getEvent(e));
    const r = [],
      a = [],
      i = [];
    return (
      e.anonymous || r.push(this.getEventTopic(e)),
      t.length !== e.inputs.length &&
        ct.throwArgumentError("event arguments/values mismatch", "values", t),
      e.inputs.forEach((s, o) => {
        const c = t[o];
        if (s.indexed)
          if (s.type === "string") r.push(wn(c));
          else if (s.type === "bytes") r.push(Ge(c));
          else {
            if (s.baseType === "tuple" || s.baseType === "array")
              throw new Error("not implemented");
            r.push(this._abiCoder.encode([s.type], [c]));
          }
        else a.push(s), i.push(c);
      }),
      { data: this._abiCoder.encode(a, i), topics: r }
    );
  }
  decodeEventLog(e, t, r) {
    if (
      (typeof e == "string" && (e = this.getEvent(e)),
      r != null && !e.anonymous)
    ) {
      let f = this.getEventTopic(e);
      (!Ve(r[0], 32) || r[0].toLowerCase() !== f) &&
        ct.throwError("fragment/topic mismatch", z.errors.INVALID_ARGUMENT, {
          argument: "topics[0]",
          expected: f,
          value: r[0],
        }),
        (r = r.slice(1));
    }
    let a = [],
      i = [],
      s = [];
    e.inputs.forEach((f, p) => {
      f.indexed
        ? f.type === "string" ||
          f.type === "bytes" ||
          f.baseType === "tuple" ||
          f.baseType === "array"
          ? (a.push(kt.fromObject({ type: "bytes32", name: f.name })),
            s.push(!0))
          : (a.push(f), s.push(!1))
        : (i.push(f), s.push(!1));
    });
    let o = r != null ? this._abiCoder.decode(a, nt(r)) : null,
      c = this._abiCoder.decode(i, t, !0),
      l = [],
      u = 0,
      d = 0;
    e.inputs.forEach((f, p) => {
      if (f.indexed)
        if (o == null) l[p] = new pp({ _isIndexed: !0, hash: null });
        else if (s[p]) l[p] = new pp({ _isIndexed: !0, hash: o[d++] });
        else
          try {
            l[p] = o[d++];
          } catch (m) {
            l[p] = m;
          }
      else
        try {
          l[p] = c[u++];
        } catch (m) {
          l[p] = m;
        }
      if (f.name && l[f.name] == null) {
        const m = l[p];
        m instanceof Error
          ? Object.defineProperty(l, f.name, {
              enumerable: !0,
              get: () => {
                throw By(`property ${JSON.stringify(f.name)}`, m);
              },
            })
          : (l[f.name] = m);
      }
    });
    for (let f = 0; f < l.length; f++) {
      const p = l[f];
      p instanceof Error &&
        Object.defineProperty(l, f, {
          enumerable: !0,
          get: () => {
            throw By(`index ${f}`, p);
          },
        });
    }
    return Object.freeze(l);
  }
  parseTransaction(e) {
    let t = this.getFunction(e.data.substring(0, 10).toLowerCase());
    return t
      ? new H3({
          args: this._abiCoder.decode(t.inputs, "0x" + e.data.substring(10)),
          functionFragment: t,
          name: t.name,
          signature: t.format(),
          sighash: this.getSighash(t),
          value: O.from(e.value || "0"),
        })
      : null;
  }
  parseLog(e) {
    let t = this.getEvent(e.topics[0]);
    return !t || t.anonymous
      ? null
      : new z3({
          eventFragment: t,
          name: t.name,
          signature: t.format(),
          topic: this.getEventTopic(t),
          args: this.decodeEventLog(t, e.data, e.topics),
        });
  }
  parseError(e) {
    const t = pe(e);
    let r = this.getError(t.substring(0, 10).toLowerCase());
    return r
      ? new q3({
          args: this._abiCoder.decode(r.inputs, "0x" + t.substring(10)),
          errorFragment: r,
          name: r.name,
          signature: r.format(),
          sighash: this.getSighash(r),
        })
      : null;
  }
  static isInterface(e) {
    return !!(e && e._isInterface);
  }
}
const G3 = "abstract-provider/5.7.0";
var K3 =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const Q3 = new z(G3);
class Y3 extends ji {
  static isForkEvent(e) {
    return !!(e && e._isForkEvent);
  }
}
class Xs {
  constructor() {
    Q3.checkAbstract(new.target, Xs), Q(this, "_isProvider", !0);
  }
  getFeeData() {
    return K3(this, void 0, void 0, function* () {
      const { block: e, gasPrice: t } = yield bt({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((s) => null),
      });
      let r = null,
        a = null,
        i = null;
      return (
        e &&
          e.baseFeePerGas &&
          ((r = e.baseFeePerGas),
          (i = O.from("1500000000")),
          (a = e.baseFeePerGas.mul(2).add(i))),
        {
          lastBaseFeePerGas: r,
          maxFeePerGas: a,
          maxPriorityFeePerGas: i,
          gasPrice: t,
        }
      );
    });
  }
  addListener(e, t) {
    return this.on(e, t);
  }
  removeListener(e, t) {
    return this.off(e, t);
  }
  static isProvider(e) {
    return !!(e && e._isProvider);
  }
}
const J3 = "abstract-signer/5.7.0";
var dr =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const Vn = new z(J3),
  X3 = [
    "accessList",
    "ccipReadEnabled",
    "chainId",
    "customData",
    "data",
    "from",
    "gasLimit",
    "gasPrice",
    "maxFeePerGas",
    "maxPriorityFeePerGas",
    "nonce",
    "to",
    "type",
    "value",
  ],
  Z3 = [
    z.errors.INSUFFICIENT_FUNDS,
    z.errors.NONCE_EXPIRED,
    z.errors.REPLACEMENT_UNDERPRICED,
  ];
class Hi {
  constructor() {
    Vn.checkAbstract(new.target, Hi), Q(this, "_isSigner", !0);
  }
  getBalance(e) {
    return dr(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getBalance"),
        yield this.provider.getBalance(this.getAddress(), e)
      );
    });
  }
  getTransactionCount(e) {
    return dr(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getTransactionCount"),
        yield this.provider.getTransactionCount(this.getAddress(), e)
      );
    });
  }
  estimateGas(e) {
    return dr(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const t = yield bt(this.checkTransaction(e));
      return yield this.provider.estimateGas(t);
    });
  }
  call(e, t) {
    return dr(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const r = yield bt(this.checkTransaction(e));
      return yield this.provider.call(r, t);
    });
  }
  sendTransaction(e) {
    return dr(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const t = yield this.populateTransaction(e),
        r = yield this.signTransaction(t);
      return yield this.provider.sendTransaction(r);
    });
  }
  getChainId() {
    return dr(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getChainId"),
        (yield this.provider.getNetwork()).chainId
      );
    });
  }
  getGasPrice() {
    return dr(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
      );
    });
  }
  getFeeData() {
    return dr(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getFeeData"), yield this.provider.getFeeData()
      );
    });
  }
  resolveName(e) {
    return dr(this, void 0, void 0, function* () {
      return (
        this._checkProvider("resolveName"), yield this.provider.resolveName(e)
      );
    });
  }
  checkTransaction(e) {
    for (const r in e)
      X3.indexOf(r) === -1 &&
        Vn.throwArgumentError(
          "invalid transaction key: " + r,
          "transaction",
          e,
        );
    const t = rt(e);
    return (
      t.from == null
        ? (t.from = this.getAddress())
        : (t.from = Promise.all([
            Promise.resolve(t.from),
            this.getAddress(),
          ]).then(
            (r) => (
              r[0].toLowerCase() !== r[1].toLowerCase() &&
                Vn.throwArgumentError(
                  "from address mismatch",
                  "transaction",
                  e,
                ),
              r[0]
            ),
          )),
      t
    );
  }
  populateTransaction(e) {
    return dr(this, void 0, void 0, function* () {
      const t = yield bt(this.checkTransaction(e));
      t.to != null &&
        ((t.to = Promise.resolve(t.to).then((a) =>
          dr(this, void 0, void 0, function* () {
            if (a == null) return null;
            const i = yield this.resolveName(a);
            return (
              i == null &&
                Vn.throwArgumentError(
                  "provided ENS name resolves to null",
                  "tx.to",
                  a,
                ),
              i
            );
          }),
        )),
        t.to.catch((a) => {}));
      const r = t.maxFeePerGas != null || t.maxPriorityFeePerGas != null;
      if (
        (t.gasPrice != null && (t.type === 2 || r)
          ? Vn.throwArgumentError(
              "eip-1559 transaction do not support gasPrice",
              "transaction",
              e,
            )
          : (t.type === 0 || t.type === 1) &&
            r &&
            Vn.throwArgumentError(
              "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
              "transaction",
              e,
            ),
        (t.type === 2 || t.type == null) &&
          t.maxFeePerGas != null &&
          t.maxPriorityFeePerGas != null)
      )
        t.type = 2;
      else if (t.type === 0 || t.type === 1)
        t.gasPrice == null && (t.gasPrice = this.getGasPrice());
      else {
        const a = yield this.getFeeData();
        if (t.type == null)
          if (a.maxFeePerGas != null && a.maxPriorityFeePerGas != null)
            if (((t.type = 2), t.gasPrice != null)) {
              const i = t.gasPrice;
              delete t.gasPrice,
                (t.maxFeePerGas = i),
                (t.maxPriorityFeePerGas = i);
            } else
              t.maxFeePerGas == null && (t.maxFeePerGas = a.maxFeePerGas),
                t.maxPriorityFeePerGas == null &&
                  (t.maxPriorityFeePerGas = a.maxPriorityFeePerGas);
          else
            a.gasPrice != null
              ? (r &&
                  Vn.throwError(
                    "network does not support EIP-1559",
                    z.errors.UNSUPPORTED_OPERATION,
                    { operation: "populateTransaction" },
                  ),
                t.gasPrice == null && (t.gasPrice = a.gasPrice),
                (t.type = 0))
              : Vn.throwError(
                  "failed to get consistent fee data",
                  z.errors.UNSUPPORTED_OPERATION,
                  { operation: "signer.getFeeData" },
                );
        else
          t.type === 2 &&
            (t.maxFeePerGas == null && (t.maxFeePerGas = a.maxFeePerGas),
            t.maxPriorityFeePerGas == null &&
              (t.maxPriorityFeePerGas = a.maxPriorityFeePerGas));
      }
      return (
        t.nonce == null && (t.nonce = this.getTransactionCount("pending")),
        t.gasLimit == null &&
          (t.gasLimit = this.estimateGas(t).catch((a) => {
            if (Z3.indexOf(a.code) >= 0) throw a;
            return Vn.throwError(
              "cannot estimate gas; transaction may fail or may require manual gas limit",
              z.errors.UNPREDICTABLE_GAS_LIMIT,
              { error: a, tx: t },
            );
          })),
        t.chainId == null
          ? (t.chainId = this.getChainId())
          : (t.chainId = Promise.all([
              Promise.resolve(t.chainId),
              this.getChainId(),
            ]).then(
              (a) => (
                a[1] !== 0 &&
                  a[0] !== a[1] &&
                  Vn.throwArgumentError(
                    "chainId address mismatch",
                    "transaction",
                    e,
                  ),
                a[0]
              ),
            )),
        yield bt(t)
      );
    });
  }
  _checkProvider(e) {
    this.provider ||
      Vn.throwError("missing provider", z.errors.UNSUPPORTED_OPERATION, {
        operation: e || "_checkProvider",
      });
  }
  static isSigner(e) {
    return !!(e && e._isSigner);
  }
}
class Rh extends Hi {
  constructor(e, t) {
    super(), Q(this, "address", e), Q(this, "provider", t || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(e, t) {
    return Promise.resolve().then(() => {
      Vn.throwError(e, z.errors.UNSUPPORTED_OPERATION, { operation: t });
    });
  }
  signMessage(e) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(e) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(e, t, r) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(e) {
    return new Rh(this.address, e);
  }
}
var ex = {},
  Me = {},
  Wc = tx;
function tx(n, e) {
  if (!n) throw new Error(e || "Assertion failed");
}
tx.equal = function (e, t, r) {
  if (e != t) throw new Error(r || "Assertion failed: " + e + " != " + t);
};
var hp = { exports: {} };
typeof Object.create == "function"
  ? (hp.exports = function (e, t) {
      t &&
        ((e.super_ = t),
        (e.prototype = Object.create(t.prototype, {
          constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })));
    })
  : (hp.exports = function (e, t) {
      if (t) {
        e.super_ = t;
        var r = function () {};
        (r.prototype = t.prototype),
          (e.prototype = new r()),
          (e.prototype.constructor = e);
      }
    });
var eT = hp.exports,
  tT = Wc,
  nT = eT;
Me.inherits = nT;
function rT(n, e) {
  return (n.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= n.length
    ? !1
    : (n.charCodeAt(e + 1) & 64512) === 56320;
}
function aT(n, e) {
  if (Array.isArray(n)) return n.slice();
  if (!n) return [];
  var t = [];
  if (typeof n == "string")
    if (e) {
      if (e === "hex")
        for (
          n = n.replace(/[^a-z0-9]+/gi, ""),
            n.length % 2 !== 0 && (n = "0" + n),
            a = 0;
          a < n.length;
          a += 2
        )
          t.push(parseInt(n[a] + n[a + 1], 16));
    } else
      for (var r = 0, a = 0; a < n.length; a++) {
        var i = n.charCodeAt(a);
        i < 128
          ? (t[r++] = i)
          : i < 2048
          ? ((t[r++] = (i >> 6) | 192), (t[r++] = (i & 63) | 128))
          : rT(n, a)
          ? ((i = 65536 + ((i & 1023) << 10) + (n.charCodeAt(++a) & 1023)),
            (t[r++] = (i >> 18) | 240),
            (t[r++] = ((i >> 12) & 63) | 128),
            (t[r++] = ((i >> 6) & 63) | 128),
            (t[r++] = (i & 63) | 128))
          : ((t[r++] = (i >> 12) | 224),
            (t[r++] = ((i >> 6) & 63) | 128),
            (t[r++] = (i & 63) | 128));
      }
  else for (a = 0; a < n.length; a++) t[a] = n[a] | 0;
  return t;
}
Me.toArray = aT;
function iT(n) {
  for (var e = "", t = 0; t < n.length; t++) e += rx(n[t].toString(16));
  return e;
}
Me.toHex = iT;
function nx(n) {
  var e =
    (n >>> 24) |
    ((n >>> 8) & 65280) |
    ((n << 8) & 16711680) |
    ((n & 255) << 24);
  return e >>> 0;
}
Me.htonl = nx;
function sT(n, e) {
  for (var t = "", r = 0; r < n.length; r++) {
    var a = n[r];
    e === "little" && (a = nx(a)), (t += ax(a.toString(16)));
  }
  return t;
}
Me.toHex32 = sT;
function rx(n) {
  return n.length === 1 ? "0" + n : n;
}
Me.zero2 = rx;
function ax(n) {
  return n.length === 7
    ? "0" + n
    : n.length === 6
    ? "00" + n
    : n.length === 5
    ? "000" + n
    : n.length === 4
    ? "0000" + n
    : n.length === 3
    ? "00000" + n
    : n.length === 2
    ? "000000" + n
    : n.length === 1
    ? "0000000" + n
    : n;
}
Me.zero8 = ax;
function oT(n, e, t, r) {
  var a = t - e;
  tT(a % 4 === 0);
  for (var i = new Array(a / 4), s = 0, o = e; s < i.length; s++, o += 4) {
    var c;
    r === "big"
      ? (c = (n[o] << 24) | (n[o + 1] << 16) | (n[o + 2] << 8) | n[o + 3])
      : (c = (n[o + 3] << 24) | (n[o + 2] << 16) | (n[o + 1] << 8) | n[o]),
      (i[s] = c >>> 0);
  }
  return i;
}
Me.join32 = oT;
function cT(n, e) {
  for (
    var t = new Array(n.length * 4), r = 0, a = 0;
    r < n.length;
    r++, a += 4
  ) {
    var i = n[r];
    e === "big"
      ? ((t[a] = i >>> 24),
        (t[a + 1] = (i >>> 16) & 255),
        (t[a + 2] = (i >>> 8) & 255),
        (t[a + 3] = i & 255))
      : ((t[a + 3] = i >>> 24),
        (t[a + 2] = (i >>> 16) & 255),
        (t[a + 1] = (i >>> 8) & 255),
        (t[a] = i & 255));
  }
  return t;
}
Me.split32 = cT;
function lT(n, e) {
  return (n >>> e) | (n << (32 - e));
}
Me.rotr32 = lT;
function uT(n, e) {
  return (n << e) | (n >>> (32 - e));
}
Me.rotl32 = uT;
function dT(n, e) {
  return (n + e) >>> 0;
}
Me.sum32 = dT;
function fT(n, e, t) {
  return (n + e + t) >>> 0;
}
Me.sum32_3 = fT;
function pT(n, e, t, r) {
  return (n + e + t + r) >>> 0;
}
Me.sum32_4 = pT;
function hT(n, e, t, r, a) {
  return (n + e + t + r + a) >>> 0;
}
Me.sum32_5 = hT;
function mT(n, e, t, r) {
  var a = n[e],
    i = n[e + 1],
    s = (r + i) >>> 0,
    o = (s < r ? 1 : 0) + t + a;
  (n[e] = o >>> 0), (n[e + 1] = s);
}
Me.sum64 = mT;
function yT(n, e, t, r) {
  var a = (e + r) >>> 0,
    i = (a < e ? 1 : 0) + n + t;
  return i >>> 0;
}
Me.sum64_hi = yT;
function gT(n, e, t, r) {
  var a = e + r;
  return a >>> 0;
}
Me.sum64_lo = gT;
function bT(n, e, t, r, a, i, s, o) {
  var c = 0,
    l = e;
  (l = (l + r) >>> 0),
    (c += l < e ? 1 : 0),
    (l = (l + i) >>> 0),
    (c += l < i ? 1 : 0),
    (l = (l + o) >>> 0),
    (c += l < o ? 1 : 0);
  var u = n + t + a + s + c;
  return u >>> 0;
}
Me.sum64_4_hi = bT;
function xT(n, e, t, r, a, i, s, o) {
  var c = e + r + i + o;
  return c >>> 0;
}
Me.sum64_4_lo = xT;
function vT(n, e, t, r, a, i, s, o, c, l) {
  var u = 0,
    d = e;
  (d = (d + r) >>> 0),
    (u += d < e ? 1 : 0),
    (d = (d + i) >>> 0),
    (u += d < i ? 1 : 0),
    (d = (d + o) >>> 0),
    (u += d < o ? 1 : 0),
    (d = (d + l) >>> 0),
    (u += d < l ? 1 : 0);
  var f = n + t + a + s + c + u;
  return f >>> 0;
}
Me.sum64_5_hi = vT;
function wT(n, e, t, r, a, i, s, o, c, l) {
  var u = e + r + i + o + l;
  return u >>> 0;
}
Me.sum64_5_lo = wT;
function TT(n, e, t) {
  var r = (e << (32 - t)) | (n >>> t);
  return r >>> 0;
}
Me.rotr64_hi = TT;
function CT(n, e, t) {
  var r = (n << (32 - t)) | (e >>> t);
  return r >>> 0;
}
Me.rotr64_lo = CT;
function AT(n, e, t) {
  return n >>> t;
}
Me.shr64_hi = AT;
function ET(n, e, t) {
  var r = (n << (32 - t)) | (e >>> t);
  return r >>> 0;
}
Me.shr64_lo = ET;
var Zs = {},
  Dy = Me,
  kT = Wc;
function Nd() {
  (this.pending = null),
    (this.pendingTotal = 0),
    (this.blockSize = this.constructor.blockSize),
    (this.outSize = this.constructor.outSize),
    (this.hmacStrength = this.constructor.hmacStrength),
    (this.padLength = this.constructor.padLength / 8),
    (this.endian = "big"),
    (this._delta8 = this.blockSize / 8),
    (this._delta32 = this.blockSize / 32);
}
Zs.BlockHash = Nd;
Nd.prototype.update = function (e, t) {
  if (
    ((e = Dy.toArray(e, t)),
    this.pending ? (this.pending = this.pending.concat(e)) : (this.pending = e),
    (this.pendingTotal += e.length),
    this.pending.length >= this._delta8)
  ) {
    e = this.pending;
    var r = e.length % this._delta8;
    (this.pending = e.slice(e.length - r, e.length)),
      this.pending.length === 0 && (this.pending = null),
      (e = Dy.join32(e, 0, e.length - r, this.endian));
    for (var a = 0; a < e.length; a += this._delta32)
      this._update(e, a, a + this._delta32);
  }
  return this;
};
Nd.prototype.digest = function (e) {
  return this.update(this._pad()), kT(this.pending === null), this._digest(e);
};
Nd.prototype._pad = function () {
  var e = this.pendingTotal,
    t = this._delta8,
    r = t - ((e + this.padLength) % t),
    a = new Array(r + this.padLength);
  a[0] = 128;
  for (var i = 1; i < r; i++) a[i] = 0;
  if (((e <<= 3), this.endian === "big")) {
    for (var s = 8; s < this.padLength; s++) a[i++] = 0;
    (a[i++] = 0),
      (a[i++] = 0),
      (a[i++] = 0),
      (a[i++] = 0),
      (a[i++] = (e >>> 24) & 255),
      (a[i++] = (e >>> 16) & 255),
      (a[i++] = (e >>> 8) & 255),
      (a[i++] = e & 255);
  } else
    for (
      a[i++] = e & 255,
        a[i++] = (e >>> 8) & 255,
        a[i++] = (e >>> 16) & 255,
        a[i++] = (e >>> 24) & 255,
        a[i++] = 0,
        a[i++] = 0,
        a[i++] = 0,
        a[i++] = 0,
        s = 8;
      s < this.padLength;
      s++
    )
      a[i++] = 0;
  return a;
};
var eo = {},
  qr = {},
  _T = Me,
  Fr = _T.rotr32;
function ST(n, e, t, r) {
  if (n === 0) return ix(e, t, r);
  if (n === 1 || n === 3) return ox(e, t, r);
  if (n === 2) return sx(e, t, r);
}
qr.ft_1 = ST;
function ix(n, e, t) {
  return (n & e) ^ (~n & t);
}
qr.ch32 = ix;
function sx(n, e, t) {
  return (n & e) ^ (n & t) ^ (e & t);
}
qr.maj32 = sx;
function ox(n, e, t) {
  return n ^ e ^ t;
}
qr.p32 = ox;
function PT(n) {
  return Fr(n, 2) ^ Fr(n, 13) ^ Fr(n, 22);
}
qr.s0_256 = PT;
function IT(n) {
  return Fr(n, 6) ^ Fr(n, 11) ^ Fr(n, 25);
}
qr.s1_256 = IT;
function RT(n) {
  return Fr(n, 7) ^ Fr(n, 18) ^ (n >>> 3);
}
qr.g0_256 = RT;
function MT(n) {
  return Fr(n, 17) ^ Fr(n, 19) ^ (n >>> 10);
}
qr.g1_256 = MT;
var Bs = Me,
  BT = Zs,
  DT = qr,
  Wf = Bs.rotl32,
  To = Bs.sum32,
  OT = Bs.sum32_5,
  NT = DT.ft_1,
  cx = BT.BlockHash,
  FT = [1518500249, 1859775393, 2400959708, 3395469782];
function Ur() {
  if (!(this instanceof Ur)) return new Ur();
  cx.call(this),
    (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
    (this.W = new Array(80));
}
Bs.inherits(Ur, cx);
var LT = Ur;
Ur.blockSize = 512;
Ur.outSize = 160;
Ur.hmacStrength = 80;
Ur.padLength = 64;
Ur.prototype._update = function (e, t) {
  for (var r = this.W, a = 0; a < 16; a++) r[a] = e[t + a];
  for (; a < r.length; a++)
    r[a] = Wf(r[a - 3] ^ r[a - 8] ^ r[a - 14] ^ r[a - 16], 1);
  var i = this.h[0],
    s = this.h[1],
    o = this.h[2],
    c = this.h[3],
    l = this.h[4];
  for (a = 0; a < r.length; a++) {
    var u = ~~(a / 20),
      d = OT(Wf(i, 5), NT(u, s, o, c), l, r[a], FT[u]);
    (l = c), (c = o), (o = Wf(s, 30)), (s = i), (i = d);
  }
  (this.h[0] = To(this.h[0], i)),
    (this.h[1] = To(this.h[1], s)),
    (this.h[2] = To(this.h[2], o)),
    (this.h[3] = To(this.h[3], c)),
    (this.h[4] = To(this.h[4], l));
};
Ur.prototype._digest = function (e) {
  return e === "hex" ? Bs.toHex32(this.h, "big") : Bs.split32(this.h, "big");
};
var Ds = Me,
  $T = Zs,
  to = qr,
  WT = Wc,
  fr = Ds.sum32,
  UT = Ds.sum32_4,
  jT = Ds.sum32_5,
  zT = to.ch32,
  HT = to.maj32,
  qT = to.s0_256,
  VT = to.s1_256,
  GT = to.g0_256,
  KT = to.g1_256,
  lx = $T.BlockHash,
  QT = [
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ];
function jr() {
  if (!(this instanceof jr)) return new jr();
  lx.call(this),
    (this.h = [
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225,
    ]),
    (this.k = QT),
    (this.W = new Array(64));
}
Ds.inherits(jr, lx);
var ux = jr;
jr.blockSize = 512;
jr.outSize = 256;
jr.hmacStrength = 192;
jr.padLength = 64;
jr.prototype._update = function (e, t) {
  for (var r = this.W, a = 0; a < 16; a++) r[a] = e[t + a];
  for (; a < r.length; a++)
    r[a] = UT(KT(r[a - 2]), r[a - 7], GT(r[a - 15]), r[a - 16]);
  var i = this.h[0],
    s = this.h[1],
    o = this.h[2],
    c = this.h[3],
    l = this.h[4],
    u = this.h[5],
    d = this.h[6],
    f = this.h[7];
  for (WT(this.k.length === r.length), a = 0; a < r.length; a++) {
    var p = jT(f, VT(l), zT(l, u, d), this.k[a], r[a]),
      m = fr(qT(i), HT(i, s, o));
    (f = d),
      (d = u),
      (u = l),
      (l = fr(c, p)),
      (c = o),
      (o = s),
      (s = i),
      (i = fr(p, m));
  }
  (this.h[0] = fr(this.h[0], i)),
    (this.h[1] = fr(this.h[1], s)),
    (this.h[2] = fr(this.h[2], o)),
    (this.h[3] = fr(this.h[3], c)),
    (this.h[4] = fr(this.h[4], l)),
    (this.h[5] = fr(this.h[5], u)),
    (this.h[6] = fr(this.h[6], d)),
    (this.h[7] = fr(this.h[7], f));
};
jr.prototype._digest = function (e) {
  return e === "hex" ? Ds.toHex32(this.h, "big") : Ds.split32(this.h, "big");
};
var mp = Me,
  dx = ux;
function oa() {
  if (!(this instanceof oa)) return new oa();
  dx.call(this),
    (this.h = [
      3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025,
      1694076839, 3204075428,
    ]);
}
mp.inherits(oa, dx);
var YT = oa;
oa.blockSize = 512;
oa.outSize = 224;
oa.hmacStrength = 192;
oa.padLength = 64;
oa.prototype._digest = function (e) {
  return e === "hex"
    ? mp.toHex32(this.h.slice(0, 7), "big")
    : mp.split32(this.h.slice(0, 7), "big");
};
var Tn = Me,
  JT = Zs,
  XT = Wc,
  Lr = Tn.rotr64_hi,
  $r = Tn.rotr64_lo,
  fx = Tn.shr64_hi,
  px = Tn.shr64_lo,
  wa = Tn.sum64,
  Uf = Tn.sum64_hi,
  jf = Tn.sum64_lo,
  ZT = Tn.sum64_4_hi,
  eC = Tn.sum64_4_lo,
  tC = Tn.sum64_5_hi,
  nC = Tn.sum64_5_lo,
  hx = JT.BlockHash,
  rC = [
    1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399,
    3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265,
    2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394,
    310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
    1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317,
    3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139,
    264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901,
    1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
    2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879,
    3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901,
    113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
    773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
    1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142,
    2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273,
    3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344,
    3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
    430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593,
    883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
    1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012,
    2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
    2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
    3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
    3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554,
    174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
    685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100,
    1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866,
    1607167915, 987167468, 1816402316, 1246189591,
  ];
function vr() {
  if (!(this instanceof vr)) return new vr();
  hx.call(this),
    (this.h = [
      1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723,
      2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199,
      528734635, 4215389547, 1541459225, 327033209,
    ]),
    (this.k = rC),
    (this.W = new Array(160));
}
Tn.inherits(vr, hx);
var mx = vr;
vr.blockSize = 1024;
vr.outSize = 512;
vr.hmacStrength = 192;
vr.padLength = 128;
vr.prototype._prepareBlock = function (e, t) {
  for (var r = this.W, a = 0; a < 32; a++) r[a] = e[t + a];
  for (; a < r.length; a += 2) {
    var i = hC(r[a - 4], r[a - 3]),
      s = mC(r[a - 4], r[a - 3]),
      o = r[a - 14],
      c = r[a - 13],
      l = fC(r[a - 30], r[a - 29]),
      u = pC(r[a - 30], r[a - 29]),
      d = r[a - 32],
      f = r[a - 31];
    (r[a] = ZT(i, s, o, c, l, u, d, f)),
      (r[a + 1] = eC(i, s, o, c, l, u, d, f));
  }
};
vr.prototype._update = function (e, t) {
  this._prepareBlock(e, t);
  var r = this.W,
    a = this.h[0],
    i = this.h[1],
    s = this.h[2],
    o = this.h[3],
    c = this.h[4],
    l = this.h[5],
    u = this.h[6],
    d = this.h[7],
    f = this.h[8],
    p = this.h[9],
    m = this.h[10],
    y = this.h[11],
    h = this.h[12],
    g = this.h[13],
    v = this.h[14],
    w = this.h[15];
  XT(this.k.length === r.length);
  for (var T = 0; T < r.length; T += 2) {
    var A = v,
      E = w,
      _ = uC(f, p),
      S = dC(f, p),
      W = aC(f, p, m, y, h),
      D = iC(f, p, m, y, h, g),
      L = this.k[T],
      G = this.k[T + 1],
      q = r[T],
      N = r[T + 1],
      H = tC(A, E, _, S, W, D, L, G, q, N),
      J = nC(A, E, _, S, W, D, L, G, q, N);
    (A = cC(a, i)),
      (E = lC(a, i)),
      (_ = sC(a, i, s, o, c)),
      (S = oC(a, i, s, o, c, l));
    var de = Uf(A, E, _, S),
      le = jf(A, E, _, S);
    (v = h),
      (w = g),
      (h = m),
      (g = y),
      (m = f),
      (y = p),
      (f = Uf(u, d, H, J)),
      (p = jf(d, d, H, J)),
      (u = c),
      (d = l),
      (c = s),
      (l = o),
      (s = a),
      (o = i),
      (a = Uf(H, J, de, le)),
      (i = jf(H, J, de, le));
  }
  wa(this.h, 0, a, i),
    wa(this.h, 2, s, o),
    wa(this.h, 4, c, l),
    wa(this.h, 6, u, d),
    wa(this.h, 8, f, p),
    wa(this.h, 10, m, y),
    wa(this.h, 12, h, g),
    wa(this.h, 14, v, w);
};
vr.prototype._digest = function (e) {
  return e === "hex" ? Tn.toHex32(this.h, "big") : Tn.split32(this.h, "big");
};
function aC(n, e, t, r, a) {
  var i = (n & t) ^ (~n & a);
  return i < 0 && (i += 4294967296), i;
}
function iC(n, e, t, r, a, i) {
  var s = (e & r) ^ (~e & i);
  return s < 0 && (s += 4294967296), s;
}
function sC(n, e, t, r, a) {
  var i = (n & t) ^ (n & a) ^ (t & a);
  return i < 0 && (i += 4294967296), i;
}
function oC(n, e, t, r, a, i) {
  var s = (e & r) ^ (e & i) ^ (r & i);
  return s < 0 && (s += 4294967296), s;
}
function cC(n, e) {
  var t = Lr(n, e, 28),
    r = Lr(e, n, 2),
    a = Lr(e, n, 7),
    i = t ^ r ^ a;
  return i < 0 && (i += 4294967296), i;
}
function lC(n, e) {
  var t = $r(n, e, 28),
    r = $r(e, n, 2),
    a = $r(e, n, 7),
    i = t ^ r ^ a;
  return i < 0 && (i += 4294967296), i;
}
function uC(n, e) {
  var t = Lr(n, e, 14),
    r = Lr(n, e, 18),
    a = Lr(e, n, 9),
    i = t ^ r ^ a;
  return i < 0 && (i += 4294967296), i;
}
function dC(n, e) {
  var t = $r(n, e, 14),
    r = $r(n, e, 18),
    a = $r(e, n, 9),
    i = t ^ r ^ a;
  return i < 0 && (i += 4294967296), i;
}
function fC(n, e) {
  var t = Lr(n, e, 1),
    r = Lr(n, e, 8),
    a = fx(n, e, 7),
    i = t ^ r ^ a;
  return i < 0 && (i += 4294967296), i;
}
function pC(n, e) {
  var t = $r(n, e, 1),
    r = $r(n, e, 8),
    a = px(n, e, 7),
    i = t ^ r ^ a;
  return i < 0 && (i += 4294967296), i;
}
function hC(n, e) {
  var t = Lr(n, e, 19),
    r = Lr(e, n, 29),
    a = fx(n, e, 6),
    i = t ^ r ^ a;
  return i < 0 && (i += 4294967296), i;
}
function mC(n, e) {
  var t = $r(n, e, 19),
    r = $r(e, n, 29),
    a = px(n, e, 6),
    i = t ^ r ^ a;
  return i < 0 && (i += 4294967296), i;
}
var yp = Me,
  yx = mx;
function ca() {
  if (!(this instanceof ca)) return new ca();
  yx.call(this),
    (this.h = [
      3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999,
      355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025,
      3675008525, 1694076839, 1203062813, 3204075428,
    ]);
}
yp.inherits(ca, yx);
var yC = ca;
ca.blockSize = 1024;
ca.outSize = 384;
ca.hmacStrength = 192;
ca.padLength = 128;
ca.prototype._digest = function (e) {
  return e === "hex"
    ? yp.toHex32(this.h.slice(0, 12), "big")
    : yp.split32(this.h.slice(0, 12), "big");
};
eo.sha1 = LT;
eo.sha224 = YT;
eo.sha256 = ux;
eo.sha384 = yC;
eo.sha512 = mx;
var gx = {},
  Mi = Me,
  gC = Zs,
  ul = Mi.rotl32,
  Oy = Mi.sum32,
  Co = Mi.sum32_3,
  Ny = Mi.sum32_4,
  bx = gC.BlockHash;
function zr() {
  if (!(this instanceof zr)) return new zr();
  bx.call(this),
    (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
    (this.endian = "little");
}
Mi.inherits(zr, bx);
gx.ripemd160 = zr;
zr.blockSize = 512;
zr.outSize = 160;
zr.hmacStrength = 192;
zr.padLength = 64;
zr.prototype._update = function (e, t) {
  for (
    var r = this.h[0],
      a = this.h[1],
      i = this.h[2],
      s = this.h[3],
      o = this.h[4],
      c = r,
      l = a,
      u = i,
      d = s,
      f = o,
      p = 0;
    p < 80;
    p++
  ) {
    var m = Oy(ul(Ny(r, Fy(p, a, i, s), e[vC[p] + t], bC(p)), TC[p]), o);
    (r = o),
      (o = s),
      (s = ul(i, 10)),
      (i = a),
      (a = m),
      (m = Oy(ul(Ny(c, Fy(79 - p, l, u, d), e[wC[p] + t], xC(p)), CC[p]), f)),
      (c = f),
      (f = d),
      (d = ul(u, 10)),
      (u = l),
      (l = m);
  }
  (m = Co(this.h[1], i, d)),
    (this.h[1] = Co(this.h[2], s, f)),
    (this.h[2] = Co(this.h[3], o, c)),
    (this.h[3] = Co(this.h[4], r, l)),
    (this.h[4] = Co(this.h[0], a, u)),
    (this.h[0] = m);
};
zr.prototype._digest = function (e) {
  return e === "hex"
    ? Mi.toHex32(this.h, "little")
    : Mi.split32(this.h, "little");
};
function Fy(n, e, t, r) {
  return n <= 15
    ? e ^ t ^ r
    : n <= 31
    ? (e & t) | (~e & r)
    : n <= 47
    ? (e | ~t) ^ r
    : n <= 63
    ? (e & r) | (t & ~r)
    : e ^ (t | ~r);
}
function bC(n) {
  return n <= 15
    ? 0
    : n <= 31
    ? 1518500249
    : n <= 47
    ? 1859775393
    : n <= 63
    ? 2400959708
    : 2840853838;
}
function xC(n) {
  return n <= 15
    ? 1352829926
    : n <= 31
    ? 1548603684
    : n <= 47
    ? 1836072691
    : n <= 63
    ? 2053994217
    : 0;
}
var vC = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6,
    15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13,
    11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9,
    7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
  ],
  wC = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5,
    10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10,
    0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10,
    4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
  ],
  TC = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9,
    7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13,
    6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9,
    15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
  ],
  CC = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8,
    9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14,
    13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5,
    12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,
  ],
  AC = Me,
  EC = Wc;
function Os(n, e, t) {
  if (!(this instanceof Os)) return new Os(n, e, t);
  (this.Hash = n),
    (this.blockSize = n.blockSize / 8),
    (this.outSize = n.outSize / 8),
    (this.inner = null),
    (this.outer = null),
    this._init(AC.toArray(e, t));
}
var kC = Os;
Os.prototype._init = function (e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()),
    EC(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++) e.push(0);
  for (t = 0; t < e.length; t++) e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++)
    e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
Os.prototype.update = function (e, t) {
  return this.inner.update(e, t), this;
};
Os.prototype.digest = function (e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function (n) {
  var e = n;
  (e.utils = Me),
    (e.common = Zs),
    (e.sha = eo),
    (e.ripemd = gx),
    (e.hmac = kC),
    (e.sha1 = e.sha.sha1),
    (e.sha256 = e.sha.sha256),
    (e.sha224 = e.sha.sha224),
    (e.sha384 = e.sha.sha384),
    (e.sha512 = e.sha.sha512),
    (e.ripemd160 = e.ripemd.ripemd160);
})(ex);
const In = ir(ex);
function no(n, e, t) {
  return (
    (t = {
      path: e,
      exports: {},
      require: function (r, a) {
        return _C(r, a ?? t.path);
      },
    }),
    n(t, t.exports),
    t.exports
  );
}
function _C() {
  throw new Error(
    "Dynamic requires are not currently supported by @rollup/plugin-commonjs",
  );
}
var Mh = xx;
function xx(n, e) {
  if (!n) throw new Error(e || "Assertion failed");
}
xx.equal = function (e, t, r) {
  if (e != t) throw new Error(r || "Assertion failed: " + e + " != " + t);
};
var br = no(function (n, e) {
    var t = e;
    function r(s, o) {
      if (Array.isArray(s)) return s.slice();
      if (!s) return [];
      var c = [];
      if (typeof s != "string") {
        for (var l = 0; l < s.length; l++) c[l] = s[l] | 0;
        return c;
      }
      if (o === "hex") {
        (s = s.replace(/[^a-z0-9]+/gi, "")),
          s.length % 2 !== 0 && (s = "0" + s);
        for (var l = 0; l < s.length; l += 2)
          c.push(parseInt(s[l] + s[l + 1], 16));
      } else
        for (var l = 0; l < s.length; l++) {
          var u = s.charCodeAt(l),
            d = u >> 8,
            f = u & 255;
          d ? c.push(d, f) : c.push(f);
        }
      return c;
    }
    t.toArray = r;
    function a(s) {
      return s.length === 1 ? "0" + s : s;
    }
    t.zero2 = a;
    function i(s) {
      for (var o = "", c = 0; c < s.length; c++) o += a(s[c].toString(16));
      return o;
    }
    (t.toHex = i),
      (t.encode = function (o, c) {
        return c === "hex" ? i(o) : o;
      });
  }),
  $n = no(function (n, e) {
    var t = e;
    (t.assert = Mh),
      (t.toArray = br.toArray),
      (t.zero2 = br.zero2),
      (t.toHex = br.toHex),
      (t.encode = br.encode);
    function r(c, l, u) {
      var d = new Array(Math.max(c.bitLength(), u) + 1);
      d.fill(0);
      for (var f = 1 << (l + 1), p = c.clone(), m = 0; m < d.length; m++) {
        var y,
          h = p.andln(f - 1);
        p.isOdd()
          ? (h > (f >> 1) - 1 ? (y = (f >> 1) - h) : (y = h), p.isubn(y))
          : (y = 0),
          (d[m] = y),
          p.iushrn(1);
      }
      return d;
    }
    t.getNAF = r;
    function a(c, l) {
      var u = [[], []];
      (c = c.clone()), (l = l.clone());
      for (var d = 0, f = 0, p; c.cmpn(-d) > 0 || l.cmpn(-f) > 0; ) {
        var m = (c.andln(3) + d) & 3,
          y = (l.andln(3) + f) & 3;
        m === 3 && (m = -1), y === 3 && (y = -1);
        var h;
        m & 1
          ? ((p = (c.andln(7) + d) & 7),
            (p === 3 || p === 5) && y === 2 ? (h = -m) : (h = m))
          : (h = 0),
          u[0].push(h);
        var g;
        y & 1
          ? ((p = (l.andln(7) + f) & 7),
            (p === 3 || p === 5) && m === 2 ? (g = -y) : (g = y))
          : (g = 0),
          u[1].push(g),
          2 * d === h + 1 && (d = 1 - d),
          2 * f === g + 1 && (f = 1 - f),
          c.iushrn(1),
          l.iushrn(1);
      }
      return u;
    }
    t.getJSF = a;
    function i(c, l, u) {
      var d = "_" + l;
      c.prototype[l] = function () {
        return this[d] !== void 0 ? this[d] : (this[d] = u.call(this));
      };
    }
    t.cachedProperty = i;
    function s(c) {
      return typeof c == "string" ? t.toArray(c, "hex") : c;
    }
    t.parseBytes = s;
    function o(c) {
      return new Te(c, "hex", "le");
    }
    t.intFromLE = o;
  }),
  cu = $n.getNAF,
  SC = $n.getJSF,
  lu = $n.assert;
function ii(n, e) {
  (this.type = n),
    (this.p = new Te(e.p, 16)),
    (this.red = e.prime ? Te.red(e.prime) : Te.mont(this.p)),
    (this.zero = new Te(0).toRed(this.red)),
    (this.one = new Te(1).toRed(this.red)),
    (this.two = new Te(2).toRed(this.red)),
    (this.n = e.n && new Te(e.n, 16)),
    (this.g = e.g && this.pointFromJSON(e.g, e.gRed)),
    (this._wnafT1 = new Array(4)),
    (this._wnafT2 = new Array(4)),
    (this._wnafT3 = new Array(4)),
    (this._wnafT4 = new Array(4)),
    (this._bitLength = this.n ? this.n.bitLength() : 0);
  var t = this.n && this.p.div(this.n);
  !t || t.cmpn(100) > 0
    ? (this.redN = null)
    : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)));
}
var qi = ii;
ii.prototype.point = function () {
  throw new Error("Not implemented");
};
ii.prototype.validate = function () {
  throw new Error("Not implemented");
};
ii.prototype._fixedNafMul = function (e, t) {
  lu(e.precomputed);
  var r = e._getDoubles(),
    a = cu(t, 1, this._bitLength),
    i = (1 << (r.step + 1)) - (r.step % 2 === 0 ? 2 : 1);
  i /= 3;
  var s = [],
    o,
    c;
  for (o = 0; o < a.length; o += r.step) {
    c = 0;
    for (var l = o + r.step - 1; l >= o; l--) c = (c << 1) + a[l];
    s.push(c);
  }
  for (
    var u = this.jpoint(null, null, null),
      d = this.jpoint(null, null, null),
      f = i;
    f > 0;
    f--
  ) {
    for (o = 0; o < s.length; o++)
      (c = s[o]),
        c === f
          ? (d = d.mixedAdd(r.points[o]))
          : c === -f && (d = d.mixedAdd(r.points[o].neg()));
    u = u.add(d);
  }
  return u.toP();
};
ii.prototype._wnafMul = function (e, t) {
  var r = 4,
    a = e._getNAFPoints(r);
  r = a.wnd;
  for (
    var i = a.points,
      s = cu(t, r, this._bitLength),
      o = this.jpoint(null, null, null),
      c = s.length - 1;
    c >= 0;
    c--
  ) {
    for (var l = 0; c >= 0 && s[c] === 0; c--) l++;
    if ((c >= 0 && l++, (o = o.dblp(l)), c < 0)) break;
    var u = s[c];
    lu(u !== 0),
      e.type === "affine"
        ? u > 0
          ? (o = o.mixedAdd(i[(u - 1) >> 1]))
          : (o = o.mixedAdd(i[(-u - 1) >> 1].neg()))
        : u > 0
        ? (o = o.add(i[(u - 1) >> 1]))
        : (o = o.add(i[(-u - 1) >> 1].neg()));
  }
  return e.type === "affine" ? o.toP() : o;
};
ii.prototype._wnafMulAdd = function (e, t, r, a, i) {
  var s = this._wnafT1,
    o = this._wnafT2,
    c = this._wnafT3,
    l = 0,
    u,
    d,
    f;
  for (u = 0; u < a; u++) {
    f = t[u];
    var p = f._getNAFPoints(e);
    (s[u] = p.wnd), (o[u] = p.points);
  }
  for (u = a - 1; u >= 1; u -= 2) {
    var m = u - 1,
      y = u;
    if (s[m] !== 1 || s[y] !== 1) {
      (c[m] = cu(r[m], s[m], this._bitLength)),
        (c[y] = cu(r[y], s[y], this._bitLength)),
        (l = Math.max(c[m].length, l)),
        (l = Math.max(c[y].length, l));
      continue;
    }
    var h = [t[m], null, null, t[y]];
    t[m].y.cmp(t[y].y) === 0
      ? ((h[1] = t[m].add(t[y])), (h[2] = t[m].toJ().mixedAdd(t[y].neg())))
      : t[m].y.cmp(t[y].y.redNeg()) === 0
      ? ((h[1] = t[m].toJ().mixedAdd(t[y])), (h[2] = t[m].add(t[y].neg())))
      : ((h[1] = t[m].toJ().mixedAdd(t[y])),
        (h[2] = t[m].toJ().mixedAdd(t[y].neg())));
    var g = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
      v = SC(r[m], r[y]);
    for (
      l = Math.max(v[0].length, l),
        c[m] = new Array(l),
        c[y] = new Array(l),
        d = 0;
      d < l;
      d++
    ) {
      var w = v[0][d] | 0,
        T = v[1][d] | 0;
      (c[m][d] = g[(w + 1) * 3 + (T + 1)]), (c[y][d] = 0), (o[m] = h);
    }
  }
  var A = this.jpoint(null, null, null),
    E = this._wnafT4;
  for (u = l; u >= 0; u--) {
    for (var _ = 0; u >= 0; ) {
      var S = !0;
      for (d = 0; d < a; d++) (E[d] = c[d][u] | 0), E[d] !== 0 && (S = !1);
      if (!S) break;
      _++, u--;
    }
    if ((u >= 0 && _++, (A = A.dblp(_)), u < 0)) break;
    for (d = 0; d < a; d++) {
      var W = E[d];
      W !== 0 &&
        (W > 0
          ? (f = o[d][(W - 1) >> 1])
          : W < 0 && (f = o[d][(-W - 1) >> 1].neg()),
        f.type === "affine" ? (A = A.mixedAdd(f)) : (A = A.add(f)));
    }
  }
  for (u = 0; u < a; u++) o[u] = null;
  return i ? A : A.toP();
};
function sr(n, e) {
  (this.curve = n), (this.type = e), (this.precomputed = null);
}
ii.BasePoint = sr;
sr.prototype.eq = function () {
  throw new Error("Not implemented");
};
sr.prototype.validate = function () {
  return this.curve.validate(this);
};
ii.prototype.decodePoint = function (e, t) {
  e = $n.toArray(e, t);
  var r = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
    e[0] === 6
      ? lu(e[e.length - 1] % 2 === 0)
      : e[0] === 7 && lu(e[e.length - 1] % 2 === 1);
    var a = this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r));
    return a;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r)
    return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
  throw new Error("Unknown point format");
};
sr.prototype.encodeCompressed = function (e) {
  return this.encode(e, !0);
};
sr.prototype._encode = function (e) {
  var t = this.curve.p.byteLength(),
    r = this.getX().toArray("be", t);
  return e
    ? [this.getY().isEven() ? 2 : 3].concat(r)
    : [4].concat(r, this.getY().toArray("be", t));
};
sr.prototype.encode = function (e, t) {
  return $n.encode(this._encode(t), e);
};
sr.prototype.precompute = function (e) {
  if (this.precomputed) return this;
  var t = { doubles: null, naf: null, beta: null };
  return (
    (t.naf = this._getNAFPoints(8)),
    (t.doubles = this._getDoubles(4, e)),
    (t.beta = this._getBeta()),
    (this.precomputed = t),
    this
  );
};
sr.prototype._hasDoubles = function (e) {
  if (!this.precomputed) return !1;
  var t = this.precomputed.doubles;
  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;
};
sr.prototype._getDoubles = function (e, t) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var r = [this], a = this, i = 0; i < t; i += e) {
    for (var s = 0; s < e; s++) a = a.dbl();
    r.push(a);
  }
  return { step: e, points: r };
};
sr.prototype._getNAFPoints = function (e) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  for (
    var t = [this], r = (1 << e) - 1, a = r === 1 ? null : this.dbl(), i = 1;
    i < r;
    i++
  )
    t[i] = t[i - 1].add(a);
  return { wnd: e, points: t };
};
sr.prototype._getBeta = function () {
  return null;
};
sr.prototype.dblp = function (e) {
  for (var t = this, r = 0; r < e; r++) t = t.dbl();
  return t;
};
var Bh = no(function (n) {
    typeof Object.create == "function"
      ? (n.exports = function (t, r) {
          r &&
            ((t.super_ = r),
            (t.prototype = Object.create(r.prototype, {
              constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })));
        })
      : (n.exports = function (t, r) {
          if (r) {
            t.super_ = r;
            var a = function () {};
            (a.prototype = r.prototype),
              (t.prototype = new a()),
              (t.prototype.constructor = t);
          }
        });
  }),
  PC = $n.assert;
function or(n) {
  qi.call(this, "short", n),
    (this.a = new Te(n.a, 16).toRed(this.red)),
    (this.b = new Te(n.b, 16).toRed(this.red)),
    (this.tinv = this.two.redInvm()),
    (this.zeroA = this.a.fromRed().cmpn(0) === 0),
    (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
    (this.endo = this._getEndomorphism(n)),
    (this._endoWnafT1 = new Array(4)),
    (this._endoWnafT2 = new Array(4));
}
Bh(or, qi);
var IC = or;
or.prototype._getEndomorphism = function (e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var t, r;
    if (e.beta) t = new Te(e.beta, 16).toRed(this.red);
    else {
      var a = this._getEndoRoots(this.p);
      (t = a[0].cmp(a[1]) < 0 ? a[0] : a[1]), (t = t.toRed(this.red));
    }
    if (e.lambda) r = new Te(e.lambda, 16);
    else {
      var i = this._getEndoRoots(this.n);
      this.g.mul(i[0]).x.cmp(this.g.x.redMul(t)) === 0
        ? (r = i[0])
        : ((r = i[1]), PC(this.g.mul(r).x.cmp(this.g.x.redMul(t)) === 0));
    }
    var s;
    return (
      e.basis
        ? (s = e.basis.map(function (o) {
            return { a: new Te(o.a, 16), b: new Te(o.b, 16) };
          }))
        : (s = this._getEndoBasis(r)),
      { beta: t, lambda: r, basis: s }
    );
  }
};
or.prototype._getEndoRoots = function (e) {
  var t = e === this.p ? this.red : Te.mont(e),
    r = new Te(2).toRed(t).redInvm(),
    a = r.redNeg(),
    i = new Te(3).toRed(t).redNeg().redSqrt().redMul(r),
    s = a.redAdd(i).fromRed(),
    o = a.redSub(i).fromRed();
  return [s, o];
};
or.prototype._getEndoBasis = function (e) {
  for (
    var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
      r = e,
      a = this.n.clone(),
      i = new Te(1),
      s = new Te(0),
      o = new Te(0),
      c = new Te(1),
      l,
      u,
      d,
      f,
      p,
      m,
      y,
      h = 0,
      g,
      v;
    r.cmpn(0) !== 0;

  ) {
    var w = a.div(r);
    (g = a.sub(w.mul(r))), (v = o.sub(w.mul(i)));
    var T = c.sub(w.mul(s));
    if (!d && g.cmp(t) < 0) (l = y.neg()), (u = i), (d = g.neg()), (f = v);
    else if (d && ++h === 2) break;
    (y = g), (a = r), (r = g), (o = i), (i = v), (c = s), (s = T);
  }
  (p = g.neg()), (m = v);
  var A = d.sqr().add(f.sqr()),
    E = p.sqr().add(m.sqr());
  return (
    E.cmp(A) >= 0 && ((p = l), (m = u)),
    d.negative && ((d = d.neg()), (f = f.neg())),
    p.negative && ((p = p.neg()), (m = m.neg())),
    [
      { a: d, b: f },
      { a: p, b: m },
    ]
  );
};
or.prototype._endoSplit = function (e) {
  var t = this.endo.basis,
    r = t[0],
    a = t[1],
    i = a.b.mul(e).divRound(this.n),
    s = r.b.neg().mul(e).divRound(this.n),
    o = i.mul(r.a),
    c = s.mul(a.a),
    l = i.mul(r.b),
    u = s.mul(a.b),
    d = e.sub(o).sub(c),
    f = l.add(u).neg();
  return { k1: d, k2: f };
};
or.prototype.pointFromX = function (e, t) {
  (e = new Te(e, 16)), e.red || (e = e.toRed(this.red));
  var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
    a = r.redSqrt();
  if (a.redSqr().redSub(r).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var i = a.fromRed().isOdd();
  return ((t && !i) || (!t && i)) && (a = a.redNeg()), this.point(e, a);
};
or.prototype.validate = function (e) {
  if (e.inf) return !0;
  var t = e.x,
    r = e.y,
    a = this.a.redMul(t),
    i = t.redSqr().redMul(t).redIAdd(a).redIAdd(this.b);
  return r.redSqr().redISub(i).cmpn(0) === 0;
};
or.prototype._endoWnafMulAdd = function (e, t, r) {
  for (
    var a = this._endoWnafT1, i = this._endoWnafT2, s = 0;
    s < e.length;
    s++
  ) {
    var o = this._endoSplit(t[s]),
      c = e[s],
      l = c._getBeta();
    o.k1.negative && (o.k1.ineg(), (c = c.neg(!0))),
      o.k2.negative && (o.k2.ineg(), (l = l.neg(!0))),
      (a[s * 2] = c),
      (a[s * 2 + 1] = l),
      (i[s * 2] = o.k1),
      (i[s * 2 + 1] = o.k2);
  }
  for (var u = this._wnafMulAdd(1, a, i, s * 2, r), d = 0; d < s * 2; d++)
    (a[d] = null), (i[d] = null);
  return u;
};
function Ot(n, e, t, r) {
  qi.BasePoint.call(this, n, "affine"),
    e === null && t === null
      ? ((this.x = null), (this.y = null), (this.inf = !0))
      : ((this.x = new Te(e, 16)),
        (this.y = new Te(t, 16)),
        r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        (this.inf = !1));
}
Bh(Ot, qi.BasePoint);
or.prototype.point = function (e, t, r) {
  return new Ot(this, e, t, r);
};
or.prototype.pointFromJSON = function (e, t) {
  return Ot.fromJSON(this, e, t);
};
Ot.prototype._getBeta = function () {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta) return e.beta;
    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var r = this.curve,
        a = function (i) {
          return r.point(i.x.redMul(r.endo.beta), i.y);
        };
      (e.beta = t),
        (t.precomputed = {
          beta: null,
          naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(a) },
          doubles: e.doubles && {
            step: e.doubles.step,
            points: e.doubles.points.map(a),
          },
        });
    }
    return t;
  }
};
Ot.prototype.toJSON = function () {
  return this.precomputed
    ? [
        this.x,
        this.y,
        this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1),
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1),
          },
        },
      ]
    : [this.x, this.y];
};
Ot.fromJSON = function (e, t, r) {
  typeof t == "string" && (t = JSON.parse(t));
  var a = e.point(t[0], t[1], r);
  if (!t[2]) return a;
  function i(o) {
    return e.point(o[0], o[1], r);
  }
  var s = t[2];
  return (
    (a.precomputed = {
      beta: null,
      doubles: s.doubles && {
        step: s.doubles.step,
        points: [a].concat(s.doubles.points.map(i)),
      },
      naf: s.naf && { wnd: s.naf.wnd, points: [a].concat(s.naf.points.map(i)) },
    }),
    a
  );
};
Ot.prototype.inspect = function () {
  return this.isInfinity()
    ? "<EC Point Infinity>"
    : "<EC Point x: " +
        this.x.fromRed().toString(16, 2) +
        " y: " +
        this.y.fromRed().toString(16, 2) +
        ">";
};
Ot.prototype.isInfinity = function () {
  return this.inf;
};
Ot.prototype.add = function (e) {
  if (this.inf) return e;
  if (e.inf) return this;
  if (this.eq(e)) return this.dbl();
  if (this.neg().eq(e)) return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
  var t = this.y.redSub(e.y);
  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
  var r = t.redSqr().redISub(this.x).redISub(e.x),
    a = t.redMul(this.x.redSub(r)).redISub(this.y);
  return this.curve.point(r, a);
};
Ot.prototype.dbl = function () {
  if (this.inf) return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0) return this.curve.point(null, null);
  var t = this.curve.a,
    r = this.x.redSqr(),
    a = e.redInvm(),
    i = r.redAdd(r).redIAdd(r).redIAdd(t).redMul(a),
    s = i.redSqr().redISub(this.x.redAdd(this.x)),
    o = i.redMul(this.x.redSub(s)).redISub(this.y);
  return this.curve.point(s, o);
};
Ot.prototype.getX = function () {
  return this.x.fromRed();
};
Ot.prototype.getY = function () {
  return this.y.fromRed();
};
Ot.prototype.mul = function (e) {
  return (
    (e = new Te(e, 16)),
    this.isInfinity()
      ? this
      : this._hasDoubles(e)
      ? this.curve._fixedNafMul(this, e)
      : this.curve.endo
      ? this.curve._endoWnafMulAdd([this], [e])
      : this.curve._wnafMul(this, e)
  );
};
Ot.prototype.mulAdd = function (e, t, r) {
  var a = [this, t],
    i = [e, r];
  return this.curve.endo
    ? this.curve._endoWnafMulAdd(a, i)
    : this.curve._wnafMulAdd(1, a, i, 2);
};
Ot.prototype.jmulAdd = function (e, t, r) {
  var a = [this, t],
    i = [e, r];
  return this.curve.endo
    ? this.curve._endoWnafMulAdd(a, i, !0)
    : this.curve._wnafMulAdd(1, a, i, 2, !0);
};
Ot.prototype.eq = function (e) {
  return (
    this === e ||
    (this.inf === e.inf &&
      (this.inf || (this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)))
  );
};
Ot.prototype.neg = function (e) {
  if (this.inf) return this;
  var t = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var r = this.precomputed,
      a = function (i) {
        return i.neg();
      };
    t.precomputed = {
      naf: r.naf && { wnd: r.naf.wnd, points: r.naf.points.map(a) },
      doubles: r.doubles && {
        step: r.doubles.step,
        points: r.doubles.points.map(a),
      },
    };
  }
  return t;
};
Ot.prototype.toJ = function () {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function Gt(n, e, t, r) {
  qi.BasePoint.call(this, n, "jacobian"),
    e === null && t === null && r === null
      ? ((this.x = this.curve.one),
        (this.y = this.curve.one),
        (this.z = new Te(0)))
      : ((this.x = new Te(e, 16)),
        (this.y = new Te(t, 16)),
        (this.z = new Te(r, 16))),
    this.x.red || (this.x = this.x.toRed(this.curve.red)),
    this.y.red || (this.y = this.y.toRed(this.curve.red)),
    this.z.red || (this.z = this.z.toRed(this.curve.red)),
    (this.zOne = this.z === this.curve.one);
}
Bh(Gt, qi.BasePoint);
or.prototype.jpoint = function (e, t, r) {
  return new Gt(this, e, t, r);
};
Gt.prototype.toP = function () {
  if (this.isInfinity()) return this.curve.point(null, null);
  var e = this.z.redInvm(),
    t = e.redSqr(),
    r = this.x.redMul(t),
    a = this.y.redMul(t).redMul(e);
  return this.curve.point(r, a);
};
Gt.prototype.neg = function () {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
Gt.prototype.add = function (e) {
  if (this.isInfinity()) return e;
  if (e.isInfinity()) return this;
  var t = e.z.redSqr(),
    r = this.z.redSqr(),
    a = this.x.redMul(t),
    i = e.x.redMul(r),
    s = this.y.redMul(t.redMul(e.z)),
    o = e.y.redMul(r.redMul(this.z)),
    c = a.redSub(i),
    l = s.redSub(o);
  if (c.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var u = c.redSqr(),
    d = u.redMul(c),
    f = a.redMul(u),
    p = l.redSqr().redIAdd(d).redISub(f).redISub(f),
    m = l.redMul(f.redISub(p)).redISub(s.redMul(d)),
    y = this.z.redMul(e.z).redMul(c);
  return this.curve.jpoint(p, m, y);
};
Gt.prototype.mixedAdd = function (e) {
  if (this.isInfinity()) return e.toJ();
  if (e.isInfinity()) return this;
  var t = this.z.redSqr(),
    r = this.x,
    a = e.x.redMul(t),
    i = this.y,
    s = e.y.redMul(t).redMul(this.z),
    o = r.redSub(a),
    c = i.redSub(s);
  if (o.cmpn(0) === 0)
    return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = o.redSqr(),
    u = l.redMul(o),
    d = r.redMul(l),
    f = c.redSqr().redIAdd(u).redISub(d).redISub(d),
    p = c.redMul(d.redISub(f)).redISub(i.redMul(u)),
    m = this.z.redMul(o);
  return this.curve.jpoint(f, p, m);
};
Gt.prototype.dblp = function (e) {
  if (e === 0) return this;
  if (this.isInfinity()) return this;
  if (!e) return this.dbl();
  var t;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (t = 0; t < e; t++) r = r.dbl();
    return r;
  }
  var a = this.curve.a,
    i = this.curve.tinv,
    s = this.x,
    o = this.y,
    c = this.z,
    l = c.redSqr().redSqr(),
    u = o.redAdd(o);
  for (t = 0; t < e; t++) {
    var d = s.redSqr(),
      f = u.redSqr(),
      p = f.redSqr(),
      m = d.redAdd(d).redIAdd(d).redIAdd(a.redMul(l)),
      y = s.redMul(f),
      h = m.redSqr().redISub(y.redAdd(y)),
      g = y.redISub(h),
      v = m.redMul(g);
    v = v.redIAdd(v).redISub(p);
    var w = u.redMul(c);
    t + 1 < e && (l = l.redMul(p)), (s = h), (c = w), (u = v);
  }
  return this.curve.jpoint(s, u.redMul(i), c);
};
Gt.prototype.dbl = function () {
  return this.isInfinity()
    ? this
    : this.curve.zeroA
    ? this._zeroDbl()
    : this.curve.threeA
    ? this._threeDbl()
    : this._dbl();
};
Gt.prototype._zeroDbl = function () {
  var e, t, r;
  if (this.zOne) {
    var a = this.x.redSqr(),
      i = this.y.redSqr(),
      s = i.redSqr(),
      o = this.x.redAdd(i).redSqr().redISub(a).redISub(s);
    o = o.redIAdd(o);
    var c = a.redAdd(a).redIAdd(a),
      l = c.redSqr().redISub(o).redISub(o),
      u = s.redIAdd(s);
    (u = u.redIAdd(u)),
      (u = u.redIAdd(u)),
      (e = l),
      (t = c.redMul(o.redISub(l)).redISub(u)),
      (r = this.y.redAdd(this.y));
  } else {
    var d = this.x.redSqr(),
      f = this.y.redSqr(),
      p = f.redSqr(),
      m = this.x.redAdd(f).redSqr().redISub(d).redISub(p);
    m = m.redIAdd(m);
    var y = d.redAdd(d).redIAdd(d),
      h = y.redSqr(),
      g = p.redIAdd(p);
    (g = g.redIAdd(g)),
      (g = g.redIAdd(g)),
      (e = h.redISub(m).redISub(m)),
      (t = y.redMul(m.redISub(e)).redISub(g)),
      (r = this.y.redMul(this.z)),
      (r = r.redIAdd(r));
  }
  return this.curve.jpoint(e, t, r);
};
Gt.prototype._threeDbl = function () {
  var e, t, r;
  if (this.zOne) {
    var a = this.x.redSqr(),
      i = this.y.redSqr(),
      s = i.redSqr(),
      o = this.x.redAdd(i).redSqr().redISub(a).redISub(s);
    o = o.redIAdd(o);
    var c = a.redAdd(a).redIAdd(a).redIAdd(this.curve.a),
      l = c.redSqr().redISub(o).redISub(o);
    e = l;
    var u = s.redIAdd(s);
    (u = u.redIAdd(u)),
      (u = u.redIAdd(u)),
      (t = c.redMul(o.redISub(l)).redISub(u)),
      (r = this.y.redAdd(this.y));
  } else {
    var d = this.z.redSqr(),
      f = this.y.redSqr(),
      p = this.x.redMul(f),
      m = this.x.redSub(d).redMul(this.x.redAdd(d));
    m = m.redAdd(m).redIAdd(m);
    var y = p.redIAdd(p);
    y = y.redIAdd(y);
    var h = y.redAdd(y);
    (e = m.redSqr().redISub(h)),
      (r = this.y.redAdd(this.z).redSqr().redISub(f).redISub(d));
    var g = f.redSqr();
    (g = g.redIAdd(g)),
      (g = g.redIAdd(g)),
      (g = g.redIAdd(g)),
      (t = m.redMul(y.redISub(e)).redISub(g));
  }
  return this.curve.jpoint(e, t, r);
};
Gt.prototype._dbl = function () {
  var e = this.curve.a,
    t = this.x,
    r = this.y,
    a = this.z,
    i = a.redSqr().redSqr(),
    s = t.redSqr(),
    o = r.redSqr(),
    c = s.redAdd(s).redIAdd(s).redIAdd(e.redMul(i)),
    l = t.redAdd(t);
  l = l.redIAdd(l);
  var u = l.redMul(o),
    d = c.redSqr().redISub(u.redAdd(u)),
    f = u.redISub(d),
    p = o.redSqr();
  (p = p.redIAdd(p)), (p = p.redIAdd(p)), (p = p.redIAdd(p));
  var m = c.redMul(f).redISub(p),
    y = r.redAdd(r).redMul(a);
  return this.curve.jpoint(d, m, y);
};
Gt.prototype.trpl = function () {
  if (!this.curve.zeroA) return this.dbl().add(this);
  var e = this.x.redSqr(),
    t = this.y.redSqr(),
    r = this.z.redSqr(),
    a = t.redSqr(),
    i = e.redAdd(e).redIAdd(e),
    s = i.redSqr(),
    o = this.x.redAdd(t).redSqr().redISub(e).redISub(a);
  (o = o.redIAdd(o)), (o = o.redAdd(o).redIAdd(o)), (o = o.redISub(s));
  var c = o.redSqr(),
    l = a.redIAdd(a);
  (l = l.redIAdd(l)), (l = l.redIAdd(l)), (l = l.redIAdd(l));
  var u = i.redIAdd(o).redSqr().redISub(s).redISub(c).redISub(l),
    d = t.redMul(u);
  (d = d.redIAdd(d)), (d = d.redIAdd(d));
  var f = this.x.redMul(c).redISub(d);
  (f = f.redIAdd(f)), (f = f.redIAdd(f));
  var p = this.y.redMul(u.redMul(l.redISub(u)).redISub(o.redMul(c)));
  (p = p.redIAdd(p)), (p = p.redIAdd(p)), (p = p.redIAdd(p));
  var m = this.z.redAdd(o).redSqr().redISub(r).redISub(c);
  return this.curve.jpoint(f, p, m);
};
Gt.prototype.mul = function (e, t) {
  return (e = new Te(e, t)), this.curve._wnafMul(this, e);
};
Gt.prototype.eq = function (e) {
  if (e.type === "affine") return this.eq(e.toJ());
  if (this === e) return !0;
  var t = this.z.redSqr(),
    r = e.z.redSqr();
  if (this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0) !== 0) return !1;
  var a = t.redMul(this.z),
    i = r.redMul(e.z);
  return this.y.redMul(i).redISub(e.y.redMul(a)).cmpn(0) === 0;
};
Gt.prototype.eqXToP = function (e) {
  var t = this.z.redSqr(),
    r = e.toRed(this.curve.red).redMul(t);
  if (this.x.cmp(r) === 0) return !0;
  for (var a = e.clone(), i = this.curve.redN.redMul(t); ; ) {
    if ((a.iadd(this.curve.n), a.cmp(this.curve.p) >= 0)) return !1;
    if ((r.redIAdd(i), this.x.cmp(r) === 0)) return !0;
  }
};
Gt.prototype.inspect = function () {
  return this.isInfinity()
    ? "<EC JPoint Infinity>"
    : "<EC JPoint x: " +
        this.x.toString(16, 2) +
        " y: " +
        this.y.toString(16, 2) +
        " z: " +
        this.z.toString(16, 2) +
        ">";
};
Gt.prototype.isInfinity = function () {
  return this.z.cmpn(0) === 0;
};
var Ul = no(function (n, e) {
    var t = e;
    (t.base = qi), (t.short = IC), (t.mont = null), (t.edwards = null);
  }),
  jl = no(function (n, e) {
    var t = e,
      r = $n.assert;
    function a(o) {
      o.type === "short"
        ? (this.curve = new Ul.short(o))
        : o.type === "edwards"
        ? (this.curve = new Ul.edwards(o))
        : (this.curve = new Ul.mont(o)),
        (this.g = this.curve.g),
        (this.n = this.curve.n),
        (this.hash = o.hash),
        r(this.g.validate(), "Invalid curve"),
        r(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    t.PresetCurve = a;
    function i(o, c) {
      Object.defineProperty(t, o, {
        configurable: !0,
        enumerable: !0,
        get: function () {
          var l = new a(c);
          return (
            Object.defineProperty(t, o, {
              configurable: !0,
              enumerable: !0,
              value: l,
            }),
            l
          );
        },
      });
    }
    i("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: In.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811",
      ],
    }),
      i("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: In.sha256,
        gRed: !1,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34",
        ],
      }),
      i("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: In.sha256,
        gRed: !1,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5",
        ],
      }),
      i("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: In.sha384,
        gRed: !1,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f",
        ],
      }),
      i("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: In.sha512,
        gRed: !1,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650",
        ],
      }),
      i("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: In.sha256,
        gRed: !1,
        g: ["9"],
      }),
      i("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: In.sha256,
        gRed: !1,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          "6666666666666666666666666666666666666666666666666666666666666658",
        ],
      });
    var s;
    try {
      s = null.crash();
    } catch {
      s = void 0;
    }
    i("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: In.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda:
        "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3",
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15",
        },
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        s,
      ],
    });
  });
function Ka(n) {
  if (!(this instanceof Ka)) return new Ka(n);
  (this.hash = n.hash),
    (this.predResist = !!n.predResist),
    (this.outLen = this.hash.outSize),
    (this.minEntropy = n.minEntropy || this.hash.hmacStrength),
    (this._reseed = null),
    (this.reseedInterval = null),
    (this.K = null),
    (this.V = null);
  var e = br.toArray(n.entropy, n.entropyEnc || "hex"),
    t = br.toArray(n.nonce, n.nonceEnc || "hex"),
    r = br.toArray(n.pers, n.persEnc || "hex");
  Mh(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits",
  ),
    this._init(e, t, r);
}
var vx = Ka;
Ka.prototype._init = function (e, t, r) {
  var a = e.concat(t).concat(r);
  (this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8));
  for (var i = 0; i < this.V.length; i++) (this.K[i] = 0), (this.V[i] = 1);
  this._update(a), (this._reseed = 1), (this.reseedInterval = 281474976710656);
};
Ka.prototype._hmac = function () {
  return new In.hmac(this.hash, this.K);
};
Ka.prototype._update = function (e) {
  var t = this._hmac().update(this.V).update([0]);
  e && (t = t.update(e)),
    (this.K = t.digest()),
    (this.V = this._hmac().update(this.V).digest()),
    e &&
      ((this.K = this._hmac().update(this.V).update([1]).update(e).digest()),
      (this.V = this._hmac().update(this.V).digest()));
};
Ka.prototype.reseed = function (e, t, r, a) {
  typeof t != "string" && ((a = r), (r = t), (t = null)),
    (e = br.toArray(e, t)),
    (r = br.toArray(r, a)),
    Mh(
      e.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits",
    ),
    this._update(e.concat(r || [])),
    (this._reseed = 1);
};
Ka.prototype.generate = function (e, t, r, a) {
  if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
  typeof t != "string" && ((a = r), (r = t), (t = null)),
    r && ((r = br.toArray(r, a || "hex")), this._update(r));
  for (var i = []; i.length < e; )
    (this.V = this._hmac().update(this.V).digest()), (i = i.concat(this.V));
  var s = i.slice(0, e);
  return this._update(r), this._reseed++, br.encode(s, t);
};
var gp = $n.assert;
function nn(n, e) {
  (this.ec = n),
    (this.priv = null),
    (this.pub = null),
    e.priv && this._importPrivate(e.priv, e.privEnc),
    e.pub && this._importPublic(e.pub, e.pubEnc);
}
var Dh = nn;
nn.fromPublic = function (e, t, r) {
  return t instanceof nn ? t : new nn(e, { pub: t, pubEnc: r });
};
nn.fromPrivate = function (e, t, r) {
  return t instanceof nn ? t : new nn(e, { priv: t, privEnc: r });
};
nn.prototype.validate = function () {
  var e = this.getPublic();
  return e.isInfinity()
    ? { result: !1, reason: "Invalid public key" }
    : e.validate()
    ? e.mul(this.ec.curve.n).isInfinity()
      ? { result: !0, reason: null }
      : { result: !1, reason: "Public key * N != O" }
    : { result: !1, reason: "Public key is not a point" };
};
nn.prototype.getPublic = function (e, t) {
  return (
    typeof e == "string" && ((t = e), (e = null)),
    this.pub || (this.pub = this.ec.g.mul(this.priv)),
    t ? this.pub.encode(t, e) : this.pub
  );
};
nn.prototype.getPrivate = function (e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
nn.prototype._importPrivate = function (e, t) {
  (this.priv = new Te(e, t || 16)),
    (this.priv = this.priv.umod(this.ec.curve.n));
};
nn.prototype._importPublic = function (e, t) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont"
      ? gp(e.x, "Need x coordinate")
      : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") &&
        gp(e.x && e.y, "Need both x and y coordinate"),
      (this.pub = this.ec.curve.point(e.x, e.y));
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, t);
};
nn.prototype.derive = function (e) {
  return (
    e.validate() || gp(e.validate(), "public point not validated"),
    e.mul(this.priv).getX()
  );
};
nn.prototype.sign = function (e, t, r) {
  return this.ec.sign(e, this, t, r);
};
nn.prototype.verify = function (e, t) {
  return this.ec.verify(e, t, this);
};
nn.prototype.inspect = function () {
  return (
    "<Key priv: " +
    (this.priv && this.priv.toString(16, 2)) +
    " pub: " +
    (this.pub && this.pub.inspect()) +
    " >"
  );
};
var RC = $n.assert;
function Fd(n, e) {
  if (n instanceof Fd) return n;
  this._importDER(n, e) ||
    (RC(n.r && n.s, "Signature without r or s"),
    (this.r = new Te(n.r, 16)),
    (this.s = new Te(n.s, 16)),
    n.recoveryParam === void 0
      ? (this.recoveryParam = null)
      : (this.recoveryParam = n.recoveryParam));
}
var Ld = Fd;
function MC() {
  this.place = 0;
}
function zf(n, e) {
  var t = n[e.place++];
  if (!(t & 128)) return t;
  var r = t & 15;
  if (r === 0 || r > 4) return !1;
  for (var a = 0, i = 0, s = e.place; i < r; i++, s++)
    (a <<= 8), (a |= n[s]), (a >>>= 0);
  return a <= 127 ? !1 : ((e.place = s), a);
}
function Ly(n) {
  for (var e = 0, t = n.length - 1; !n[e] && !(n[e + 1] & 128) && e < t; ) e++;
  return e === 0 ? n : n.slice(e);
}
Fd.prototype._importDER = function (e, t) {
  e = $n.toArray(e, t);
  var r = new MC();
  if (e[r.place++] !== 48) return !1;
  var a = zf(e, r);
  if (a === !1 || a + r.place !== e.length || e[r.place++] !== 2) return !1;
  var i = zf(e, r);
  if (i === !1) return !1;
  var s = e.slice(r.place, i + r.place);
  if (((r.place += i), e[r.place++] !== 2)) return !1;
  var o = zf(e, r);
  if (o === !1 || e.length !== o + r.place) return !1;
  var c = e.slice(r.place, o + r.place);
  if (s[0] === 0)
    if (s[1] & 128) s = s.slice(1);
    else return !1;
  if (c[0] === 0)
    if (c[1] & 128) c = c.slice(1);
    else return !1;
  return (
    (this.r = new Te(s)), (this.s = new Te(c)), (this.recoveryParam = null), !0
  );
};
function Hf(n, e) {
  if (e < 128) {
    n.push(e);
    return;
  }
  var t = 1 + ((Math.log(e) / Math.LN2) >>> 3);
  for (n.push(t | 128); --t; ) n.push((e >>> (t << 3)) & 255);
  n.push(e);
}
Fd.prototype.toDER = function (e) {
  var t = this.r.toArray(),
    r = this.s.toArray();
  for (
    t[0] & 128 && (t = [0].concat(t)),
      r[0] & 128 && (r = [0].concat(r)),
      t = Ly(t),
      r = Ly(r);
    !r[0] && !(r[1] & 128);

  )
    r = r.slice(1);
  var a = [2];
  Hf(a, t.length), (a = a.concat(t)), a.push(2), Hf(a, r.length);
  var i = a.concat(r),
    s = [48];
  return Hf(s, i.length), (s = s.concat(i)), $n.encode(s, e);
};
var BC = function () {
    throw new Error("unsupported");
  },
  wx = $n.assert;
function tr(n) {
  if (!(this instanceof tr)) return new tr(n);
  typeof n == "string" &&
    (wx(Object.prototype.hasOwnProperty.call(jl, n), "Unknown curve " + n),
    (n = jl[n])),
    n instanceof jl.PresetCurve && (n = { curve: n }),
    (this.curve = n.curve.curve),
    (this.n = this.curve.n),
    (this.nh = this.n.ushrn(1)),
    (this.g = this.curve.g),
    (this.g = n.curve.g),
    this.g.precompute(n.curve.n.bitLength() + 1),
    (this.hash = n.hash || n.curve.hash);
}
var DC = tr;
tr.prototype.keyPair = function (e) {
  return new Dh(this, e);
};
tr.prototype.keyFromPrivate = function (e, t) {
  return Dh.fromPrivate(this, e, t);
};
tr.prototype.keyFromPublic = function (e, t) {
  return Dh.fromPublic(this, e, t);
};
tr.prototype.genKeyPair = function (e) {
  e || (e = {});
  for (
    var t = new vx({
        hash: this.hash,
        pers: e.pers,
        persEnc: e.persEnc || "utf8",
        entropy: e.entropy || BC(this.hash.hmacStrength),
        entropyEnc: (e.entropy && e.entropyEnc) || "utf8",
        nonce: this.n.toArray(),
      }),
      r = this.n.byteLength(),
      a = this.n.sub(new Te(2));
    ;

  ) {
    var i = new Te(t.generate(r));
    if (!(i.cmp(a) > 0)) return i.iaddn(1), this.keyFromPrivate(i);
  }
};
tr.prototype._truncateToN = function (e, t) {
  var r = e.byteLength() * 8 - this.n.bitLength();
  return (
    r > 0 && (e = e.ushrn(r)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
  );
};
tr.prototype.sign = function (e, t, r, a) {
  typeof r == "object" && ((a = r), (r = null)),
    a || (a = {}),
    (t = this.keyFromPrivate(t, r)),
    (e = this._truncateToN(new Te(e, 16)));
  for (
    var i = this.n.byteLength(),
      s = t.getPrivate().toArray("be", i),
      o = e.toArray("be", i),
      c = new vx({
        hash: this.hash,
        entropy: s,
        nonce: o,
        pers: a.pers,
        persEnc: a.persEnc || "utf8",
      }),
      l = this.n.sub(new Te(1)),
      u = 0;
    ;
    u++
  ) {
    var d = a.k ? a.k(u) : new Te(c.generate(this.n.byteLength()));
    if (((d = this._truncateToN(d, !0)), !(d.cmpn(1) <= 0 || d.cmp(l) >= 0))) {
      var f = this.g.mul(d);
      if (!f.isInfinity()) {
        var p = f.getX(),
          m = p.umod(this.n);
        if (m.cmpn(0) !== 0) {
          var y = d.invm(this.n).mul(m.mul(t.getPrivate()).iadd(e));
          if (((y = y.umod(this.n)), y.cmpn(0) !== 0)) {
            var h = (f.getY().isOdd() ? 1 : 0) | (p.cmp(m) !== 0 ? 2 : 0);
            return (
              a.canonical &&
                y.cmp(this.nh) > 0 &&
                ((y = this.n.sub(y)), (h ^= 1)),
              new Ld({ r: m, s: y, recoveryParam: h })
            );
          }
        }
      }
    }
  }
};
tr.prototype.verify = function (e, t, r, a) {
  (e = this._truncateToN(new Te(e, 16))),
    (r = this.keyFromPublic(r, a)),
    (t = new Ld(t, "hex"));
  var i = t.r,
    s = t.s;
  if (
    i.cmpn(1) < 0 ||
    i.cmp(this.n) >= 0 ||
    s.cmpn(1) < 0 ||
    s.cmp(this.n) >= 0
  )
    return !1;
  var o = s.invm(this.n),
    c = o.mul(e).umod(this.n),
    l = o.mul(i).umod(this.n),
    u;
  return this.curve._maxwellTrick
    ? ((u = this.g.jmulAdd(c, r.getPublic(), l)),
      u.isInfinity() ? !1 : u.eqXToP(i))
    : ((u = this.g.mulAdd(c, r.getPublic(), l)),
      u.isInfinity() ? !1 : u.getX().umod(this.n).cmp(i) === 0);
};
tr.prototype.recoverPubKey = function (n, e, t, r) {
  wx((3 & t) === t, "The recovery param is more than two bits"),
    (e = new Ld(e, r));
  var a = this.n,
    i = new Te(n),
    s = e.r,
    o = e.s,
    c = t & 1,
    l = t >> 1;
  if (s.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l)
    throw new Error("Unable to find sencond key candinate");
  l
    ? (s = this.curve.pointFromX(s.add(this.curve.n), c))
    : (s = this.curve.pointFromX(s, c));
  var u = e.r.invm(a),
    d = a.sub(i).mul(u).umod(a),
    f = o.mul(u).umod(a);
  return this.g.mulAdd(d, s, f);
};
tr.prototype.getKeyRecoveryParam = function (n, e, t, r) {
  if (((e = new Ld(e, r)), e.recoveryParam !== null)) return e.recoveryParam;
  for (var a = 0; a < 4; a++) {
    var i;
    try {
      i = this.recoverPubKey(n, e, a);
    } catch {
      continue;
    }
    if (i.eq(t)) return a;
  }
  throw new Error("Unable to find valid recovery factor");
};
var OC = no(function (n, e) {
    var t = e;
    (t.version = "6.5.4"),
      (t.utils = $n),
      (t.rand = function () {
        throw new Error("unsupported");
      }),
      (t.curve = Ul),
      (t.curves = jl),
      (t.ec = DC),
      (t.eddsa = null);
  }),
  NC = OC.ec;
const FC = "signing-key/5.7.0",
  bp = new z(FC);
let qf = null;
function Er() {
  return qf || (qf = new NC("secp256k1")), qf;
}
class Cs {
  constructor(e) {
    Q(this, "curve", "secp256k1"),
      Q(this, "privateKey", pe(e)),
      sa(this.privateKey) !== 32 &&
        bp.throwArgumentError(
          "invalid private key",
          "privateKey",
          "[[ REDACTED ]]",
        );
    const t = Er().keyFromPrivate(ae(this.privateKey));
    Q(this, "publicKey", "0x" + t.getPublic(!1, "hex")),
      Q(this, "compressedPublicKey", "0x" + t.getPublic(!0, "hex")),
      Q(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const t = Er().keyFromPublic(ae(this.publicKey)),
      r = Er().keyFromPublic(ae(e));
    return "0x" + t.pub.add(r.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const t = Er().keyFromPrivate(ae(this.privateKey)),
      r = ae(e);
    r.length !== 32 && bp.throwArgumentError("bad digest length", "digest", e);
    const a = t.sign(r, { canonical: !0 });
    return ai({
      recoveryParam: a.recoveryParam,
      r: Ue("0x" + a.r.toString(16), 32),
      s: Ue("0x" + a.s.toString(16), 32),
    });
  }
  computeSharedSecret(e) {
    const t = Er().keyFromPrivate(ae(this.privateKey)),
      r = Er().keyFromPublic(ae(Tx(e)));
    return Ue("0x" + t.derive(r.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function LC(n, e) {
  const t = ai(e),
    r = { r: ae(t.r), s: ae(t.s) };
  return "0x" + Er().recoverPubKey(ae(n), r, t.recoveryParam).encode("hex", !1);
}
function Tx(n, e) {
  const t = ae(n);
  if (t.length === 32) {
    const r = new Cs(t);
    return e ? "0x" + Er().keyFromPrivate(t).getPublic(!0, "hex") : r.publicKey;
  } else {
    if (t.length === 33)
      return e ? pe(t) : "0x" + Er().keyFromPublic(t).getPublic(!1, "hex");
    if (t.length === 65)
      return e ? "0x" + Er().keyFromPublic(t).getPublic(!0, "hex") : pe(t);
  }
  return bp.throwArgumentError(
    "invalid public or private key",
    "key",
    "[REDACTED]",
  );
}
const $C = "transactions/5.7.0",
  en = new z($C);
var $y;
(function (n) {
  (n[(n.legacy = 0)] = "legacy"),
    (n[(n.eip2930 = 1)] = "eip2930"),
    (n[(n.eip1559 = 2)] = "eip1559");
})($y || ($y = {}));
function Oh(n) {
  return n === "0x" ? null : ht(n);
}
function Zt(n) {
  return n === "0x" ? F2 : O.from(n);
}
const WC = [
    { name: "nonce", maxLength: 32, numeric: !0 },
    { name: "gasPrice", maxLength: 32, numeric: !0 },
    { name: "gasLimit", maxLength: 32, numeric: !0 },
    { name: "to", length: 20 },
    { name: "value", maxLength: 32, numeric: !0 },
    { name: "data" },
  ],
  UC = {
    chainId: !0,
    data: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    type: !0,
    value: !0,
  };
function Ei(n) {
  const e = Tx(n);
  return ht(Mt(Ge(Mt(e, 1)), 12));
}
function Uc(n, e) {
  return Ei(LC(ae(n), e));
}
function Mn(n, e) {
  const t = Zn(O.from(n).toHexString());
  return (
    t.length > 32 &&
      en.throwArgumentError("invalid length for " + e, "transaction:" + e, n),
    t
  );
}
function Vf(n, e) {
  return {
    address: ht(n),
    storageKeys: (e || []).map(
      (t, r) => (
        sa(t) !== 32 &&
          en.throwArgumentError(
            "invalid access list storageKey",
            `accessList[${n}:${r}]`,
            t,
          ),
        t.toLowerCase()
      ),
    ),
  };
}
function Vi(n) {
  if (Array.isArray(n))
    return n.map((t, r) =>
      Array.isArray(t)
        ? (t.length > 2 &&
            en.throwArgumentError(
              "access list expected to be [ address, storageKeys[] ]",
              `value[${r}]`,
              t,
            ),
          Vf(t[0], t[1]))
        : Vf(t.address, t.storageKeys),
    );
  const e = Object.keys(n).map((t) => {
    const r = n[t].reduce((a, i) => ((a[i] = !0), a), {});
    return Vf(t, Object.keys(r).sort());
  });
  return e.sort((t, r) => t.address.localeCompare(r.address)), e;
}
function Cx(n) {
  return Vi(n).map((e) => [e.address, e.storageKeys]);
}
function Ax(n, e) {
  if (n.gasPrice != null) {
    const r = O.from(n.gasPrice),
      a = O.from(n.maxFeePerGas || 0);
    r.eq(a) ||
      en.throwArgumentError(
        "mismatch EIP-1559 gasPrice != maxFeePerGas",
        "tx",
        { gasPrice: r, maxFeePerGas: a },
      );
  }
  const t = [
    Mn(n.chainId || 0, "chainId"),
    Mn(n.nonce || 0, "nonce"),
    Mn(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Mn(n.maxFeePerGas || 0, "maxFeePerGas"),
    Mn(n.gasLimit || 0, "gasLimit"),
    n.to != null ? ht(n.to) : "0x",
    Mn(n.value || 0, "value"),
    n.data || "0x",
    Cx(n.accessList || []),
  ];
  if (e) {
    const r = ai(e);
    t.push(Mn(r.recoveryParam, "recoveryParam")),
      t.push(Zn(r.r)),
      t.push(Zn(r.s));
  }
  return xn(["0x02", Yo(t)]);
}
function Ex(n, e) {
  const t = [
    Mn(n.chainId || 0, "chainId"),
    Mn(n.nonce || 0, "nonce"),
    Mn(n.gasPrice || 0, "gasPrice"),
    Mn(n.gasLimit || 0, "gasLimit"),
    n.to != null ? ht(n.to) : "0x",
    Mn(n.value || 0, "value"),
    n.data || "0x",
    Cx(n.accessList || []),
  ];
  if (e) {
    const r = ai(e);
    t.push(Mn(r.recoveryParam, "recoveryParam")),
      t.push(Zn(r.r)),
      t.push(Zn(r.s));
  }
  return xn(["0x01", Yo(t)]);
}
function jC(n, e) {
  P2(n, UC);
  const t = [];
  WC.forEach(function (s) {
    let o = n[s.name] || [];
    const c = {};
    s.numeric && (c.hexPad = "left"),
      (o = ae(pe(o, c))),
      s.length &&
        o.length !== s.length &&
        o.length > 0 &&
        en.throwArgumentError(
          "invalid length for " + s.name,
          "transaction:" + s.name,
          o,
        ),
      s.maxLength &&
        ((o = Zn(o)),
        o.length > s.maxLength &&
          en.throwArgumentError(
            "invalid length for " + s.name,
            "transaction:" + s.name,
            o,
          )),
      t.push(pe(o));
  });
  let r = 0;
  if (
    (n.chainId != null
      ? ((r = n.chainId),
        typeof r != "number" &&
          en.throwArgumentError(
            "invalid transaction.chainId",
            "transaction",
            n,
          ))
      : e && !T2(e) && e.v > 28 && (r = Math.floor((e.v - 35) / 2)),
    r !== 0 && (t.push(pe(r)), t.push("0x"), t.push("0x")),
    !e)
  )
    return Yo(t);
  const a = ai(e);
  let i = 27 + a.recoveryParam;
  return (
    r !== 0
      ? (t.pop(),
        t.pop(),
        t.pop(),
        (i += r * 2 + 8),
        a.v > 28 &&
          a.v !== i &&
          en.throwArgumentError(
            "transaction.chainId/signature.v mismatch",
            "signature",
            e,
          ))
      : a.v !== i &&
        en.throwArgumentError(
          "transaction.chainId/signature.v mismatch",
          "signature",
          e,
        ),
    t.push(pe(i)),
    t.push(Zn(ae(a.r))),
    t.push(Zn(ae(a.s))),
    Yo(t)
  );
}
function uu(n, e) {
  if (n.type == null || n.type === 0)
    return (
      n.accessList != null &&
        en.throwArgumentError(
          "untyped transactions do not support accessList; include type: 1",
          "transaction",
          n,
        ),
      jC(n, e)
    );
  switch (n.type) {
    case 1:
      return Ex(n, e);
    case 2:
      return Ax(n, e);
  }
  return en.throwError(
    `unsupported transaction type: ${n.type}`,
    z.errors.UNSUPPORTED_OPERATION,
    { operation: "serializeTransaction", transactionType: n.type },
  );
}
function kx(n, e, t) {
  try {
    const r = Zt(e[0]).toNumber();
    if (r !== 0 && r !== 1) throw new Error("bad recid");
    n.v = r;
  } catch {
    en.throwArgumentError("invalid v for transaction type: 1", "v", e[0]);
  }
  (n.r = Ue(e[1], 32)), (n.s = Ue(e[2], 32));
  try {
    const r = Ge(t(n));
    n.from = Uc(r, { r: n.r, s: n.s, recoveryParam: n.v });
  } catch {}
}
function zC(n) {
  const e = _h(n.slice(1));
  e.length !== 9 &&
    e.length !== 12 &&
    en.throwArgumentError(
      "invalid component count for transaction type: 2",
      "payload",
      pe(n),
    );
  const t = Zt(e[2]),
    r = Zt(e[3]),
    a = {
      type: 2,
      chainId: Zt(e[0]).toNumber(),
      nonce: Zt(e[1]).toNumber(),
      maxPriorityFeePerGas: t,
      maxFeePerGas: r,
      gasPrice: null,
      gasLimit: Zt(e[4]),
      to: Oh(e[5]),
      value: Zt(e[6]),
      data: e[7],
      accessList: Vi(e[8]),
    };
  return e.length === 9 || ((a.hash = Ge(n)), kx(a, e.slice(9), Ax)), a;
}
function HC(n) {
  const e = _h(n.slice(1));
  e.length !== 8 &&
    e.length !== 11 &&
    en.throwArgumentError(
      "invalid component count for transaction type: 1",
      "payload",
      pe(n),
    );
  const t = {
    type: 1,
    chainId: Zt(e[0]).toNumber(),
    nonce: Zt(e[1]).toNumber(),
    gasPrice: Zt(e[2]),
    gasLimit: Zt(e[3]),
    to: Oh(e[4]),
    value: Zt(e[5]),
    data: e[6],
    accessList: Vi(e[7]),
  };
  return e.length === 8 || ((t.hash = Ge(n)), kx(t, e.slice(8), Ex)), t;
}
function qC(n) {
  const e = _h(n);
  e.length !== 9 &&
    e.length !== 6 &&
    en.throwArgumentError("invalid raw transaction", "rawTransaction", n);
  const t = {
    nonce: Zt(e[0]).toNumber(),
    gasPrice: Zt(e[1]),
    gasLimit: Zt(e[2]),
    to: Oh(e[3]),
    value: Zt(e[4]),
    data: e[5],
    chainId: 0,
  };
  if (e.length === 6) return t;
  try {
    t.v = O.from(e[6]).toNumber();
  } catch {
    return t;
  }
  if (
    ((t.r = Ue(e[7], 32)),
    (t.s = Ue(e[8], 32)),
    O.from(t.r).isZero() && O.from(t.s).isZero())
  )
    (t.chainId = t.v), (t.v = 0);
  else {
    (t.chainId = Math.floor((t.v - 35) / 2)), t.chainId < 0 && (t.chainId = 0);
    let r = t.v - 27;
    const a = e.slice(0, 6);
    t.chainId !== 0 &&
      (a.push(pe(t.chainId)),
      a.push("0x"),
      a.push("0x"),
      (r -= t.chainId * 2 + 8));
    const i = Ge(Yo(a));
    try {
      t.from = Uc(i, { r: pe(t.r), s: pe(t.s), recoveryParam: r });
    } catch {}
    t.hash = Ge(n);
  }
  return (t.type = null), t;
}
function VC(n) {
  const e = ae(n);
  if (e[0] > 127) return qC(e);
  switch (e[0]) {
    case 1:
      return HC(e);
    case 2:
      return zC(e);
  }
  return en.throwError(
    `unsupported transaction type: ${e[0]}`,
    z.errors.UNSUPPORTED_OPERATION,
    { operation: "parseTransaction", transactionType: e[0] },
  );
}
const GC = "contracts/5.7.0";
var Qa =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const Qe = new z(GC),
  KC = {
    chainId: !0,
    data: !0,
    from: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    value: !0,
    type: !0,
    accessList: !0,
    maxFeePerGas: !0,
    maxPriorityFeePerGas: !0,
    customData: !0,
    ccipReadEnabled: !0,
  };
function du(n, e) {
  return Qa(this, void 0, void 0, function* () {
    const t = yield e;
    typeof t != "string" &&
      Qe.throwArgumentError("invalid address or ENS name", "name", t);
    try {
      return ht(t);
    } catch {}
    n ||
      Qe.throwError(
        "a provider or signer is needed to resolve ENS names",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "resolveName" },
      );
    const r = yield n.resolveName(t);
    return (
      r == null &&
        Qe.throwArgumentError(
          "resolver or addr is not configured for ENS name",
          "name",
          t,
        ),
      r
    );
  });
}
function Ho(n, e, t) {
  return Qa(this, void 0, void 0, function* () {
    return Array.isArray(t)
      ? yield Promise.all(
          t.map((r, a) => Ho(n, Array.isArray(e) ? e[a] : e[r.name], r)),
        )
      : t.type === "address"
      ? yield du(n, e)
      : t.type === "tuple"
      ? yield Ho(n, e, t.components)
      : t.baseType === "array"
      ? Array.isArray(e)
        ? yield Promise.all(e.map((r) => Ho(n, r, t.arrayChildren)))
        : Promise.reject(
            Qe.makeError("invalid value for array", z.errors.INVALID_ARGUMENT, {
              argument: "value",
              value: e,
            }),
          )
      : e;
  });
}
function $d(n, e, t) {
  return Qa(this, void 0, void 0, function* () {
    let r = {};
    t.length === e.inputs.length + 1 &&
      typeof t[t.length - 1] == "object" &&
      (r = rt(t.pop())),
      Qe.checkArgumentCount(t.length, e.inputs.length, "passed to contract"),
      n.signer
        ? r.from
          ? (r.from = bt({
              override: du(n.signer, r.from),
              signer: n.signer.getAddress(),
            }).then((l) =>
              Qa(this, void 0, void 0, function* () {
                return (
                  ht(l.signer) !== l.override &&
                    Qe.throwError(
                      "Contract with a Signer cannot override from",
                      z.errors.UNSUPPORTED_OPERATION,
                      { operation: "overrides.from" },
                    ),
                  l.override
                );
              }),
            ))
          : (r.from = n.signer.getAddress())
        : r.from && (r.from = du(n.provider, r.from));
    const a = yield bt({
        args: Ho(n.signer || n.provider, t, e.inputs),
        address: n.resolvedAddress,
        overrides: bt(r) || {},
      }),
      i = n.interface.encodeFunctionData(e, a.args),
      s = { data: i, to: a.address },
      o = a.overrides;
    if (
      (o.nonce != null && (s.nonce = O.from(o.nonce).toNumber()),
      o.gasLimit != null && (s.gasLimit = O.from(o.gasLimit)),
      o.gasPrice != null && (s.gasPrice = O.from(o.gasPrice)),
      o.maxFeePerGas != null && (s.maxFeePerGas = O.from(o.maxFeePerGas)),
      o.maxPriorityFeePerGas != null &&
        (s.maxPriorityFeePerGas = O.from(o.maxPriorityFeePerGas)),
      o.from != null && (s.from = o.from),
      o.type != null && (s.type = o.type),
      o.accessList != null && (s.accessList = Vi(o.accessList)),
      s.gasLimit == null && e.gas != null)
    ) {
      let l = 21e3;
      const u = ae(i);
      for (let d = 0; d < u.length; d++) (l += 4), u[d] && (l += 64);
      s.gasLimit = O.from(e.gas).add(l);
    }
    if (o.value) {
      const l = O.from(o.value);
      !l.isZero() &&
        !e.payable &&
        Qe.throwError(
          "non-payable method cannot override value",
          z.errors.UNSUPPORTED_OPERATION,
          { operation: "overrides.value", value: r.value },
        ),
        (s.value = l);
    }
    o.customData && (s.customData = rt(o.customData)),
      o.ccipReadEnabled && (s.ccipReadEnabled = !!o.ccipReadEnabled),
      delete r.nonce,
      delete r.gasLimit,
      delete r.gasPrice,
      delete r.from,
      delete r.value,
      delete r.type,
      delete r.accessList,
      delete r.maxFeePerGas,
      delete r.maxPriorityFeePerGas,
      delete r.customData,
      delete r.ccipReadEnabled;
    const c = Object.keys(r).filter((l) => r[l] != null);
    return (
      c.length &&
        Qe.throwError(
          `cannot override ${c.map((l) => JSON.stringify(l)).join(",")}`,
          z.errors.UNSUPPORTED_OPERATION,
          { operation: "overrides", overrides: c },
        ),
      s
    );
  });
}
function QC(n, e) {
  return function (...t) {
    return $d(n, e, t);
  };
}
function YC(n, e) {
  const t = n.signer || n.provider;
  return function (...r) {
    return Qa(this, void 0, void 0, function* () {
      t ||
        Qe.throwError(
          "estimate require a provider or signer",
          z.errors.UNSUPPORTED_OPERATION,
          { operation: "estimateGas" },
        );
      const a = yield $d(n, e, r);
      return yield t.estimateGas(a);
    });
  };
}
function _x(n, e) {
  const t = e.wait.bind(e);
  e.wait = (r) =>
    t(r).then(
      (a) => (
        (a.events = a.logs.map((i) => {
          let s = hn(i),
            o = null;
          try {
            o = n.interface.parseLog(i);
          } catch {}
          return (
            o &&
              ((s.args = o.args),
              (s.decode = (c, l) =>
                n.interface.decodeEventLog(o.eventFragment, c, l)),
              (s.event = o.name),
              (s.eventSignature = o.signature)),
            (s.removeListener = () => n.provider),
            (s.getBlock = () => n.provider.getBlock(a.blockHash)),
            (s.getTransaction = () =>
              n.provider.getTransaction(a.transactionHash)),
            (s.getTransactionReceipt = () => Promise.resolve(a)),
            s
          );
        })),
        a
      ),
    );
}
function Sx(n, e, t) {
  const r = n.signer || n.provider;
  return function (...a) {
    return Qa(this, void 0, void 0, function* () {
      let i;
      if (
        a.length === e.inputs.length + 1 &&
        typeof a[a.length - 1] == "object"
      ) {
        const c = rt(a.pop());
        c.blockTag != null && (i = yield c.blockTag),
          delete c.blockTag,
          a.push(c);
      }
      n.deployTransaction != null && (yield n._deployed(i));
      const s = yield $d(n, e, a),
        o = yield r.call(s, i);
      try {
        let c = n.interface.decodeFunctionResult(e, o);
        return t && e.outputs.length === 1 && (c = c[0]), c;
      } catch (c) {
        throw (
          (c.code === z.errors.CALL_EXCEPTION &&
            ((c.address = n.address), (c.args = a), (c.transaction = s)),
          c)
        );
      }
    });
  };
}
function JC(n, e) {
  return function (...t) {
    return Qa(this, void 0, void 0, function* () {
      n.signer ||
        Qe.throwError(
          "sending a transaction requires a signer",
          z.errors.UNSUPPORTED_OPERATION,
          { operation: "sendTransaction" },
        ),
        n.deployTransaction != null && (yield n._deployed());
      const r = yield $d(n, e, t),
        a = yield n.signer.sendTransaction(r);
      return _x(n, a), a;
    });
  };
}
function Wy(n, e, t) {
  return e.constant ? Sx(n, e, t) : JC(n, e);
}
function Px(n) {
  return n.address && (n.topics == null || n.topics.length === 0)
    ? "*"
    : (n.address || "*") +
        "@" +
        (n.topics
          ? n.topics.map((e) => (Array.isArray(e) ? e.join("|") : e)).join(":")
          : "");
}
class tc {
  constructor(e, t) {
    Q(this, "tag", e), Q(this, "filter", t), (this._listeners = []);
  }
  addListener(e, t) {
    this._listeners.push({ listener: e, once: t });
  }
  removeListener(e) {
    let t = !1;
    this._listeners = this._listeners.filter((r) =>
      t || r.listener !== e ? !0 : ((t = !0), !1),
    );
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((e) => e.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(e) {
    const t = this.listenerCount();
    return (
      (this._listeners = this._listeners.filter((r) => {
        const a = e.slice();
        return (
          setTimeout(() => {
            r.listener.apply(this, a);
          }, 0),
          !r.once
        );
      })),
      t
    );
  }
  prepareEvent(e) {}
  getEmit(e) {
    return [e];
  }
}
class XC extends tc {
  constructor() {
    super("error", null);
  }
}
class Uy extends tc {
  constructor(e, t, r, a) {
    const i = { address: e };
    let s = t.getEventTopic(r);
    a
      ? (s !== a[0] && Qe.throwArgumentError("topic mismatch", "topics", a),
        (i.topics = a.slice()))
      : (i.topics = [s]),
      super(Px(i), i),
      Q(this, "address", e),
      Q(this, "interface", t),
      Q(this, "fragment", r);
  }
  prepareEvent(e) {
    super.prepareEvent(e),
      (e.event = this.fragment.name),
      (e.eventSignature = this.fragment.format()),
      (e.decode = (t, r) => this.interface.decodeEventLog(this.fragment, t, r));
    try {
      e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics);
    } catch (t) {
      (e.args = null), (e.decodeError = t);
    }
  }
  getEmit(e) {
    const t = H8(e.args);
    if (t.length) throw t[0].error;
    const r = (e.args || []).slice();
    return r.push(e), r;
  }
}
class jy extends tc {
  constructor(e, t) {
    super("*", { address: e }), Q(this, "address", e), Q(this, "interface", t);
  }
  prepareEvent(e) {
    super.prepareEvent(e);
    try {
      const t = this.interface.parseLog(e);
      (e.event = t.name),
        (e.eventSignature = t.signature),
        (e.decode = (r, a) =>
          this.interface.decodeEventLog(t.eventFragment, r, a)),
        (e.args = t.args);
    } catch {}
  }
}
class ZC {
  constructor(e, t, r) {
    Q(this, "interface", tn(new.target, "getInterface")(t)),
      r == null
        ? (Q(this, "provider", null), Q(this, "signer", null))
        : Hi.isSigner(r)
        ? (Q(this, "provider", r.provider || null), Q(this, "signer", r))
        : Xs.isProvider(r)
        ? (Q(this, "provider", r), Q(this, "signer", null))
        : Qe.throwArgumentError(
            "invalid signer or provider",
            "signerOrProvider",
            r,
          ),
      Q(this, "callStatic", {}),
      Q(this, "estimateGas", {}),
      Q(this, "functions", {}),
      Q(this, "populateTransaction", {}),
      Q(this, "filters", {});
    {
      const s = {};
      Object.keys(this.interface.events).forEach((o) => {
        const c = this.interface.events[o];
        Q(this.filters, o, (...l) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(c, l),
        })),
          s[c.name] || (s[c.name] = []),
          s[c.name].push(o);
      }),
        Object.keys(s).forEach((o) => {
          const c = s[o];
          c.length === 1
            ? Q(this.filters, o, this.filters[c[0]])
            : Qe.warn(`Duplicate definition of ${o} (${c.join(", ")})`);
        });
    }
    if (
      (Q(this, "_runningEvents", {}),
      Q(this, "_wrappedEmits", {}),
      e == null &&
        Qe.throwArgumentError(
          "invalid contract address or ENS name",
          "addressOrName",
          e,
        ),
      Q(this, "address", e),
      this.provider)
    )
      Q(this, "resolvedAddress", du(this.provider, e));
    else
      try {
        Q(this, "resolvedAddress", Promise.resolve(ht(e)));
      } catch {
        Qe.throwError(
          "provider is required to use ENS name as contract address",
          z.errors.UNSUPPORTED_OPERATION,
          { operation: "new Contract" },
        );
      }
    this.resolvedAddress.catch((s) => {});
    const a = {},
      i = {};
    Object.keys(this.interface.functions).forEach((s) => {
      const o = this.interface.functions[s];
      if (i[s]) {
        Qe.warn(`Duplicate ABI entry for ${JSON.stringify(s)}`);
        return;
      }
      i[s] = !0;
      {
        const c = o.name;
        a[`%${c}`] || (a[`%${c}`] = []), a[`%${c}`].push(s);
      }
      this[s] == null && Q(this, s, Wy(this, o, !0)),
        this.functions[s] == null && Q(this.functions, s, Wy(this, o, !1)),
        this.callStatic[s] == null && Q(this.callStatic, s, Sx(this, o, !0)),
        this.populateTransaction[s] == null &&
          Q(this.populateTransaction, s, QC(this, o)),
        this.estimateGas[s] == null && Q(this.estimateGas, s, YC(this, o));
    }),
      Object.keys(a).forEach((s) => {
        const o = a[s];
        if (o.length > 1) return;
        s = s.substring(1);
        const c = o[0];
        try {
          this[s] == null && Q(this, s, this[c]);
        } catch {}
        this.functions[s] == null && Q(this.functions, s, this.functions[c]),
          this.callStatic[s] == null &&
            Q(this.callStatic, s, this.callStatic[c]),
          this.populateTransaction[s] == null &&
            Q(this.populateTransaction, s, this.populateTransaction[c]),
          this.estimateGas[s] == null &&
            Q(this.estimateGas, s, this.estimateGas[c]);
      });
  }
  static getContractAddress(e) {
    return Nc(e);
  }
  static getInterface(e) {
    return ec.isInterface(e) ? e : new ec(e);
  }
  deployed() {
    return this._deployed();
  }
  _deployed(e) {
    return (
      this._deployedPromise ||
        (this.deployTransaction
          ? (this._deployedPromise = this.deployTransaction
              .wait()
              .then(() => this))
          : (this._deployedPromise = this.provider
              .getCode(this.address, e)
              .then(
                (t) => (
                  t === "0x" &&
                    Qe.throwError(
                      "contract not deployed",
                      z.errors.UNSUPPORTED_OPERATION,
                      {
                        contractAddress: this.address,
                        operation: "getDeployed",
                      },
                    ),
                  this
                ),
              ))),
      this._deployedPromise
    );
  }
  fallback(e) {
    this.signer ||
      Qe.throwError(
        "sending a transactions require a signer",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "sendTransaction(fallback)" },
      );
    const t = rt(e || {});
    return (
      ["from", "to"].forEach(function (r) {
        t[r] != null &&
          Qe.throwError(
            "cannot override " + r,
            z.errors.UNSUPPORTED_OPERATION,
            { operation: r },
          );
      }),
      (t.to = this.resolvedAddress),
      this.deployed().then(() => this.signer.sendTransaction(t))
    );
  }
  connect(e) {
    typeof e == "string" && (e = new Rh(e, this.provider));
    const t = new this.constructor(this.address, this.interface, e);
    return (
      this.deployTransaction &&
        Q(t, "deployTransaction", this.deployTransaction),
      t
    );
  }
  attach(e) {
    return new this.constructor(
      e,
      this.interface,
      this.signer || this.provider,
    );
  }
  static isIndexed(e) {
    return pp.isIndexed(e);
  }
  _normalizeRunningEvent(e) {
    return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e;
  }
  _getRunningEvent(e) {
    if (typeof e == "string") {
      if (e === "error") return this._normalizeRunningEvent(new XC());
      if (e === "event")
        return this._normalizeRunningEvent(new tc("event", null));
      if (e === "*")
        return this._normalizeRunningEvent(
          new jy(this.address, this.interface),
        );
      const t = this.interface.getEvent(e);
      return this._normalizeRunningEvent(
        new Uy(this.address, this.interface, t),
      );
    }
    if (e.topics && e.topics.length > 0) {
      try {
        const r = e.topics[0];
        if (typeof r != "string") throw new Error("invalid topic");
        const a = this.interface.getEvent(r);
        return this._normalizeRunningEvent(
          new Uy(this.address, this.interface, a, e.topics),
        );
      } catch {}
      const t = { address: this.address, topics: e.topics };
      return this._normalizeRunningEvent(new tc(Px(t), t));
    }
    return this._normalizeRunningEvent(new jy(this.address, this.interface));
  }
  _checkRunningEvents(e) {
    if (e.listenerCount() === 0) {
      delete this._runningEvents[e.tag];
      const t = this._wrappedEmits[e.tag];
      t &&
        e.filter &&
        (this.provider.off(e.filter, t), delete this._wrappedEmits[e.tag]);
    }
  }
  _wrapEvent(e, t, r) {
    const a = hn(t);
    return (
      (a.removeListener = () => {
        r && (e.removeListener(r), this._checkRunningEvents(e));
      }),
      (a.getBlock = () => this.provider.getBlock(t.blockHash)),
      (a.getTransaction = () =>
        this.provider.getTransaction(t.transactionHash)),
      (a.getTransactionReceipt = () =>
        this.provider.getTransactionReceipt(t.transactionHash)),
      e.prepareEvent(a),
      a
    );
  }
  _addEventListener(e, t, r) {
    if (
      (this.provider ||
        Qe.throwError(
          "events require a provider or a signer with a provider",
          z.errors.UNSUPPORTED_OPERATION,
          { operation: "once" },
        ),
      e.addListener(t, r),
      (this._runningEvents[e.tag] = e),
      !this._wrappedEmits[e.tag])
    ) {
      const a = (i) => {
        let s = this._wrapEvent(e, i, t);
        if (s.decodeError == null)
          try {
            const o = e.getEmit(s);
            this.emit(e.filter, ...o);
          } catch (o) {
            s.decodeError = o.error;
          }
        e.filter != null && this.emit("event", s),
          s.decodeError != null && this.emit("error", s.decodeError, s);
      };
      (this._wrappedEmits[e.tag] = a),
        e.filter != null && this.provider.on(e.filter, a);
    }
  }
  queryFilter(e, t, r) {
    const a = this._getRunningEvent(e),
      i = rt(a.filter);
    return (
      typeof t == "string" && Ve(t, 32)
        ? (r != null &&
            Qe.throwArgumentError(
              "cannot specify toBlock with blockhash",
              "toBlock",
              r,
            ),
          (i.blockHash = t))
        : ((i.fromBlock = t ?? 0), (i.toBlock = r ?? "latest")),
      this.provider
        .getLogs(i)
        .then((s) => s.map((o) => this._wrapEvent(a, o, null)))
    );
  }
  on(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !1), this;
  }
  once(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !0), this;
  }
  emit(e, ...t) {
    if (!this.provider) return !1;
    const r = this._getRunningEvent(e),
      a = r.run(t) > 0;
    return this._checkRunningEvents(r), a;
  }
  listenerCount(e) {
    return this.provider
      ? e == null
        ? Object.keys(this._runningEvents).reduce(
            (t, r) => t + this._runningEvents[r].listenerCount(),
            0,
          )
        : this._getRunningEvent(e).listenerCount()
      : 0;
  }
  listeners(e) {
    if (!this.provider) return [];
    if (e == null) {
      const t = [];
      for (let r in this._runningEvents)
        this._runningEvents[r].listeners().forEach((a) => {
          t.push(a);
        });
      return t;
    }
    return this._getRunningEvent(e).listeners();
  }
  removeAllListeners(e) {
    if (!this.provider) return this;
    if (e == null) {
      for (const r in this._runningEvents) {
        const a = this._runningEvents[r];
        a.removeAllListeners(), this._checkRunningEvents(a);
      }
      return this;
    }
    const t = this._getRunningEvent(e);
    return t.removeAllListeners(), this._checkRunningEvents(t), this;
  }
  off(e, t) {
    if (!this.provider) return this;
    const r = this._getRunningEvent(e);
    return r.removeListener(t), this._checkRunningEvents(r), this;
  }
  removeListener(e, t) {
    return this.off(e, t);
  }
}
class Pe extends ZC {}
let Ix = class {
  constructor(e, t, r) {
    let a = null;
    typeof t == "string"
      ? (a = t)
      : w2(t)
      ? (a = pe(t))
      : t && typeof t.object == "string"
      ? (a = t.object)
      : (a = "!"),
      a.substring(0, 2) !== "0x" && (a = "0x" + a),
      (!Ve(a) || a.length % 2) &&
        Qe.throwArgumentError("invalid bytecode", "bytecode", t),
      r &&
        !Hi.isSigner(r) &&
        Qe.throwArgumentError("invalid signer", "signer", r),
      Q(this, "bytecode", a),
      Q(this, "interface", tn(new.target, "getInterface")(e)),
      Q(this, "signer", r || null);
  }
  getDeployTransaction(...e) {
    let t = {};
    if (
      e.length === this.interface.deploy.inputs.length + 1 &&
      typeof e[e.length - 1] == "object"
    ) {
      t = rt(e.pop());
      for (const r in t)
        if (!KC[r]) throw new Error("unknown transaction override " + r);
    }
    return (
      ["data", "from", "to"].forEach((r) => {
        t[r] != null &&
          Qe.throwError(
            "cannot override " + r,
            z.errors.UNSUPPORTED_OPERATION,
            { operation: r },
          );
      }),
      t.value &&
        !O.from(t.value).isZero() &&
        !this.interface.deploy.payable &&
        Qe.throwError(
          "non-payable constructor cannot override value",
          z.errors.UNSUPPORTED_OPERATION,
          { operation: "overrides.value", value: t.value },
        ),
      Qe.checkArgumentCount(
        e.length,
        this.interface.deploy.inputs.length,
        " in Contract constructor",
      ),
      (t.data = pe(nt([this.bytecode, this.interface.encodeDeploy(e)]))),
      t
    );
  }
  deploy(...e) {
    return Qa(this, void 0, void 0, function* () {
      let t = {};
      e.length === this.interface.deploy.inputs.length + 1 && (t = e.pop()),
        Qe.checkArgumentCount(
          e.length,
          this.interface.deploy.inputs.length,
          " in Contract constructor",
        );
      const r = yield Ho(this.signer, e, this.interface.deploy.inputs);
      r.push(t);
      const a = this.getDeployTransaction(...r),
        i = yield this.signer.sendTransaction(a),
        s = tn(this.constructor, "getContractAddress")(i),
        o = tn(this.constructor, "getContract")(s, this.interface, this.signer);
      return _x(o, i), Q(o, "deployTransaction", i), o;
    });
  }
  attach(e) {
    return this.constructor.getContract(e, this.interface, this.signer);
  }
  connect(e) {
    return new this.constructor(this.interface, this.bytecode, e);
  }
  static fromSolidity(e, t) {
    e == null &&
      Qe.throwError("missing compiler output", z.errors.MISSING_ARGUMENT, {
        argument: "compilerOutput",
      }),
      typeof e == "string" && (e = JSON.parse(e));
    const r = e.abi;
    let a = null;
    return (
      e.bytecode
        ? (a = e.bytecode)
        : e.evm && e.evm.bytecode && (a = e.evm.bytecode),
      new this(r, a, t)
    );
  }
  static getInterface(e) {
    return Pe.getInterface(e);
  }
  static getContractAddress(e) {
    return Nc(e);
  }
  static getContract(e, t, r) {
    return new Pe(e, t, r);
  }
};
class Rx {
  constructor(e) {
    Q(this, "alphabet", e),
      Q(this, "base", e.length),
      Q(this, "_alphabetMap", {}),
      Q(this, "_leader", e.charAt(0));
    for (let t = 0; t < e.length; t++) this._alphabetMap[e.charAt(t)] = t;
  }
  encode(e) {
    let t = ae(e);
    if (t.length === 0) return "";
    let r = [0];
    for (let i = 0; i < t.length; ++i) {
      let s = t[i];
      for (let o = 0; o < r.length; ++o)
        (s += r[o] << 8), (r[o] = s % this.base), (s = (s / this.base) | 0);
      for (; s > 0; ) r.push(s % this.base), (s = (s / this.base) | 0);
    }
    let a = "";
    for (let i = 0; t[i] === 0 && i < t.length - 1; ++i) a += this._leader;
    for (let i = r.length - 1; i >= 0; --i) a += this.alphabet[r[i]];
    return a;
  }
  decode(e) {
    if (typeof e != "string") throw new TypeError("Expected String");
    let t = [];
    if (e.length === 0) return new Uint8Array(t);
    t.push(0);
    for (let r = 0; r < e.length; r++) {
      let a = this._alphabetMap[e[r]];
      if (a === void 0) throw new Error("Non-base" + this.base + " character");
      let i = a;
      for (let s = 0; s < t.length; ++s)
        (i += t[s] * this.base), (t[s] = i & 255), (i >>= 8);
      for (; i > 0; ) t.push(i & 255), (i >>= 8);
    }
    for (let r = 0; e[r] === this._leader && r < e.length - 1; ++r) t.push(0);
    return ae(new Uint8Array(t.reverse()));
  }
}
new Rx("abcdefghijklmnopqrstuvwxyz234567");
const nc = new Rx("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var rc;
(function (n) {
  (n.sha256 = "sha256"), (n.sha512 = "sha512");
})(rc || (rc = {}));
const eA = "sha2/5.7.0",
  tA = new z(eA);
function nA(n) {
  return "0x" + In.ripemd160().update(ae(n)).digest("hex");
}
function Bi(n) {
  return "0x" + In.sha256().update(ae(n)).digest("hex");
}
function fu(n, e, t) {
  return (
    rc[n] ||
      tA.throwError(
        "unsupported algorithm " + n,
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "hmac", algorithm: n },
      ),
    "0x" + In.hmac(In[n], ae(e)).update(ae(t)).digest("hex")
  );
}
function Nh(n, e, t, r, a) {
  (n = ae(n)), (e = ae(e));
  let i,
    s = 1;
  const o = new Uint8Array(r),
    c = new Uint8Array(e.length + 4);
  c.set(e);
  let l, u;
  for (let d = 1; d <= s; d++) {
    (c[e.length] = (d >> 24) & 255),
      (c[e.length + 1] = (d >> 16) & 255),
      (c[e.length + 2] = (d >> 8) & 255),
      (c[e.length + 3] = d & 255);
    let f = ae(fu(a, n, c));
    i ||
      ((i = f.length),
      (u = new Uint8Array(i)),
      (s = Math.ceil(r / i)),
      (l = r - (s - 1) * i)),
      u.set(f);
    for (let y = 1; y < t; y++) {
      f = ae(fu(a, n, f));
      for (let h = 0; h < i; h++) u[h] ^= f[h];
    }
    const p = (d - 1) * i,
      m = d === s ? l : i;
    o.set(ae(u).slice(0, m), p);
  }
  return pe(o);
}
const rA = "wordlists/5.7.0",
  aA = new z(rA);
class jc {
  constructor(e) {
    aA.checkAbstract(new.target, jc), Q(this, "locale", e);
  }
  split(e) {
    return e.toLowerCase().split(/ +/g);
  }
  join(e) {
    return e.join(" ");
  }
  static check(e) {
    const t = [];
    for (let r = 0; r < 2048; r++) {
      const a = e.getWord(r);
      if (r !== e.getWordIndex(a)) return "0x";
      t.push(a);
    }
    return wn(
      t.join(`
`) +
        `
`,
    );
  }
  static register(e, t) {
    t || (t = e.locale);
  }
}
const iA =
  "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let qo = null;
function zy(n) {
  if (
    qo == null &&
    ((qo = iA
      .replace(/([A-Z])/g, " $1")
      .toLowerCase()
      .substring(1)
      .split(" ")),
    jc.check(n) !==
      "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60")
  )
    throw ((qo = null), new Error("BIP39 Wordlist for en (English) FAILED"));
}
class sA extends jc {
  constructor() {
    super("en");
  }
  getWord(e) {
    return zy(this), qo[e];
  }
  getWordIndex(e) {
    return zy(this), qo.indexOf(e);
  }
}
const Mx = new sA();
jc.register(Mx);
const Hy = { en: Mx },
  oA = "hdnode/5.7.0",
  pu = new z(oA),
  cA = O.from(
    "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
  ),
  lA = Ne("Bitcoin seed"),
  Ao = 2147483648;
function Bx(n) {
  return ((1 << n) - 1) << (8 - n);
}
function uA(n) {
  return (1 << n) - 1;
}
function dl(n) {
  return Ue(pe(n), 32);
}
function qy(n) {
  return nc.encode(nt([n, Mt(Bi(Bi(n)), 0, 4)]));
}
function Fh(n) {
  if (n == null) return Hy.en;
  if (typeof n == "string") {
    const e = Hy[n];
    return (
      e == null && pu.throwArgumentError("unknown locale", "wordlist", n), e
    );
  }
  return n;
}
const ts = {},
  ac = "m/44'/60'/0'/0/0";
class Jn {
  constructor(e, t, r, a, i, s, o, c) {
    if (e !== ts)
      throw new Error("HDNode constructor cannot be called directly");
    if (t) {
      const l = new Cs(t);
      Q(this, "privateKey", l.privateKey),
        Q(this, "publicKey", l.compressedPublicKey);
    } else Q(this, "privateKey", null), Q(this, "publicKey", pe(r));
    Q(this, "parentFingerprint", a),
      Q(this, "fingerprint", Mt(nA(Bi(this.publicKey)), 0, 4)),
      Q(this, "address", Ei(this.publicKey)),
      Q(this, "chainCode", i),
      Q(this, "index", s),
      Q(this, "depth", o),
      c == null
        ? (Q(this, "mnemonic", null), Q(this, "path", null))
        : typeof c == "string"
        ? (Q(this, "mnemonic", null), Q(this, "path", c))
        : (Q(this, "mnemonic", c), Q(this, "path", c.path));
  }
  get extendedKey() {
    if (this.depth >= 256) throw new Error("Depth too large!");
    return qy(
      nt([
        this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
        pe(this.depth),
        this.parentFingerprint,
        Ue(pe(this.index), 4),
        this.chainCode,
        this.privateKey != null
          ? nt(["0x00", this.privateKey])
          : this.publicKey,
      ]),
    );
  }
  neuter() {
    return new Jn(
      ts,
      null,
      this.publicKey,
      this.parentFingerprint,
      this.chainCode,
      this.index,
      this.depth,
      this.path,
    );
  }
  _derive(e) {
    if (e > 4294967295) throw new Error("invalid index - " + String(e));
    let t = this.path;
    t && (t += "/" + (e & ~Ao));
    const r = new Uint8Array(37);
    if (e & Ao) {
      if (!this.privateKey)
        throw new Error("cannot derive child of neutered node");
      r.set(ae(this.privateKey), 1), t && (t += "'");
    } else r.set(ae(this.publicKey));
    for (let d = 24; d >= 0; d -= 8) r[33 + (d >> 3)] = (e >> (24 - d)) & 255;
    const a = ae(fu(rc.sha512, this.chainCode, r)),
      i = a.slice(0, 32),
      s = a.slice(32);
    let o = null,
      c = null;
    this.privateKey
      ? (o = dl(O.from(i).add(this.privateKey).mod(cA)))
      : (c = new Cs(pe(i))._addPoint(this.publicKey));
    let l = t;
    const u = this.mnemonic;
    return (
      u &&
        (l = Object.freeze({
          phrase: u.phrase,
          path: t,
          locale: u.locale || "en",
        })),
      new Jn(ts, o, c, this.fingerprint, dl(s), e, this.depth + 1, l)
    );
  }
  derivePath(e) {
    const t = e.split("/");
    if (t.length === 0 || (t[0] === "m" && this.depth !== 0))
      throw new Error("invalid path - " + e);
    t[0] === "m" && t.shift();
    let r = this;
    for (let a = 0; a < t.length; a++) {
      const i = t[a];
      if (i.match(/^[0-9]+'$/)) {
        const s = parseInt(i.substring(0, i.length - 1));
        if (s >= Ao) throw new Error("invalid path index - " + i);
        r = r._derive(Ao + s);
      } else if (i.match(/^[0-9]+$/)) {
        const s = parseInt(i);
        if (s >= Ao) throw new Error("invalid path index - " + i);
        r = r._derive(s);
      } else throw new Error("invalid path component - " + i);
    }
    return r;
  }
  static _fromSeed(e, t) {
    const r = ae(e);
    if (r.length < 16 || r.length > 64) throw new Error("invalid seed");
    const a = ae(fu(rc.sha512, lA, r));
    return new Jn(
      ts,
      dl(a.slice(0, 32)),
      null,
      "0x00000000",
      dl(a.slice(32)),
      0,
      0,
      t,
    );
  }
  static fromMnemonic(e, t, r) {
    return (
      (r = Fh(r)),
      (e = Lh(Dx(e, r), r)),
      Jn._fromSeed(dA(e, t), { phrase: e, path: "m", locale: r.locale })
    );
  }
  static fromSeed(e) {
    return Jn._fromSeed(e, null);
  }
  static fromExtendedKey(e) {
    const t = nc.decode(e);
    (t.length !== 82 || qy(t.slice(0, 78)) !== e) &&
      pu.throwArgumentError(
        "invalid extended key",
        "extendedKey",
        "[REDACTED]",
      );
    const r = t[4],
      a = pe(t.slice(5, 9)),
      i = parseInt(pe(t.slice(9, 13)).substring(2), 16),
      s = pe(t.slice(13, 45)),
      o = t.slice(45, 78);
    switch (pe(t.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new Jn(ts, null, pe(o), a, s, i, r, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (o[0] !== 0) break;
        return new Jn(ts, pe(o.slice(1)), null, a, s, i, r, null);
    }
    return pu.throwArgumentError(
      "invalid extended key",
      "extendedKey",
      "[REDACTED]",
    );
  }
}
function dA(n, e) {
  e || (e = "");
  const t = Ne("mnemonic" + e, Va.NFKD);
  return Nh(Ne(n, Va.NFKD), t, 2048, 64, "sha512");
}
function Dx(n, e) {
  (e = Fh(e)), pu.checkNormalize();
  const t = e.split(n);
  if (t.length % 3 !== 0) throw new Error("invalid mnemonic");
  const r = ae(new Uint8Array(Math.ceil((11 * t.length) / 8)));
  let a = 0;
  for (let l = 0; l < t.length; l++) {
    let u = e.getWordIndex(t[l].normalize("NFKD"));
    if (u === -1) throw new Error("invalid mnemonic");
    for (let d = 0; d < 11; d++)
      u & (1 << (10 - d)) && (r[a >> 3] |= 1 << (7 - (a % 8))), a++;
  }
  const i = (32 * t.length) / 3,
    s = t.length / 3,
    o = Bx(s);
  if ((ae(Bi(r.slice(0, i / 8)))[0] & o) !== (r[r.length - 1] & o))
    throw new Error("invalid checksum");
  return pe(r.slice(0, i / 8));
}
function Lh(n, e) {
  if (
    ((e = Fh(e)),
    (n = ae(n)),
    n.length % 4 !== 0 || n.length < 16 || n.length > 32)
  )
    throw new Error("invalid entropy");
  const t = [0];
  let r = 11;
  for (let s = 0; s < n.length; s++)
    r > 8
      ? ((t[t.length - 1] <<= 8), (t[t.length - 1] |= n[s]), (r -= 8))
      : ((t[t.length - 1] <<= r),
        (t[t.length - 1] |= n[s] >> (8 - r)),
        t.push(n[s] & uA(8 - r)),
        (r += 3));
  const a = n.length / 4,
    i = ae(Bi(n))[0] & Bx(a);
  return (
    (t[t.length - 1] <<= a),
    (t[t.length - 1] |= i >> (8 - a)),
    e.join(t.map((s) => e.getWord(s)))
  );
}
const fA = "random/5.7.0",
  xp = new z(fA);
function pA() {
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw new Error("unable to locate global object");
}
const Vy = pA();
let zl = Vy.crypto || Vy.msCrypto;
(!zl || !zl.getRandomValues) &&
  (xp.warn("WARNING: Missing strong random number source"),
  (zl = {
    getRandomValues: function (n) {
      return xp.throwError(
        "no secure random source avaialble",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "crypto.getRandomValues" },
      );
    },
  }));
function No(n) {
  (n <= 0 || n > 1024 || n % 1 || n != n) &&
    xp.throwArgumentError("invalid length", "length", n);
  const e = new Uint8Array(n);
  return zl.getRandomValues(e), ae(e);
}
function hA(n) {
  n = n.slice();
  for (let e = n.length - 1; e > 0; e--) {
    const t = Math.floor(Math.random() * (e + 1)),
      r = n[e];
    (n[e] = n[t]), (n[t] = r);
  }
  return n;
}
var Ox = { exports: {} };
(function (n, e) {
  (function (t) {
    function r(P) {
      return parseInt(P) === P;
    }
    function a(P) {
      if (!r(P.length)) return !1;
      for (var B = 0; B < P.length; B++)
        if (!r(P[B]) || P[B] < 0 || P[B] > 255) return !1;
      return !0;
    }
    function i(P, B) {
      if (P.buffer && ArrayBuffer.isView(P) && P.name === "Uint8Array")
        return (
          B &&
            (P.slice ? (P = P.slice()) : (P = Array.prototype.slice.call(P))),
          P
        );
      if (Array.isArray(P)) {
        if (!a(P)) throw new Error("Array contains invalid value: " + P);
        return new Uint8Array(P);
      }
      if (r(P.length) && a(P)) return new Uint8Array(P);
      throw new Error("unsupported array-like object");
    }
    function s(P) {
      return new Uint8Array(P);
    }
    function o(P, B, j, F, V) {
      (F != null || V != null) &&
        (P.slice
          ? (P = P.slice(F, V))
          : (P = Array.prototype.slice.call(P, F, V))),
        B.set(P, j);
    }
    var c = (function () {
        function P(j) {
          var F = [],
            V = 0;
          for (j = encodeURI(j); V < j.length; ) {
            var re = j.charCodeAt(V++);
            re === 37
              ? (F.push(parseInt(j.substr(V, 2), 16)), (V += 2))
              : F.push(re);
          }
          return i(F);
        }
        function B(j) {
          for (var F = [], V = 0; V < j.length; ) {
            var re = j[V];
            re < 128
              ? (F.push(String.fromCharCode(re)), V++)
              : re > 191 && re < 224
              ? (F.push(
                  String.fromCharCode(((re & 31) << 6) | (j[V + 1] & 63)),
                ),
                (V += 2))
              : (F.push(
                  String.fromCharCode(
                    ((re & 15) << 12) |
                      ((j[V + 1] & 63) << 6) |
                      (j[V + 2] & 63),
                  ),
                ),
                (V += 3));
          }
          return F.join("");
        }
        return { toBytes: P, fromBytes: B };
      })(),
      l = (function () {
        function P(F) {
          for (var V = [], re = 0; re < F.length; re += 2)
            V.push(parseInt(F.substr(re, 2), 16));
          return V;
        }
        var B = "0123456789abcdef";
        function j(F) {
          for (var V = [], re = 0; re < F.length; re++) {
            var we = F[re];
            V.push(B[(we & 240) >> 4] + B[we & 15]);
          }
          return V.join("");
        }
        return { toBytes: P, fromBytes: j };
      })(),
      u = { 16: 10, 24: 12, 32: 14 },
      d = [
        1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94,
        188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145,
      ],
      f = [
        99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171,
        118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164,
        114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113,
        216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39,
        178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227,
        47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76,
        88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60,
        159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16,
        255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61,
        100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20,
        222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98,
        145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244,
        234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221,
        116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53,
        87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155,
        30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104,
        65, 153, 45, 15, 176, 84, 187, 22,
      ],
      p = [
        82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251,
        124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233,
        203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195,
        78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209,
        37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101,
        182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167,
        141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5,
        184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1,
        19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206,
        240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55,
        232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183,
        98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219,
        192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18,
        16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229,
        122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200,
        235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225,
        105, 20, 99, 85, 33, 12, 125,
      ],
      m = [
        3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157,
        3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757,
        3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813,
        2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307,
        1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063,
        3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618,
        1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420,
        3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767,
        134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841,
        168101135, 798661301, 235341577, 605164086, 461406363, 3756188221,
        3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174,
        1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627,
        2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582,
        1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436,
        1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302,
        1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746,
        3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463,
        1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577,
        2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438,
        2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100,
        1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450,
        4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079,
        3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866,
        4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909,
        3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534,
        999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540,
        2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286,
        1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836,
        2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756,
        3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599,
        26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514,
        4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816,
        1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505,
        1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977,
        2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954,
        1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154,
        3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992,
        974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859,
        3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754,
        361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378,
        59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649,
        2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377,
        2075177163, 2824099068, 1841019862, 739644986,
      ],
      y = [
        2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027,
        2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147,
        434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938,
        1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592,
        3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988,
        2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398,
        1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525,
        886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517,
        201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806,
        252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786,
        651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339,
        1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112,
        4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187,
        1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861,
        1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867,
        3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471,
        1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773,
        1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647,
        4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603,
        3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005,
        3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895,
        251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324,
        3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751,
        2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019,
        2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034,
        2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540,
        2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026,
        1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516,
        1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981,
        936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389,
        2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294,
        133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816,
        3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350,
        3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327,
        3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654,
        3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494,
        2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617,
        658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609,
        3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214,
        2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103,
        2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934,
        3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607,
        3413881008, 4238890068, 3597515707, 975967766,
      ],
      h = [
        1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307,
        1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347,
        4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298,
        3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232,
        2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228,
        1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518,
        911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325,
        3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077,
        67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926,
        84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826,
        3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539,
        745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552,
        1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067,
        795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784,
        4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910,
        961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360,
        4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739,
        2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960,
        1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568,
        2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668,
        3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003,
        3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855,
        2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534,
        1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744,
        2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008,
        2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782,
        1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090,
        169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650,
        3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972,
        2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893,
        3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908,
        3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946,
        2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164,
        3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131,
        3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261,
        1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081,
        895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045,
        2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777,
        3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927,
        3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796,
        2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242,
        1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488,
        1425844308, 3151392187, 372911126,
      ],
      g = [
        1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062,
        1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422,
        4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983,
        3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547,
        2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643,
        1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788,
        909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625,
        3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962,
        67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071,
        84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791,
        3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989,
        741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667,
        1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797,
        791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704,
        4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535,
        960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995,
        4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214,
        2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760,
        1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408,
        2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563,
        3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573,
        3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230,
        2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284,
        1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344,
        2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123,
        2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087,
        1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700,
        168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855,
        3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747,
        2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873,
        3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523,
        3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511,
        2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419,
        3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126,
        3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401,
        1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866,
        892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850,
        2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042,
        3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917,
        3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891,
        2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452,
        1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443,
        1414855848, 3149649517, 370555436,
      ],
      v = [
        1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753,
        2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485,
        1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703,
        1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150,
        59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843,
        1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733,
        3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074,
        2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228,
        1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562,
        3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269,
        807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154,
        4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474,
        875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634,
        1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366,
        2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327,
        2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483,
        2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436,
        1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852,
        1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058,
        463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234,
        3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465,
        337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775,
        1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960,
        3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733,
        3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860,
        2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396,
        2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238,
        2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012,
        1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814,
        2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619,
        270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369,
        2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889,
        1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144,
        899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186,
        1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980,
        3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204,
        25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971,
        1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302,
        3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761,
        1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769,
        3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627,
        4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265,
        3576870512, 1215061108, 3501741890,
      ],
      w = [
        1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933,
        2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900,
        4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723,
        2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385,
        3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473,
        692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113,
        3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529,
        1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523,
        1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122,
        1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824,
        4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204,
        4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614,
        2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839,
        106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461,
        3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937,
        3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598,
        1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597,
        2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945,
        1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535,
        3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394,
        182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863,
        3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624,
        2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486,
        1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369,
        2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024,
        3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148,
        3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545,
        4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671,
        3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776,
        1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106,
        1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472,
        32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392,
        3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259,
        818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840,
        1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904,
        1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889,
        77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242,
        870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476,
        4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235,
        2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891,
        2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253,
        2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913,
        1635502980, 1893020342, 1950903388, 1120974935,
      ],
      T = [
        2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173,
        1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970,
        3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698,
        244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515,
        1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868,
        1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033,
        1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914,
        861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368,
        1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827,
        2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239,
        2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009,
        4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174,
        1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224,
        2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286,
        2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237,
        1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968,
        172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081,
        1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047,
        2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278,
        2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539,
        719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150,
        2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665,
        4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005,
        4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898,
        1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670,
        3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556,
        1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178,
        188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442,
        2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569,
        2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044,
        2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634,
        2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639,
        919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549,
        1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196,
        3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050,
        81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974,
        895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576,
        1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897,
        3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516,
        935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519,
        3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572,
        2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195,
        3060847922, 1551124588, 1463996600,
      ],
      A = [
        4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623,
        4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885,
        3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053,
        3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835,
        2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848,
        3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143,
        3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389,
        1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913,
        1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242,
        529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619,
        679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159,
        133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524,
        777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424,
        1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981,
        1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582,
        1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953,
        2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766,
        1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162,
        1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748,
        2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234,
        2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765,
        514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535,
        1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070,
        3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413,
        3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325,
        3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816,
        4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628,
        3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092,
        2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814,
        3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464,
        410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844,
        1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714,
        1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454,
        2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521,
        3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700,
        2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909,
        2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841,
        3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542,
        1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736,
        3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274,
        1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712,
        227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555,
        850817237, 1817998408, 3092726480,
      ],
      E = [
        0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554,
        708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108,
        1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990,
        4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216,
        2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058,
        3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343,
        3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029,
        3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995,
        899835584, 666464733, 699432150, 59727847, 226906860, 530400753,
        294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775,
        2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520,
        3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422,
        3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228,
        4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434,
        2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896,
        800440835, 92987698, 193195065, 429456164, 395441711, 1984812685,
        2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311,
        1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657,
        807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971,
        2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805,
        3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751,
        3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483,
        2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465,
        599762354, 159417987, 126454664, 361929877, 463180190, 2709260871,
        2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733,
        2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971,
        3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178,
        2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284,
        3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302,
        3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384,
        1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330,
        404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369,
        3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619,
        3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557,
        2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487,
        504459436, 875451293, 975658646, 675039627, 641025152, 2084704233,
        1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843,
        1451044056, 933301370, 967311729, 733156972, 632953703, 260388950,
        25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500,
        1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226,
        3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432,
        4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150,
        2438237621, 2203032232, 2370213795,
      ],
      _ = [
        0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694,
        824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388,
        2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410,
        2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776,
        3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918,
        3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543,
        1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569,
        1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355,
        3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933,
        4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895,
        3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975,
        3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917,
        2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523,
        2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409,
        1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751,
        53458370, 839224033, 957055980, 605657339, 790073846, 2373340630,
        2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216,
        3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602,
        4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276,
        545572369, 296679730, 446754879, 129166120, 213705253, 1709610350,
        1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296,
        1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598,
        3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840,
        2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386,
        1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268,
        1988838185, 533804130, 350174575, 164439672, 46346101, 870912086,
        954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643,
        2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929,
        3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127,
        3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309,
        457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035,
        2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319,
        182621114, 401639597, 486441376, 768917123, 651868046, 1003007129,
        818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387,
        2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917,
        2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703,
        3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473,
        3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720,
        1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390,
        1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636,
        3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122,
        4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200,
        3046200461, 2827177882, 2743944855,
      ],
      S = [
        0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294,
        590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588,
        1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250,
        3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176,
        3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278,
        2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663,
        2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769,
        3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195,
        1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173,
        1224348052, 59984867, 244860394, 428169201, 344873464, 935293895,
        984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180,
        2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982,
        145085239, 532201772, 313773861, 830661914, 1015671571, 731183368,
        648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554,
        2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636,
        3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085,
        3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771,
        4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177,
        2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631,
        287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925,
        1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571,
        1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968,
        3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150,
        2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556,
        122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898,
        695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576,
        1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613,
        1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639,
        81781910, 331544205, 516552836, 1039717051, 821288114, 669961897,
        719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299,
        2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885,
        3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634,
        3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044,
        2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702,
        3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632,
        1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938,
        48394827, 369057872, 418672217, 1002783846, 919489135, 567498868,
        752375421, 209336225, 24197544, 376187827, 459744698, 945164165,
        895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635,
        1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881,
        3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127,
        4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285,
        2377486676, 2594734927, 2544078150,
      ],
      W = [
        0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204,
        1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408,
        1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100,
        2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816,
        3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748,
        3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843,
        377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439,
        1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315,
        2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623,
        2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475,
        3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905,
        1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837,
        923313619, 740276417, 621982671, 439452389, 322734571, 137073913,
        19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589,
        3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641,
        3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550,
        1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426,
        1928707164, 96392454, 213114376, 396673818, 514443284, 562755902,
        679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866,
        3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230,
        2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026,
        2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953,
        3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765,
        3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481,
        1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413,
        1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841,
        425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038,
        3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674,
        2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542,
        2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834,
        1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990,
        349075736, 736970802, 585122620, 972512814, 821712160, 2595684844,
        2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464,
        2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212,
        4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952,
        292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068,
        1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848,
        2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775,
        2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155,
        4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431,
        953270745, 600235211, 718002117, 367585007, 484830689, 133361907,
        251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495,
        1418573201, 1335535747, 1184342925,
      ];
    function D(P) {
      for (var B = [], j = 0; j < P.length; j += 4)
        B.push((P[j] << 24) | (P[j + 1] << 16) | (P[j + 2] << 8) | P[j + 3]);
      return B;
    }
    var L = function (P) {
      if (!(this instanceof L))
        throw Error("AES must be instanitated with `new`");
      Object.defineProperty(this, "key", { value: i(P, !0) }), this._prepare();
    };
    (L.prototype._prepare = function () {
      var P = u[this.key.length];
      if (P == null)
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      (this._Ke = []), (this._Kd = []);
      for (var B = 0; B <= P; B++)
        this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
      for (
        var j = (P + 1) * 4,
          F = this.key.length / 4,
          V = D(this.key),
          re,
          B = 0;
        B < F;
        B++
      )
        (re = B >> 2),
          (this._Ke[re][B % 4] = V[B]),
          (this._Kd[P - re][B % 4] = V[B]);
      for (var we = 0, se = F, be; se < j; ) {
        if (
          ((be = V[F - 1]),
          (V[0] ^=
            (f[(be >> 16) & 255] << 24) ^
            (f[(be >> 8) & 255] << 16) ^
            (f[be & 255] << 8) ^
            f[(be >> 24) & 255] ^
            (d[we] << 24)),
          (we += 1),
          F != 8)
        )
          for (var B = 1; B < F; B++) V[B] ^= V[B - 1];
        else {
          for (var B = 1; B < F / 2; B++) V[B] ^= V[B - 1];
          (be = V[F / 2 - 1]),
            (V[F / 2] ^=
              f[be & 255] ^
              (f[(be >> 8) & 255] << 8) ^
              (f[(be >> 16) & 255] << 16) ^
              (f[(be >> 24) & 255] << 24));
          for (var B = F / 2 + 1; B < F; B++) V[B] ^= V[B - 1];
        }
        for (var B = 0, Ke, dt; B < F && se < j; )
          (Ke = se >> 2),
            (dt = se % 4),
            (this._Ke[Ke][dt] = V[B]),
            (this._Kd[P - Ke][dt] = V[B++]),
            se++;
      }
      for (var Ke = 1; Ke < P; Ke++)
        for (var dt = 0; dt < 4; dt++)
          (be = this._Kd[Ke][dt]),
            (this._Kd[Ke][dt] =
              E[(be >> 24) & 255] ^
              _[(be >> 16) & 255] ^
              S[(be >> 8) & 255] ^
              W[be & 255]);
    }),
      (L.prototype.encrypt = function (P) {
        if (P.length != 16)
          throw new Error("invalid plaintext size (must be 16 bytes)");
        for (
          var B = this._Ke.length - 1, j = [0, 0, 0, 0], F = D(P), V = 0;
          V < 4;
          V++
        )
          F[V] ^= this._Ke[0][V];
        for (var re = 1; re < B; re++) {
          for (var V = 0; V < 4; V++)
            j[V] =
              m[(F[V] >> 24) & 255] ^
              y[(F[(V + 1) % 4] >> 16) & 255] ^
              h[(F[(V + 2) % 4] >> 8) & 255] ^
              g[F[(V + 3) % 4] & 255] ^
              this._Ke[re][V];
          F = j.slice();
        }
        for (var we = s(16), se, V = 0; V < 4; V++)
          (se = this._Ke[B][V]),
            (we[4 * V] = (f[(F[V] >> 24) & 255] ^ (se >> 24)) & 255),
            (we[4 * V + 1] =
              (f[(F[(V + 1) % 4] >> 16) & 255] ^ (se >> 16)) & 255),
            (we[4 * V + 2] =
              (f[(F[(V + 2) % 4] >> 8) & 255] ^ (se >> 8)) & 255),
            (we[4 * V + 3] = (f[F[(V + 3) % 4] & 255] ^ se) & 255);
        return we;
      }),
      (L.prototype.decrypt = function (P) {
        if (P.length != 16)
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        for (
          var B = this._Kd.length - 1, j = [0, 0, 0, 0], F = D(P), V = 0;
          V < 4;
          V++
        )
          F[V] ^= this._Kd[0][V];
        for (var re = 1; re < B; re++) {
          for (var V = 0; V < 4; V++)
            j[V] =
              v[(F[V] >> 24) & 255] ^
              w[(F[(V + 3) % 4] >> 16) & 255] ^
              T[(F[(V + 2) % 4] >> 8) & 255] ^
              A[F[(V + 1) % 4] & 255] ^
              this._Kd[re][V];
          F = j.slice();
        }
        for (var we = s(16), se, V = 0; V < 4; V++)
          (se = this._Kd[B][V]),
            (we[4 * V] = (p[(F[V] >> 24) & 255] ^ (se >> 24)) & 255),
            (we[4 * V + 1] =
              (p[(F[(V + 3) % 4] >> 16) & 255] ^ (se >> 16)) & 255),
            (we[4 * V + 2] =
              (p[(F[(V + 2) % 4] >> 8) & 255] ^ (se >> 8)) & 255),
            (we[4 * V + 3] = (p[F[(V + 1) % 4] & 255] ^ se) & 255);
        return we;
      });
    var G = function (P) {
      if (!(this instanceof G))
        throw Error("AES must be instanitated with `new`");
      (this.description = "Electronic Code Block"),
        (this.name = "ecb"),
        (this._aes = new L(P));
    };
    (G.prototype.encrypt = function (P) {
      if (((P = i(P)), P.length % 16 !== 0))
        throw new Error(
          "invalid plaintext size (must be multiple of 16 bytes)",
        );
      for (var B = s(P.length), j = s(16), F = 0; F < P.length; F += 16)
        o(P, j, 0, F, F + 16), (j = this._aes.encrypt(j)), o(j, B, F);
      return B;
    }),
      (G.prototype.decrypt = function (P) {
        if (((P = i(P)), P.length % 16 !== 0))
          throw new Error(
            "invalid ciphertext size (must be multiple of 16 bytes)",
          );
        for (var B = s(P.length), j = s(16), F = 0; F < P.length; F += 16)
          o(P, j, 0, F, F + 16), (j = this._aes.decrypt(j)), o(j, B, F);
        return B;
      });
    var q = function (P, B) {
      if (!(this instanceof q))
        throw Error("AES must be instanitated with `new`");
      if (
        ((this.description = "Cipher Block Chaining"), (this.name = "cbc"), !B)
      )
        B = s(16);
      else if (B.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      (this._lastCipherblock = i(B, !0)), (this._aes = new L(P));
    };
    (q.prototype.encrypt = function (P) {
      if (((P = i(P)), P.length % 16 !== 0))
        throw new Error(
          "invalid plaintext size (must be multiple of 16 bytes)",
        );
      for (var B = s(P.length), j = s(16), F = 0; F < P.length; F += 16) {
        o(P, j, 0, F, F + 16);
        for (var V = 0; V < 16; V++) j[V] ^= this._lastCipherblock[V];
        (this._lastCipherblock = this._aes.encrypt(j)),
          o(this._lastCipherblock, B, F);
      }
      return B;
    }),
      (q.prototype.decrypt = function (P) {
        if (((P = i(P)), P.length % 16 !== 0))
          throw new Error(
            "invalid ciphertext size (must be multiple of 16 bytes)",
          );
        for (var B = s(P.length), j = s(16), F = 0; F < P.length; F += 16) {
          o(P, j, 0, F, F + 16), (j = this._aes.decrypt(j));
          for (var V = 0; V < 16; V++)
            B[F + V] = j[V] ^ this._lastCipherblock[V];
          o(P, this._lastCipherblock, 0, F, F + 16);
        }
        return B;
      });
    var N = function (P, B, j) {
      if (!(this instanceof N))
        throw Error("AES must be instanitated with `new`");
      if (((this.description = "Cipher Feedback"), (this.name = "cfb"), !B))
        B = s(16);
      else if (B.length != 16)
        throw new Error("invalid initialation vector size (must be 16 size)");
      j || (j = 1),
        (this.segmentSize = j),
        (this._shiftRegister = i(B, !0)),
        (this._aes = new L(P));
    };
    (N.prototype.encrypt = function (P) {
      if (P.length % this.segmentSize != 0)
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      for (var B = i(P, !0), j, F = 0; F < B.length; F += this.segmentSize) {
        j = this._aes.encrypt(this._shiftRegister);
        for (var V = 0; V < this.segmentSize; V++) B[F + V] ^= j[V];
        o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize),
          o(
            B,
            this._shiftRegister,
            16 - this.segmentSize,
            F,
            F + this.segmentSize,
          );
      }
      return B;
    }),
      (N.prototype.decrypt = function (P) {
        if (P.length % this.segmentSize != 0)
          throw new Error(
            "invalid ciphertext size (must be segmentSize bytes)",
          );
        for (var B = i(P, !0), j, F = 0; F < B.length; F += this.segmentSize) {
          j = this._aes.encrypt(this._shiftRegister);
          for (var V = 0; V < this.segmentSize; V++) B[F + V] ^= j[V];
          o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize),
            o(
              P,
              this._shiftRegister,
              16 - this.segmentSize,
              F,
              F + this.segmentSize,
            );
        }
        return B;
      });
    var H = function (P, B) {
      if (!(this instanceof H))
        throw Error("AES must be instanitated with `new`");
      if (((this.description = "Output Feedback"), (this.name = "ofb"), !B))
        B = s(16);
      else if (B.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      (this._lastPrecipher = i(B, !0)),
        (this._lastPrecipherIndex = 16),
        (this._aes = new L(P));
    };
    (H.prototype.encrypt = function (P) {
      for (var B = i(P, !0), j = 0; j < B.length; j++)
        this._lastPrecipherIndex === 16 &&
          ((this._lastPrecipher = this._aes.encrypt(this._lastPrecipher)),
          (this._lastPrecipherIndex = 0)),
          (B[j] ^= this._lastPrecipher[this._lastPrecipherIndex++]);
      return B;
    }),
      (H.prototype.decrypt = H.prototype.encrypt);
    var J = function (P) {
      if (!(this instanceof J))
        throw Error("Counter must be instanitated with `new`");
      P !== 0 && !P && (P = 1),
        typeof P == "number"
          ? ((this._counter = s(16)), this.setValue(P))
          : this.setBytes(P);
    };
    (J.prototype.setValue = function (P) {
      if (typeof P != "number" || parseInt(P) != P)
        throw new Error("invalid counter value (must be an integer)");
      for (var B = 15; B >= 0; --B) (this._counter[B] = P % 256), (P = P >> 8);
    }),
      (J.prototype.setBytes = function (P) {
        if (((P = i(P, !0)), P.length != 16))
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        this._counter = P;
      }),
      (J.prototype.increment = function () {
        for (var P = 15; P >= 0; P--)
          if (this._counter[P] === 255) this._counter[P] = 0;
          else {
            this._counter[P]++;
            break;
          }
      });
    var de = function (P, B) {
      if (!(this instanceof de))
        throw Error("AES must be instanitated with `new`");
      (this.description = "Counter"),
        (this.name = "ctr"),
        B instanceof J || (B = new J(B)),
        (this._counter = B),
        (this._remainingCounter = null),
        (this._remainingCounterIndex = 16),
        (this._aes = new L(P));
    };
    (de.prototype.encrypt = function (P) {
      for (var B = i(P, !0), j = 0; j < B.length; j++)
        this._remainingCounterIndex === 16 &&
          ((this._remainingCounter = this._aes.encrypt(this._counter._counter)),
          (this._remainingCounterIndex = 0),
          this._counter.increment()),
          (B[j] ^= this._remainingCounter[this._remainingCounterIndex++]);
      return B;
    }),
      (de.prototype.decrypt = de.prototype.encrypt);
    function le(P) {
      P = i(P, !0);
      var B = 16 - (P.length % 16),
        j = s(P.length + B);
      o(P, j);
      for (var F = P.length; F < j.length; F++) j[F] = B;
      return j;
    }
    function Z(P) {
      if (((P = i(P, !0)), P.length < 16))
        throw new Error("PKCS#7 invalid length");
      var B = P[P.length - 1];
      if (B > 16) throw new Error("PKCS#7 padding byte out of range");
      for (var j = P.length - B, F = 0; F < B; F++)
        if (P[j + F] !== B) throw new Error("PKCS#7 invalid padding byte");
      var V = s(j);
      return o(P, V, 0, 0, j), V;
    }
    var ue = {
      AES: L,
      Counter: J,
      ModeOfOperation: { ecb: G, cbc: q, cfb: N, ofb: H, ctr: de },
      utils: { hex: l, utf8: c },
      padding: { pkcs7: { pad: le, strip: Z } },
      _arrayTest: { coerceArray: i, createArray: s, copyArray: o },
    };
    n.exports = ue;
  })();
})(Ox);
var mA = Ox.exports;
const Br = ir(mA),
  Nx = "json-wallets/5.7.0";
function ki(n) {
  return (
    typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), ae(n)
  );
}
function Eo(n, e) {
  for (n = String(n); n.length < e; ) n = "0" + n;
  return n;
}
function $h(n) {
  return typeof n == "string" ? Ne(n, Va.NFKC) : ae(n);
}
function xt(n, e) {
  let t = n;
  const r = e.toLowerCase().split("/");
  for (let a = 0; a < r.length; a++) {
    let i = null;
    for (const s in t)
      if (s.toLowerCase() === r[a]) {
        i = t[s];
        break;
      }
    if (i === null) return null;
    t = i;
  }
  return t;
}
function yA(n) {
  const e = ae(n);
  (e[6] = (e[6] & 15) | 64), (e[8] = (e[8] & 63) | 128);
  const t = pe(e);
  return [
    t.substring(2, 10),
    t.substring(10, 14),
    t.substring(14, 18),
    t.substring(18, 22),
    t.substring(22, 34),
  ].join("-");
}
const gA = new z(Nx);
class bA extends ji {
  isCrowdsaleAccount(e) {
    return !!(e && e._isCrowdsaleAccount);
  }
}
function Fx(n, e) {
  const t = JSON.parse(n);
  e = $h(e);
  const r = ht(xt(t, "ethaddr")),
    a = ki(xt(t, "encseed"));
  (!a || a.length % 16 !== 0) &&
    gA.throwArgumentError("invalid encseed", "json", n);
  const i = ae(Nh(e, e, 2e3, 32, "sha256")).slice(0, 16),
    s = a.slice(0, 16),
    o = a.slice(16),
    c = new Br.ModeOfOperation.cbc(i, s),
    l = Br.padding.pkcs7.strip(ae(c.decrypt(o)));
  let u = "";
  for (let p = 0; p < l.length; p++) u += String.fromCharCode(l[p]);
  const d = Ne(u),
    f = Ge(d);
  return new bA({ _isCrowdsaleAccount: !0, address: r, privateKey: f });
}
function Lx(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return e.encseed && e.ethaddr;
}
function $x(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return !(
    !e.version ||
    parseInt(e.version) !== e.version ||
    parseInt(e.version) !== 3
  );
}
var Wx = { exports: {} };
(function (n, e) {
  (function (t) {
    function a(y) {
      const h = new Uint32Array([
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
        2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
        264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
        113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
        3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
        1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298,
      ]);
      let g = 1779033703,
        v = 3144134277,
        w = 1013904242,
        T = 2773480762,
        A = 1359893119,
        E = 2600822924,
        _ = 528734635,
        S = 1541459225;
      const W = new Uint32Array(64);
      function D(de) {
        let le = 0,
          Z = de.length;
        for (; Z >= 64; ) {
          let ue = g,
            P = v,
            B = w,
            j = T,
            F = A,
            V = E,
            re = _,
            we = S,
            se,
            be,
            Ke,
            dt,
            cn;
          for (be = 0; be < 16; be++)
            (Ke = le + be * 4),
              (W[be] =
                ((de[Ke] & 255) << 24) |
                ((de[Ke + 1] & 255) << 16) |
                ((de[Ke + 2] & 255) << 8) |
                (de[Ke + 3] & 255));
          for (be = 16; be < 64; be++)
            (se = W[be - 2]),
              (dt =
                ((se >>> 17) | (se << (32 - 17))) ^
                ((se >>> 19) | (se << (32 - 19))) ^
                (se >>> 10)),
              (se = W[be - 15]),
              (cn =
                ((se >>> 7) | (se << (32 - 7))) ^
                ((se >>> 18) | (se << (32 - 18))) ^
                (se >>> 3)),
              (W[be] = (((dt + W[be - 7]) | 0) + ((cn + W[be - 16]) | 0)) | 0);
          for (be = 0; be < 64; be++)
            (dt =
              ((((((F >>> 6) | (F << (32 - 6))) ^
                ((F >>> 11) | (F << (32 - 11))) ^
                ((F >>> 25) | (F << (32 - 25)))) +
                ((F & V) ^ (~F & re))) |
                0) +
                ((we + ((h[be] + W[be]) | 0)) | 0)) |
              0),
              (cn =
                ((((ue >>> 2) | (ue << (32 - 2))) ^
                  ((ue >>> 13) | (ue << (32 - 13))) ^
                  ((ue >>> 22) | (ue << (32 - 22)))) +
                  ((ue & P) ^ (ue & B) ^ (P & B))) |
                0),
              (we = re),
              (re = V),
              (V = F),
              (F = (j + dt) | 0),
              (j = B),
              (B = P),
              (P = ue),
              (ue = (dt + cn) | 0);
          (g = (g + ue) | 0),
            (v = (v + P) | 0),
            (w = (w + B) | 0),
            (T = (T + j) | 0),
            (A = (A + F) | 0),
            (E = (E + V) | 0),
            (_ = (_ + re) | 0),
            (S = (S + we) | 0),
            (le += 64),
            (Z -= 64);
        }
      }
      D(y);
      let L,
        G = y.length % 64,
        q = (y.length / 536870912) | 0,
        N = y.length << 3,
        H = G < 56 ? 56 : 120,
        J = y.slice(y.length - G, y.length);
      for (J.push(128), L = G + 1; L < H; L++) J.push(0);
      return (
        J.push((q >>> 24) & 255),
        J.push((q >>> 16) & 255),
        J.push((q >>> 8) & 255),
        J.push((q >>> 0) & 255),
        J.push((N >>> 24) & 255),
        J.push((N >>> 16) & 255),
        J.push((N >>> 8) & 255),
        J.push((N >>> 0) & 255),
        D(J),
        [
          (g >>> 24) & 255,
          (g >>> 16) & 255,
          (g >>> 8) & 255,
          (g >>> 0) & 255,
          (v >>> 24) & 255,
          (v >>> 16) & 255,
          (v >>> 8) & 255,
          (v >>> 0) & 255,
          (w >>> 24) & 255,
          (w >>> 16) & 255,
          (w >>> 8) & 255,
          (w >>> 0) & 255,
          (T >>> 24) & 255,
          (T >>> 16) & 255,
          (T >>> 8) & 255,
          (T >>> 0) & 255,
          (A >>> 24) & 255,
          (A >>> 16) & 255,
          (A >>> 8) & 255,
          (A >>> 0) & 255,
          (E >>> 24) & 255,
          (E >>> 16) & 255,
          (E >>> 8) & 255,
          (E >>> 0) & 255,
          (_ >>> 24) & 255,
          (_ >>> 16) & 255,
          (_ >>> 8) & 255,
          (_ >>> 0) & 255,
          (S >>> 24) & 255,
          (S >>> 16) & 255,
          (S >>> 8) & 255,
          (S >>> 0) & 255,
        ]
      );
    }
    function i(y, h, g) {
      y = y.length <= 64 ? y : a(y);
      const v = 64 + h.length + 4,
        w = new Array(v),
        T = new Array(64);
      let A,
        E = [];
      for (A = 0; A < 64; A++) w[A] = 54;
      for (A = 0; A < y.length; A++) w[A] ^= y[A];
      for (A = 0; A < h.length; A++) w[64 + A] = h[A];
      for (A = v - 4; A < v; A++) w[A] = 0;
      for (A = 0; A < 64; A++) T[A] = 92;
      for (A = 0; A < y.length; A++) T[A] ^= y[A];
      function _() {
        for (let S = v - 1; S >= v - 4; S--) {
          if ((w[S]++, w[S] <= 255)) return;
          w[S] = 0;
        }
      }
      for (; g >= 32; ) _(), (E = E.concat(a(T.concat(a(w))))), (g -= 32);
      return g > 0 && (_(), (E = E.concat(a(T.concat(a(w))).slice(0, g)))), E;
    }
    function s(y, h, g, v, w) {
      let T;
      for (u(y, (2 * g - 1) * 16, w, 0, 16), T = 0; T < 2 * g; T++)
        l(y, T * 16, w, 16), c(w, v), u(w, 0, y, h + T * 16, 16);
      for (T = 0; T < g; T++) u(y, h + T * 2 * 16, y, T * 16, 16);
      for (T = 0; T < g; T++) u(y, h + (T * 2 + 1) * 16, y, (T + g) * 16, 16);
    }
    function o(y, h) {
      return (y << h) | (y >>> (32 - h));
    }
    function c(y, h) {
      u(y, 0, h, 0, 16);
      for (let g = 8; g > 0; g -= 2)
        (h[4] ^= o(h[0] + h[12], 7)),
          (h[8] ^= o(h[4] + h[0], 9)),
          (h[12] ^= o(h[8] + h[4], 13)),
          (h[0] ^= o(h[12] + h[8], 18)),
          (h[9] ^= o(h[5] + h[1], 7)),
          (h[13] ^= o(h[9] + h[5], 9)),
          (h[1] ^= o(h[13] + h[9], 13)),
          (h[5] ^= o(h[1] + h[13], 18)),
          (h[14] ^= o(h[10] + h[6], 7)),
          (h[2] ^= o(h[14] + h[10], 9)),
          (h[6] ^= o(h[2] + h[14], 13)),
          (h[10] ^= o(h[6] + h[2], 18)),
          (h[3] ^= o(h[15] + h[11], 7)),
          (h[7] ^= o(h[3] + h[15], 9)),
          (h[11] ^= o(h[7] + h[3], 13)),
          (h[15] ^= o(h[11] + h[7], 18)),
          (h[1] ^= o(h[0] + h[3], 7)),
          (h[2] ^= o(h[1] + h[0], 9)),
          (h[3] ^= o(h[2] + h[1], 13)),
          (h[0] ^= o(h[3] + h[2], 18)),
          (h[6] ^= o(h[5] + h[4], 7)),
          (h[7] ^= o(h[6] + h[5], 9)),
          (h[4] ^= o(h[7] + h[6], 13)),
          (h[5] ^= o(h[4] + h[7], 18)),
          (h[11] ^= o(h[10] + h[9], 7)),
          (h[8] ^= o(h[11] + h[10], 9)),
          (h[9] ^= o(h[8] + h[11], 13)),
          (h[10] ^= o(h[9] + h[8], 18)),
          (h[12] ^= o(h[15] + h[14], 7)),
          (h[13] ^= o(h[12] + h[15], 9)),
          (h[14] ^= o(h[13] + h[12], 13)),
          (h[15] ^= o(h[14] + h[13], 18));
      for (let g = 0; g < 16; ++g) y[g] += h[g];
    }
    function l(y, h, g, v) {
      for (let w = 0; w < v; w++) g[w] ^= y[h + w];
    }
    function u(y, h, g, v, w) {
      for (; w--; ) g[v++] = y[h++];
    }
    function d(y) {
      if (!y || typeof y.length != "number") return !1;
      for (let h = 0; h < y.length; h++) {
        const g = y[h];
        if (typeof g != "number" || g % 1 || g < 0 || g >= 256) return !1;
      }
      return !0;
    }
    function f(y, h) {
      if (typeof y != "number" || y % 1) throw new Error("invalid " + h);
      return y;
    }
    function p(y, h, g, v, w, T, A) {
      if (
        ((g = f(g, "N")),
        (v = f(v, "r")),
        (w = f(w, "p")),
        (T = f(T, "dkLen")),
        g === 0 || g & (g - 1))
      )
        throw new Error("N must be power of 2");
      if (g > 2147483647 / 128 / v) throw new Error("N too large");
      if (v > 2147483647 / 128 / w) throw new Error("r too large");
      if (!d(y)) throw new Error("password must be an array or buffer");
      if (((y = Array.prototype.slice.call(y)), !d(h)))
        throw new Error("salt must be an array or buffer");
      h = Array.prototype.slice.call(h);
      let E = i(y, h, w * 128 * v);
      const _ = new Uint32Array(w * 32 * v);
      for (let F = 0; F < _.length; F++) {
        const V = F * 4;
        _[F] =
          ((E[V + 3] & 255) << 24) |
          ((E[V + 2] & 255) << 16) |
          ((E[V + 1] & 255) << 8) |
          ((E[V + 0] & 255) << 0);
      }
      const S = new Uint32Array(64 * v),
        W = new Uint32Array(32 * v * g),
        D = 32 * v,
        L = new Uint32Array(16),
        G = new Uint32Array(16),
        q = w * g * 2;
      let N = 0,
        H = null,
        J = !1,
        de = 0,
        le = 0,
        Z,
        ue;
      const P = A ? parseInt(1e3 / v) : 4294967295,
        B = typeof setImmediate < "u" ? setImmediate : setTimeout,
        j = function () {
          if (J) return A(new Error("cancelled"), N / q);
          let F;
          switch (de) {
            case 0:
              (ue = le * 32 * v), u(_, ue, S, 0, D), (de = 1), (Z = 0);
            case 1:
              (F = g - Z), F > P && (F = P);
              for (let re = 0; re < F; re++)
                u(S, 0, W, (Z + re) * D, D), s(S, D, v, L, G);
              if (((Z += F), (N += F), A)) {
                const re = parseInt((1e3 * N) / q);
                if (re !== H) {
                  if (((J = A(null, N / q)), J)) break;
                  H = re;
                }
              }
              if (Z < g) break;
              (Z = 0), (de = 2);
            case 2:
              (F = g - Z), F > P && (F = P);
              for (let re = 0; re < F; re++) {
                const we = (2 * v - 1) * 16,
                  se = S[we] & (g - 1);
                l(W, se * D, S, D), s(S, D, v, L, G);
              }
              if (((Z += F), (N += F), A)) {
                const re = parseInt((1e3 * N) / q);
                if (re !== H) {
                  if (((J = A(null, N / q)), J)) break;
                  H = re;
                }
              }
              if (Z < g) break;
              if ((u(S, 0, _, ue, D), le++, le < w)) {
                de = 0;
                break;
              }
              E = [];
              for (let re = 0; re < _.length; re++)
                E.push((_[re] >> 0) & 255),
                  E.push((_[re] >> 8) & 255),
                  E.push((_[re] >> 16) & 255),
                  E.push((_[re] >> 24) & 255);
              const V = i(y, E, T);
              return A && A(null, 1, V), V;
          }
          A && B(j);
        };
      if (!A)
        for (;;) {
          const F = j();
          if (F != null) return F;
        }
      j();
    }
    const m = {
      scrypt: function (y, h, g, v, w, T, A) {
        return new Promise(function (E, _) {
          let S = 0;
          A && A(0),
            p(y, h, g, v, w, T, function (W, D, L) {
              if (W) _(W);
              else if (L) A && S !== 1 && A(1), E(new Uint8Array(L));
              else if (A && D !== S) return (S = D), A(D);
            });
        });
      },
      syncScrypt: function (y, h, g, v, w, T) {
        return new Uint8Array(p(y, h, g, v, w, T));
      },
    };
    n.exports = m;
  })();
})(Wx);
var xA = Wx.exports;
const Wh = ir(xA);
var vA =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const vp = new z(Nx);
function Gy(n) {
  return n != null && n.mnemonic && n.mnemonic.phrase;
}
class wA extends ji {
  isKeystoreAccount(e) {
    return !!(e && e._isKeystoreAccount);
  }
}
function TA(n, e, t) {
  if (xt(n, "crypto/cipher") === "aes-128-ctr") {
    const a = ki(xt(n, "crypto/cipherparams/iv")),
      i = new Br.Counter(a),
      s = new Br.ModeOfOperation.ctr(e, i);
    return ae(s.decrypt(t));
  }
  return null;
}
function Ux(n, e) {
  const t = ki(xt(n, "crypto/ciphertext"));
  if (
    pe(Ge(nt([e.slice(16, 32), t]))).substring(2) !==
    xt(n, "crypto/mac").toLowerCase()
  )
    throw new Error("invalid password");
  const a = TA(n, e.slice(0, 16), t);
  a ||
    vp.throwError("unsupported cipher", z.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt",
    });
  const i = e.slice(32, 64),
    s = Ei(a);
  if (n.address) {
    let c = n.address.toLowerCase();
    if ((c.substring(0, 2) !== "0x" && (c = "0x" + c), ht(c) !== s))
      throw new Error("address mismatch");
  }
  const o = { _isKeystoreAccount: !0, address: s, privateKey: pe(a) };
  if (xt(n, "x-ethers/version") === "0.1") {
    const c = ki(xt(n, "x-ethers/mnemonicCiphertext")),
      l = ki(xt(n, "x-ethers/mnemonicCounter")),
      u = new Br.Counter(l),
      d = new Br.ModeOfOperation.ctr(i, u),
      f = xt(n, "x-ethers/path") || ac,
      p = xt(n, "x-ethers/locale") || "en",
      m = ae(d.decrypt(c));
    try {
      const y = Lh(m, p),
        h = Jn.fromMnemonic(y, null, p).derivePath(f);
      if (h.privateKey != o.privateKey) throw new Error("mnemonic mismatch");
      o.mnemonic = h.mnemonic;
    } catch (y) {
      if (y.code !== z.errors.INVALID_ARGUMENT || y.argument !== "wordlist")
        throw y;
    }
  }
  return new wA(o);
}
function jx(n, e, t, r, a) {
  return ae(Nh(n, e, t, r, a));
}
function CA(n, e, t, r, a) {
  return Promise.resolve(jx(n, e, t, r, a));
}
function zx(n, e, t, r, a) {
  const i = $h(e),
    s = xt(n, "crypto/kdf");
  if (s && typeof s == "string") {
    const o = function (c, l) {
      return vp.throwArgumentError(
        "invalid key-derivation function parameters",
        c,
        l,
      );
    };
    if (s.toLowerCase() === "scrypt") {
      const c = ki(xt(n, "crypto/kdfparams/salt")),
        l = parseInt(xt(n, "crypto/kdfparams/n")),
        u = parseInt(xt(n, "crypto/kdfparams/r")),
        d = parseInt(xt(n, "crypto/kdfparams/p"));
      (!l || !u || !d) && o("kdf", s), l & (l - 1) && o("N", l);
      const f = parseInt(xt(n, "crypto/kdfparams/dklen"));
      return f !== 32 && o("dklen", f), r(i, c, l, u, d, 64, a);
    } else if (s.toLowerCase() === "pbkdf2") {
      const c = ki(xt(n, "crypto/kdfparams/salt"));
      let l = null;
      const u = xt(n, "crypto/kdfparams/prf");
      u === "hmac-sha256"
        ? (l = "sha256")
        : u === "hmac-sha512"
        ? (l = "sha512")
        : o("prf", u);
      const d = parseInt(xt(n, "crypto/kdfparams/c")),
        f = parseInt(xt(n, "crypto/kdfparams/dklen"));
      return f !== 32 && o("dklen", f), t(i, c, d, f, l);
    }
  }
  return vp.throwArgumentError("unsupported key-derivation function", "kdf", s);
}
function AA(n, e) {
  const t = JSON.parse(n),
    r = zx(t, e, jx, Wh.syncScrypt);
  return Ux(t, r);
}
function EA(n, e, t) {
  return vA(this, void 0, void 0, function* () {
    const r = JSON.parse(n),
      a = yield zx(r, e, CA, Wh.scrypt, t);
    return Ux(r, a);
  });
}
function kA(n, e, t, r) {
  try {
    if (ht(n.address) !== Ei(n.privateKey))
      throw new Error("address/privateKey mismatch");
    if (Gy(n)) {
      const h = n.mnemonic;
      if (
        Jn.fromMnemonic(h.phrase, null, h.locale).derivePath(h.path || ac)
          .privateKey != n.privateKey
      )
        throw new Error("mnemonic mismatch");
    }
  } catch (h) {
    return Promise.reject(h);
  }
  typeof t == "function" && !r && ((r = t), (t = {})), t || (t = {});
  const a = ae(n.privateKey),
    i = $h(e);
  let s = null,
    o = null,
    c = null;
  if (Gy(n)) {
    const h = n.mnemonic;
    (s = ae(Dx(h.phrase, h.locale || "en"))),
      (o = h.path || ac),
      (c = h.locale || "en");
  }
  let l = t.client;
  l || (l = "ethers.js");
  let u = null;
  t.salt ? (u = ae(t.salt)) : (u = No(32));
  let d = null;
  if (t.iv) {
    if (((d = ae(t.iv)), d.length !== 16)) throw new Error("invalid iv");
  } else d = No(16);
  let f = null;
  if (t.uuid) {
    if (((f = ae(t.uuid)), f.length !== 16)) throw new Error("invalid uuid");
  } else f = No(16);
  let p = 1 << 17,
    m = 8,
    y = 1;
  return (
    t.scrypt &&
      (t.scrypt.N && (p = t.scrypt.N),
      t.scrypt.r && (m = t.scrypt.r),
      t.scrypt.p && (y = t.scrypt.p)),
    Wh.scrypt(i, u, p, m, y, 64, r).then((h) => {
      h = ae(h);
      const g = h.slice(0, 16),
        v = h.slice(16, 32),
        w = h.slice(32, 64),
        T = new Br.Counter(d),
        A = new Br.ModeOfOperation.ctr(g, T),
        E = ae(A.encrypt(a)),
        _ = Ge(nt([v, E])),
        S = {
          address: n.address.substring(2).toLowerCase(),
          id: yA(f),
          version: 3,
          crypto: {
            cipher: "aes-128-ctr",
            cipherparams: { iv: pe(d).substring(2) },
            ciphertext: pe(E).substring(2),
            kdf: "scrypt",
            kdfparams: {
              salt: pe(u).substring(2),
              n: p,
              dklen: 32,
              p: y,
              r: m,
            },
            mac: _.substring(2),
          },
        };
      if (s) {
        const W = No(16),
          D = new Br.Counter(W),
          L = new Br.ModeOfOperation.ctr(w, D),
          G = ae(L.encrypt(s)),
          q = new Date(),
          N =
            q.getUTCFullYear() +
            "-" +
            Eo(q.getUTCMonth() + 1, 2) +
            "-" +
            Eo(q.getUTCDate(), 2) +
            "T" +
            Eo(q.getUTCHours(), 2) +
            "-" +
            Eo(q.getUTCMinutes(), 2) +
            "-" +
            Eo(q.getUTCSeconds(), 2) +
            ".0Z";
        S["x-ethers"] = {
          client: l,
          gethFilename: "UTC--" + N + "--" + S.address,
          mnemonicCounter: pe(W).substring(2),
          mnemonicCiphertext: pe(G).substring(2),
          path: o,
          locale: c,
          version: "0.1",
        };
      }
      return JSON.stringify(S);
    })
  );
}
function _A(n, e, t) {
  if (Lx(n)) {
    t && t(0);
    const r = Fx(n, e);
    return t && t(1), Promise.resolve(r);
  }
  return $x(n) ? EA(n, e, t) : Promise.reject(new Error("invalid JSON wallet"));
}
function SA(n, e) {
  if (Lx(n)) return Fx(n, e);
  if ($x(n)) return AA(n, e);
  throw new Error("invalid JSON wallet");
}
const PA = "wallet/5.7.0";
var Ky =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const ns = new z(PA);
function IA(n) {
  return n != null && Ve(n.privateKey, 32) && n.address != null;
}
function RA(n) {
  const e = n.mnemonic;
  return e && e.phrase;
}
class Ia extends Hi {
  constructor(e, t) {
    if ((super(), IA(e))) {
      const r = new Cs(e.privateKey);
      if (
        (Q(this, "_signingKey", () => r),
        Q(this, "address", Ei(this.publicKey)),
        this.address !== ht(e.address) &&
          ns.throwArgumentError(
            "privateKey/address mismatch",
            "privateKey",
            "[REDACTED]",
          ),
        RA(e))
      ) {
        const a = e.mnemonic;
        Q(this, "_mnemonic", () => ({
          phrase: a.phrase,
          path: a.path || ac,
          locale: a.locale || "en",
        }));
        const i = this.mnemonic,
          s = Jn.fromMnemonic(i.phrase, null, i.locale).derivePath(i.path);
        Ei(s.privateKey) !== this.address &&
          ns.throwArgumentError(
            "mnemonic/address mismatch",
            "privateKey",
            "[REDACTED]",
          );
      } else Q(this, "_mnemonic", () => null);
    } else {
      if (Cs.isSigningKey(e))
        e.curve !== "secp256k1" &&
          ns.throwArgumentError(
            "unsupported curve; must be secp256k1",
            "privateKey",
            "[REDACTED]",
          ),
          Q(this, "_signingKey", () => e);
      else {
        typeof e == "string" &&
          e.match(/^[0-9a-f]*$/i) &&
          e.length === 64 &&
          (e = "0x" + e);
        const r = new Cs(e);
        Q(this, "_signingKey", () => r);
      }
      Q(this, "_mnemonic", () => null), Q(this, "address", Ei(this.publicKey));
    }
    t &&
      !Xs.isProvider(t) &&
      ns.throwArgumentError("invalid provider", "provider", t),
      Q(this, "provider", t || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(e) {
    return new Ia(this, e);
  }
  signTransaction(e) {
    return bt(e).then((t) => {
      t.from != null &&
        (ht(t.from) !== this.address &&
          ns.throwArgumentError(
            "transaction from address mismatch",
            "transaction.from",
            e.from,
          ),
        delete t.from);
      const r = this._signingKey().signDigest(Ge(uu(t)));
      return uu(t, r);
    });
  }
  signMessage(e) {
    return Ky(this, void 0, void 0, function* () {
      return au(this._signingKey().signDigest(Od(e)));
    });
  }
  _signTypedData(e, t, r) {
    return Ky(this, void 0, void 0, function* () {
      const a = yield Wt.resolveNames(
        e,
        t,
        r,
        (i) => (
          this.provider == null &&
            ns.throwError(
              "cannot resolve ENS names without a provider",
              z.errors.UNSUPPORTED_OPERATION,
              { operation: "resolveName", value: i },
            ),
          this.provider.resolveName(i)
        ),
      );
      return au(this._signingKey().signDigest(Wt.hash(a.domain, t, a.value)));
    });
  }
  encrypt(e, t, r) {
    if (
      (typeof t == "function" && !r && ((r = t), (t = {})),
      r && typeof r != "function")
    )
      throw new Error("invalid callback");
    return t || (t = {}), kA(this, e, t, r);
  }
  static createRandom(e) {
    let t = No(16);
    e || (e = {}),
      e.extraEntropy && (t = ae(Mt(Ge(nt([t, e.extraEntropy])), 0, 16)));
    const r = Lh(t, e.locale);
    return Ia.fromMnemonic(r, e.path, e.locale);
  }
  static fromEncryptedJson(e, t, r) {
    return _A(e, t, r).then((a) => new Ia(a));
  }
  static fromEncryptedJsonSync(e, t) {
    return new Ia(SA(e, t));
  }
  static fromMnemonic(e, t, r) {
    return t || (t = ac), new Ia(Jn.fromMnemonic(e, null, r).derivePath(t));
  }
}
const MA = "networks/5.7.1",
  Qy = new z(MA);
function BA(n) {
  return n && typeof n.renetwork == "function";
}
function ea(n) {
  const e = function (t, r) {
    r == null && (r = {});
    const a = [];
    if (t.InfuraProvider && r.infura !== "-")
      try {
        a.push(new t.InfuraProvider(n, r.infura));
      } catch {}
    if (t.EtherscanProvider && r.etherscan !== "-")
      try {
        a.push(new t.EtherscanProvider(n, r.etherscan));
      } catch {}
    if (t.AlchemyProvider && r.alchemy !== "-")
      try {
        a.push(new t.AlchemyProvider(n, r.alchemy));
      } catch {}
    if (t.PocketProvider && r.pocket !== "-") {
      const i = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const s = new t.PocketProvider(n, r.pocket);
        s.network && i.indexOf(s.network.name) === -1 && a.push(s);
      } catch {}
    }
    if (t.CloudflareProvider && r.cloudflare !== "-")
      try {
        a.push(new t.CloudflareProvider(n));
      } catch {}
    if (t.AnkrProvider && r.ankr !== "-")
      try {
        const i = ["ropsten"],
          s = new t.AnkrProvider(n, r.ankr);
        s.network && i.indexOf(s.network.name) === -1 && a.push(s);
      } catch {}
    if (a.length === 0) return null;
    if (t.FallbackProvider) {
      let i = 1;
      return (
        r.quorum != null ? (i = r.quorum) : n === "homestead" && (i = 2),
        new t.FallbackProvider(a, i)
      );
    }
    return a[0];
  };
  return (
    (e.renetwork = function (t) {
      return ea(t);
    }),
    e
  );
}
function hu(n, e) {
  const t = function (r, a) {
    return r.JsonRpcProvider ? new r.JsonRpcProvider(n, e) : null;
  };
  return (
    (t.renetwork = function (r) {
      return hu(n, r);
    }),
    t
  );
}
const Yy = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: ea("homestead"),
  },
  Jy = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: ea("ropsten"),
  },
  Xy = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: hu(
      "https://www.ethercluster.com/mordor",
      "classicMordor",
    ),
  },
  fl = {
    unspecified: { chainId: 0, name: "unspecified" },
    homestead: Yy,
    mainnet: Yy,
    morden: { chainId: 2, name: "morden" },
    ropsten: Jy,
    testnet: Jy,
    rinkeby: {
      chainId: 4,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "rinkeby",
      _defaultProvider: ea("rinkeby"),
    },
    kovan: { chainId: 42, name: "kovan", _defaultProvider: ea("kovan") },
    goerli: {
      chainId: 5,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "goerli",
      _defaultProvider: ea("goerli"),
    },
    kintsugi: { chainId: 1337702, name: "kintsugi" },
    sepolia: {
      chainId: 11155111,
      name: "sepolia",
      _defaultProvider: ea("sepolia"),
    },
    classic: {
      chainId: 61,
      name: "classic",
      _defaultProvider: hu("https://www.ethercluster.com/etc", "classic"),
    },
    classicMorden: { chainId: 62, name: "classicMorden" },
    classicMordor: Xy,
    classicTestnet: Xy,
    classicKotti: {
      chainId: 6,
      name: "classicKotti",
      _defaultProvider: hu(
        "https://www.ethercluster.com/kotti",
        "classicKotti",
      ),
    },
    xdai: { chainId: 100, name: "xdai" },
    matic: { chainId: 137, name: "matic", _defaultProvider: ea("matic") },
    maticmum: { chainId: 80001, name: "maticmum" },
    optimism: {
      chainId: 10,
      name: "optimism",
      _defaultProvider: ea("optimism"),
    },
    "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
    "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
    arbitrum: { chainId: 42161, name: "arbitrum" },
    "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
    "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
    bnb: { chainId: 56, name: "bnb" },
    bnbt: { chainId: 97, name: "bnbt" },
  };
function Hx(n) {
  if (n == null) return null;
  if (typeof n == "number") {
    for (const r in fl) {
      const a = fl[r];
      if (a.chainId === n)
        return {
          name: a.name,
          chainId: a.chainId,
          ensAddress: a.ensAddress || null,
          _defaultProvider: a._defaultProvider || null,
        };
    }
    return { chainId: n, name: "unknown" };
  }
  if (typeof n == "string") {
    const r = fl[n];
    return r == null
      ? null
      : {
          name: r.name,
          chainId: r.chainId,
          ensAddress: r.ensAddress,
          _defaultProvider: r._defaultProvider || null,
        };
  }
  const e = fl[n.name];
  if (!e)
    return (
      typeof n.chainId != "number" &&
        Qy.throwArgumentError("invalid network chainId", "network", n),
      n
    );
  n.chainId !== 0 &&
    n.chainId !== e.chainId &&
    Qy.throwArgumentError("network chainId mismatch", "network", n);
  let t = n._defaultProvider || null;
  return (
    t == null &&
      e._defaultProvider &&
      (BA(e._defaultProvider)
        ? (t = e._defaultProvider.renetwork(n))
        : (t = e._defaultProvider)),
    {
      name: n.name,
      chainId: e.chainId,
      ensAddress: n.ensAddress || e.ensAddress || null,
      _defaultProvider: t,
    }
  );
}
const DA = "web/5.7.1";
var OA =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
function NA(n, e) {
  return OA(this, void 0, void 0, function* () {
    e == null && (e = {});
    const t = {
      method: e.method || "GET",
      headers: e.headers || {},
      body: e.body || void 0,
    };
    if (
      (e.skipFetchSetup !== !0 &&
        ((t.mode = "cors"),
        (t.cache = "no-cache"),
        (t.credentials = "same-origin"),
        (t.redirect = "follow"),
        (t.referrer = "client")),
      e.fetchOptions != null)
    ) {
      const s = e.fetchOptions;
      s.mode && (t.mode = s.mode),
        s.cache && (t.cache = s.cache),
        s.credentials && (t.credentials = s.credentials),
        s.redirect && (t.redirect = s.redirect),
        s.referrer && (t.referrer = s.referrer);
    }
    const r = yield fetch(n, t),
      a = yield r.arrayBuffer(),
      i = {};
    return (
      r.headers.forEach
        ? r.headers.forEach((s, o) => {
            i[o.toLowerCase()] = s;
          })
        : r.headers.keys().forEach((s) => {
            i[s.toLowerCase()] = r.headers.get(s);
          }),
      {
        headers: i,
        statusCode: r.status,
        statusMessage: r.statusText,
        body: ae(new Uint8Array(a)),
      }
    );
  });
}
var FA =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const pr = new z(DA);
function Zy(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function Ta(n, e) {
  if (n == null) return null;
  if (typeof n == "string") return n;
  if (T2(n)) {
    if (
      e &&
      (e.split("/")[0] === "text" ||
        e.split(";")[0].trim() === "application/json")
    )
      try {
        return zi(n);
      } catch {}
    return pe(n);
  }
  return n;
}
function LA(n) {
  return Ne(
    n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) =>
      String.fromCharCode(parseInt(t, 16)),
    ),
  );
}
function $A(n, e, t) {
  const r =
    typeof n == "object" && n.throttleLimit != null ? n.throttleLimit : 12;
  pr.assertArgument(
    r > 0 && r % 1 === 0,
    "invalid connection throttle limit",
    "connection.throttleLimit",
    r,
  );
  const a = typeof n == "object" ? n.throttleCallback : null,
    i =
      typeof n == "object" && typeof n.throttleSlotInterval == "number"
        ? n.throttleSlotInterval
        : 100;
  pr.assertArgument(
    i > 0 && i % 1 === 0,
    "invalid connection throttle slot interval",
    "connection.throttleSlotInterval",
    i,
  );
  const s = typeof n == "object" ? !!n.errorPassThrough : !1,
    o = {};
  let c = null;
  const l = { method: "GET" };
  let u = !1,
    d = 2 * 60 * 1e3;
  if (typeof n == "string") c = n;
  else if (typeof n == "object") {
    if (
      ((n == null || n.url == null) &&
        pr.throwArgumentError("missing URL", "connection.url", n),
      (c = n.url),
      typeof n.timeout == "number" && n.timeout > 0 && (d = n.timeout),
      n.headers)
    )
      for (const g in n.headers)
        (o[g.toLowerCase()] = { key: g, value: String(n.headers[g]) }),
          ["if-none-match", "if-modified-since"].indexOf(g.toLowerCase()) >=
            0 && (u = !0);
    if (((l.allowGzip = !!n.allowGzip), n.user != null && n.password != null)) {
      c.substring(0, 6) !== "https:" &&
        n.allowInsecureAuthentication !== !0 &&
        pr.throwError(
          "basic authentication requires a secure https url",
          z.errors.INVALID_ARGUMENT,
          { argument: "url", url: c, user: n.user, password: "[REDACTED]" },
        );
      const g = n.user + ":" + n.password;
      o.authorization = { key: "Authorization", value: "Basic " + H2(Ne(g)) };
    }
    n.skipFetchSetup != null && (l.skipFetchSetup = !!n.skipFetchSetup),
      n.fetchOptions != null && (l.fetchOptions = rt(n.fetchOptions));
  }
  const f = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
    p = c ? c.match(f) : null;
  if (p)
    try {
      const g = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": p[1] || "text/plain" },
        body: p[2] ? z2(p[3]) : LA(p[3]),
      };
      let v = g.body;
      return t && (v = t(g.body, g)), Promise.resolve(v);
    } catch (g) {
      pr.throwError("processing response error", z.errors.SERVER_ERROR, {
        body: Ta(p[1], p[2]),
        error: g,
        requestBody: null,
        requestMethod: "GET",
        url: c,
      });
    }
  e &&
    ((l.method = "POST"),
    (l.body = e),
    o["content-type"] == null &&
      (o["content-type"] = {
        key: "Content-Type",
        value: "application/octet-stream",
      }),
    o["content-length"] == null &&
      (o["content-length"] = {
        key: "Content-Length",
        value: String(e.length),
      }));
  const m = {};
  Object.keys(o).forEach((g) => {
    const v = o[g];
    m[v.key] = v.value;
  }),
    (l.headers = m);
  const y = (function () {
      let g = null;
      return {
        promise: new Promise(function (T, A) {
          d &&
            (g = setTimeout(() => {
              g != null &&
                ((g = null),
                A(
                  pr.makeError("timeout", z.errors.TIMEOUT, {
                    requestBody: Ta(l.body, m["content-type"]),
                    requestMethod: l.method,
                    timeout: d,
                    url: c,
                  }),
                ));
            }, d));
        }),
        cancel: function () {
          g != null && (clearTimeout(g), (g = null));
        },
      };
    })(),
    h = (function () {
      return FA(this, void 0, void 0, function* () {
        for (let g = 0; g < r; g++) {
          let v = null;
          try {
            if (((v = yield NA(c, l)), g < r)) {
              if (v.statusCode === 301 || v.statusCode === 302) {
                const T = v.headers.location || "";
                if (l.method === "GET" && T.match(/^https:/)) {
                  c = v.headers.location;
                  continue;
                }
              } else if (v.statusCode === 429) {
                let T = !0;
                if ((a && (T = yield a(g, c)), T)) {
                  let A = 0;
                  const E = v.headers["retry-after"];
                  typeof E == "string" && E.match(/^[1-9][0-9]*$/)
                    ? (A = parseInt(E) * 1e3)
                    : (A =
                        i * parseInt(String(Math.random() * Math.pow(2, g)))),
                    yield Zy(A);
                  continue;
                }
              }
            }
          } catch (T) {
            (v = T.response),
              v == null &&
                (y.cancel(),
                pr.throwError("missing response", z.errors.SERVER_ERROR, {
                  requestBody: Ta(l.body, m["content-type"]),
                  requestMethod: l.method,
                  serverError: T,
                  url: c,
                }));
          }
          let w = v.body;
          if (
            (u && v.statusCode === 304
              ? (w = null)
              : !s &&
                (v.statusCode < 200 || v.statusCode >= 300) &&
                (y.cancel(),
                pr.throwError("bad response", z.errors.SERVER_ERROR, {
                  status: v.statusCode,
                  headers: v.headers,
                  body: Ta(w, v.headers ? v.headers["content-type"] : null),
                  requestBody: Ta(l.body, m["content-type"]),
                  requestMethod: l.method,
                  url: c,
                })),
            t)
          )
            try {
              const T = yield t(w, v);
              return y.cancel(), T;
            } catch (T) {
              if (T.throttleRetry && g < r) {
                let A = !0;
                if ((a && (A = yield a(g, c)), A)) {
                  const E =
                    i * parseInt(String(Math.random() * Math.pow(2, g)));
                  yield Zy(E);
                  continue;
                }
              }
              y.cancel(),
                pr.throwError(
                  "processing response error",
                  z.errors.SERVER_ERROR,
                  {
                    body: Ta(w, v.headers ? v.headers["content-type"] : null),
                    error: T,
                    requestBody: Ta(l.body, m["content-type"]),
                    requestMethod: l.method,
                    url: c,
                  },
                );
            }
          return y.cancel(), w;
        }
        return pr.throwError("failed response", z.errors.SERVER_ERROR, {
          requestBody: Ta(l.body, m["content-type"]),
          requestMethod: l.method,
          url: c,
        });
      });
    })();
  return Promise.race([y.promise, h]);
}
function ro(n, e, t) {
  let r = (i, s) => {
      let o = null;
      if (i != null)
        try {
          o = JSON.parse(zi(i));
        } catch (c) {
          pr.throwError("invalid JSON", z.errors.SERVER_ERROR, {
            body: i,
            error: c,
          });
        }
      return t && (o = t(o, s)), o;
    },
    a = null;
  if (e != null) {
    a = Ne(e);
    const i = typeof n == "string" ? { url: n } : rt(n);
    i.headers
      ? Object.keys(i.headers).filter((o) => o.toLowerCase() === "content-type")
          .length !== 0 ||
        ((i.headers = rt(i.headers)),
        (i.headers["content-type"] = "application/json"))
      : (i.headers = { "content-type": "application/json" }),
      (n = i);
  }
  return $A(n, a, r);
}
function ms(n, e) {
  return (
    e || (e = {}),
    (e = rt(e)),
    e.floor == null && (e.floor = 0),
    e.ceiling == null && (e.ceiling = 1e4),
    e.interval == null && (e.interval = 250),
    new Promise(function (t, r) {
      let a = null,
        i = !1;
      const s = () => (i ? !1 : ((i = !0), a && clearTimeout(a), !0));
      e.timeout &&
        (a = setTimeout(() => {
          s() && r(new Error("timeout"));
        }, e.timeout));
      const o = e.retryLimit;
      let c = 0;
      function l() {
        return n().then(
          function (u) {
            if (u !== void 0) s() && t(u);
            else if (e.oncePoll) e.oncePoll.once("poll", l);
            else if (e.onceBlock) e.onceBlock.once("block", l);
            else if (!i) {
              if ((c++, c > o)) {
                s() && r(new Error("retry limit reached"));
                return;
              }
              let d =
                e.interval * parseInt(String(Math.random() * Math.pow(2, c)));
              d < e.floor && (d = e.floor),
                d > e.ceiling && (d = e.ceiling),
                setTimeout(l, d);
            }
            return null;
          },
          function (u) {
            s() && r(u);
          },
        );
      }
      l();
    })
  );
}
var mu = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
  wp = {};
for (var pl = 0; pl < mu.length; pl++) {
  var Gf = mu.charAt(pl);
  if (wp[Gf] !== void 0) throw new TypeError(Gf + " is ambiguous");
  wp[Gf] = pl;
}
function As(n) {
  var e = n >> 25;
  return (
    ((n & 33554431) << 5) ^
    (-((e >> 0) & 1) & 996825010) ^
    (-((e >> 1) & 1) & 642813549) ^
    (-((e >> 2) & 1) & 513874426) ^
    (-((e >> 3) & 1) & 1027748829) ^
    (-((e >> 4) & 1) & 705979059)
  );
}
function qx(n) {
  for (var e = 1, t = 0; t < n.length; ++t) {
    var r = n.charCodeAt(t);
    if (r < 33 || r > 126) return "Invalid prefix (" + n + ")";
    e = As(e) ^ (r >> 5);
  }
  for (e = As(e), t = 0; t < n.length; ++t) {
    var a = n.charCodeAt(t);
    e = As(e) ^ (a & 31);
  }
  return e;
}
function WA(n, e, t) {
  if (((t = t || 90), n.length + 7 + e.length > t))
    throw new TypeError("Exceeds length limit");
  n = n.toLowerCase();
  var r = qx(n);
  if (typeof r == "string") throw new Error(r);
  for (var a = n + "1", i = 0; i < e.length; ++i) {
    var s = e[i];
    if (s >> 5) throw new Error("Non 5-bit word");
    (r = As(r) ^ s), (a += mu.charAt(s));
  }
  for (i = 0; i < 6; ++i) r = As(r);
  for (r ^= 1, i = 0; i < 6; ++i) {
    var o = (r >> ((5 - i) * 5)) & 31;
    a += mu.charAt(o);
  }
  return a;
}
function Vx(n, e) {
  if (((e = e || 90), n.length < 8)) return n + " too short";
  if (n.length > e) return "Exceeds length limit";
  var t = n.toLowerCase(),
    r = n.toUpperCase();
  if (n !== t && n !== r) return "Mixed-case string " + n;
  n = t;
  var a = n.lastIndexOf("1");
  if (a === -1) return "No separator character for " + n;
  if (a === 0) return "Missing prefix for " + n;
  var i = n.slice(0, a),
    s = n.slice(a + 1);
  if (s.length < 6) return "Data too short";
  var o = qx(i);
  if (typeof o == "string") return o;
  for (var c = [], l = 0; l < s.length; ++l) {
    var u = s.charAt(l),
      d = wp[u];
    if (d === void 0) return "Unknown character " + u;
    (o = As(o) ^ d), !(l + 6 >= s.length) && c.push(d);
  }
  return o !== 1 ? "Invalid checksum for " + n : { prefix: i, words: c };
}
function UA() {
  var n = Vx.apply(null, arguments);
  if (typeof n == "object") return n;
}
function jA(n) {
  var e = Vx.apply(null, arguments);
  if (typeof e == "object") return e;
  throw new Error(e);
}
function Wd(n, e, t, r) {
  for (var a = 0, i = 0, s = (1 << t) - 1, o = [], c = 0; c < n.length; ++c)
    for (a = (a << e) | n[c], i += e; i >= t; ) (i -= t), o.push((a >> i) & s);
  if (r) i > 0 && o.push((a << (t - i)) & s);
  else {
    if (i >= e) return "Excess padding";
    if ((a << (t - i)) & s) return "Non-zero padding";
  }
  return o;
}
function zA(n) {
  var e = Wd(n, 8, 5, !0);
  if (Array.isArray(e)) return e;
}
function HA(n) {
  var e = Wd(n, 8, 5, !0);
  if (Array.isArray(e)) return e;
  throw new Error(e);
}
function qA(n) {
  var e = Wd(n, 5, 8, !1);
  if (Array.isArray(e)) return e;
}
function VA(n) {
  var e = Wd(n, 5, 8, !1);
  if (Array.isArray(e)) return e;
  throw new Error(e);
}
var GA = {
  decodeUnsafe: UA,
  decode: jA,
  encode: WA,
  toWordsUnsafe: zA,
  toWords: HA,
  fromWordsUnsafe: qA,
  fromWords: VA,
};
const e1 = ir(GA),
  on = "providers/5.7.2",
  ko = new z(on);
class me {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const e = {},
      t = this.address.bind(this),
      r = this.bigNumber.bind(this),
      a = this.blockTag.bind(this),
      i = this.data.bind(this),
      s = this.hash.bind(this),
      o = this.hex.bind(this),
      c = this.number.bind(this),
      l = this.type.bind(this),
      u = (d) => this.data(d, !0);
    return (
      (e.transaction = {
        hash: s,
        type: l,
        accessList: me.allowNull(this.accessList.bind(this), null),
        blockHash: me.allowNull(s, null),
        blockNumber: me.allowNull(c, null),
        transactionIndex: me.allowNull(c, null),
        confirmations: me.allowNull(c, null),
        from: t,
        gasPrice: me.allowNull(r),
        maxPriorityFeePerGas: me.allowNull(r),
        maxFeePerGas: me.allowNull(r),
        gasLimit: r,
        to: me.allowNull(t, null),
        value: r,
        nonce: c,
        data: i,
        r: me.allowNull(this.uint256),
        s: me.allowNull(this.uint256),
        v: me.allowNull(c),
        creates: me.allowNull(t, null),
        raw: me.allowNull(i),
      }),
      (e.transactionRequest = {
        from: me.allowNull(t),
        nonce: me.allowNull(c),
        gasLimit: me.allowNull(r),
        gasPrice: me.allowNull(r),
        maxPriorityFeePerGas: me.allowNull(r),
        maxFeePerGas: me.allowNull(r),
        to: me.allowNull(t),
        value: me.allowNull(r),
        data: me.allowNull(u),
        type: me.allowNull(c),
        accessList: me.allowNull(this.accessList.bind(this), null),
      }),
      (e.receiptLog = {
        transactionIndex: c,
        blockNumber: c,
        transactionHash: s,
        address: t,
        topics: me.arrayOf(s),
        data: i,
        logIndex: c,
        blockHash: s,
      }),
      (e.receipt = {
        to: me.allowNull(this.address, null),
        from: me.allowNull(this.address, null),
        contractAddress: me.allowNull(t, null),
        transactionIndex: c,
        root: me.allowNull(o),
        gasUsed: r,
        logsBloom: me.allowNull(i),
        blockHash: s,
        transactionHash: s,
        logs: me.arrayOf(this.receiptLog.bind(this)),
        blockNumber: c,
        confirmations: me.allowNull(c, null),
        cumulativeGasUsed: r,
        effectiveGasPrice: me.allowNull(r),
        status: me.allowNull(c),
        type: l,
      }),
      (e.block = {
        hash: me.allowNull(s),
        parentHash: s,
        number: c,
        timestamp: c,
        nonce: me.allowNull(o),
        difficulty: this.difficulty.bind(this),
        gasLimit: r,
        gasUsed: r,
        miner: me.allowNull(t),
        extraData: i,
        transactions: me.allowNull(me.arrayOf(s)),
        baseFeePerGas: me.allowNull(r),
      }),
      (e.blockWithTransactions = rt(e.block)),
      (e.blockWithTransactions.transactions = me.allowNull(
        me.arrayOf(this.transactionResponse.bind(this)),
      )),
      (e.filter = {
        fromBlock: me.allowNull(a, void 0),
        toBlock: me.allowNull(a, void 0),
        blockHash: me.allowNull(s, void 0),
        address: me.allowNull(t, void 0),
        topics: me.allowNull(this.topics.bind(this), void 0),
      }),
      (e.filterLog = {
        blockNumber: me.allowNull(c),
        blockHash: me.allowNull(s),
        transactionIndex: c,
        removed: me.allowNull(this.boolean.bind(this)),
        address: t,
        data: me.allowFalsish(i, "0x"),
        topics: me.arrayOf(s),
        transactionHash: s,
        logIndex: c,
      }),
      e
    );
  }
  accessList(e) {
    return Vi(e || []);
  }
  number(e) {
    return e === "0x" ? 0 : O.from(e).toNumber();
  }
  type(e) {
    return e === "0x" || e == null ? 0 : O.from(e).toNumber();
  }
  bigNumber(e) {
    return O.from(e);
  }
  boolean(e) {
    if (typeof e == "boolean") return e;
    if (typeof e == "string") {
      if (((e = e.toLowerCase()), e === "true")) return !0;
      if (e === "false") return !1;
    }
    throw new Error("invalid boolean - " + e);
  }
  hex(e, t) {
    return typeof e == "string" &&
      (!t && e.substring(0, 2) !== "0x" && (e = "0x" + e), Ve(e))
      ? e.toLowerCase()
      : ko.throwArgumentError("invalid hash", "value", e);
  }
  data(e, t) {
    const r = this.hex(e, t);
    if (r.length % 2 !== 0) throw new Error("invalid data; odd-length - " + e);
    return r;
  }
  address(e) {
    return ht(e);
  }
  callAddress(e) {
    if (!Ve(e, 32)) return null;
    const t = ht(Mt(e, 12));
    return t === Ie ? null : t;
  }
  contractAddress(e) {
    return Nc(e);
  }
  blockTag(e) {
    if (e == null) return "latest";
    if (e === "earliest") return "0x0";
    switch (e) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return e;
    }
    if (typeof e == "number" || Ve(e)) return Bd(e);
    throw new Error("invalid blockTag");
  }
  hash(e, t) {
    const r = this.hex(e, t);
    return sa(r) !== 32 ? ko.throwArgumentError("invalid hash", "value", e) : r;
  }
  difficulty(e) {
    if (e == null) return null;
    const t = O.from(e);
    try {
      return t.toNumber();
    } catch {}
    return null;
  }
  uint256(e) {
    if (!Ve(e)) throw new Error("invalid uint256");
    return Ue(e, 32);
  }
  _block(e, t) {
    e.author != null && e.miner == null && (e.miner = e.author);
    const r = e._difficulty != null ? e._difficulty : e.difficulty,
      a = me.check(t, e);
    return (a._difficulty = r == null ? null : O.from(r)), a;
  }
  block(e) {
    return this._block(e, this.formats.block);
  }
  blockWithTransactions(e) {
    return this._block(e, this.formats.blockWithTransactions);
  }
  transactionRequest(e) {
    return me.check(this.formats.transactionRequest, e);
  }
  transactionResponse(e) {
    e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas),
      e.to &&
        O.from(e.to).isZero() &&
        (e.to = "0x0000000000000000000000000000000000000000"),
      e.input != null && e.data == null && (e.data = e.input),
      e.to == null &&
        e.creates == null &&
        (e.creates = this.contractAddress(e)),
      (e.type === 1 || e.type === 2) &&
        e.accessList == null &&
        (e.accessList = []);
    const t = me.check(this.formats.transaction, e);
    if (e.chainId != null) {
      let r = e.chainId;
      Ve(r) && (r = O.from(r).toNumber()), (t.chainId = r);
    } else {
      let r = e.networkId;
      r == null && t.v == null && (r = e.chainId),
        Ve(r) && (r = O.from(r).toNumber()),
        typeof r != "number" &&
          t.v != null &&
          ((r = (t.v - 35) / 2), r < 0 && (r = 0), (r = parseInt(r))),
        typeof r != "number" && (r = 0),
        (t.chainId = r);
    }
    return (
      t.blockHash &&
        t.blockHash.replace(/0/g, "") === "x" &&
        (t.blockHash = null),
      t
    );
  }
  transaction(e) {
    return VC(e);
  }
  receiptLog(e) {
    return me.check(this.formats.receiptLog, e);
  }
  receipt(e) {
    const t = me.check(this.formats.receipt, e);
    if (t.root != null)
      if (t.root.length <= 4) {
        const r = O.from(t.root).toNumber();
        r === 0 || r === 1
          ? (t.status != null &&
              t.status !== r &&
              ko.throwArgumentError(
                "alt-root-status/status mismatch",
                "value",
                { root: t.root, status: t.status },
              ),
            (t.status = r),
            delete t.root)
          : ko.throwArgumentError(
              "invalid alt-root-status",
              "value.root",
              t.root,
            );
      } else
        t.root.length !== 66 &&
          ko.throwArgumentError("invalid root hash", "value.root", t.root);
    return t.status != null && (t.byzantium = !0), t;
  }
  topics(e) {
    return Array.isArray(e)
      ? e.map((t) => this.topics(t))
      : e != null
      ? this.hash(e, !0)
      : null;
  }
  filter(e) {
    return me.check(this.formats.filter, e);
  }
  filterLog(e) {
    return me.check(this.formats.filterLog, e);
  }
  static check(e, t) {
    const r = {};
    for (const a in e)
      try {
        const i = e[a](t[a]);
        i !== void 0 && (r[a] = i);
      } catch (i) {
        throw ((i.checkKey = a), (i.checkValue = t[a]), i);
      }
    return r;
  }
  static allowNull(e, t) {
    return function (r) {
      return r == null ? t : e(r);
    };
  }
  static allowFalsish(e, t) {
    return function (r) {
      return r ? e(r) : t;
    };
  }
  static arrayOf(e) {
    return function (t) {
      if (!Array.isArray(t)) throw new Error("not an array");
      const r = [];
      return (
        t.forEach(function (a) {
          r.push(e(a));
        }),
        r
      );
    };
  }
}
function KA(n) {
  return n && typeof n.isCommunityResource == "function";
}
function t1(n) {
  return KA(n) && n.isCommunityResource();
}
let n1 = !1;
function Ud() {
  n1 ||
    ((n1 = !0),
    console.log("========= NOTICE ========="),
    console.log("Request-Rate Exceeded  (this message will not be repeated)"),
    console.log(""),
    console.log(
      "The default API keys for each service are provided as a highly-throttled,",
    ),
    console.log(
      "community resource for low-traffic projects and early prototyping.",
    ),
    console.log(""),
    console.log(
      "While your application will continue to function, we highly recommended",
    ),
    console.log(
      "signing up for your own API keys to improve performance, increase your",
    ),
    console.log(
      "request rate/limit and enable other perks, such as metrics and advanced APIs.",
    ),
    console.log(""),
    console.log("For more details: https://docs.ethers.io/api-keys/"),
    console.log("=========================="));
}
var Ce =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const Se = new z(on),
  QA = 10;
function r1(n) {
  return n == null
    ? "null"
    : (sa(n) !== 32 && Se.throwArgumentError("invalid topic", "topic", n),
      n.toLowerCase());
}
function a1(n) {
  for (n = n.slice(); n.length > 0 && n[n.length - 1] == null; ) n.pop();
  return n
    .map((e) => {
      if (Array.isArray(e)) {
        const t = {};
        e.forEach((a) => {
          t[r1(a)] = !0;
        });
        const r = Object.keys(t);
        return r.sort(), r.join("|");
      } else return r1(e);
    })
    .join("&");
}
function YA(n) {
  return n === ""
    ? []
    : n.split(/&/g).map((e) => {
        if (e === "") return [];
        const t = e.split("|").map((r) => (r === "null" ? null : r));
        return t.length === 1 ? t[0] : t;
      });
}
function rs(n) {
  if (typeof n == "string") {
    if (((n = n.toLowerCase()), sa(n) === 32)) return "tx:" + n;
    if (n.indexOf(":") === -1) return n;
  } else {
    if (Array.isArray(n)) return "filter:*:" + a1(n);
    if (Y3.isForkEvent(n))
      throw (Se.warn("not implemented"), new Error("not implemented"));
    if (n && typeof n == "object")
      return "filter:" + (n.address || "*") + ":" + a1(n.topics || []);
  }
  throw new Error("invalid event - " + n);
}
function _o() {
  return new Date().getTime();
}
function i1(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
const JA = ["block", "network", "pending", "poll"];
class XA {
  constructor(e, t, r) {
    Q(this, "tag", e),
      Q(this, "listener", t),
      Q(this, "once", r),
      (this._lastBlockNumber = -2),
      (this._inflight = !1);
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const e = this.tag.split(":");
    return e[0] !== "tx" ? null : e[1];
  }
  get filter() {
    const e = this.tag.split(":");
    if (e[0] !== "filter") return null;
    const t = e[1],
      r = YA(e[2]),
      a = {};
    return r.length > 0 && (a.topics = r), t && t !== "*" && (a.address = t), a;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || JA.indexOf(this.tag) >= 0;
  }
}
const ZA = {
  0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
  60: { symbol: "eth", ilk: "eth" },
  61: { symbol: "etc", ilk: "eth" },
  700: { symbol: "xdai", ilk: "eth" },
};
function Kf(n) {
  return Ue(O.from(n).toHexString(), 32);
}
function s1(n) {
  return nc.encode(nt([n, Mt(Bi(Bi(n)), 0, 4)]));
}
const Gx = new RegExp("^(ipfs)://(.*)$", "i"),
  o1 = [
    new RegExp("^(https)://(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    Gx,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
  ];
function Hl(n, e) {
  try {
    return zi(ic(n, e));
  } catch {}
  return null;
}
function ic(n, e) {
  if (n === "0x") return null;
  const t = O.from(Mt(n, e, e + 32)).toNumber(),
    r = O.from(Mt(n, t, t + 32)).toNumber();
  return Mt(n, t + 32, t + 32 + r);
}
function Qf(n) {
  return (
    n.match(/^ipfs:\/\/ipfs\//i)
      ? (n = n.substring(12))
      : n.match(/^ipfs:\/\//i)
      ? (n = n.substring(7))
      : Se.throwArgumentError("unsupported IPFS format", "link", n),
    `https://gateway.ipfs.io/ipfs/${n}`
  );
}
function c1(n) {
  const e = ae(n);
  if (e.length > 32) throw new Error("internal; should not happen");
  const t = new Uint8Array(32);
  return t.set(e, 32 - e.length), t;
}
function eE(n) {
  if (n.length % 32 === 0) return n;
  const e = new Uint8Array(Math.ceil(n.length / 32) * 32);
  return e.set(n), e;
}
function Kx(n) {
  const e = [];
  let t = 0;
  for (let r = 0; r < n.length; r++) e.push(null), (t += 32);
  for (let r = 0; r < n.length; r++) {
    const a = ae(n[r]);
    (e[r] = c1(t)),
      e.push(c1(a.length)),
      e.push(eE(a)),
      (t += 32 + Math.ceil(a.length / 32) * 32);
  }
  return xn(e);
}
class l1 {
  constructor(e, t, r, a) {
    Q(this, "provider", e),
      Q(this, "name", r),
      Q(this, "address", e.formatter.address(t)),
      Q(this, "_resolvedAddress", a);
  }
  supportsWildcard() {
    return (
      this._supportsEip2544 ||
        (this._supportsEip2544 = this.provider
          .call({
            to: this.address,
            data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000",
          })
          .then((e) => O.from(e).eq(1))
          .catch((e) => {
            if (e.code === z.errors.CALL_EXCEPTION) return !1;
            throw ((this._supportsEip2544 = null), e);
          })),
      this._supportsEip2544
    );
  }
  _fetch(e, t) {
    return Ce(this, void 0, void 0, function* () {
      const r = {
        to: this.address,
        ccipReadEnabled: !0,
        data: xn([e, Wl(this.name), t || "0x"]),
      };
      let a = !1;
      (yield this.supportsWildcard()) &&
        ((a = !0), (r.data = xn(["0x9061b923", Kx([D3(this.name), r.data])])));
      try {
        let i = yield this.provider.call(r);
        return (
          ae(i).length % 32 === 4 &&
            Se.throwError("resolver threw error", z.errors.CALL_EXCEPTION, {
              transaction: r,
              data: i,
            }),
          a && (i = ic(i, 0)),
          i
        );
      } catch (i) {
        if (i.code === z.errors.CALL_EXCEPTION) return null;
        throw i;
      }
    });
  }
  _fetchBytes(e, t) {
    return Ce(this, void 0, void 0, function* () {
      const r = yield this._fetch(e, t);
      return r != null ? ic(r, 0) : null;
    });
  }
  _getAddress(e, t) {
    const r = ZA[String(e)];
    if (
      (r == null &&
        Se.throwError(
          `unsupported coin type: ${e}`,
          z.errors.UNSUPPORTED_OPERATION,
          { operation: `getAddress(${e})` },
        ),
      r.ilk === "eth")
    )
      return this.provider.formatter.address(t);
    const a = ae(t);
    if (r.p2pkh != null) {
      const i = t.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (i) {
        const s = parseInt(i[1], 16);
        if (i[2].length === s * 2 && s >= 1 && s <= 75)
          return s1(nt([[r.p2pkh], "0x" + i[2]]));
      }
    }
    if (r.p2sh != null) {
      const i = t.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (i) {
        const s = parseInt(i[1], 16);
        if (i[2].length === s * 2 && s >= 1 && s <= 75)
          return s1(nt([[r.p2sh], "0x" + i[2]]));
      }
    }
    if (r.prefix != null) {
      const i = a[1];
      let s = a[0];
      if (
        (s === 0 ? i !== 20 && i !== 32 && (s = -1) : (s = -1),
        s >= 0 && a.length === 2 + i && i >= 1 && i <= 75)
      ) {
        const o = e1.toWords(a.slice(2));
        return o.unshift(s), e1.encode(r.prefix, o);
      }
    }
    return null;
  }
  getAddress(e) {
    return Ce(this, void 0, void 0, function* () {
      if ((e == null && (e = 60), e === 60))
        try {
          const a = yield this._fetch("0x3b3b57de");
          return a === "0x" || a === L2
            ? null
            : this.provider.formatter.callAddress(a);
        } catch (a) {
          if (a.code === z.errors.CALL_EXCEPTION) return null;
          throw a;
        }
      const t = yield this._fetchBytes("0xf1cb7e06", Kf(e));
      if (t == null || t === "0x") return null;
      const r = this._getAddress(e, t);
      return (
        r == null &&
          Se.throwError(
            "invalid or unsupported coin data",
            z.errors.UNSUPPORTED_OPERATION,
            { operation: `getAddress(${e})`, coinType: e, data: t },
          ),
        r
      );
    });
  }
  getAvatar() {
    return Ce(this, void 0, void 0, function* () {
      const e = [{ type: "name", content: this.name }];
      try {
        const t = yield this.getText("avatar");
        if (t == null) return null;
        for (let r = 0; r < o1.length; r++) {
          const a = t.match(o1[r]);
          if (a == null) continue;
          const i = a[1].toLowerCase();
          switch (i) {
            case "https":
              return (
                e.push({ type: "url", content: t }), { linkage: e, url: t }
              );
            case "data":
              return (
                e.push({ type: "data", content: t }), { linkage: e, url: t }
              );
            case "ipfs":
              return (
                e.push({ type: "ipfs", content: t }), { linkage: e, url: Qf(t) }
              );
            case "erc721":
            case "erc1155": {
              const s = i === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              e.push({ type: i, content: t });
              const o = this._resolvedAddress || (yield this.getAddress()),
                c = (a[2] || "").split("/");
              if (c.length !== 2) return null;
              const l = yield this.provider.formatter.address(c[0]),
                u = Ue(O.from(c[1]).toHexString(), 32);
              if (i === "erc721") {
                const y = this.provider.formatter.callAddress(
                  yield this.provider.call({
                    to: l,
                    data: xn(["0x6352211e", u]),
                  }),
                );
                if (o !== y) return null;
                e.push({ type: "owner", content: y });
              } else if (i === "erc1155") {
                const y = O.from(
                  yield this.provider.call({
                    to: l,
                    data: xn(["0x00fdd58e", Ue(o, 32), u]),
                  }),
                );
                if (y.isZero()) return null;
                e.push({ type: "balance", content: y.toString() });
              }
              const d = {
                to: this.provider.formatter.address(c[0]),
                data: xn([s, u]),
              };
              let f = Hl(yield this.provider.call(d), 0);
              if (f == null) return null;
              e.push({ type: "metadata-url-base", content: f }),
                i === "erc1155" &&
                  ((f = f.replace("{id}", u.substring(2))),
                  e.push({ type: "metadata-url-expanded", content: f })),
                f.match(/^ipfs:/i) && (f = Qf(f)),
                e.push({ type: "metadata-url", content: f });
              const p = yield ro(f);
              if (!p) return null;
              e.push({ type: "metadata", content: JSON.stringify(p) });
              let m = p.image;
              if (typeof m != "string") return null;
              if (!m.match(/^(https:\/\/|data:)/i)) {
                if (m.match(Gx) == null) return null;
                e.push({ type: "url-ipfs", content: m }), (m = Qf(m));
              }
              return (
                e.push({ type: "url", content: m }), { linkage: e, url: m }
              );
            }
          }
        }
      } catch {}
      return null;
    });
  }
  getContentHash() {
    return Ce(this, void 0, void 0, function* () {
      const e = yield this._fetchBytes("0xbc1c58d1");
      if (e == null || e === "0x") return null;
      const t = e.match(
        /^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/,
      );
      if (t) {
        const s = parseInt(t[3], 16);
        if (t[4].length === s * 2) return "ipfs://" + nc.encode("0x" + t[1]);
      }
      const r = e.match(
        /^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/,
      );
      if (r) {
        const s = parseInt(r[3], 16);
        if (r[4].length === s * 2) return "ipns://" + nc.encode("0x" + r[1]);
      }
      const a = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (a && a[1].length === 32 * 2) return "bzz://" + a[1];
      const i = e.match(/^0x90b2c605([0-9a-f]*)$/);
      if (i && i[1].length === 34 * 2) {
        const s = { "=": "", "+": "-", "/": "_" };
        return "sia://" + H2("0x" + i[1]).replace(/[=+\/]/g, (c) => s[c]);
      }
      return Se.throwError(
        "invalid or unsupported content hash data",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "getContentHash()", data: e },
      );
    });
  }
  getText(e) {
    return Ce(this, void 0, void 0, function* () {
      let t = Ne(e);
      (t = nt([Kf(64), Kf(t.length), t])),
        t.length % 32 !== 0 && (t = nt([t, Ue("0x", 32 - (e.length % 32))]));
      const r = yield this._fetchBytes("0x59d1d43c", pe(t));
      return r == null || r === "0x" ? null : zi(r);
    });
  }
}
let Yf = null,
  tE = 1;
class Uh extends Xs {
  constructor(e) {
    if (
      (super(),
      (this._events = []),
      (this._emitted = { block: -2 }),
      (this.disableCcipRead = !1),
      (this.formatter = new.target.getFormatter()),
      Q(this, "anyNetwork", e === "any"),
      this.anyNetwork && (e = this.detectNetwork()),
      e instanceof Promise)
    )
      (this._networkPromise = e),
        e.catch((t) => {}),
        this._ready().catch((t) => {});
    else {
      const t = tn(new.target, "getNetwork")(e);
      t
        ? (Q(this, "_network", t), this.emit("network", t, null))
        : Se.throwArgumentError("invalid network", "network", e);
    }
    (this._maxInternalBlockNumber = -1024),
      (this._lastBlockNumber = -2),
      (this._maxFilterBlockRange = 10),
      (this._pollingInterval = 4e3),
      (this._fastQueryDate = 0);
  }
  _ready() {
    return Ce(this, void 0, void 0, function* () {
      if (this._network == null) {
        let e = null;
        if (this._networkPromise)
          try {
            e = yield this._networkPromise;
          } catch {}
        e == null && (e = yield this.detectNetwork()),
          e || Se.throwError("no network detected", z.errors.UNKNOWN_ERROR, {}),
          this._network == null &&
            (this.anyNetwork ? (this._network = e) : Q(this, "_network", e),
            this.emit("network", e, null));
      }
      return this._network;
    });
  }
  get ready() {
    return ms(() =>
      this._ready().then(
        (e) => e,
        (e) => {
          if (!(e.code === z.errors.NETWORK_ERROR && e.event === "noNetwork"))
            throw e;
        },
      ),
    );
  }
  static getFormatter() {
    return Yf == null && (Yf = new me()), Yf;
  }
  static getNetwork(e) {
    return Hx(e ?? "homestead");
  }
  ccipReadFetch(e, t, r) {
    return Ce(this, void 0, void 0, function* () {
      if (this.disableCcipRead || r.length === 0) return null;
      const a = e.to.toLowerCase(),
        i = t.toLowerCase(),
        s = [];
      for (let o = 0; o < r.length; o++) {
        const c = r[o],
          l = c.replace("{sender}", a).replace("{data}", i),
          u =
            c.indexOf("{data}") >= 0
              ? null
              : JSON.stringify({ data: i, sender: a }),
          d = yield ro(
            { url: l, errorPassThrough: !0 },
            u,
            (p, m) => ((p.status = m.statusCode), p),
          );
        if (d.data) return d.data;
        const f = d.message || "unknown error";
        if (d.status >= 400 && d.status < 500)
          return Se.throwError(
            `response not found during CCIP fetch: ${f}`,
            z.errors.SERVER_ERROR,
            { url: c, errorMessage: f },
          );
        s.push(f);
      }
      return Se.throwError(
        `error encountered during CCIP fetch: ${s
          .map((o) => JSON.stringify(o))
          .join(", ")}`,
        z.errors.SERVER_ERROR,
        { urls: r, errorMessages: s },
      );
    });
  }
  _getInternalBlockNumber(e) {
    return Ce(this, void 0, void 0, function* () {
      if ((yield this._ready(), e > 0))
        for (; this._internalBlockNumber; ) {
          const a = this._internalBlockNumber;
          try {
            const i = yield a;
            if (_o() - i.respTime <= e) return i.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === a) break;
          }
        }
      const t = _o(),
        r = bt({
          blockNumber: this.perform("getBlockNumber", {}),
          networkError: this.getNetwork().then(
            (a) => null,
            (a) => a,
          ),
        }).then(({ blockNumber: a, networkError: i }) => {
          if (i)
            throw (
              (this._internalBlockNumber === r &&
                (this._internalBlockNumber = null),
              i)
            );
          const s = _o();
          return (
            (a = O.from(a).toNumber()),
            a < this._maxInternalBlockNumber &&
              (a = this._maxInternalBlockNumber),
            (this._maxInternalBlockNumber = a),
            this._setFastBlockNumber(a),
            { blockNumber: a, reqTime: t, respTime: s }
          );
        });
      return (
        (this._internalBlockNumber = r),
        r.catch((a) => {
          this._internalBlockNumber === r && (this._internalBlockNumber = null);
        }),
        (yield r).blockNumber
      );
    });
  }
  poll() {
    return Ce(this, void 0, void 0, function* () {
      const e = tE++,
        t = [];
      let r = null;
      try {
        r = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (a) {
        this.emit("error", a);
        return;
      }
      if (
        (this._setFastBlockNumber(r),
        this.emit("poll", e, r),
        r === this._lastBlockNumber)
      ) {
        this.emit("didPoll", e);
        return;
      }
      if (
        (this._emitted.block === -2 && (this._emitted.block = r - 1),
        Math.abs(this._emitted.block - r) > 1e3)
      )
        Se.warn(
          `network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${r})`,
        ),
          this.emit(
            "error",
            Se.makeError(
              "network block skew detected",
              z.errors.NETWORK_ERROR,
              {
                blockNumber: r,
                event: "blockSkew",
                previousBlockNumber: this._emitted.block,
              },
            ),
          ),
          this.emit("block", r);
      else
        for (let a = this._emitted.block + 1; a <= r; a++)
          this.emit("block", a);
      this._emitted.block !== r &&
        ((this._emitted.block = r),
        Object.keys(this._emitted).forEach((a) => {
          if (a === "block") return;
          const i = this._emitted[a];
          i !== "pending" && r - i > 12 && delete this._emitted[a];
        })),
        this._lastBlockNumber === -2 && (this._lastBlockNumber = r - 1),
        this._events.forEach((a) => {
          switch (a.type) {
            case "tx": {
              const i = a.hash;
              let s = this.getTransactionReceipt(i)
                .then(
                  (o) => (
                    !o ||
                      o.blockNumber == null ||
                      ((this._emitted["t:" + i] = o.blockNumber),
                      this.emit(i, o)),
                    null
                  ),
                )
                .catch((o) => {
                  this.emit("error", o);
                });
              t.push(s);
              break;
            }
            case "filter": {
              if (!a._inflight) {
                (a._inflight = !0),
                  a._lastBlockNumber === -2 && (a._lastBlockNumber = r - 1);
                const i = a.filter;
                (i.fromBlock = a._lastBlockNumber + 1), (i.toBlock = r);
                const s = i.toBlock - this._maxFilterBlockRange;
                s > i.fromBlock && (i.fromBlock = s),
                  i.fromBlock < 0 && (i.fromBlock = 0);
                const o = this.getLogs(i)
                  .then((c) => {
                    (a._inflight = !1),
                      c.length !== 0 &&
                        c.forEach((l) => {
                          l.blockNumber > a._lastBlockNumber &&
                            (a._lastBlockNumber = l.blockNumber),
                            (this._emitted["b:" + l.blockHash] = l.blockNumber),
                            (this._emitted["t:" + l.transactionHash] =
                              l.blockNumber),
                            this.emit(i, l);
                        });
                  })
                  .catch((c) => {
                    this.emit("error", c), (a._inflight = !1);
                  });
                t.push(o);
              }
              break;
            }
          }
        }),
        (this._lastBlockNumber = r),
        Promise.all(t)
          .then(() => {
            this.emit("didPoll", e);
          })
          .catch((a) => {
            this.emit("error", a);
          });
    });
  }
  resetEventsBlock(e) {
    (this._lastBlockNumber = e - 1), this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return Ce(this, void 0, void 0, function* () {
      return Se.throwError(
        "provider does not support network detection",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "provider.detectNetwork" },
      );
    });
  }
  getNetwork() {
    return Ce(this, void 0, void 0, function* () {
      const e = yield this._ready(),
        t = yield this.detectNetwork();
      if (e.chainId !== t.chainId) {
        if (this.anyNetwork)
          return (
            (this._network = t),
            (this._lastBlockNumber = -2),
            (this._fastBlockNumber = null),
            (this._fastBlockNumberPromise = null),
            (this._fastQueryDate = 0),
            (this._emitted.block = -2),
            (this._maxInternalBlockNumber = -1024),
            (this._internalBlockNumber = null),
            this.emit("network", t, e),
            yield i1(0),
            this._network
          );
        const r = Se.makeError(
          "underlying network changed",
          z.errors.NETWORK_ERROR,
          { event: "changed", network: e, detectedNetwork: t },
        );
        throw (this.emit("error", r), r);
      }
      return e;
    });
  }
  get blockNumber() {
    return (
      this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(
        (e) => {
          this._setFastBlockNumber(e);
        },
        (e) => {},
      ),
      this._fastBlockNumber != null ? this._fastBlockNumber : -1
    );
  }
  get polling() {
    return this._poller != null;
  }
  set polling(e) {
    e && !this._poller
      ? ((this._poller = setInterval(() => {
          this.poll();
        }, this.pollingInterval)),
        this._bootstrapPoll ||
          (this._bootstrapPoll = setTimeout(() => {
            this.poll(),
              (this._bootstrapPoll = setTimeout(() => {
                this._poller || this.poll(), (this._bootstrapPoll = null);
              }, this.pollingInterval));
          }, 0)))
      : !e &&
        this._poller &&
        (clearInterval(this._poller), (this._poller = null));
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(e) {
    if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e)
      throw new Error("invalid polling interval");
    (this._pollingInterval = e),
      this._poller &&
        (clearInterval(this._poller),
        (this._poller = setInterval(() => {
          this.poll();
        }, this._pollingInterval)));
  }
  _getFastBlockNumber() {
    const e = _o();
    return (
      e - this._fastQueryDate > 2 * this._pollingInterval &&
        ((this._fastQueryDate = e),
        (this._fastBlockNumberPromise = this.getBlockNumber().then(
          (t) => (
            (this._fastBlockNumber == null || t > this._fastBlockNumber) &&
              (this._fastBlockNumber = t),
            this._fastBlockNumber
          ),
        ))),
      this._fastBlockNumberPromise
    );
  }
  _setFastBlockNumber(e) {
    (this._fastBlockNumber != null && e < this._fastBlockNumber) ||
      ((this._fastQueryDate = _o()),
      (this._fastBlockNumber == null || e > this._fastBlockNumber) &&
        ((this._fastBlockNumber = e),
        (this._fastBlockNumberPromise = Promise.resolve(e))));
  }
  waitForTransaction(e, t, r) {
    return Ce(this, void 0, void 0, function* () {
      return this._waitForTransaction(e, t ?? 1, r || 0, null);
    });
  }
  _waitForTransaction(e, t, r, a) {
    return Ce(this, void 0, void 0, function* () {
      const i = yield this.getTransactionReceipt(e);
      return (i ? i.confirmations : 0) >= t
        ? i
        : new Promise((s, o) => {
            const c = [];
            let l = !1;
            const u = function () {
                return l
                  ? !0
                  : ((l = !0),
                    c.forEach((f) => {
                      f();
                    }),
                    !1);
              },
              d = (f) => {
                f.confirmations < t || u() || s(f);
              };
            if (
              (this.on(e, d),
              c.push(() => {
                this.removeListener(e, d);
              }),
              a)
            ) {
              let f = a.startBlock,
                p = null;
              const m = (y) =>
                Ce(this, void 0, void 0, function* () {
                  l ||
                    (yield i1(1e3),
                    this.getTransactionCount(a.from).then(
                      (h) =>
                        Ce(this, void 0, void 0, function* () {
                          if (!l) {
                            if (h <= a.nonce) f = y;
                            else {
                              {
                                const g = yield this.getTransaction(e);
                                if (g && g.blockNumber != null) return;
                              }
                              for (
                                p == null &&
                                ((p = f - 3),
                                p < a.startBlock && (p = a.startBlock));
                                p <= y;

                              ) {
                                if (l) return;
                                const g =
                                  yield this.getBlockWithTransactions(p);
                                for (
                                  let v = 0;
                                  v < g.transactions.length;
                                  v++
                                ) {
                                  const w = g.transactions[v];
                                  if (w.hash === e) return;
                                  if (
                                    w.from === a.from &&
                                    w.nonce === a.nonce
                                  ) {
                                    if (l) return;
                                    const T = yield this.waitForTransaction(
                                      w.hash,
                                      t,
                                    );
                                    if (u()) return;
                                    let A = "replaced";
                                    w.data === a.data &&
                                    w.to === a.to &&
                                    w.value.eq(a.value)
                                      ? (A = "repriced")
                                      : w.data === "0x" &&
                                        w.from === w.to &&
                                        w.value.isZero() &&
                                        (A = "cancelled"),
                                      o(
                                        Se.makeError(
                                          "transaction was replaced",
                                          z.errors.TRANSACTION_REPLACED,
                                          {
                                            cancelled:
                                              A === "replaced" ||
                                              A === "cancelled",
                                            reason: A,
                                            replacement:
                                              this._wrapTransaction(w),
                                            hash: e,
                                            receipt: T,
                                          },
                                        ),
                                      );
                                    return;
                                  }
                                }
                                p++;
                              }
                            }
                            l || this.once("block", m);
                          }
                        }),
                      (h) => {
                        l || this.once("block", m);
                      },
                    ));
                });
              if (l) return;
              this.once("block", m),
                c.push(() => {
                  this.removeListener("block", m);
                });
            }
            if (typeof r == "number" && r > 0) {
              const f = setTimeout(() => {
                u() ||
                  o(
                    Se.makeError("timeout exceeded", z.errors.TIMEOUT, {
                      timeout: r,
                    }),
                  );
              }, r);
              f.unref && f.unref(),
                c.push(() => {
                  clearTimeout(f);
                });
            }
          });
    });
  }
  getBlockNumber() {
    return Ce(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const e = yield this.perform("getGasPrice", {});
      try {
        return O.from(e);
      } catch (t) {
        return Se.throwError("bad result from backend", z.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result: e,
          error: t,
        });
      }
    });
  }
  getBalance(e, t) {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield bt({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(t),
        }),
        a = yield this.perform("getBalance", r);
      try {
        return O.from(a);
      } catch (i) {
        return Se.throwError("bad result from backend", z.errors.SERVER_ERROR, {
          method: "getBalance",
          params: r,
          result: a,
          error: i,
        });
      }
    });
  }
  getTransactionCount(e, t) {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield bt({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(t),
        }),
        a = yield this.perform("getTransactionCount", r);
      try {
        return O.from(a).toNumber();
      } catch (i) {
        return Se.throwError("bad result from backend", z.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params: r,
          result: a,
          error: i,
        });
      }
    });
  }
  getCode(e, t) {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield bt({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(t),
        }),
        a = yield this.perform("getCode", r);
      try {
        return pe(a);
      } catch (i) {
        return Se.throwError("bad result from backend", z.errors.SERVER_ERROR, {
          method: "getCode",
          params: r,
          result: a,
          error: i,
        });
      }
    });
  }
  getStorageAt(e, t, r) {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const a = yield bt({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(r),
          position: Promise.resolve(t).then((s) => Bd(s)),
        }),
        i = yield this.perform("getStorageAt", a);
      try {
        return pe(i);
      } catch (s) {
        return Se.throwError("bad result from backend", z.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params: a,
          result: i,
          error: s,
        });
      }
    });
  }
  _wrapTransaction(e, t, r) {
    if (t != null && sa(t) !== 32)
      throw new Error("invalid response - sendTransaction");
    const a = e;
    return (
      t != null &&
        e.hash !== t &&
        Se.throwError(
          "Transaction hash mismatch from Provider.sendTransaction.",
          z.errors.UNKNOWN_ERROR,
          { expectedHash: e.hash, returnedHash: t },
        ),
      (a.wait = (i, s) =>
        Ce(this, void 0, void 0, function* () {
          i == null && (i = 1), s == null && (s = 0);
          let o;
          i !== 0 &&
            r != null &&
            (o = {
              data: e.data,
              from: e.from,
              nonce: e.nonce,
              to: e.to,
              value: e.value,
              startBlock: r,
            });
          const c = yield this._waitForTransaction(e.hash, i, s, o);
          return c == null && i === 0
            ? null
            : ((this._emitted["t:" + e.hash] = c.blockNumber),
              c.status === 0 &&
                Se.throwError("transaction failed", z.errors.CALL_EXCEPTION, {
                  transactionHash: e.hash,
                  transaction: e,
                  receipt: c,
                }),
              c);
        })),
      a
    );
  }
  sendTransaction(e) {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Promise.resolve(e).then((i) => pe(i)),
        r = this.formatter.transaction(e);
      r.confirmations == null && (r.confirmations = 0);
      const a = yield this._getInternalBlockNumber(
        100 + 2 * this.pollingInterval,
      );
      try {
        const i = yield this.perform("sendTransaction", {
          signedTransaction: t,
        });
        return this._wrapTransaction(r, i, a);
      } catch (i) {
        throw ((i.transaction = r), (i.transactionHash = r.hash), i);
      }
    });
  }
  _getTransactionRequest(e) {
    return Ce(this, void 0, void 0, function* () {
      const t = yield e,
        r = {};
      return (
        ["from", "to"].forEach((a) => {
          t[a] != null &&
            (r[a] = Promise.resolve(t[a]).then((i) =>
              i ? this._getAddress(i) : null,
            ));
        }),
        [
          "gasLimit",
          "gasPrice",
          "maxFeePerGas",
          "maxPriorityFeePerGas",
          "value",
        ].forEach((a) => {
          t[a] != null &&
            (r[a] = Promise.resolve(t[a]).then((i) => (i ? O.from(i) : null)));
        }),
        ["type"].forEach((a) => {
          t[a] != null && (r[a] = Promise.resolve(t[a]).then((i) => i ?? null));
        }),
        t.accessList &&
          (r.accessList = this.formatter.accessList(t.accessList)),
        ["data"].forEach((a) => {
          t[a] != null &&
            (r[a] = Promise.resolve(t[a]).then((i) => (i ? pe(i) : null)));
        }),
        this.formatter.transactionRequest(yield bt(r))
      );
    });
  }
  _getFilter(e) {
    return Ce(this, void 0, void 0, function* () {
      e = yield e;
      const t = {};
      return (
        e.address != null && (t.address = this._getAddress(e.address)),
        ["blockHash", "topics"].forEach((r) => {
          e[r] != null && (t[r] = e[r]);
        }),
        ["fromBlock", "toBlock"].forEach((r) => {
          e[r] != null && (t[r] = this._getBlockTag(e[r]));
        }),
        this.formatter.filter(yield bt(t))
      );
    });
  }
  _call(e, t, r) {
    return Ce(this, void 0, void 0, function* () {
      r >= QA &&
        Se.throwError(
          "CCIP read exceeded maximum redirections",
          z.errors.SERVER_ERROR,
          { redirects: r, transaction: e },
        );
      const a = e.to,
        i = yield this.perform("call", { transaction: e, blockTag: t });
      if (
        r >= 0 &&
        t === "latest" &&
        a != null &&
        i.substring(0, 10) === "0x556f1830" &&
        sa(i) % 32 === 4
      )
        try {
          const s = Mt(i, 4),
            o = Mt(s, 0, 32);
          O.from(o).eq(a) ||
            Se.throwError(
              "CCIP Read sender did not match",
              z.errors.CALL_EXCEPTION,
              {
                name: "OffchainLookup",
                signature:
                  "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction: e,
                data: i,
              },
            );
          const c = [],
            l = O.from(Mt(s, 32, 64)).toNumber(),
            u = O.from(Mt(s, l, l + 32)).toNumber(),
            d = Mt(s, l + 32);
          for (let g = 0; g < u; g++) {
            const v = Hl(d, g * 32);
            v == null &&
              Se.throwError(
                "CCIP Read contained corrupt URL string",
                z.errors.CALL_EXCEPTION,
                {
                  name: "OffchainLookup",
                  signature:
                    "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  transaction: e,
                  data: i,
                },
              ),
              c.push(v);
          }
          const f = ic(s, 64);
          O.from(Mt(s, 100, 128)).isZero() ||
            Se.throwError(
              "CCIP Read callback selector included junk",
              z.errors.CALL_EXCEPTION,
              {
                name: "OffchainLookup",
                signature:
                  "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction: e,
                data: i,
              },
            );
          const p = Mt(s, 96, 100),
            m = ic(s, 128),
            y = yield this.ccipReadFetch(e, f, c);
          y == null &&
            Se.throwError(
              "CCIP Read disabled or provided no URLs",
              z.errors.CALL_EXCEPTION,
              {
                name: "OffchainLookup",
                signature:
                  "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction: e,
                data: i,
              },
            );
          const h = { to: a, data: xn([p, Kx([y, m])]) };
          return this._call(h, t, r + 1);
        } catch (s) {
          if (s.code === z.errors.SERVER_ERROR) throw s;
        }
      try {
        return pe(i);
      } catch (s) {
        return Se.throwError("bad result from backend", z.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction: e, blockTag: t },
          result: i,
          error: s,
        });
      }
    });
  }
  call(e, t) {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield bt({
        transaction: this._getTransactionRequest(e),
        blockTag: this._getBlockTag(t),
        ccipReadEnabled: Promise.resolve(e.ccipReadEnabled),
      });
      return this._call(r.transaction, r.blockTag, r.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(e) {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield bt({ transaction: this._getTransactionRequest(e) }),
        r = yield this.perform("estimateGas", t);
      try {
        return O.from(r);
      } catch (a) {
        return Se.throwError("bad result from backend", z.errors.SERVER_ERROR, {
          method: "estimateGas",
          params: t,
          result: r,
          error: a,
        });
      }
    });
  }
  _getAddress(e) {
    return Ce(this, void 0, void 0, function* () {
      (e = yield e),
        typeof e != "string" &&
          Se.throwArgumentError("invalid address or ENS name", "name", e);
      const t = yield this.resolveName(e);
      return (
        t == null &&
          Se.throwError(
            "ENS name not configured",
            z.errors.UNSUPPORTED_OPERATION,
            { operation: `resolveName(${JSON.stringify(e)})` },
          ),
        t
      );
    });
  }
  _getBlock(e, t) {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      let r = -128;
      const a = { includeTransactions: !!t };
      if (Ve(e, 32)) a.blockHash = e;
      else
        try {
          (a.blockTag = yield this._getBlockTag(e)),
            Ve(a.blockTag) && (r = parseInt(a.blockTag.substring(2), 16));
        } catch {
          Se.throwArgumentError(
            "invalid block hash or block tag",
            "blockHashOrBlockTag",
            e,
          );
        }
      return ms(
        () =>
          Ce(this, void 0, void 0, function* () {
            const i = yield this.perform("getBlock", a);
            if (i == null)
              return (a.blockHash != null &&
                this._emitted["b:" + a.blockHash] == null) ||
                (a.blockTag != null && r > this._emitted.block)
                ? null
                : void 0;
            if (t) {
              let s = null;
              for (let c = 0; c < i.transactions.length; c++) {
                const l = i.transactions[c];
                if (l.blockNumber == null) l.confirmations = 0;
                else if (l.confirmations == null) {
                  s == null &&
                    (s = yield this._getInternalBlockNumber(
                      100 + 2 * this.pollingInterval,
                    ));
                  let u = s - l.blockNumber + 1;
                  u <= 0 && (u = 1), (l.confirmations = u);
                }
              }
              const o = this.formatter.blockWithTransactions(i);
              return (
                (o.transactions = o.transactions.map((c) =>
                  this._wrapTransaction(c),
                )),
                o
              );
            }
            return this.formatter.block(i);
          }),
        { oncePoll: this },
      );
    });
  }
  getBlock(e) {
    return this._getBlock(e, !1);
  }
  getBlockWithTransactions(e) {
    return this._getBlock(e, !0);
  }
  getTransaction(e) {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return ms(
        () =>
          Ce(this, void 0, void 0, function* () {
            const r = yield this.perform("getTransaction", t);
            if (r == null)
              return this._emitted["t:" + e] == null ? null : void 0;
            const a = this.formatter.transactionResponse(r);
            if (a.blockNumber == null) a.confirmations = 0;
            else if (a.confirmations == null) {
              let s =
                (yield this._getInternalBlockNumber(
                  100 + 2 * this.pollingInterval,
                )) -
                a.blockNumber +
                1;
              s <= 0 && (s = 1), (a.confirmations = s);
            }
            return this._wrapTransaction(a);
          }),
        { oncePoll: this },
      );
    });
  }
  getTransactionReceipt(e) {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return ms(
        () =>
          Ce(this, void 0, void 0, function* () {
            const r = yield this.perform("getTransactionReceipt", t);
            if (r == null)
              return this._emitted["t:" + e] == null ? null : void 0;
            if (r.blockHash == null) return;
            const a = this.formatter.receipt(r);
            if (a.blockNumber == null) a.confirmations = 0;
            else if (a.confirmations == null) {
              let s =
                (yield this._getInternalBlockNumber(
                  100 + 2 * this.pollingInterval,
                )) -
                a.blockNumber +
                1;
              s <= 0 && (s = 1), (a.confirmations = s);
            }
            return a;
          }),
        { oncePoll: this },
      );
    });
  }
  getLogs(e) {
    return Ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield bt({ filter: this._getFilter(e) }),
        r = yield this.perform("getLogs", t);
      return (
        r.forEach((a) => {
          a.removed == null && (a.removed = !1);
        }),
        me.arrayOf(this.formatter.filterLog.bind(this.formatter))(r)
      );
    });
  }
  getEtherPrice() {
    return Ce(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(e) {
    return Ce(this, void 0, void 0, function* () {
      if (((e = yield e), typeof e == "number" && e < 0)) {
        e % 1 && Se.throwArgumentError("invalid BlockTag", "blockTag", e);
        let t = yield this._getInternalBlockNumber(
          100 + 2 * this.pollingInterval,
        );
        return (t += e), t < 0 && (t = 0), this.formatter.blockTag(t);
      }
      return this.formatter.blockTag(e);
    });
  }
  getResolver(e) {
    return Ce(this, void 0, void 0, function* () {
      let t = e;
      for (;;) {
        if (t === "" || t === "." || (e !== "eth" && t === "eth")) return null;
        const r = yield this._getResolver(t, "getResolver");
        if (r != null) {
          const a = new l1(this, r, e);
          return t !== e && !(yield a.supportsWildcard()) ? null : a;
        }
        t = t.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(e, t) {
    return Ce(this, void 0, void 0, function* () {
      t == null && (t = "ENS");
      const r = yield this.getNetwork();
      r.ensAddress ||
        Se.throwError(
          "network does not support ENS",
          z.errors.UNSUPPORTED_OPERATION,
          { operation: t, network: r.name },
        );
      try {
        const a = yield this.call({
          to: r.ensAddress,
          data: "0x0178b8bf" + Wl(e).substring(2),
        });
        return this.formatter.callAddress(a);
      } catch {}
      return null;
    });
  }
  resolveName(e) {
    return Ce(this, void 0, void 0, function* () {
      e = yield e;
      try {
        return Promise.resolve(this.formatter.address(e));
      } catch (r) {
        if (Ve(e)) throw r;
      }
      typeof e != "string" &&
        Se.throwArgumentError("invalid ENS name", "name", e);
      const t = yield this.getResolver(e);
      return t ? yield t.getAddress() : null;
    });
  }
  lookupAddress(e) {
    return Ce(this, void 0, void 0, function* () {
      (e = yield e), (e = this.formatter.address(e));
      const t = e.substring(2).toLowerCase() + ".addr.reverse",
        r = yield this._getResolver(t, "lookupAddress");
      if (r == null) return null;
      const a = Hl(
        yield this.call({ to: r, data: "0x691f3431" + Wl(t).substring(2) }),
        0,
      );
      return (yield this.resolveName(a)) != e ? null : a;
    });
  }
  getAvatar(e) {
    return Ce(this, void 0, void 0, function* () {
      let t = null;
      if (Ve(e)) {
        const i =
            this.formatter.address(e).substring(2).toLowerCase() +
            ".addr.reverse",
          s = yield this._getResolver(i, "getAvatar");
        if (!s) return null;
        t = new l1(this, s, i);
        try {
          const o = yield t.getAvatar();
          if (o) return o.url;
        } catch (o) {
          if (o.code !== z.errors.CALL_EXCEPTION) throw o;
        }
        try {
          const o = Hl(
            yield this.call({ to: s, data: "0x691f3431" + Wl(i).substring(2) }),
            0,
          );
          t = yield this.getResolver(o);
        } catch (o) {
          if (o.code !== z.errors.CALL_EXCEPTION) throw o;
          return null;
        }
      } else if (((t = yield this.getResolver(e)), !t)) return null;
      const r = yield t.getAvatar();
      return r == null ? null : r.url;
    });
  }
  perform(e, t) {
    return Se.throwError(e + " not implemented", z.errors.NOT_IMPLEMENTED, {
      operation: e,
    });
  }
  _startEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _stopEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _addEventListener(e, t, r) {
    const a = new XA(rs(e), t, r);
    return this._events.push(a), this._startEvent(a), this;
  }
  on(e, t) {
    return this._addEventListener(e, t, !1);
  }
  once(e, t) {
    return this._addEventListener(e, t, !0);
  }
  emit(e, ...t) {
    let r = !1,
      a = [],
      i = rs(e);
    return (
      (this._events = this._events.filter((s) =>
        s.tag !== i
          ? !0
          : (setTimeout(() => {
              s.listener.apply(this, t);
            }, 0),
            (r = !0),
            s.once ? (a.push(s), !1) : !0),
      )),
      a.forEach((s) => {
        this._stopEvent(s);
      }),
      r
    );
  }
  listenerCount(e) {
    if (!e) return this._events.length;
    let t = rs(e);
    return this._events.filter((r) => r.tag === t).length;
  }
  listeners(e) {
    if (e == null) return this._events.map((r) => r.listener);
    let t = rs(e);
    return this._events.filter((r) => r.tag === t).map((r) => r.listener);
  }
  off(e, t) {
    if (t == null) return this.removeAllListeners(e);
    const r = [];
    let a = !1,
      i = rs(e);
    return (
      (this._events = this._events.filter((s) =>
        s.tag !== i || s.listener != t || a ? !0 : ((a = !0), r.push(s), !1),
      )),
      r.forEach((s) => {
        this._stopEvent(s);
      }),
      this
    );
  }
  removeAllListeners(e) {
    let t = [];
    if (e == null) (t = this._events), (this._events = []);
    else {
      const r = rs(e);
      this._events = this._events.filter((a) =>
        a.tag !== r ? !0 : (t.push(a), !1),
      );
    }
    return (
      t.forEach((r) => {
        this._stopEvent(r);
      }),
      this
    );
  }
}
var Zr =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const Tt = new z(on),
  nE = ["call", "estimateGas"];
function Vo(n, e) {
  if (n == null) return null;
  if (typeof n.message == "string" && n.message.match("reverted")) {
    const t = Ve(n.data) ? n.data : null;
    if (!e || t) return { message: n.message, data: t };
  }
  if (typeof n == "object") {
    for (const t in n) {
      const r = Vo(n[t], e);
      if (r) return r;
    }
    return null;
  }
  if (typeof n == "string")
    try {
      return Vo(JSON.parse(n), e);
    } catch {}
  return null;
}
function Qx(n, e, t) {
  const r = t.transaction || t.signedTransaction;
  if (n === "call") {
    const i = Vo(e, !0);
    if (i) return i.data;
    Tt.throwError(
      "missing revert data in call exception; Transaction reverted without a reason string",
      z.errors.CALL_EXCEPTION,
      { data: "0x", transaction: r, error: e },
    );
  }
  if (n === "estimateGas") {
    let i = Vo(e.body, !1);
    i == null && (i = Vo(e, !1)),
      i &&
        Tt.throwError(
          "cannot estimate gas; transaction may fail or may require manual gas limit",
          z.errors.UNPREDICTABLE_GAS_LIMIT,
          { reason: i.message, method: n, transaction: r, error: e },
        );
  }
  let a = e.message;
  throw (
    (e.code === z.errors.SERVER_ERROR &&
    e.error &&
    typeof e.error.message == "string"
      ? (a = e.error.message)
      : typeof e.body == "string"
      ? (a = e.body)
      : typeof e.responseText == "string" && (a = e.responseText),
    (a = (a || "").toLowerCase()),
    a.match(
      /insufficient funds|base fee exceeds gas limit|InsufficientFunds/i,
    ) &&
      Tt.throwError(
        "insufficient funds for intrinsic transaction cost",
        z.errors.INSUFFICIENT_FUNDS,
        { error: e, method: n, transaction: r },
      ),
    a.match(/nonce (is )?too low/i) &&
      Tt.throwError("nonce has already been used", z.errors.NONCE_EXPIRED, {
        error: e,
        method: n,
        transaction: r,
      }),
    a.match(
      /replacement transaction underpriced|transaction gas price.*too low/i,
    ) &&
      Tt.throwError(
        "replacement fee too low",
        z.errors.REPLACEMENT_UNDERPRICED,
        { error: e, method: n, transaction: r },
      ),
    a.match(/only replay-protected/i) &&
      Tt.throwError(
        "legacy pre-eip-155 transactions not supported",
        z.errors.UNSUPPORTED_OPERATION,
        { error: e, method: n, transaction: r },
      ),
    nE.indexOf(n) >= 0 &&
      a.match(
        /gas required exceeds allowance|always failing transaction|execution reverted|revert/,
      ) &&
      Tt.throwError(
        "cannot estimate gas; transaction may fail or may require manual gas limit",
        z.errors.UNPREDICTABLE_GAS_LIMIT,
        { error: e, method: n, transaction: r },
      ),
    e)
  );
}
function u1(n) {
  return new Promise(function (e) {
    setTimeout(e, n);
  });
}
function rE(n) {
  if (n.error) {
    const e = new Error(n.error.message);
    throw ((e.code = n.error.code), (e.data = n.error.data), e);
  }
  return n.result;
}
function So(n) {
  return n && n.toLowerCase();
}
const Tp = {};
class Yx extends Hi {
  constructor(e, t, r) {
    if ((super(), e !== Tp))
      throw new Error(
        "do not call the JsonRpcSigner constructor directly; use provider.getSigner",
      );
    Q(this, "provider", t),
      r == null && (r = 0),
      typeof r == "string"
        ? (Q(this, "_address", this.provider.formatter.address(r)),
          Q(this, "_index", null))
        : typeof r == "number"
        ? (Q(this, "_index", r), Q(this, "_address", null))
        : Tt.throwArgumentError(
            "invalid address or index",
            "addressOrIndex",
            r,
          );
  }
  connect(e) {
    return Tt.throwError(
      "cannot alter JSON-RPC Signer connection",
      z.errors.UNSUPPORTED_OPERATION,
      { operation: "connect" },
    );
  }
  connectUnchecked() {
    return new aE(Tp, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address
      ? Promise.resolve(this._address)
      : this.provider
          .send("eth_accounts", [])
          .then(
            (e) => (
              e.length <= this._index &&
                Tt.throwError(
                  "unknown account #" + this._index,
                  z.errors.UNSUPPORTED_OPERATION,
                  { operation: "getAddress" },
                ),
              this.provider.formatter.address(e[this._index])
            ),
          );
  }
  sendUncheckedTransaction(e) {
    e = rt(e);
    const t = this.getAddress().then((r) => (r && (r = r.toLowerCase()), r));
    if (e.gasLimit == null) {
      const r = rt(e);
      (r.from = t), (e.gasLimit = this.provider.estimateGas(r));
    }
    return (
      e.to != null &&
        (e.to = Promise.resolve(e.to).then((r) =>
          Zr(this, void 0, void 0, function* () {
            if (r == null) return null;
            const a = yield this.provider.resolveName(r);
            return (
              a == null &&
                Tt.throwArgumentError(
                  "provided ENS name resolves to null",
                  "tx.to",
                  r,
                ),
              a
            );
          }),
        )),
      bt({ tx: bt(e), sender: t }).then(({ tx: r, sender: a }) => {
        r.from != null
          ? r.from.toLowerCase() !== a &&
            Tt.throwArgumentError("from address mismatch", "transaction", e)
          : (r.from = a);
        const i = this.provider.constructor.hexlifyTransaction(r, { from: !0 });
        return this.provider.send("eth_sendTransaction", [i]).then(
          (s) => s,
          (s) => (
            typeof s.message == "string" &&
              s.message.match(/user denied/i) &&
              Tt.throwError(
                "user rejected transaction",
                z.errors.ACTION_REJECTED,
                { action: "sendTransaction", transaction: r },
              ),
            Qx("sendTransaction", s, i)
          ),
        );
      })
    );
  }
  signTransaction(e) {
    return Tt.throwError(
      "signing transactions is unsupported",
      z.errors.UNSUPPORTED_OPERATION,
      { operation: "signTransaction" },
    );
  }
  sendTransaction(e) {
    return Zr(this, void 0, void 0, function* () {
      const t = yield this.provider._getInternalBlockNumber(
          100 + 2 * this.provider.pollingInterval,
        ),
        r = yield this.sendUncheckedTransaction(e);
      try {
        return yield ms(
          () =>
            Zr(this, void 0, void 0, function* () {
              const a = yield this.provider.getTransaction(r);
              if (a !== null) return this.provider._wrapTransaction(a, r, t);
            }),
          { oncePoll: this.provider },
        );
      } catch (a) {
        throw ((a.transactionHash = r), a);
      }
    });
  }
  signMessage(e) {
    return Zr(this, void 0, void 0, function* () {
      const t = typeof e == "string" ? Ne(e) : e,
        r = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [
          pe(t),
          r.toLowerCase(),
        ]);
      } catch (a) {
        throw (
          (typeof a.message == "string" &&
            a.message.match(/user denied/i) &&
            Tt.throwError("user rejected signing", z.errors.ACTION_REJECTED, {
              action: "signMessage",
              from: r,
              messageData: e,
            }),
          a)
        );
      }
    });
  }
  _legacySignMessage(e) {
    return Zr(this, void 0, void 0, function* () {
      const t = typeof e == "string" ? Ne(e) : e,
        r = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [r.toLowerCase(), pe(t)]);
      } catch (a) {
        throw (
          (typeof a.message == "string" &&
            a.message.match(/user denied/i) &&
            Tt.throwError("user rejected signing", z.errors.ACTION_REJECTED, {
              action: "_legacySignMessage",
              from: r,
              messageData: e,
            }),
          a)
        );
      }
    });
  }
  _signTypedData(e, t, r) {
    return Zr(this, void 0, void 0, function* () {
      const a = yield Wt.resolveNames(e, t, r, (s) =>
          this.provider.resolveName(s),
        ),
        i = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          i.toLowerCase(),
          JSON.stringify(Wt.getPayload(a.domain, t, a.value)),
        ]);
      } catch (s) {
        throw (
          (typeof s.message == "string" &&
            s.message.match(/user denied/i) &&
            Tt.throwError("user rejected signing", z.errors.ACTION_REJECTED, {
              action: "_signTypedData",
              from: i,
              messageData: { domain: a.domain, types: t, value: a.value },
            }),
          s)
        );
      }
    });
  }
  unlock(e) {
    return Zr(this, void 0, void 0, function* () {
      const t = this.provider,
        r = yield this.getAddress();
      return t.send("personal_unlockAccount", [r.toLowerCase(), e, null]);
    });
  }
}
class aE extends Yx {
  sendTransaction(e) {
    return this.sendUncheckedTransaction(e).then((t) => ({
      hash: t,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (r) => this.provider.waitForTransaction(t, r),
    }));
  }
}
const iE = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0,
};
class Ya extends Uh {
  constructor(e, t) {
    let r = t;
    r == null &&
      (r = new Promise((a, i) => {
        setTimeout(() => {
          this.detectNetwork().then(
            (s) => {
              a(s);
            },
            (s) => {
              i(s);
            },
          );
        }, 0);
      })),
      super(r),
      e || (e = tn(this.constructor, "defaultUrl")()),
      typeof e == "string"
        ? Q(this, "connection", Object.freeze({ url: e }))
        : Q(this, "connection", Object.freeze(rt(e))),
      (this._nextId = 42);
  }
  get _cache() {
    return (
      this._eventLoopCache == null && (this._eventLoopCache = {}),
      this._eventLoopCache
    );
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    return (
      this._cache.detectNetwork ||
        ((this._cache.detectNetwork = this._uncachedDetectNetwork()),
        setTimeout(() => {
          this._cache.detectNetwork = null;
        }, 0)),
      this._cache.detectNetwork
    );
  }
  _uncachedDetectNetwork() {
    return Zr(this, void 0, void 0, function* () {
      yield u1(0);
      let e = null;
      try {
        e = yield this.send("eth_chainId", []);
      } catch {
        try {
          e = yield this.send("net_version", []);
        } catch {}
      }
      if (e != null) {
        const t = tn(this.constructor, "getNetwork");
        try {
          return t(O.from(e).toNumber());
        } catch (r) {
          return Tt.throwError(
            "could not detect network",
            z.errors.NETWORK_ERROR,
            { chainId: e, event: "invalidNetwork", serverError: r },
          );
        }
      }
      return Tt.throwError("could not detect network", z.errors.NETWORK_ERROR, {
        event: "noNetwork",
      });
    });
  }
  getSigner(e) {
    return new Yx(Tp, this, e);
  }
  getUncheckedSigner(e) {
    return this.getSigner(e).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((e) =>
      e.map((t) => this.formatter.address(t)),
    );
  }
  send(e, t) {
    const r = { method: e, params: t, id: this._nextId++, jsonrpc: "2.0" };
    this.emit("debug", { action: "request", request: hn(r), provider: this });
    const a = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0;
    if (a && this._cache[e]) return this._cache[e];
    const i = ro(this.connection, JSON.stringify(r), rE).then(
      (s) => (
        this.emit("debug", {
          action: "response",
          request: r,
          response: s,
          provider: this,
        }),
        s
      ),
      (s) => {
        throw (
          (this.emit("debug", {
            action: "response",
            error: s,
            request: r,
            provider: this,
          }),
          s)
        );
      },
    );
    return (
      a &&
        ((this._cache[e] = i),
        setTimeout(() => {
          this._cache[e] = null;
        }, 0)),
      i
    );
  }
  prepareRequest(e, t) {
    switch (e) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [So(t.address), t.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [So(t.address), t.blockTag]];
      case "getCode":
        return ["eth_getCode", [So(t.address), t.blockTag]];
      case "getStorageAt":
        return [
          "eth_getStorageAt",
          [So(t.address), Ue(t.position, 32), t.blockTag],
        ];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [t.signedTransaction]];
      case "getBlock":
        return t.blockTag
          ? ["eth_getBlockByNumber", [t.blockTag, !!t.includeTransactions]]
          : t.blockHash
          ? ["eth_getBlockByHash", [t.blockHash, !!t.includeTransactions]]
          : null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [t.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [t.transactionHash]];
      case "call":
        return [
          "eth_call",
          [
            tn(this.constructor, "hexlifyTransaction")(t.transaction, {
              from: !0,
            }),
            t.blockTag,
          ],
        ];
      case "estimateGas":
        return [
          "eth_estimateGas",
          [
            tn(this.constructor, "hexlifyTransaction")(t.transaction, {
              from: !0,
            }),
          ],
        ];
      case "getLogs":
        return (
          t.filter &&
            t.filter.address != null &&
            (t.filter.address = So(t.filter.address)),
          ["eth_getLogs", [t.filter]]
        );
    }
    return null;
  }
  perform(e, t) {
    return Zr(this, void 0, void 0, function* () {
      if (e === "call" || e === "estimateGas") {
        const a = t.transaction;
        if (
          a &&
          a.type != null &&
          O.from(a.type).isZero() &&
          a.maxFeePerGas == null &&
          a.maxPriorityFeePerGas == null
        ) {
          const i = yield this.getFeeData();
          i.maxFeePerGas == null &&
            i.maxPriorityFeePerGas == null &&
            ((t = rt(t)), (t.transaction = rt(a)), delete t.transaction.type);
        }
      }
      const r = this.prepareRequest(e, t);
      r == null &&
        Tt.throwError(e + " not implemented", z.errors.NOT_IMPLEMENTED, {
          operation: e,
        });
      try {
        return yield this.send(r[0], r[1]);
      } catch (a) {
        return Qx(e, a, t);
      }
    });
  }
  _startEvent(e) {
    e.tag === "pending" && this._startPending(), super._startEvent(e);
  }
  _startPending() {
    if (this._pendingFilter != null) return;
    const e = this,
      t = this.send("eth_newPendingTransactionFilter", []);
    (this._pendingFilter = t),
      t
        .then(function (r) {
          function a() {
            e.send("eth_getFilterChanges", [r])
              .then(function (i) {
                if (e._pendingFilter != t) return null;
                let s = Promise.resolve();
                return (
                  i.forEach(function (o) {
                    (e._emitted["t:" + o.toLowerCase()] = "pending"),
                      (s = s.then(function () {
                        return e.getTransaction(o).then(function (c) {
                          return e.emit("pending", c), null;
                        });
                      }));
                  }),
                  s.then(function () {
                    return u1(1e3);
                  })
                );
              })
              .then(function () {
                if (e._pendingFilter != t) {
                  e.send("eth_uninstallFilter", [r]);
                  return;
                }
                return (
                  setTimeout(function () {
                    a();
                  }, 0),
                  null
                );
              })
              .catch((i) => {});
          }
          return a(), r;
        })
        .catch((r) => {});
  }
  _stopEvent(e) {
    e.tag === "pending" &&
      this.listenerCount("pending") === 0 &&
      (this._pendingFilter = null),
      super._stopEvent(e);
  }
  static hexlifyTransaction(e, t) {
    const r = rt(iE);
    if (t) for (const i in t) t[i] && (r[i] = !0);
    P2(e, r);
    const a = {};
    return (
      [
        "chainId",
        "gasLimit",
        "gasPrice",
        "type",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "nonce",
        "value",
      ].forEach(function (i) {
        if (e[i] == null) return;
        const s = Bd(O.from(e[i]));
        i === "gasLimit" && (i = "gas"), (a[i] = s);
      }),
      ["from", "to", "data"].forEach(function (i) {
        e[i] != null && (a[i] = pe(e[i]));
      }),
      e.accessList && (a.accessList = Vi(e.accessList)),
      a
    );
  }
}
let Go = null;
try {
  if (((Go = WebSocket), Go == null)) throw new Error("inject please");
} catch {
  const e = new z(on);
  Go = function () {
    e.throwError(
      "WebSockets not supported in this environment",
      z.errors.UNSUPPORTED_OPERATION,
      { operation: "new WebSocket()" },
    );
  };
}
var Jf =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const hl = new z(on);
let sE = 1;
class jd extends Ya {
  constructor(e, t) {
    t === "any" &&
      hl.throwError(
        "WebSocketProvider does not support 'any' network yet",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "network:any" },
      ),
      typeof e == "string" ? super(e, t) : super("_websocket", t),
      (this._pollingInterval = -1),
      (this._wsReady = !1),
      typeof e == "string"
        ? Q(this, "_websocket", new Go(this.connection.url))
        : Q(this, "_websocket", e),
      Q(this, "_requests", {}),
      Q(this, "_subs", {}),
      Q(this, "_subIds", {}),
      Q(this, "_detectNetwork", super.detectNetwork()),
      (this.websocket.onopen = () => {
        (this._wsReady = !0),
          Object.keys(this._requests).forEach((a) => {
            this.websocket.send(this._requests[a].payload);
          });
      }),
      (this.websocket.onmessage = (a) => {
        const i = a.data,
          s = JSON.parse(i);
        if (s.id != null) {
          const o = String(s.id),
            c = this._requests[o];
          if ((delete this._requests[o], s.result !== void 0))
            c.callback(null, s.result),
              this.emit("debug", {
                action: "response",
                request: JSON.parse(c.payload),
                response: s.result,
                provider: this,
              });
          else {
            let l = null;
            s.error
              ? ((l = new Error(s.error.message || "unknown error")),
                Q(l, "code", s.error.code || null),
                Q(l, "response", i))
              : (l = new Error("unknown error")),
              c.callback(l, void 0),
              this.emit("debug", {
                action: "response",
                error: l,
                request: JSON.parse(c.payload),
                provider: this,
              });
          }
        } else if (s.method === "eth_subscription") {
          const o = this._subs[s.params.subscription];
          o && o.processFunc(s.params.result);
        } else console.warn("this should not happen");
      });
    const r = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    r.unref && r.unref();
  }
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(e) {
    hl.throwError(
      "cannot reset events block on WebSocketProvider",
      z.errors.UNSUPPORTED_OPERATION,
      { operation: "resetEventBlock" },
    );
  }
  set pollingInterval(e) {
    hl.throwError(
      "cannot set polling interval on WebSocketProvider",
      z.errors.UNSUPPORTED_OPERATION,
      { operation: "setPollingInterval" },
    );
  }
  poll() {
    return Jf(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(e) {
    e &&
      hl.throwError(
        "cannot set polling on WebSocketProvider",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "setPolling" },
      );
  }
  send(e, t) {
    const r = sE++;
    return new Promise((a, i) => {
      function s(c, l) {
        return c ? i(c) : a(l);
      }
      const o = JSON.stringify({ method: e, params: t, id: r, jsonrpc: "2.0" });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(o),
        provider: this,
      }),
        (this._requests[String(r)] = { callback: s, payload: o }),
        this._wsReady && this.websocket.send(o);
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(e, t, r) {
    return Jf(this, void 0, void 0, function* () {
      let a = this._subIds[e];
      a == null &&
        ((a = Promise.all(t).then((s) => this.send("eth_subscribe", s))),
        (this._subIds[e] = a));
      const i = yield a;
      this._subs[i] = { tag: e, processFunc: r };
    });
  }
  _startEvent(e) {
    switch (e.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (t) => {
          const r = O.from(t.number).toNumber();
          (this._emitted.block = r), this.emit("block", r);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (t) => {
          this.emit("pending", t);
        });
        break;
      case "filter":
        this._subscribe(e.tag, ["logs", this._getFilter(e.filter)], (t) => {
          t.removed == null && (t.removed = !1),
            this.emit(e.filter, this.formatter.filterLog(t));
        });
        break;
      case "tx": {
        const t = (r) => {
          const a = r.hash;
          this.getTransactionReceipt(a).then((i) => {
            i && this.emit(a, i);
          });
        };
        t(e),
          this._subscribe("tx", ["newHeads"], (r) => {
            this._events.filter((a) => a.type === "tx").forEach(t);
          });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", e);
        break;
    }
  }
  _stopEvent(e) {
    let t = e.tag;
    if (e.type === "tx") {
      if (this._events.filter((a) => a.type === "tx").length) return;
      t = "tx";
    } else if (this.listenerCount(e.event)) return;
    const r = this._subIds[t];
    r &&
      (delete this._subIds[t],
      r.then((a) => {
        this._subs[a] &&
          (delete this._subs[a], this.send("eth_unsubscribe", [a]));
      }));
  }
  destroy() {
    return Jf(this, void 0, void 0, function* () {
      this.websocket.readyState === Go.CONNECTING &&
        (yield new Promise((e) => {
          (this.websocket.onopen = function () {
            e(!0);
          }),
            (this.websocket.onerror = function () {
              e(!1);
            });
        })),
        this.websocket.close(1e3);
    });
  }
}
var oE =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const Fo = new z(on);
class Jx extends Ya {
  detectNetwork() {
    const e = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork },
    });
    return oE(this, void 0, void 0, function* () {
      let t = this.network;
      return (
        t == null &&
          ((t = yield e.detectNetwork.call(this)),
          t || Fo.throwError("no network detected", z.errors.UNKNOWN_ERROR, {}),
          this._network == null &&
            (Q(this, "_network", t), this.emit("network", t, null))),
        t
      );
    });
  }
}
class si extends Jx {
  constructor(e, t) {
    Fo.checkAbstract(new.target, si),
      (e = tn(new.target, "getNetwork")(e)),
      (t = tn(new.target, "getApiKey")(t));
    const r = tn(new.target, "getUrl")(e, t);
    super(r, e),
      typeof t == "string"
        ? Q(this, "apiKey", t)
        : t != null &&
          Object.keys(t).forEach((a) => {
            Q(this, a, t[a]);
          });
  }
  _startPending() {
    Fo.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return !1;
  }
  getSigner(e) {
    return Fo.throwError(
      "API provider does not support signing",
      z.errors.UNSUPPORTED_OPERATION,
      { operation: "getSigner" },
    );
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  static getApiKey(e) {
    return e;
  }
  static getUrl(e, t) {
    return Fo.throwError(
      "not implemented; sub-classes must override getUrl",
      z.errors.NOT_IMPLEMENTED,
      { operation: "getUrl" },
    );
  }
}
const d1 = new z(on),
  ql = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class cE extends jd {
  constructor(e, t) {
    const r = new Xx(e, t),
      a = r.connection.url
        .replace(/^http/i, "ws")
        .replace(".alchemyapi.", ".ws.alchemyapi.");
    super(a, r.network), Q(this, "apiKey", r.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === ql;
  }
}
class Xx extends si {
  static getWebSocketProvider(e, t) {
    return new cE(e, t);
  }
  static getApiKey(e) {
    return e == null
      ? ql
      : (e &&
          typeof e != "string" &&
          d1.throwArgumentError("invalid apiKey", "apiKey", e),
        e);
  }
  static getUrl(e, t) {
    let r = null;
    switch (e.name) {
      case "homestead":
        r = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "goerli":
        r = "eth-goerli.g.alchemy.com/v2/";
        break;
      case "matic":
        r = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        r = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        r = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-goerli":
        r = "arb-goerli.g.alchemy.com/v2/";
        break;
      case "optimism":
        r = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-goerli":
        r = "opt-goerli.g.alchemy.com/v2/";
        break;
      default:
        d1.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: !0,
      url: "https://" + r + t,
      throttleCallback: (a, i) => (t === ql && Ud(), Promise.resolve(!0)),
    };
  }
  isCommunityResource() {
    return this.apiKey === ql;
  }
}
const lE = new z(on),
  ml = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function uE(n) {
  switch (n) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return lE.throwArgumentError("unsupported network", "name", n);
}
class dE extends si {
  isCommunityResource() {
    return this.apiKey === ml;
  }
  static getApiKey(e) {
    return e ?? ml;
  }
  static getUrl(e, t) {
    t == null && (t = ml);
    const r = {
      allowGzip: !0,
      url: "https://" + uE(e.name) + t,
      throttleCallback: (a, i) => (
        t.apiKey === ml && Ud(), Promise.resolve(!0)
      ),
    };
    return (
      t.projectSecret != null &&
        ((r.user = ""), (r.password = t.projectSecret)),
      r
    );
  }
}
var fE =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const f1 = new z(on);
class pE extends si {
  static getApiKey(e) {
    return (
      e != null &&
        f1.throwArgumentError(
          "apiKey not supported for cloudflare",
          "apiKey",
          e,
        ),
      null
    );
  }
  static getUrl(e, t) {
    let r = null;
    switch (e.name) {
      case "homestead":
        r = "https://cloudflare-eth.com/";
        break;
      default:
        f1.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return r;
  }
  perform(e, t) {
    const r = Object.create(null, { perform: { get: () => super.perform } });
    return fE(this, void 0, void 0, function* () {
      return e === "getBlockNumber"
        ? (yield r.perform.call(this, "getBlock", { blockTag: "latest" }))
            .number
        : r.perform.call(this, e, t);
    });
  }
}
var yl =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const Ra = new z(on);
function p1(n) {
  const e = {};
  for (let t in n) {
    if (n[t] == null) continue;
    let r = n[t];
    (t === "type" && r === 0) ||
      ({
        type: !0,
        gasLimit: !0,
        gasPrice: !0,
        maxFeePerGs: !0,
        maxPriorityFeePerGas: !0,
        nonce: !0,
        value: !0,
      }[t]
        ? (r = Bd(pe(r)))
        : t === "accessList"
        ? (r =
            "[" +
            Vi(r)
              .map(
                (a) =>
                  `{address:"${a.address}",storageKeys:["${a.storageKeys.join(
                    '","',
                  )}"]}`,
              )
              .join(",") +
            "]")
        : (r = pe(r)),
      (e[t] = r));
  }
  return e;
}
function hE(n) {
  if (
    n.status == 0 &&
    (n.message === "No records found" || n.message === "No transactions found")
  )
    return n.result;
  if (
    n.status != 1 ||
    typeof n.message != "string" ||
    !n.message.match(/^OK/)
  ) {
    const e = new Error("invalid response");
    throw (
      ((e.result = JSON.stringify(n)),
      (n.result || "").toLowerCase().indexOf("rate limit") >= 0 &&
        (e.throttleRetry = !0),
      e)
    );
  }
  return n.result;
}
function h1(n) {
  if (
    n &&
    n.status == 0 &&
    n.message == "NOTOK" &&
    (n.result || "").toLowerCase().indexOf("rate limit") >= 0
  ) {
    const e = new Error("throttled response");
    throw ((e.result = JSON.stringify(n)), (e.throttleRetry = !0), e);
  }
  if (n.jsonrpc != "2.0") {
    const e = new Error("invalid response");
    throw ((e.result = JSON.stringify(n)), e);
  }
  if (n.error) {
    const e = new Error(n.error.message || "unknown error");
    throw (
      (n.error.code && (e.code = n.error.code),
      n.error.data && (e.data = n.error.data),
      e)
    );
  }
  return n.result;
}
function m1(n) {
  if (n === "pending") throw new Error("pending not supported");
  return n === "latest" ? n : parseInt(n.substring(2), 16);
}
function Xf(n, e, t) {
  if (n === "call" && e.code === z.errors.SERVER_ERROR) {
    const a = e.error;
    if (
      a &&
      (a.message.match(/reverted/i) || a.message.match(/VM execution error/i))
    ) {
      let i = a.data;
      if ((i && (i = "0x" + i.replace(/^.*0x/i, "")), Ve(i))) return i;
      Ra.throwError(
        "missing revert data in call exception",
        z.errors.CALL_EXCEPTION,
        { error: e, data: "0x" },
      );
    }
  }
  let r = e.message;
  throw (
    (e.code === z.errors.SERVER_ERROR &&
      (e.error && typeof e.error.message == "string"
        ? (r = e.error.message)
        : typeof e.body == "string"
        ? (r = e.body)
        : typeof e.responseText == "string" && (r = e.responseText)),
    (r = (r || "").toLowerCase()),
    r.match(/insufficient funds/) &&
      Ra.throwError(
        "insufficient funds for intrinsic transaction cost",
        z.errors.INSUFFICIENT_FUNDS,
        { error: e, method: n, transaction: t },
      ),
    r.match(
      /same hash was already imported|transaction nonce is too low|nonce too low/,
    ) &&
      Ra.throwError("nonce has already been used", z.errors.NONCE_EXPIRED, {
        error: e,
        method: n,
        transaction: t,
      }),
    r.match(/another transaction with same nonce/) &&
      Ra.throwError(
        "replacement fee too low",
        z.errors.REPLACEMENT_UNDERPRICED,
        { error: e, method: n, transaction: t },
      ),
    r.match(/execution failed due to an exception|execution reverted/) &&
      Ra.throwError(
        "cannot estimate gas; transaction may fail or may require manual gas limit",
        z.errors.UNPREDICTABLE_GAS_LIMIT,
        { error: e, method: n, transaction: t },
      ),
    e)
  );
}
class mE extends Uh {
  constructor(e, t) {
    super(e),
      Q(this, "baseUrl", this.getBaseUrl()),
      Q(this, "apiKey", t || null);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "matic":
        return "https://api.polygonscan.com";
      case "maticmum":
        return "https://api-testnet.polygonscan.com";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
    }
    return Ra.throwArgumentError(
      "unsupported network",
      "network",
      this.network.name,
    );
  }
  getUrl(e, t) {
    const r = Object.keys(t).reduce((i, s) => {
        const o = t[s];
        return o != null && (i += `&${s}=${o}`), i;
      }, ""),
      a = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${e}${r}${a}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(e, t) {
    return (t.module = e), (t.apikey = this.apiKey), t;
  }
  fetch(e, t, r) {
    return yl(this, void 0, void 0, function* () {
      const a = r ? this.getPostUrl() : this.getUrl(e, t),
        i = r ? this.getPostData(e, t) : null,
        s = e === "proxy" ? h1 : hE;
      this.emit("debug", { action: "request", request: a, provider: this });
      const o = {
        url: a,
        throttleSlotInterval: 1e3,
        throttleCallback: (u, d) => (
          this.isCommunityResource() && Ud(), Promise.resolve(!0)
        ),
      };
      let c = null;
      i &&
        ((o.headers = {
          "content-type": "application/x-www-form-urlencoded; charset=UTF-8",
        }),
        (c = Object.keys(i)
          .map((u) => `${u}=${i[u]}`)
          .join("&")));
      const l = yield ro(o, c, s || h1);
      return (
        this.emit("debug", {
          action: "response",
          request: a,
          response: hn(l),
          provider: this,
        }),
        l
      );
    });
  }
  detectNetwork() {
    return yl(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(e, t) {
    const r = Object.create(null, { perform: { get: () => super.perform } });
    return yl(this, void 0, void 0, function* () {
      switch (e) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: t.address,
            tag: t.blockTag,
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: t.address,
            tag: t.blockTag,
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: t.address,
            tag: t.blockTag,
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: t.address,
            position: t.position,
            tag: t.blockTag,
          });
        case "sendTransaction":
          return this.fetch(
            "proxy",
            { action: "eth_sendRawTransaction", hex: t.signedTransaction },
            !0,
          ).catch((a) => Xf("sendTransaction", a, t.signedTransaction));
        case "getBlock":
          if (t.blockTag)
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: t.blockTag,
              boolean: t.includeTransactions ? "true" : "false",
            });
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: t.transactionHash,
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: t.transactionHash,
          });
        case "call": {
          if (t.blockTag !== "latest")
            throw new Error(
              "EtherscanProvider does not support blockTag for call",
            );
          const a = p1(t.transaction);
          (a.module = "proxy"), (a.action = "eth_call");
          try {
            return yield this.fetch("proxy", a, !0);
          } catch (i) {
            return Xf("call", i, t.transaction);
          }
        }
        case "estimateGas": {
          const a = p1(t.transaction);
          (a.module = "proxy"), (a.action = "eth_estimateGas");
          try {
            return yield this.fetch("proxy", a, !0);
          } catch (i) {
            return Xf("estimateGas", i, t.transaction);
          }
        }
        case "getLogs": {
          const a = { action: "getLogs" };
          if (
            (t.filter.fromBlock && (a.fromBlock = m1(t.filter.fromBlock)),
            t.filter.toBlock && (a.toBlock = m1(t.filter.toBlock)),
            t.filter.address && (a.address = t.filter.address),
            t.filter.topics &&
              t.filter.topics.length > 0 &&
              (t.filter.topics.length > 1 &&
                Ra.throwError(
                  "unsupported topic count",
                  z.errors.UNSUPPORTED_OPERATION,
                  { topics: t.filter.topics },
                ),
              t.filter.topics.length === 1))
          ) {
            const o = t.filter.topics[0];
            (typeof o != "string" || o.length !== 66) &&
              Ra.throwError(
                "unsupported topic format",
                z.errors.UNSUPPORTED_OPERATION,
                { topic0: o },
              ),
              (a.topic0 = o);
          }
          const i = yield this.fetch("logs", a);
          let s = {};
          for (let o = 0; o < i.length; o++) {
            const c = i[o];
            if (c.blockHash == null) {
              if (s[c.blockNumber] == null) {
                const l = yield this.getBlock(c.blockNumber);
                l && (s[c.blockNumber] = l.hash);
              }
              c.blockHash = s[c.blockNumber];
            }
          }
          return i;
        }
        case "getEtherPrice":
          return this.network.name !== "homestead"
            ? 0
            : parseFloat(
                (yield this.fetch("stats", { action: "ethprice" })).ethusd,
              );
      }
      return r.perform.call(this, e, t);
    });
  }
  getHistory(e, t, r) {
    return yl(this, void 0, void 0, function* () {
      const a = {
        action: "txlist",
        address: yield this.resolveName(e),
        startblock: t ?? 0,
        endblock: r ?? 99999999,
        sort: "asc",
      };
      return (yield this.fetch("account", a)).map((s) => {
        ["contractAddress", "to"].forEach(function (c) {
          s[c] == "" && delete s[c];
        }),
          s.creates == null &&
            s.contractAddress != null &&
            (s.creates = s.contractAddress);
        const o = this.formatter.transactionResponse(s);
        return s.timeStamp && (o.timestamp = parseInt(s.timeStamp)), o;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
}
var yu =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function a(i) {
      return i instanceof t
        ? i
        : new t(function (s) {
            s(i);
          });
    }
    return new (t || (t = Promise))(function (i, s) {
      function o(u) {
        try {
          l(r.next(u));
        } catch (d) {
          s(d);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (d) {
          s(d);
        }
      }
      function l(u) {
        u.done ? i(u.value) : a(u.value).then(o, c);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const xi = new z(on);
function gl() {
  return new Date().getTime();
}
function y1(n) {
  let e = null;
  for (let t = 0; t < n.length; t++) {
    const r = n[t];
    if (r == null) return null;
    e
      ? (e.name === r.name &&
          e.chainId === r.chainId &&
          (e.ensAddress === r.ensAddress ||
            (e.ensAddress == null && r.ensAddress == null))) ||
        xi.throwArgumentError("provider mismatch", "networks", n)
      : (e = r);
  }
  return e;
}
function g1(n, e) {
  n = n.slice().sort();
  const t = Math.floor(n.length / 2);
  if (n.length % 2) return n[t];
  const r = n[t - 1],
    a = n[t];
  return e != null && Math.abs(r - a) > e ? null : (r + a) / 2;
}
function ys(n) {
  if (n === null) return "null";
  if (typeof n == "number" || typeof n == "boolean") return JSON.stringify(n);
  if (typeof n == "string") return n;
  if (O.isBigNumber(n)) return n.toString();
  if (Array.isArray(n)) return JSON.stringify(n.map((e) => ys(e)));
  if (typeof n == "object") {
    const e = Object.keys(n);
    return (
      e.sort(),
      "{" +
        e
          .map((t) => {
            let r = n[t];
            return (
              typeof r == "function" ? (r = "[function]") : (r = ys(r)),
              JSON.stringify(t) + ":" + r
            );
          })
          .join(",") +
        "}"
    );
  }
  throw new Error("unknown value type: " + typeof n);
}
let yE = 1;
function b1(n) {
  let e = null,
    t = null,
    r = new Promise((s) => {
      (e = function () {
        t && (clearTimeout(t), (t = null)), s();
      }),
        (t = setTimeout(e, n));
    });
  const a = (s) => ((r = r.then(s)), r);
  function i() {
    return r;
  }
  return { cancel: e, getPromise: i, wait: a };
}
const gE = [
    z.errors.CALL_EXCEPTION,
    z.errors.INSUFFICIENT_FUNDS,
    z.errors.NONCE_EXPIRED,
    z.errors.REPLACEMENT_UNDERPRICED,
    z.errors.UNPREDICTABLE_GAS_LIMIT,
  ],
  bE = [
    "address",
    "args",
    "errorArgs",
    "errorSignature",
    "method",
    "transaction",
  ];
function bl(n, e) {
  const t = { weight: n.weight };
  return (
    Object.defineProperty(t, "provider", { get: () => n.provider }),
    n.start && (t.start = n.start),
    e && (t.duration = e - n.start),
    n.done && (n.error ? (t.error = n.error) : (t.result = n.result || null)),
    t
  );
}
function xE(n, e) {
  return function (t) {
    const r = {};
    t.forEach((i) => {
      const s = n(i.result);
      r[s] || (r[s] = { count: 0, result: i.result }), r[s].count++;
    });
    const a = Object.keys(r);
    for (let i = 0; i < a.length; i++) {
      const s = r[a[i]];
      if (s.count >= e) return s.result;
    }
  };
}
function vE(n, e, t) {
  let r = ys;
  switch (e) {
    case "getBlockNumber":
      return function (a) {
        const i = a.map((o) => o.result);
        let s = g1(
          a.map((o) => o.result),
          2,
        );
        if (s != null)
          return (
            (s = Math.ceil(s)),
            i.indexOf(s + 1) >= 0 && s++,
            s >= n._highestBlockNumber && (n._highestBlockNumber = s),
            n._highestBlockNumber
          );
      };
    case "getGasPrice":
      return function (a) {
        const i = a.map((s) => s.result);
        return i.sort(), i[Math.floor(i.length / 2)];
      };
    case "getEtherPrice":
      return function (a) {
        return g1(a.map((i) => i.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      r = function (a) {
        return a == null ? null : ((a = rt(a)), (a.confirmations = -1), ys(a));
      };
      break;
    case "getBlock":
      t.includeTransactions
        ? (r = function (a) {
            return a == null
              ? null
              : ((a = rt(a)),
                (a.transactions = a.transactions.map(
                  (i) => ((i = rt(i)), (i.confirmations = -1), i),
                )),
                ys(a));
          })
        : (r = function (a) {
            return a == null ? null : ys(a);
          });
      break;
    default:
      throw new Error("unknown method: " + e);
  }
  return xE(r, n.quorum);
}
function Po(n, e) {
  return yu(this, void 0, void 0, function* () {
    const t = n.provider;
    return (t.blockNumber != null && t.blockNumber >= e) || e === -1
      ? t
      : ms(
          () =>
            new Promise((r, a) => {
              setTimeout(function () {
                return t.blockNumber >= e
                  ? r(t)
                  : n.cancelled
                  ? r(null)
                  : r(void 0);
              }, 0);
            }),
          { oncePoll: t },
        );
  });
}
function wE(n, e, t, r) {
  return yu(this, void 0, void 0, function* () {
    let a = n.provider;
    switch (t) {
      case "getBlockNumber":
      case "getGasPrice":
        return a[t]();
      case "getEtherPrice":
        if (a.getEtherPrice) return a.getEtherPrice();
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        return (
          r.blockTag && Ve(r.blockTag) && (a = yield Po(n, e)),
          a[t](r.address, r.blockTag || "latest")
        );
      case "getStorageAt":
        return (
          r.blockTag && Ve(r.blockTag) && (a = yield Po(n, e)),
          a.getStorageAt(r.address, r.position, r.blockTag || "latest")
        );
      case "getBlock":
        return (
          r.blockTag && Ve(r.blockTag) && (a = yield Po(n, e)),
          a[r.includeTransactions ? "getBlockWithTransactions" : "getBlock"](
            r.blockTag || r.blockHash,
          )
        );
      case "call":
      case "estimateGas":
        return (
          r.blockTag && Ve(r.blockTag) && (a = yield Po(n, e)),
          t === "call" && r.blockTag
            ? a[t](r.transaction, r.blockTag)
            : a[t](r.transaction)
        );
      case "getTransaction":
      case "getTransactionReceipt":
        return a[t](r.transactionHash);
      case "getLogs": {
        let i = r.filter;
        return (
          ((i.fromBlock && Ve(i.fromBlock)) || (i.toBlock && Ve(i.toBlock))) &&
            (a = yield Po(n, e)),
          a.getLogs(i)
        );
      }
    }
    return xi.throwError("unknown method error", z.errors.UNKNOWN_ERROR, {
      method: t,
      params: r,
    });
  });
}
class TE extends Uh {
  constructor(e, t) {
    e.length === 0 &&
      xi.throwArgumentError("missing providers", "providers", e);
    const r = e.map((s, o) => {
        if (Xs.isProvider(s)) {
          const u = t1(s) ? 2e3 : 750;
          return Object.freeze({
            provider: s,
            weight: 1,
            stallTimeout: u,
            priority: 1,
          });
        }
        const c = rt(s);
        c.priority == null && (c.priority = 1),
          c.stallTimeout == null && (c.stallTimeout = t1(s) ? 2e3 : 750),
          c.weight == null && (c.weight = 1);
        const l = c.weight;
        return (
          (l % 1 || l > 512 || l < 1) &&
            xi.throwArgumentError(
              "invalid weight; must be integer in [1, 512]",
              `providers[${o}].weight`,
              l,
            ),
          Object.freeze(c)
        );
      }),
      a = r.reduce((s, o) => s + o.weight, 0);
    t == null
      ? (t = a / 2)
      : t > a &&
        xi.throwArgumentError(
          "quorum will always fail; larger than total weight",
          "quorum",
          t,
        );
    let i = y1(r.map((s) => s.provider.network));
    i == null &&
      (i = new Promise((s, o) => {
        setTimeout(() => {
          this.detectNetwork().then(s, o);
        }, 0);
      })),
      super(i),
      Q(this, "providerConfigs", Object.freeze(r)),
      Q(this, "quorum", t),
      (this._highestBlockNumber = -1);
  }
  detectNetwork() {
    return yu(this, void 0, void 0, function* () {
      const e = yield Promise.all(
        this.providerConfigs.map((t) => t.provider.getNetwork()),
      );
      return y1(e);
    });
  }
  perform(e, t) {
    return yu(this, void 0, void 0, function* () {
      if (e === "sendTransaction") {
        const c = yield Promise.all(
          this.providerConfigs.map((l) =>
            l.provider.sendTransaction(t.signedTransaction).then(
              (u) => u.hash,
              (u) => u,
            ),
          ),
        );
        for (let l = 0; l < c.length; l++) {
          const u = c[l];
          if (typeof u == "string") return u;
        }
        throw c[0];
      }
      this._highestBlockNumber === -1 &&
        e !== "getBlockNumber" &&
        (yield this.getBlockNumber());
      const r = vE(this, e, t),
        a = hA(this.providerConfigs.map(rt));
      a.sort((c, l) => c.priority - l.priority);
      const i = this._highestBlockNumber;
      let s = 0,
        o = !0;
      for (;;) {
        const c = gl();
        let l = a
          .filter((p) => p.runner && c - p.start < p.stallTimeout)
          .reduce((p, m) => p + m.weight, 0);
        for (; l < this.quorum && s < a.length; ) {
          const p = a[s++],
            m = yE++;
          (p.start = gl()),
            (p.staller = b1(p.stallTimeout)),
            p.staller.wait(() => {
              p.staller = null;
            }),
            (p.runner = wE(p, i, e, t).then(
              (y) => {
                (p.done = !0),
                  (p.result = y),
                  this.listenerCount("debug") &&
                    this.emit("debug", {
                      action: "request",
                      rid: m,
                      backend: bl(p, gl()),
                      request: { method: e, params: hn(t) },
                      provider: this,
                    });
              },
              (y) => {
                (p.done = !0),
                  (p.error = y),
                  this.listenerCount("debug") &&
                    this.emit("debug", {
                      action: "request",
                      rid: m,
                      backend: bl(p, gl()),
                      request: { method: e, params: hn(t) },
                      provider: this,
                    });
              },
            )),
            this.listenerCount("debug") &&
              this.emit("debug", {
                action: "request",
                rid: m,
                backend: bl(p, null),
                request: { method: e, params: hn(t) },
                provider: this,
              }),
            (l += p.weight);
        }
        const u = [];
        a.forEach((p) => {
          p.done ||
            !p.runner ||
            (u.push(p.runner), p.staller && u.push(p.staller.getPromise()));
        }),
          u.length && (yield Promise.race(u));
        const d = a.filter((p) => p.done && p.error == null);
        if (d.length >= this.quorum) {
          const p = r(d);
          if (p !== void 0)
            return (
              a.forEach((m) => {
                m.staller && m.staller.cancel(), (m.cancelled = !0);
              }),
              p
            );
          o || (yield b1(100).getPromise()), (o = !1);
        }
        const f = a.reduce((p, m) => {
          if (!m.done || m.error == null) return p;
          const y = m.error.code;
          return (
            gE.indexOf(y) >= 0 &&
              (p[y] || (p[y] = { error: m.error, weight: 0 }),
              (p[y].weight += m.weight)),
            p
          );
        }, {});
        if (
          (Object.keys(f).forEach((p) => {
            const m = f[p];
            if (m.weight < this.quorum) return;
            a.forEach((g) => {
              g.staller && g.staller.cancel(), (g.cancelled = !0);
            });
            const y = m.error,
              h = {};
            bE.forEach((g) => {
              y[g] != null && (h[g] = y[g]);
            }),
              xi.throwError(y.reason || y.message, p, h);
          }),
          a.filter((p) => !p.done).length === 0)
        )
          break;
      }
      return (
        a.forEach((c) => {
          c.staller && c.staller.cancel(), (c.cancelled = !0);
        }),
        xi.throwError("failed to meet quorum", z.errors.SERVER_ERROR, {
          method: e,
          params: t,
          results: a.map((c) => bl(c)),
          provider: this,
        })
      );
    });
  }
}
const CE = null,
  Vl = new z(on),
  Lo = "84842078b09946638c03157f83405213";
class AE extends jd {
  constructor(e, t) {
    const r = new Zx(e, t),
      a = r.connection;
    a.password &&
      Vl.throwError(
        "INFURA WebSocket project secrets unsupported",
        z.errors.UNSUPPORTED_OPERATION,
        { operation: "InfuraProvider.getWebSocketProvider()" },
      );
    const i = a.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(i, e),
      Q(this, "apiKey", r.projectId),
      Q(this, "projectId", r.projectId),
      Q(this, "projectSecret", r.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === Lo;
  }
}
class Zx extends si {
  static getWebSocketProvider(e, t) {
    return new AE(e, t);
  }
  static getApiKey(e) {
    const t = { apiKey: Lo, projectId: Lo, projectSecret: null };
    return (
      e == null ||
        (typeof e == "string"
          ? (t.projectId = e)
          : e.projectSecret != null
          ? (Vl.assertArgument(
              typeof e.projectId == "string",
              "projectSecret requires a projectId",
              "projectId",
              e.projectId,
            ),
            Vl.assertArgument(
              typeof e.projectSecret == "string",
              "invalid projectSecret",
              "projectSecret",
              "[REDACTED]",
            ),
            (t.projectId = e.projectId),
            (t.projectSecret = e.projectSecret))
          : e.projectId && (t.projectId = e.projectId),
        (t.apiKey = t.projectId)),
      t
    );
  }
  static getUrl(e, t) {
    let r = null;
    switch (e ? e.name : "unknown") {
      case "homestead":
        r = "mainnet.infura.io";
        break;
      case "goerli":
        r = "goerli.infura.io";
        break;
      case "sepolia":
        r = "sepolia.infura.io";
        break;
      case "matic":
        r = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        r = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        r = "optimism-mainnet.infura.io";
        break;
      case "optimism-goerli":
        r = "optimism-goerli.infura.io";
        break;
      case "arbitrum":
        r = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-goerli":
        r = "arbitrum-goerli.infura.io";
        break;
      default:
        Vl.throwError("unsupported network", z.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: e,
        });
    }
    const a = {
      allowGzip: !0,
      url: "https://" + r + "/v3/" + t.projectId,
      throttleCallback: (i, s) => (
        t.projectId === Lo && Ud(), Promise.resolve(!0)
      ),
    };
    return (
      t.projectSecret != null &&
        ((a.user = ""), (a.password = t.projectSecret)),
      a
    );
  }
  isCommunityResource() {
    return this.projectId === Lo;
  }
}
class EE extends Ya {
  send(e, t) {
    const r = { method: e, params: t, id: this._nextId++, jsonrpc: "2.0" };
    this._pendingBatch == null && (this._pendingBatch = []);
    const a = { request: r, resolve: null, reject: null },
      i = new Promise((s, o) => {
        (a.resolve = s), (a.reject = o);
      });
    return (
      this._pendingBatch.push(a),
      this._pendingBatchAggregator ||
        (this._pendingBatchAggregator = setTimeout(() => {
          const s = this._pendingBatch;
          (this._pendingBatch = null), (this._pendingBatchAggregator = null);
          const o = s.map((c) => c.request);
          return (
            this.emit("debug", {
              action: "requestBatch",
              request: hn(o),
              provider: this,
            }),
            ro(this.connection, JSON.stringify(o)).then(
              (c) => {
                this.emit("debug", {
                  action: "response",
                  request: o,
                  response: c,
                  provider: this,
                }),
                  s.forEach((l, u) => {
                    const d = c[u];
                    if (d.error) {
                      const f = new Error(d.error.message);
                      (f.code = d.error.code),
                        (f.data = d.error.data),
                        l.reject(f);
                    } else l.resolve(d.result);
                  });
              },
              (c) => {
                this.emit("debug", {
                  action: "response",
                  error: c,
                  request: o,
                  provider: this,
                }),
                  s.forEach((l) => {
                    l.reject(c);
                  });
              },
            )
          );
        }, 10)),
      i
    );
  }
}
const Zf = new z(on),
  kE = "ETHERS_JS_SHARED";
class _E extends si {
  static getApiKey(e) {
    return (
      e &&
        typeof e != "string" &&
        Zf.throwArgumentError("invalid apiKey", "apiKey", e),
      e || kE
    );
  }
  static getUrl(e, t) {
    Zf.warn(
      "NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.",
    );
    let r = null;
    switch (e.name) {
      case "homestead":
        r = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        r = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        r = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        r = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        r = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        Zf.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return r + "?apiKey=" + t;
  }
}
const x1 = new z(on),
  v1 = "62e1ad51b37b8e00394bda3b";
class SE extends si {
  static getApiKey(e) {
    const t = {
      applicationId: null,
      loadBalancer: !0,
      applicationSecretKey: null,
    };
    return (
      e == null
        ? (t.applicationId = v1)
        : typeof e == "string"
        ? (t.applicationId = e)
        : e.applicationSecretKey != null
        ? ((t.applicationId = e.applicationId),
          (t.applicationSecretKey = e.applicationSecretKey))
        : e.applicationId
        ? (t.applicationId = e.applicationId)
        : x1.throwArgumentError(
            "unsupported PocketProvider apiKey",
            "apiKey",
            e,
          ),
      t
    );
  }
  static getUrl(e, t) {
    let r = null;
    switch (e ? e.name : "unknown") {
      case "goerli":
        r = "eth-goerli.gateway.pokt.network";
        break;
      case "homestead":
        r = "eth-mainnet.gateway.pokt.network";
        break;
      case "kovan":
        r = "poa-kovan.gateway.pokt.network";
        break;
      case "matic":
        r = "poly-mainnet.gateway.pokt.network";
        break;
      case "maticmum":
        r = "polygon-mumbai-rpc.gateway.pokt.network";
        break;
      case "rinkeby":
        r = "eth-rinkeby.gateway.pokt.network";
        break;
      case "ropsten":
        r = "eth-ropsten.gateway.pokt.network";
        break;
      default:
        x1.throwError("unsupported network", z.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: e,
        });
    }
    const a = `https://${r}/v1/lb/${t.applicationId}`,
      i = { headers: {}, url: a };
    return (
      t.applicationSecretKey != null &&
        ((i.user = ""), (i.password = t.applicationSecretKey)),
      i
    );
  }
  isCommunityResource() {
    return this.applicationId === v1;
  }
}
const w1 = new z(on);
let PE = 1;
function T1(n, e) {
  const t = "Web3LegacyFetcher";
  return function (r, a) {
    const i = { method: r, params: a, id: PE++, jsonrpc: "2.0" };
    return new Promise((s, o) => {
      this.emit("debug", {
        action: "request",
        fetcher: t,
        request: hn(i),
        provider: this,
      }),
        e(i, (c, l) => {
          if (c)
            return (
              this.emit("debug", {
                action: "response",
                fetcher: t,
                error: c,
                request: i,
                provider: this,
              }),
              o(c)
            );
          if (
            (this.emit("debug", {
              action: "response",
              fetcher: t,
              request: i,
              response: l,
              provider: this,
            }),
            l.error)
          ) {
            const u = new Error(l.error.message);
            return (u.code = l.error.code), (u.data = l.error.data), o(u);
          }
          s(l.result);
        });
    });
  };
}
function IE(n) {
  return function (e, t) {
    t == null && (t = []);
    const r = { method: e, params: t };
    return (
      this.emit("debug", {
        action: "request",
        fetcher: "Eip1193Fetcher",
        request: hn(r),
        provider: this,
      }),
      n.request(r).then(
        (a) => (
          this.emit("debug", {
            action: "response",
            fetcher: "Eip1193Fetcher",
            request: r,
            response: a,
            provider: this,
          }),
          a
        ),
        (a) => {
          throw (
            (this.emit("debug", {
              action: "response",
              fetcher: "Eip1193Fetcher",
              request: r,
              error: a,
              provider: this,
            }),
            a)
          );
        },
      )
    );
  };
}
class jh extends Ya {
  constructor(e, t) {
    e == null && w1.throwArgumentError("missing provider", "provider", e);
    let r = null,
      a = null,
      i = null;
    typeof e == "function"
      ? ((r = "unknown:"), (a = e))
      : ((r = e.host || e.path || ""),
        !r && e.isMetaMask && (r = "metamask"),
        (i = e),
        e.request
          ? (r === "" && (r = "eip-1193:"), (a = IE(e)))
          : e.sendAsync
          ? (a = T1(e, e.sendAsync.bind(e)))
          : e.send
          ? (a = T1(e, e.send.bind(e)))
          : w1.throwArgumentError("unsupported provider", "provider", e),
        r || (r = "unknown:")),
      super(r, t),
      Q(this, "jsonRpcFetchFunc", a),
      Q(this, "provider", i);
  }
  send(e, t) {
    return this.jsonRpcFetchFunc(e, t);
  }
}
const C1 = new z(on);
function RE(n, e) {
  if ((n == null && (n = "homestead"), typeof n == "string")) {
    const r = n.match(/^(ws|http)s?:/i);
    if (r)
      switch (r[1].toLowerCase()) {
        case "http":
        case "https":
          return new Ya(n);
        case "ws":
        case "wss":
          return new jd(n);
        default:
          C1.throwArgumentError("unsupported URL scheme", "network", n);
      }
  }
  const t = Hx(n);
  return (
    (!t || !t._defaultProvider) &&
      C1.throwError(
        "unsupported getDefaultProvider network",
        z.errors.NETWORK_ERROR,
        { operation: "getDefaultProvider", network: n },
      ),
    t._defaultProvider(
      {
        FallbackProvider: TE,
        AlchemyProvider: Xx,
        AnkrProvider: dE,
        CloudflareProvider: pE,
        EtherscanProvider: mE,
        InfuraProvider: Zx,
        JsonRpcProvider: Ya,
        NodesmithProvider: _E,
        PocketProvider: SE,
        Web3Provider: jh,
        IpcProvider: CE,
      },
      e,
    )
  );
}
const ME = "solidity/5.7.0",
  BE = new RegExp("^bytes([0-9]+)$"),
  DE = new RegExp("^(u?int)([0-9]*)$"),
  OE = new RegExp("^(.*)\\[([0-9]*)\\]$"),
  NE = "0000000000000000000000000000000000000000000000000000000000000000",
  fs = new z(ME);
function e5(n, e, t) {
  switch (n) {
    case "address":
      return t ? Ff(e, 32) : ae(e);
    case "string":
      return Ne(e);
    case "bytes":
      return ae(e);
    case "bool":
      return (e = e ? "0x01" : "0x00"), t ? Ff(e, 32) : ae(e);
  }
  let r = n.match(DE);
  if (r) {
    let a = parseInt(r[2] || "256");
    return (
      ((r[2] && String(a) !== r[2]) || a % 8 !== 0 || a === 0 || a > 256) &&
        fs.throwArgumentError("invalid number type", "type", n),
      t && (a = 256),
      (e = O.from(e).toTwos(a)),
      Ff(e, a / 8)
    );
  }
  if (((r = n.match(BE)), r)) {
    const a = parseInt(r[1]);
    return (
      (String(a) !== r[1] || a === 0 || a > 32) &&
        fs.throwArgumentError("invalid bytes type", "type", n),
      ae(e).byteLength !== a &&
        fs.throwArgumentError(`invalid value for ${n}`, "value", e),
      t ? ae((e + NE).substring(0, 66)) : e
    );
  }
  if (((r = n.match(OE)), r && Array.isArray(e))) {
    const a = r[1];
    parseInt(r[2] || String(e.length)) != e.length &&
      fs.throwArgumentError(`invalid array length for ${n}`, "value", e);
    const s = [];
    return (
      e.forEach(function (o) {
        s.push(e5(a, o, !0));
      }),
      nt(s)
    );
  }
  return fs.throwArgumentError("invalid type", "type", n);
}
function Ns(n, e) {
  n.length != e.length &&
    fs.throwArgumentError(
      "wrong number of values; expected ${ types.length }",
      "values",
      e,
    );
  const t = [];
  return (
    n.forEach(function (r, a) {
      t.push(e5(r, e[a]));
    }),
    pe(nt(t))
  );
}
function er(n, e) {
  return Ge(Ns(n, e));
}
const FE = "units/5.7.0",
  LE = new z(FE),
  t5 = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
function Ja(n, e) {
  if (typeof e == "string") {
    const t = t5.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return Ll(n, e ?? 18);
}
function Ht(n, e) {
  if (
    (typeof n != "string" &&
      LE.throwArgumentError("value must be a string", "value", n),
    typeof e == "string")
  ) {
    const t = t5.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return Ar(n, e ?? 18);
}
function zd(n) {
  return Ja(n, 18);
}
function zh(n) {
  return Ht(n, 18);
}
const $E = "_container_aapa9_1",
  WE = "_infoWrapper_aapa9_20",
  UE = "_productInfo_aapa9_25",
  jE = "_productImage_aapa9_30",
  zE = "_imageWrapper_aapa9_35",
  HE = "_image_aapa9_35",
  qE = "_body_aapa9_50",
  VE = "_productBuy_aapa9_54",
  GE = "_price_aapa9_65",
  KE = "_stock_aapa9_66",
  QE = "_tabNavLogo_aapa9_78",
  YE = "_tabContent_aapa9_84",
  JE = "_center_aapa9_92",
  XE = "_balance_aapa9_97",
  ZE = "_table_aapa9_105",
  e7 = "_line_aapa9_120",
  t7 = "_lineLeft_aapa9_134",
  n7 = "_name_aapa9_140",
  r7 = "_dollar_aapa9_141",
  a7 = "_abbr_aapa9_146",
  i7 = "_crypto_aapa9_147",
  s7 = "_modalInputs_aapa9_157",
  o7 = "_modalButtons_aapa9_162",
  Fe = {
    container: $E,
    infoWrapper: WE,
    productInfo: UE,
    productImage: jE,
    imageWrapper: zE,
    image: HE,
    body: qE,
    productBuy: VE,
    price: GE,
    stock: KE,
    tabNavLogo: QE,
    tabContent: YE,
    center: JE,
    balance: XE,
    table: ZE,
    line: e7,
    lineLeft: t7,
    name: n7,
    dollar: r7,
    abbr: a7,
    crypto: i7,
    modalInputs: s7,
    modalButtons: o7,
  },
  c7 = "_tabBody_18ti8_1",
  l7 = "_tabNav_18ti8_6",
  u7 = "_tabNavItem_18ti8_13",
  e0 = { tabBody: c7, tabNav: l7, tabNavItem: u7 },
  d7 = ({
    tabIds: n,
    initActiveTab: e,
    getHeader: t,
    getBody: r,
    beforeChangeTab: a,
  }) => {
    const [i, s] = C.useState(e);
    return I.jsxs("div", {
      className: `${e0.tabBody} card`,
      children: [
        I.jsx("div", {
          className: e0.tabNav,
          children: n.map((o) =>
            I.jsx(
              "div",
              {
                className: e0.tabNavItem,
                onClick: () => {
                  a && a(o), s(o);
                },
                style: {
                  borderColor: i === o ? "#fff" : "transparent",
                  color: i === o ? "#fff" : "#c4c4c4",
                },
                children: t(o),
              },
              o,
            ),
          ),
        }),
        r(i),
      ],
    });
  },
  f7 = "_top_1j02u_1",
  p7 = { top: f7 },
  Cp = ({ title: n, description: e, children: t }) =>
    I.jsxs("div", {
      className: p7.top,
      children: [
        I.jsxs("div", {
          children: [I.jsx("h4", { children: n }), I.jsx("p", { children: e })],
        }),
        t,
      ],
    }),
  h7 = "_card_ozbu5_1",
  m7 = "_table_ozbu5_6",
  y7 = "_tableHead_ozbu5_31",
  g7 = "_tableBody_ozbu5_46",
  b7 = "_striped_ozbu5_56",
  x7 = "_colored_ozbu5_71",
  v7 = "_highlighted_ozbu5_75",
  pi = {
    card: h7,
    table: m7,
    tableHead: y7,
    tableBody: g7,
    striped: b7,
    colored: x7,
    highlighted: v7,
  },
  w7 = ({
    headers: n,
    data: e,
    colSizes: t,
    colColored: r,
    colHighlighted: a,
    striped: i,
    className: s,
  }) => (
    t || (t = e[0].map(() => 1)),
    (t = t.map((o) => `${o}fr`).join(" ")),
    r || (r = []),
    a || (a = []),
    I.jsx("div", {
      className: Fl(pi.card, "card", s),
      children: I.jsxs("div", {
        className: Fl(pi.table, { [pi.striped]: i }),
        children: [
          n &&
            I.jsx("div", {
              className: pi.tableHead,
              children: I.jsx("ul", {
                style: { gridTemplateColumns: t },
                children: n.map((o) =>
                  I.jsx("li", { children: o }, "header" + o),
                ),
              }),
            }),
          I.jsx("div", {
            className: pi.tableBody,
            children: e.map((o, c) =>
              I.jsx(
                "ul",
                {
                  style: { gridTemplateColumns: t },
                  children: o.map((l, u) =>
                    I.jsx(
                      "li",
                      {
                        className: Fl({
                          [pi.colored]: r.includes(u),
                          [pi.highlighted]: a.includes(u),
                        }),
                        children: l,
                      },
                      c + "_" + u,
                    ),
                  ),
                },
                c,
              ),
            ),
          }),
        ],
      }),
    })
  ),
  T7 = "_messagewrapper_1huke_1",
  C7 = "_errormessagecontainer_1huke_10",
  A7 = "_messagecontainer_1huke_19",
  E7 = "_icon_1huke_28",
  k7 = "_closeButton_1huke_40",
  _7 = "_hide_1huke_48",
  Ca = {
    messagewrapper: T7,
    errormessagecontainer: C7,
    messagecontainer: A7,
    icon: E7,
    closeButton: k7,
    hide: _7,
  },
  n5 = ({ hide: n }) => {
    const {
      infoMessage: e,
      errorMessage: t,
      setInfoMessage: r,
      setErrorMessage: a,
    } = C.useContext(C2);
    function i() {
      r(void 0);
    }
    function s() {
      a(void 0);
    }
    return (
      n || (n = !1),
      I.jsxs("div", {
        className: Fl({ [Ca.messagewrapper]: !0, [Ca.hide]: n }),
        children: [
          t &&
            I.jsxs("div", {
              className: Ca.errormessagecontainer,
              children: [
                I.jsx("p", { children: t }),
                I.jsx(aa, {
                  className: Ca.closeButton,
                  onClick: s,
                  children: I.jsx("img", {
                    className: Ca.icon,
                    src: wy,
                    alt: "",
                  }),
                }),
              ],
            }),
          e &&
            I.jsxs("div", {
              className: Ca.messagecontainer,
              children: [
                I.jsx("p", { children: e }),
                I.jsx(aa, {
                  className: Ca.closeButton,
                  onClick: i,
                  children: I.jsx("img", {
                    className: Ca.icon,
                    src: wy,
                    alt: "",
                  }),
                }),
              ],
            }),
        ],
      })
    );
  },
  S7 = "_modalOverlay_rtw79_1",
  P7 = "_modalBox_rtw79_15",
  A1 = { modalOverlay: S7, modalBox: P7 },
  I7 = ({ children: n, style: e }) =>
    I.jsx("div", {
      className: A1.modalOverlay,
      children: I.jsx("div", {
        className: `${A1.modalBox} card`,
        style: e,
        children: n,
      }),
    }),
  R7 = "/assets/logo_n-476813c9.png",
  M7 = "/assets/MetaMask-16977ec8.svg",
  B7 = "hh-sol-artifact-1",
  D7 = "IUniswapV3Pool",
  O7 = "contracts/interfaces/IUniswapV3Pool.sol",
  N7 = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "int24",
          name: "tickLower",
          type: "int24",
        },
        {
          indexed: !0,
          internalType: "int24",
          name: "tickUpper",
          type: "int24",
        },
        {
          indexed: !1,
          internalType: "uint128",
          name: "amount",
          type: "uint128",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount0",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount1",
          type: "uint256",
        },
      ],
      name: "Burn",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "int24",
          name: "tickLower",
          type: "int24",
        },
        {
          indexed: !0,
          internalType: "int24",
          name: "tickUpper",
          type: "int24",
        },
        {
          indexed: !1,
          internalType: "uint128",
          name: "amount0",
          type: "uint128",
        },
        {
          indexed: !1,
          internalType: "uint128",
          name: "amount1",
          type: "uint128",
        },
      ],
      name: "Collect",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint128",
          name: "amount0",
          type: "uint128",
        },
        {
          indexed: !1,
          internalType: "uint128",
          name: "amount1",
          type: "uint128",
        },
      ],
      name: "CollectProtocol",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount0",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount1",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "paid0",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "paid1",
          type: "uint256",
        },
      ],
      name: "Flash",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint16",
          name: "observationCardinalityNextOld",
          type: "uint16",
        },
        {
          indexed: !1,
          internalType: "uint16",
          name: "observationCardinalityNextNew",
          type: "uint16",
        },
      ],
      name: "IncreaseObservationCardinalityNext",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint160",
          name: "sqrtPriceX96",
          type: "uint160",
        },
        { indexed: !1, internalType: "int24", name: "tick", type: "int24" },
      ],
      name: "Initialize",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "int24",
          name: "tickLower",
          type: "int24",
        },
        {
          indexed: !0,
          internalType: "int24",
          name: "tickUpper",
          type: "int24",
        },
        {
          indexed: !1,
          internalType: "uint128",
          name: "amount",
          type: "uint128",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount0",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount1",
          type: "uint256",
        },
      ],
      name: "Mint",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint8",
          name: "feeProtocol0Old",
          type: "uint8",
        },
        {
          indexed: !1,
          internalType: "uint8",
          name: "feeProtocol1Old",
          type: "uint8",
        },
        {
          indexed: !1,
          internalType: "uint8",
          name: "feeProtocol0New",
          type: "uint8",
        },
        {
          indexed: !1,
          internalType: "uint8",
          name: "feeProtocol1New",
          type: "uint8",
        },
      ],
      name: "SetFeeProtocol",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "int256",
          name: "amount0",
          type: "int256",
        },
        {
          indexed: !1,
          internalType: "int256",
          name: "amount1",
          type: "int256",
        },
        {
          indexed: !1,
          internalType: "uint160",
          name: "sqrtPriceX96",
          type: "uint160",
        },
        {
          indexed: !1,
          internalType: "uint128",
          name: "liquidity",
          type: "uint128",
        },
        { indexed: !1, internalType: "int24", name: "tick", type: "int24" },
      ],
      name: "Swap",
      type: "event",
    },
    {
      inputs: [
        { internalType: "int24", name: "tickLower", type: "int24" },
        { internalType: "int24", name: "tickUpper", type: "int24" },
        { internalType: "uint128", name: "amount", type: "uint128" },
      ],
      name: "burn",
      outputs: [
        { internalType: "uint256", name: "amount0", type: "uint256" },
        { internalType: "uint256", name: "amount1", type: "uint256" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "recipient", type: "address" },
        { internalType: "int24", name: "tickLower", type: "int24" },
        { internalType: "int24", name: "tickUpper", type: "int24" },
        { internalType: "uint128", name: "amount0Requested", type: "uint128" },
        { internalType: "uint128", name: "amount1Requested", type: "uint128" },
      ],
      name: "collect",
      outputs: [
        { internalType: "uint128", name: "amount0", type: "uint128" },
        { internalType: "uint128", name: "amount1", type: "uint128" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "recipient", type: "address" },
        { internalType: "uint128", name: "amount0Requested", type: "uint128" },
        { internalType: "uint128", name: "amount1Requested", type: "uint128" },
      ],
      name: "collectProtocol",
      outputs: [
        { internalType: "uint128", name: "amount0", type: "uint128" },
        { internalType: "uint128", name: "amount1", type: "uint128" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "factory",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "fee",
      outputs: [{ internalType: "uint24", name: "", type: "uint24" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "feeGrowthGlobal0X128",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "feeGrowthGlobal1X128",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "recipient", type: "address" },
        { internalType: "uint256", name: "amount0", type: "uint256" },
        { internalType: "uint256", name: "amount1", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "flash",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint16",
          name: "observationCardinalityNext",
          type: "uint16",
        },
      ],
      name: "increaseObservationCardinalityNext",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint160", name: "sqrtPriceX96", type: "uint160" },
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "liquidity",
      outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "maxLiquidityPerTick",
      outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "recipient", type: "address" },
        { internalType: "int24", name: "tickLower", type: "int24" },
        { internalType: "int24", name: "tickUpper", type: "int24" },
        { internalType: "uint128", name: "amount", type: "uint128" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "mint",
      outputs: [
        { internalType: "uint256", name: "amount0", type: "uint256" },
        { internalType: "uint256", name: "amount1", type: "uint256" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
      name: "observations",
      outputs: [
        { internalType: "uint32", name: "blockTimestamp", type: "uint32" },
        { internalType: "int56", name: "tickCumulative", type: "int56" },
        {
          internalType: "uint160",
          name: "secondsPerLiquidityCumulativeX128",
          type: "uint160",
        },
        { internalType: "bool", name: "initialized", type: "bool" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint32[]", name: "secondsAgos", type: "uint32[]" },
      ],
      name: "observe",
      outputs: [
        { internalType: "int56[]", name: "tickCumulatives", type: "int56[]" },
        {
          internalType: "uint160[]",
          name: "secondsPerLiquidityCumulativeX128s",
          type: "uint160[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "key", type: "bytes32" }],
      name: "positions",
      outputs: [
        { internalType: "uint128", name: "_liquidity", type: "uint128" },
        {
          internalType: "uint256",
          name: "feeGrowthInside0LastX128",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "feeGrowthInside1LastX128",
          type: "uint256",
        },
        { internalType: "uint128", name: "tokensOwed0", type: "uint128" },
        { internalType: "uint128", name: "tokensOwed1", type: "uint128" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "protocolFees",
      outputs: [
        { internalType: "uint128", name: "token0", type: "uint128" },
        { internalType: "uint128", name: "token1", type: "uint128" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint8", name: "feeProtocol0", type: "uint8" },
        { internalType: "uint8", name: "feeProtocol1", type: "uint8" },
      ],
      name: "setFeeProtocol",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "slot0",
      outputs: [
        { internalType: "uint160", name: "sqrtPriceX96", type: "uint160" },
        { internalType: "int24", name: "tick", type: "int24" },
        { internalType: "uint16", name: "observationIndex", type: "uint16" },
        {
          internalType: "uint16",
          name: "observationCardinality",
          type: "uint16",
        },
        {
          internalType: "uint16",
          name: "observationCardinalityNext",
          type: "uint16",
        },
        { internalType: "uint8", name: "feeProtocol", type: "uint8" },
        { internalType: "bool", name: "unlocked", type: "bool" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "int24", name: "tickLower", type: "int24" },
        { internalType: "int24", name: "tickUpper", type: "int24" },
      ],
      name: "snapshotCumulativesInside",
      outputs: [
        { internalType: "int56", name: "tickCumulativeInside", type: "int56" },
        {
          internalType: "uint160",
          name: "secondsPerLiquidityInsideX128",
          type: "uint160",
        },
        { internalType: "uint32", name: "secondsInside", type: "uint32" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "recipient", type: "address" },
        { internalType: "bool", name: "zeroForOne", type: "bool" },
        { internalType: "int256", name: "amountSpecified", type: "int256" },
        { internalType: "uint160", name: "sqrtPriceLimitX96", type: "uint160" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "swap",
      outputs: [
        { internalType: "int256", name: "amount0", type: "int256" },
        { internalType: "int256", name: "amount1", type: "int256" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "int16", name: "wordPosition", type: "int16" }],
      name: "tickBitmap",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "tickSpacing",
      outputs: [{ internalType: "int24", name: "", type: "int24" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "int24", name: "tick", type: "int24" }],
      name: "ticks",
      outputs: [
        { internalType: "uint128", name: "liquidityGross", type: "uint128" },
        { internalType: "int128", name: "liquidityNet", type: "int128" },
        {
          internalType: "uint256",
          name: "feeGrowthOutside0X128",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "feeGrowthOutside1X128",
          type: "uint256",
        },
        { internalType: "int56", name: "tickCumulativeOutside", type: "int56" },
        {
          internalType: "uint160",
          name: "secondsPerLiquidityOutsideX128",
          type: "uint160",
        },
        { internalType: "uint32", name: "secondsOutside", type: "uint32" },
        { internalType: "bool", name: "initialized", type: "bool" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "token0",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "token1",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  F7 = "0x",
  L7 = "0x",
  $7 = {},
  W7 = {},
  r5 = {
    _format: B7,
    contractName: D7,
    sourceName: O7,
    abi: N7,
    bytecode: F7,
    deployedBytecode: L7,
    linkReferences: $7,
    deployedLinkReferences: W7,
  },
  U7 = "hh-sol-artifact-1",
  j7 = "IUniswapV3Factory",
  z7 = "contracts/interfaces/IUniswapV3Factory.sol",
  H7 = [
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "uint24", name: "fee", type: "uint24" },
        {
          indexed: !0,
          internalType: "int24",
          name: "tickSpacing",
          type: "int24",
        },
      ],
      name: "FeeAmountEnabled",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "oldOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnerChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "token0",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "token1",
          type: "address",
        },
        { indexed: !0, internalType: "uint24", name: "fee", type: "uint24" },
        {
          indexed: !1,
          internalType: "int24",
          name: "tickSpacing",
          type: "int24",
        },
        { indexed: !1, internalType: "address", name: "pool", type: "address" },
      ],
      name: "PoolCreated",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "tokenA", type: "address" },
        { internalType: "address", name: "tokenB", type: "address" },
        { internalType: "uint24", name: "fee", type: "uint24" },
      ],
      name: "createPool",
      outputs: [{ internalType: "address", name: "pool", type: "address" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint24", name: "fee", type: "uint24" },
        { internalType: "int24", name: "tickSpacing", type: "int24" },
      ],
      name: "enableFeeAmount",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint24", name: "fee", type: "uint24" }],
      name: "feeAmountTickSpacing",
      outputs: [{ internalType: "int24", name: "", type: "int24" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "tokenA", type: "address" },
        { internalType: "address", name: "tokenB", type: "address" },
        { internalType: "uint24", name: "fee", type: "uint24" },
      ],
      name: "getPool",
      outputs: [{ internalType: "address", name: "pool", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_owner", type: "address" }],
      name: "setOwner",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  q7 = "0x",
  V7 = "0x",
  G7 = {},
  K7 = {},
  Q7 = {
    _format: U7,
    contractName: j7,
    sourceName: z7,
    abi: H7,
    bytecode: q7,
    deployedBytecode: V7,
    linkReferences: G7,
    deployedLinkReferences: K7,
  },
  Ap = [
    {
      constant: !0,
      inputs: [],
      name: "name",
      outputs: [{ name: "", type: "string" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [
        { name: "_spender", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      name: "approve",
      outputs: [{ name: "", type: "bool" }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "totalSupply",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [
        { name: "_from", type: "address" },
        { name: "_to", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [{ name: "", type: "bool" }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "decimals",
      outputs: [{ name: "", type: "uint8" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [{ name: "_owner", type: "address" }],
      name: "balanceOf",
      outputs: [{ name: "balance", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "symbol",
      outputs: [{ name: "", type: "string" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [
        { name: "_to", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      name: "transfer",
      outputs: [{ name: "", type: "bool" }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [
        { name: "_owner", type: "address" },
        { name: "_spender", type: "address" },
      ],
      name: "allowance",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    { payable: !0, stateMutability: "payable", type: "fallback" },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, name: "owner", type: "address" },
        { indexed: !0, name: "spender", type: "address" },
        { indexed: !1, name: "value", type: "uint256" },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, name: "from", type: "address" },
        { indexed: !0, name: "to", type: "address" },
        { indexed: !1, name: "value", type: "uint256" },
      ],
      name: "Transfer",
      type: "event",
    },
  ],
  Y7 = "0x1F98431c8aD98523631AE4a59f267346ea31F984",
  xl = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  a5 = "500",
  J7 = "639eea2ebcabed7eab90b56aceeed08b",
  i5 = new Ya("https://ethereum.rpc.thirdweb.com/" + J7);
class s5 {
  constructor(e) {
    $(
      this,
      "WETH_CONTRACT_ADDRESS",
      "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    );
    e === "metamask"
      ? (this.provider = new jh(window.ethereum))
      : (this.provider = i5),
      (this.FactoryContract = new Pe(Y7, Q7.abi, this.provider));
  }
  calculatePoolPrice(e, t, r, a, i) {
    let s = (e / 7922816251426434e13) ** 2;
    return parseInt(t) < parseInt(r)
      ? ((s = s * 10 ** (a - i)), s)
      : ((s = s / 10 ** (a - i)), 1 / s);
  }
  async getDecimals(e) {
    return await new Pe(e, Ap, this.provider).decimals();
  }
  async getUSDCPriceForToken(e, t = null, r = null) {
    if (e === xl) return 1;
    const a = await this.FactoryContract.getPool(e, xl, a5),
      o = (
        await new Pe(a, r5.abi, this.provider).slot0()
      ).sqrtPriceX96.toString();
    return (
      (t === null || r === null) &&
        ([t, r] = await Promise.all([
          this.getDecimals(e),
          this.getDecimals(xl),
        ])),
      this.calculatePoolPrice(o, e, xl, t, r)
    );
  }
}
class o5 {
  constructor(e) {
    e === "metamask"
      ? (this.provider = new jh(window.ethereum))
      : (this.provider = i5);
  }
  async getBalanceNative(e) {
    const t = await this.provider.getBalance(e);
    return zd(t);
  }
  async getBalanceToken(e, t) {
    if (!e) return await this.getBalanceNative(t);
    const r = new Pe(e, Ap, this.provider),
      [a, i] = await Promise.all([r.decimals(), r.balanceOf(t)]);
    return Ja(i, a);
  }
  async send(e, t, r) {
    return e ? await this.sendToken(e, t, r) : await this.sendNative(t, r);
  }
  async sendNative(e, t) {
    const r = this.provider.getSigner(),
      a = { to: t, value: zh(e) };
    return await (await r.sendTransaction(a)).wait();
  }
  async sendToken(e, t, r) {
    const a = this.provider.getSigner(),
      i = new Pe(e, Ap, a),
      s = await i.decimals();
    return await (await i.transfer(r, Ht(t, s))).wait();
  }
  async callDepositContract(e, t, r, a, i, s, o) {
    const c = new s5(),
      l = 18,
      u = await c.getDecimals(s),
      d = await c.getUSDCPriceForToken(c.WETH_CONTRACT_ADDRESS, l, u),
      f = o / d,
      p = Math.ceil(f * 10 ** l),
      m = o * 0.98 * 10 ** u;
    console.log("priceConvert: " + d),
      console.log("amountIn: " + f),
      console.log("amountInInt: " + p),
      console.log("minAmountOut: " + m);
    const y = Ty[Ty.length - 1],
      h = this.provider.getSigner(),
      g = new Pe(y.address, y.abi, h),
      v = Date.now(),
      w = await g.deposit(e, t, r, a, i, s, m, a5, { value: p });
    console.log(w);
    const T = await w.wait();
    console.log(T);
    const A = Date.now(),
      E = this.parseReceipt(w, T);
    return (
      (E.timestampSent = v),
      (E.timestampMined = A),
      (E.sellerAddress = vo(fi(e))),
      (E.affiliateAddress = vo(fi(t))),
      (E.brokerAddress = vo(fi(r))),
      (E.seniorBrokerAddress = vo(fi(a))),
      (E.leaderAddress = vo(fi(i))),
      (E.currencyAddress = null),
      (E.stablecoinAddress = fi(s)),
      (E.transactionHash = T.transactionHash),
      E
    );
  }
  parseReceipt(e, t) {
    function r(s) {
      try {
        return s.toBigInt();
      } catch (o) {
        console.log(o);
      }
      return O.from(s.hex).toBigInt();
    }
    let a = {};
    (a.contractAddress = fi(e.to)),
      (a.status = t.status),
      (a.gasPrice = O.from(e.gasPrice).toBigInt()),
      (a.gasUsed = O.from(t.gasUsed).toBigInt()),
      (a.value = O.from(e.value).toBigInt());
    for (const s of t.events)
      if (s.event === "Distributed") {
        console.log(s);
        const o = s.args.map((c) => r(c));
        a = {
          ...a,
          sellerAmount: o[0],
          affiliateAmount: o[1],
          brokerAmount: o[2],
          seniorBrokerAmount: o[3],
          leaderAmount: o[4],
          ownerAmount: o[5],
        };
      }
    const i = new ec(r5.abi);
    for (const s of t.logs)
      try {
        const o = i.decodeEventLog("Swap", s.data, s.topics);
        a.swappedAmount = O.from(o[3]).abs().toBigInt();
      } catch {}
    return a;
  }
  convertBigIntToString(e) {
    for (const t of Object.keys(e))
      typeof e[t] == "bigint" && (e[t] = e[t].toString());
  }
}
function c5() {
  const [n, e] = C.useState([]),
    t = new A2();
  async function r() {
    const a = await t.getWalletAddresses();
    if (a) {
      console.log(a);
      const i = a.filter((s) => s.internal).map((s) => s.address);
      console.log(i), e(i);
    }
  }
  return (
    C.useEffect(() => {
      r();
    }, []),
    n.length > 0 ? n[0] : void 0
  );
}
function Hd() {
  (this._types = Object.create(null)), (this._extensions = Object.create(null));
  for (let n = 0; n < arguments.length; n++) this.define(arguments[n]);
  (this.define = this.define.bind(this)),
    (this.getType = this.getType.bind(this)),
    (this.getExtension = this.getExtension.bind(this));
}
Hd.prototype.define = function (n, e) {
  for (let t in n) {
    let r = n[t].map(function (a) {
      return a.toLowerCase();
    });
    t = t.toLowerCase();
    for (let a = 0; a < r.length; a++) {
      const i = r[a];
      if (i[0] !== "*") {
        if (!e && i in this._types)
          throw new Error(
            'Attempt to change mapping for "' +
              i +
              '" extension from "' +
              this._types[i] +
              '" to "' +
              t +
              '". Pass `force=true` to allow this, otherwise remove "' +
              i +
              '" from the list of extensions for "' +
              t +
              '".',
          );
        this._types[i] = t;
      }
    }
    if (e || !this._extensions[t]) {
      const a = r[0];
      this._extensions[t] = a[0] !== "*" ? a : a.substr(1);
    }
  }
};
Hd.prototype.getType = function (n) {
  n = String(n);
  let e = n.replace(/^.*[/\\]/, "").toLowerCase(),
    t = e.replace(/^.*\./, "").toLowerCase(),
    r = e.length < n.length;
  return ((t.length < e.length - 1 || !r) && this._types[t]) || null;
};
Hd.prototype.getExtension = function (n) {
  return (
    (n = /^\s*([^;\s]*)/.test(n) && RegExp.$1),
    (n && this._extensions[n.toLowerCase()]) || null
  );
};
var X7 = Hd,
  Z7 = {
    "application/andrew-inset": ["ez"],
    "application/applixware": ["aw"],
    "application/atom+xml": ["atom"],
    "application/atomcat+xml": ["atomcat"],
    "application/atomdeleted+xml": ["atomdeleted"],
    "application/atomsvc+xml": ["atomsvc"],
    "application/atsc-dwd+xml": ["dwd"],
    "application/atsc-held+xml": ["held"],
    "application/atsc-rsat+xml": ["rsat"],
    "application/bdoc": ["bdoc"],
    "application/calendar+xml": ["xcs"],
    "application/ccxml+xml": ["ccxml"],
    "application/cdfx+xml": ["cdfx"],
    "application/cdmi-capability": ["cdmia"],
    "application/cdmi-container": ["cdmic"],
    "application/cdmi-domain": ["cdmid"],
    "application/cdmi-object": ["cdmio"],
    "application/cdmi-queue": ["cdmiq"],
    "application/cu-seeme": ["cu"],
    "application/dash+xml": ["mpd"],
    "application/davmount+xml": ["davmount"],
    "application/docbook+xml": ["dbk"],
    "application/dssc+der": ["dssc"],
    "application/dssc+xml": ["xdssc"],
    "application/ecmascript": ["es", "ecma"],
    "application/emma+xml": ["emma"],
    "application/emotionml+xml": ["emotionml"],
    "application/epub+zip": ["epub"],
    "application/exi": ["exi"],
    "application/express": ["exp"],
    "application/fdt+xml": ["fdt"],
    "application/font-tdpfr": ["pfr"],
    "application/geo+json": ["geojson"],
    "application/gml+xml": ["gml"],
    "application/gpx+xml": ["gpx"],
    "application/gxf": ["gxf"],
    "application/gzip": ["gz"],
    "application/hjson": ["hjson"],
    "application/hyperstudio": ["stk"],
    "application/inkml+xml": ["ink", "inkml"],
    "application/ipfix": ["ipfix"],
    "application/its+xml": ["its"],
    "application/java-archive": ["jar", "war", "ear"],
    "application/java-serialized-object": ["ser"],
    "application/java-vm": ["class"],
    "application/javascript": ["js", "mjs"],
    "application/json": ["json", "map"],
    "application/json5": ["json5"],
    "application/jsonml+json": ["jsonml"],
    "application/ld+json": ["jsonld"],
    "application/lgr+xml": ["lgr"],
    "application/lost+xml": ["lostxml"],
    "application/mac-binhex40": ["hqx"],
    "application/mac-compactpro": ["cpt"],
    "application/mads+xml": ["mads"],
    "application/manifest+json": ["webmanifest"],
    "application/marc": ["mrc"],
    "application/marcxml+xml": ["mrcx"],
    "application/mathematica": ["ma", "nb", "mb"],
    "application/mathml+xml": ["mathml"],
    "application/mbox": ["mbox"],
    "application/mediaservercontrol+xml": ["mscml"],
    "application/metalink+xml": ["metalink"],
    "application/metalink4+xml": ["meta4"],
    "application/mets+xml": ["mets"],
    "application/mmt-aei+xml": ["maei"],
    "application/mmt-usd+xml": ["musd"],
    "application/mods+xml": ["mods"],
    "application/mp21": ["m21", "mp21"],
    "application/mp4": ["mp4s", "m4p"],
    "application/msword": ["doc", "dot"],
    "application/mxf": ["mxf"],
    "application/n-quads": ["nq"],
    "application/n-triples": ["nt"],
    "application/node": ["cjs"],
    "application/octet-stream": [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer",
    ],
    "application/oda": ["oda"],
    "application/oebps-package+xml": ["opf"],
    "application/ogg": ["ogx"],
    "application/omdoc+xml": ["omdoc"],
    "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
    "application/oxps": ["oxps"],
    "application/p2p-overlay+xml": ["relo"],
    "application/patch-ops-error+xml": ["xer"],
    "application/pdf": ["pdf"],
    "application/pgp-encrypted": ["pgp"],
    "application/pgp-signature": ["asc", "sig"],
    "application/pics-rules": ["prf"],
    "application/pkcs10": ["p10"],
    "application/pkcs7-mime": ["p7m", "p7c"],
    "application/pkcs7-signature": ["p7s"],
    "application/pkcs8": ["p8"],
    "application/pkix-attr-cert": ["ac"],
    "application/pkix-cert": ["cer"],
    "application/pkix-crl": ["crl"],
    "application/pkix-pkipath": ["pkipath"],
    "application/pkixcmp": ["pki"],
    "application/pls+xml": ["pls"],
    "application/postscript": ["ai", "eps", "ps"],
    "application/provenance+xml": ["provx"],
    "application/pskc+xml": ["pskcxml"],
    "application/raml+yaml": ["raml"],
    "application/rdf+xml": ["rdf", "owl"],
    "application/reginfo+xml": ["rif"],
    "application/relax-ng-compact-syntax": ["rnc"],
    "application/resource-lists+xml": ["rl"],
    "application/resource-lists-diff+xml": ["rld"],
    "application/rls-services+xml": ["rs"],
    "application/route-apd+xml": ["rapd"],
    "application/route-s-tsid+xml": ["sls"],
    "application/route-usd+xml": ["rusd"],
    "application/rpki-ghostbusters": ["gbr"],
    "application/rpki-manifest": ["mft"],
    "application/rpki-roa": ["roa"],
    "application/rsd+xml": ["rsd"],
    "application/rss+xml": ["rss"],
    "application/rtf": ["rtf"],
    "application/sbml+xml": ["sbml"],
    "application/scvp-cv-request": ["scq"],
    "application/scvp-cv-response": ["scs"],
    "application/scvp-vp-request": ["spq"],
    "application/scvp-vp-response": ["spp"],
    "application/sdp": ["sdp"],
    "application/senml+xml": ["senmlx"],
    "application/sensml+xml": ["sensmlx"],
    "application/set-payment-initiation": ["setpay"],
    "application/set-registration-initiation": ["setreg"],
    "application/shf+xml": ["shf"],
    "application/sieve": ["siv", "sieve"],
    "application/smil+xml": ["smi", "smil"],
    "application/sparql-query": ["rq"],
    "application/sparql-results+xml": ["srx"],
    "application/srgs": ["gram"],
    "application/srgs+xml": ["grxml"],
    "application/sru+xml": ["sru"],
    "application/ssdl+xml": ["ssdl"],
    "application/ssml+xml": ["ssml"],
    "application/swid+xml": ["swidtag"],
    "application/tei+xml": ["tei", "teicorpus"],
    "application/thraud+xml": ["tfi"],
    "application/timestamped-data": ["tsd"],
    "application/toml": ["toml"],
    "application/trig": ["trig"],
    "application/ttml+xml": ["ttml"],
    "application/ubjson": ["ubj"],
    "application/urc-ressheet+xml": ["rsheet"],
    "application/urc-targetdesc+xml": ["td"],
    "application/voicexml+xml": ["vxml"],
    "application/wasm": ["wasm"],
    "application/widget": ["wgt"],
    "application/winhlp": ["hlp"],
    "application/wsdl+xml": ["wsdl"],
    "application/wspolicy+xml": ["wspolicy"],
    "application/xaml+xml": ["xaml"],
    "application/xcap-att+xml": ["xav"],
    "application/xcap-caps+xml": ["xca"],
    "application/xcap-diff+xml": ["xdf"],
    "application/xcap-el+xml": ["xel"],
    "application/xcap-ns+xml": ["xns"],
    "application/xenc+xml": ["xenc"],
    "application/xhtml+xml": ["xhtml", "xht"],
    "application/xliff+xml": ["xlf"],
    "application/xml": ["xml", "xsl", "xsd", "rng"],
    "application/xml-dtd": ["dtd"],
    "application/xop+xml": ["xop"],
    "application/xproc+xml": ["xpl"],
    "application/xslt+xml": ["*xsl", "xslt"],
    "application/xspf+xml": ["xspf"],
    "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
    "application/yang": ["yang"],
    "application/yin+xml": ["yin"],
    "application/zip": ["zip"],
    "audio/3gpp": ["*3gpp"],
    "audio/adpcm": ["adp"],
    "audio/amr": ["amr"],
    "audio/basic": ["au", "snd"],
    "audio/midi": ["mid", "midi", "kar", "rmi"],
    "audio/mobile-xmf": ["mxmf"],
    "audio/mp3": ["*mp3"],
    "audio/mp4": ["m4a", "mp4a"],
    "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
    "audio/ogg": ["oga", "ogg", "spx", "opus"],
    "audio/s3m": ["s3m"],
    "audio/silk": ["sil"],
    "audio/wav": ["wav"],
    "audio/wave": ["*wav"],
    "audio/webm": ["weba"],
    "audio/xm": ["xm"],
    "font/collection": ["ttc"],
    "font/otf": ["otf"],
    "font/ttf": ["ttf"],
    "font/woff": ["woff"],
    "font/woff2": ["woff2"],
    "image/aces": ["exr"],
    "image/apng": ["apng"],
    "image/avif": ["avif"],
    "image/bmp": ["bmp"],
    "image/cgm": ["cgm"],
    "image/dicom-rle": ["drle"],
    "image/emf": ["emf"],
    "image/fits": ["fits"],
    "image/g3fax": ["g3"],
    "image/gif": ["gif"],
    "image/heic": ["heic"],
    "image/heic-sequence": ["heics"],
    "image/heif": ["heif"],
    "image/heif-sequence": ["heifs"],
    "image/hej2k": ["hej2"],
    "image/hsj2": ["hsj2"],
    "image/ief": ["ief"],
    "image/jls": ["jls"],
    "image/jp2": ["jp2", "jpg2"],
    "image/jpeg": ["jpeg", "jpg", "jpe"],
    "image/jph": ["jph"],
    "image/jphc": ["jhc"],
    "image/jpm": ["jpm"],
    "image/jpx": ["jpx", "jpf"],
    "image/jxr": ["jxr"],
    "image/jxra": ["jxra"],
    "image/jxrs": ["jxrs"],
    "image/jxs": ["jxs"],
    "image/jxsc": ["jxsc"],
    "image/jxsi": ["jxsi"],
    "image/jxss": ["jxss"],
    "image/ktx": ["ktx"],
    "image/ktx2": ["ktx2"],
    "image/png": ["png"],
    "image/sgi": ["sgi"],
    "image/svg+xml": ["svg", "svgz"],
    "image/t38": ["t38"],
    "image/tiff": ["tif", "tiff"],
    "image/tiff-fx": ["tfx"],
    "image/webp": ["webp"],
    "image/wmf": ["wmf"],
    "message/disposition-notification": ["disposition-notification"],
    "message/global": ["u8msg"],
    "message/global-delivery-status": ["u8dsn"],
    "message/global-disposition-notification": ["u8mdn"],
    "message/global-headers": ["u8hdr"],
    "message/rfc822": ["eml", "mime"],
    "model/3mf": ["3mf"],
    "model/gltf+json": ["gltf"],
    "model/gltf-binary": ["glb"],
    "model/iges": ["igs", "iges"],
    "model/mesh": ["msh", "mesh", "silo"],
    "model/mtl": ["mtl"],
    "model/obj": ["obj"],
    "model/step+xml": ["stpx"],
    "model/step+zip": ["stpz"],
    "model/step-xml+zip": ["stpxz"],
    "model/stl": ["stl"],
    "model/vrml": ["wrl", "vrml"],
    "model/x3d+binary": ["*x3db", "x3dbz"],
    "model/x3d+fastinfoset": ["x3db"],
    "model/x3d+vrml": ["*x3dv", "x3dvz"],
    "model/x3d+xml": ["x3d", "x3dz"],
    "model/x3d-vrml": ["x3dv"],
    "text/cache-manifest": ["appcache", "manifest"],
    "text/calendar": ["ics", "ifb"],
    "text/coffeescript": ["coffee", "litcoffee"],
    "text/css": ["css"],
    "text/csv": ["csv"],
    "text/html": ["html", "htm", "shtml"],
    "text/jade": ["jade"],
    "text/jsx": ["jsx"],
    "text/less": ["less"],
    "text/markdown": ["markdown", "md"],
    "text/mathml": ["mml"],
    "text/mdx": ["mdx"],
    "text/n3": ["n3"],
    "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
    "text/richtext": ["rtx"],
    "text/rtf": ["*rtf"],
    "text/sgml": ["sgml", "sgm"],
    "text/shex": ["shex"],
    "text/slim": ["slim", "slm"],
    "text/spdx": ["spdx"],
    "text/stylus": ["stylus", "styl"],
    "text/tab-separated-values": ["tsv"],
    "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
    "text/turtle": ["ttl"],
    "text/uri-list": ["uri", "uris", "urls"],
    "text/vcard": ["vcard"],
    "text/vtt": ["vtt"],
    "text/xml": ["*xml"],
    "text/yaml": ["yaml", "yml"],
    "video/3gpp": ["3gp", "3gpp"],
    "video/3gpp2": ["3g2"],
    "video/h261": ["h261"],
    "video/h263": ["h263"],
    "video/h264": ["h264"],
    "video/iso.segment": ["m4s"],
    "video/jpeg": ["jpgv"],
    "video/jpm": ["*jpm", "jpgm"],
    "video/mj2": ["mj2", "mjp2"],
    "video/mp2t": ["ts"],
    "video/mp4": ["mp4", "mp4v", "mpg4"],
    "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
    "video/ogg": ["ogv"],
    "video/quicktime": ["qt", "mov"],
    "video/webm": ["webm"],
  };
let e9 = X7;
var t9 = new e9(Z7);
const n9 = ir(t9);
class ao {
  constructor() {
    (this.listeners = new Set()), (this.subscribe = this.subscribe.bind(this));
  }
  subscribe(e) {
    const t = { listener: e };
    return (
      this.listeners.add(t),
      this.onSubscribe(),
      () => {
        this.listeners.delete(t), this.onUnsubscribe();
      }
    );
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {}
  onUnsubscribe() {}
}
const sc = typeof window > "u" || "Deno" in window;
function Kn() {}
function r9(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function Ep(n) {
  return typeof n == "number" && n >= 0 && n !== 1 / 0;
}
function l5(n, e) {
  return Math.max(n + (e || 0) - Date.now(), 0);
}
function $o(n, e, t) {
  return zc(n)
    ? typeof e == "function"
      ? { ...t, queryKey: n, queryFn: e }
      : { ...e, queryKey: n }
    : n;
}
function a9(n, e, t) {
  return zc(n)
    ? typeof e == "function"
      ? { ...t, mutationKey: n, mutationFn: e }
      : { ...e, mutationKey: n }
    : typeof n == "function"
    ? { ...e, mutationFn: n }
    : { ...n };
}
function Sa(n, e, t) {
  return zc(n) ? [{ ...e, queryKey: n }, t] : [n || {}, e];
}
function E1(n, e) {
  const {
    type: t = "all",
    exact: r,
    fetchStatus: a,
    predicate: i,
    queryKey: s,
    stale: o,
  } = n;
  if (zc(s)) {
    if (r) {
      if (e.queryHash !== Hh(s, e.options)) return !1;
    } else if (!gu(e.queryKey, s)) return !1;
  }
  if (t !== "all") {
    const c = e.isActive();
    if ((t === "active" && !c) || (t === "inactive" && c)) return !1;
  }
  return !(
    (typeof o == "boolean" && e.isStale() !== o) ||
    (typeof a < "u" && a !== e.state.fetchStatus) ||
    (i && !i(e))
  );
}
function k1(n, e) {
  const { exact: t, fetching: r, predicate: a, mutationKey: i } = n;
  if (zc(i)) {
    if (!e.options.mutationKey) return !1;
    if (t) {
      if (vi(e.options.mutationKey) !== vi(i)) return !1;
    } else if (!gu(e.options.mutationKey, i)) return !1;
  }
  return !(
    (typeof r == "boolean" && (e.state.status === "loading") !== r) ||
    (a && !a(e))
  );
}
function Hh(n, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || vi)(n);
}
function vi(n) {
  return JSON.stringify(n, (e, t) =>
    _p(t)
      ? Object.keys(t)
          .sort()
          .reduce((r, a) => ((r[a] = t[a]), r), {})
      : t,
  );
}
function gu(n, e) {
  return u5(n, e);
}
function u5(n, e) {
  return n === e
    ? !0
    : typeof n != typeof e
    ? !1
    : n && e && typeof n == "object" && typeof e == "object"
    ? !Object.keys(e).some((t) => !u5(n[t], e[t]))
    : !1;
}
function d5(n, e) {
  if (n === e) return n;
  const t = _1(n) && _1(e);
  if (t || (_p(n) && _p(e))) {
    const r = t ? n.length : Object.keys(n).length,
      a = t ? e : Object.keys(e),
      i = a.length,
      s = t ? [] : {};
    let o = 0;
    for (let c = 0; c < i; c++) {
      const l = t ? c : a[c];
      (s[l] = d5(n[l], e[l])), s[l] === n[l] && o++;
    }
    return r === i && o === r ? n : s;
  }
  return e;
}
function kp(n, e) {
  if ((n && !e) || (e && !n)) return !1;
  for (const t in n) if (n[t] !== e[t]) return !1;
  return !0;
}
function _1(n) {
  return Array.isArray(n) && n.length === Object.keys(n).length;
}
function _p(n) {
  if (!S1(n)) return !1;
  const e = n.constructor;
  if (typeof e > "u") return !0;
  const t = e.prototype;
  return !(!S1(t) || !t.hasOwnProperty("isPrototypeOf"));
}
function S1(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
function zc(n) {
  return Array.isArray(n);
}
function f5(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function P1(n) {
  f5(0).then(n);
}
function i9() {
  if (typeof AbortController == "function") return new AbortController();
}
function Sp(n, e, t) {
  return t.isDataEqual != null && t.isDataEqual(n, e)
    ? n
    : typeof t.structuralSharing == "function"
    ? t.structuralSharing(n, e)
    : t.structuralSharing !== !1
    ? d5(n, e)
    : e;
}
class s9 extends ao {
  constructor() {
    super(),
      (this.setup = (e) => {
        if (!sc && window.addEventListener) {
          const t = () => e();
          return (
            window.addEventListener("visibilitychange", t, !1),
            window.addEventListener("focus", t, !1),
            () => {
              window.removeEventListener("visibilitychange", t),
                window.removeEventListener("focus", t);
            }
          );
        }
      });
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var e;
      (e = this.cleanup) == null || e.call(this), (this.cleanup = void 0);
    }
  }
  setEventListener(e) {
    var t;
    (this.setup = e),
      (t = this.cleanup) == null || t.call(this),
      (this.cleanup = e((r) => {
        typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
      }));
  }
  setFocused(e) {
    this.focused !== e && ((this.focused = e), this.onFocus());
  }
  onFocus() {
    this.listeners.forEach(({ listener: e }) => {
      e();
    });
  }
  isFocused() {
    return typeof this.focused == "boolean"
      ? this.focused
      : typeof document > "u"
      ? !0
      : [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
}
const bu = new s9(),
  I1 = ["online", "offline"];
class o9 extends ao {
  constructor() {
    super(),
      (this.setup = (e) => {
        if (!sc && window.addEventListener) {
          const t = () => e();
          return (
            I1.forEach((r) => {
              window.addEventListener(r, t, !1);
            }),
            () => {
              I1.forEach((r) => {
                window.removeEventListener(r, t);
              });
            }
          );
        }
      });
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var e;
      (e = this.cleanup) == null || e.call(this), (this.cleanup = void 0);
    }
  }
  setEventListener(e) {
    var t;
    (this.setup = e),
      (t = this.cleanup) == null || t.call(this),
      (this.cleanup = e((r) => {
        typeof r == "boolean" ? this.setOnline(r) : this.onOnline();
      }));
  }
  setOnline(e) {
    this.online !== e && ((this.online = e), this.onOnline());
  }
  onOnline() {
    this.listeners.forEach(({ listener: e }) => {
      e();
    });
  }
  isOnline() {
    return typeof this.online == "boolean"
      ? this.online
      : typeof navigator > "u" || typeof navigator.onLine > "u"
      ? !0
      : navigator.onLine;
  }
}
const xu = new o9();
function c9(n) {
  return Math.min(1e3 * 2 ** n, 3e4);
}
function qd(n) {
  return (n ?? "online") === "online" ? xu.isOnline() : !0;
}
class p5 {
  constructor(e) {
    (this.revert = e == null ? void 0 : e.revert),
      (this.silent = e == null ? void 0 : e.silent);
  }
}
function Gl(n) {
  return n instanceof p5;
}
function h5(n) {
  let e = !1,
    t = 0,
    r = !1,
    a,
    i,
    s;
  const o = new Promise((h, g) => {
      (i = h), (s = g);
    }),
    c = (h) => {
      r || (p(new p5(h)), n.abort == null || n.abort());
    },
    l = () => {
      e = !0;
    },
    u = () => {
      e = !1;
    },
    d = () => !bu.isFocused() || (n.networkMode !== "always" && !xu.isOnline()),
    f = (h) => {
      r ||
        ((r = !0),
        n.onSuccess == null || n.onSuccess(h),
        a == null || a(),
        i(h));
    },
    p = (h) => {
      r ||
        ((r = !0), n.onError == null || n.onError(h), a == null || a(), s(h));
    },
    m = () =>
      new Promise((h) => {
        (a = (g) => {
          const v = r || !d();
          return v && h(g), v;
        }),
          n.onPause == null || n.onPause();
      }).then(() => {
        (a = void 0), r || n.onContinue == null || n.onContinue();
      }),
    y = () => {
      if (r) return;
      let h;
      try {
        h = n.fn();
      } catch (g) {
        h = Promise.reject(g);
      }
      Promise.resolve(h)
        .then(f)
        .catch((g) => {
          var v, w;
          if (r) return;
          const T = (v = n.retry) != null ? v : 3,
            A = (w = n.retryDelay) != null ? w : c9,
            E = typeof A == "function" ? A(t, g) : A,
            _ =
              T === !0 ||
              (typeof T == "number" && t < T) ||
              (typeof T == "function" && T(t, g));
          if (e || !_) {
            p(g);
            return;
          }
          t++,
            n.onFail == null || n.onFail(t, g),
            f5(E)
              .then(() => {
                if (d()) return m();
              })
              .then(() => {
                e ? p(g) : y();
              });
        });
    };
  return (
    qd(n.networkMode) ? y() : m().then(y),
    {
      promise: o,
      cancel: c,
      continue: () => ((a == null ? void 0 : a()) ? o : Promise.resolve()),
      cancelRetry: l,
      continueRetry: u,
    }
  );
}
const qh = console;
function l9() {
  let n = [],
    e = 0,
    t = (u) => {
      u();
    },
    r = (u) => {
      u();
    };
  const a = (u) => {
      let d;
      e++;
      try {
        d = u();
      } finally {
        e--, e || o();
      }
      return d;
    },
    i = (u) => {
      e
        ? n.push(u)
        : P1(() => {
            t(u);
          });
    },
    s =
      (u) =>
      (...d) => {
        i(() => {
          u(...d);
        });
      },
    o = () => {
      const u = n;
      (n = []),
        u.length &&
          P1(() => {
            r(() => {
              u.forEach((d) => {
                t(d);
              });
            });
          });
    };
  return {
    batch: a,
    batchCalls: s,
    schedule: i,
    setNotifyFunction: (u) => {
      t = u;
    },
    setBatchNotifyFunction: (u) => {
      r = u;
    },
  };
}
const pt = l9();
class m5 {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(),
      Ep(this.cacheTime) &&
        (this.gcTimeout = setTimeout(() => {
          this.optionalRemove();
        }, this.cacheTime));
  }
  updateCacheTime(e) {
    this.cacheTime = Math.max(
      this.cacheTime || 0,
      e ?? (sc ? 1 / 0 : 5 * 60 * 1e3),
    );
  }
  clearGcTimeout() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), (this.gcTimeout = void 0));
  }
}
class u9 extends m5 {
  constructor(e) {
    super(),
      (this.abortSignalConsumed = !1),
      (this.defaultOptions = e.defaultOptions),
      this.setOptions(e.options),
      (this.observers = []),
      (this.cache = e.cache),
      (this.logger = e.logger || qh),
      (this.queryKey = e.queryKey),
      (this.queryHash = e.queryHash),
      (this.initialState = e.state || d9(this.options)),
      (this.state = this.initialState),
      this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(e) {
    (this.options = { ...this.defaultOptions, ...e }),
      this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    !this.observers.length &&
      this.state.fetchStatus === "idle" &&
      this.cache.remove(this);
  }
  setData(e, t) {
    const r = Sp(this.state.data, e, this.options);
    return (
      this.dispatch({
        data: r,
        type: "success",
        dataUpdatedAt: t == null ? void 0 : t.updatedAt,
        manual: t == null ? void 0 : t.manual,
      }),
      r
    );
  }
  setState(e, t) {
    this.dispatch({ type: "setState", state: e, setStateOptions: t });
  }
  cancel(e) {
    var t;
    const r = this.promise;
    return (
      (t = this.retryer) == null || t.cancel(e),
      r ? r.then(Kn).catch(Kn) : Promise.resolve()
    );
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((e) => e.options.enabled !== !1);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return (
      this.state.isInvalidated ||
      !this.state.dataUpdatedAt ||
      this.observers.some((e) => e.getCurrentResult().isStale)
    );
  }
  isStaleByTime(e = 0) {
    return (
      this.state.isInvalidated ||
      !this.state.dataUpdatedAt ||
      !l5(this.state.dataUpdatedAt, e)
    );
  }
  onFocus() {
    var e;
    const t = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    t && t.refetch({ cancelRefetch: !1 }),
      (e = this.retryer) == null || e.continue();
  }
  onOnline() {
    var e;
    const t = this.observers.find((r) => r.shouldFetchOnReconnect());
    t && t.refetch({ cancelRefetch: !1 }),
      (e = this.retryer) == null || e.continue();
  }
  addObserver(e) {
    this.observers.includes(e) ||
      (this.observers.push(e),
      this.clearGcTimeout(),
      this.cache.notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) &&
      ((this.observers = this.observers.filter((t) => t !== e)),
      this.observers.length ||
        (this.retryer &&
          (this.abortSignalConsumed
            ? this.retryer.cancel({ revert: !0 })
            : this.retryer.cancelRetry()),
        this.scheduleGc()),
      this.cache.notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.dispatch({ type: "invalidate" });
  }
  fetch(e, t) {
    var r, a;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && t != null && t.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (this.promise) {
        var i;
        return (i = this.retryer) == null || i.continueRetry(), this.promise;
      }
    }
    if ((e && this.setOptions(e), !this.options.queryFn)) {
      const p = this.observers.find((m) => m.options.queryFn);
      p && this.setOptions(p.options);
    }
    Array.isArray(this.options.queryKey);
    const s = i9(),
      o = { queryKey: this.queryKey, pageParam: void 0, meta: this.meta },
      c = (p) => {
        Object.defineProperty(p, "signal", {
          enumerable: !0,
          get: () => {
            if (s) return (this.abortSignalConsumed = !0), s.signal;
          },
        });
      };
    c(o);
    const l = () =>
        this.options.queryFn
          ? ((this.abortSignalConsumed = !1), this.options.queryFn(o))
          : Promise.reject(
              "Missing queryFn for queryKey '" + this.options.queryHash + "'",
            ),
      u = {
        fetchOptions: t,
        options: this.options,
        queryKey: this.queryKey,
        state: this.state,
        fetchFn: l,
      };
    if (
      (c(u),
      (r = this.options.behavior) == null || r.onFetch(u),
      (this.revertState = this.state),
      this.state.fetchStatus === "idle" ||
        this.state.fetchMeta !==
          ((a = u.fetchOptions) == null ? void 0 : a.meta))
    ) {
      var d;
      this.dispatch({
        type: "fetch",
        meta: (d = u.fetchOptions) == null ? void 0 : d.meta,
      });
    }
    const f = (p) => {
      if (
        ((Gl(p) && p.silent) || this.dispatch({ type: "error", error: p }),
        !Gl(p))
      ) {
        var m, y, h, g;
        (m = (y = this.cache.config).onError) == null || m.call(y, p, this),
          (h = (g = this.cache.config).onSettled) == null ||
            h.call(g, this.state.data, p, this);
      }
      this.isFetchingOptimistic || this.scheduleGc(),
        (this.isFetchingOptimistic = !1);
    };
    return (
      (this.retryer = h5({
        fn: u.fetchFn,
        abort: s == null ? void 0 : s.abort.bind(s),
        onSuccess: (p) => {
          var m, y, h, g;
          if (typeof p > "u") {
            f(new Error(this.queryHash + " data is undefined"));
            return;
          }
          this.setData(p),
            (m = (y = this.cache.config).onSuccess) == null ||
              m.call(y, p, this),
            (h = (g = this.cache.config).onSettled) == null ||
              h.call(g, p, this.state.error, this),
            this.isFetchingOptimistic || this.scheduleGc(),
            (this.isFetchingOptimistic = !1);
        },
        onError: f,
        onFail: (p, m) => {
          this.dispatch({ type: "failed", failureCount: p, error: m });
        },
        onPause: () => {
          this.dispatch({ type: "pause" });
        },
        onContinue: () => {
          this.dispatch({ type: "continue" });
        },
        retry: u.options.retry,
        retryDelay: u.options.retryDelay,
        networkMode: u.options.networkMode,
      })),
      (this.promise = this.retryer.promise),
      this.promise
    );
  }
  dispatch(e) {
    const t = (r) => {
      var a, i;
      switch (e.type) {
        case "failed":
          return {
            ...r,
            fetchFailureCount: e.failureCount,
            fetchFailureReason: e.error,
          };
        case "pause":
          return { ...r, fetchStatus: "paused" };
        case "continue":
          return { ...r, fetchStatus: "fetching" };
        case "fetch":
          return {
            ...r,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta: (a = e.meta) != null ? a : null,
            fetchStatus: qd(this.options.networkMode) ? "fetching" : "paused",
            ...(!r.dataUpdatedAt && { error: null, status: "loading" }),
          };
        case "success":
          return {
            ...r,
            data: e.data,
            dataUpdateCount: r.dataUpdateCount + 1,
            dataUpdatedAt: (i = e.dataUpdatedAt) != null ? i : Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...(!e.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null,
            }),
          };
        case "error":
          const s = e.error;
          return Gl(s) && s.revert && this.revertState
            ? { ...this.revertState }
            : {
                ...r,
                error: s,
                errorUpdateCount: r.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: r.fetchFailureCount + 1,
                fetchFailureReason: s,
                fetchStatus: "idle",
                status: "error",
              };
        case "invalidate":
          return { ...r, isInvalidated: !0 };
        case "setState":
          return { ...r, ...e.state };
      }
    };
    (this.state = t(this.state)),
      pt.batch(() => {
        this.observers.forEach((r) => {
          r.onQueryUpdate(e);
        }),
          this.cache.notify({ query: this, type: "updated", action: e });
      });
  }
}
function d9(n) {
  const e =
      typeof n.initialData == "function" ? n.initialData() : n.initialData,
    t = typeof e < "u",
    r = t
      ? typeof n.initialDataUpdatedAt == "function"
        ? n.initialDataUpdatedAt()
        : n.initialDataUpdatedAt
      : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: t ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: t ? "success" : "loading",
    fetchStatus: "idle",
  };
}
class f9 extends ao {
  constructor(e) {
    super(),
      (this.config = e || {}),
      (this.queries = []),
      (this.queriesMap = {});
  }
  build(e, t, r) {
    var a;
    const i = t.queryKey,
      s = (a = t.queryHash) != null ? a : Hh(i, t);
    let o = this.get(s);
    return (
      o ||
        ((o = new u9({
          cache: this,
          logger: e.getLogger(),
          queryKey: i,
          queryHash: s,
          options: e.defaultQueryOptions(t),
          state: r,
          defaultOptions: e.getQueryDefaults(i),
        })),
        this.add(o)),
      o
    );
  }
  add(e) {
    this.queriesMap[e.queryHash] ||
      ((this.queriesMap[e.queryHash] = e),
      this.queries.push(e),
      this.notify({ type: "added", query: e }));
  }
  remove(e) {
    const t = this.queriesMap[e.queryHash];
    t &&
      (e.destroy(),
      (this.queries = this.queries.filter((r) => r !== e)),
      t === e && delete this.queriesMap[e.queryHash],
      this.notify({ type: "removed", query: e }));
  }
  clear() {
    pt.batch(() => {
      this.queries.forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return this.queriesMap[e];
  }
  getAll() {
    return this.queries;
  }
  find(e, t) {
    const [r] = Sa(e, t);
    return (
      typeof r.exact > "u" && (r.exact = !0), this.queries.find((a) => E1(r, a))
    );
  }
  findAll(e, t) {
    const [r] = Sa(e, t);
    return Object.keys(r).length > 0
      ? this.queries.filter((a) => E1(r, a))
      : this.queries;
  }
  notify(e) {
    pt.batch(() => {
      this.listeners.forEach(({ listener: t }) => {
        t(e);
      });
    });
  }
  onFocus() {
    pt.batch(() => {
      this.queries.forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    pt.batch(() => {
      this.queries.forEach((e) => {
        e.onOnline();
      });
    });
  }
}
class p9 extends m5 {
  constructor(e) {
    super(),
      (this.defaultOptions = e.defaultOptions),
      (this.mutationId = e.mutationId),
      (this.mutationCache = e.mutationCache),
      (this.logger = e.logger || qh),
      (this.observers = []),
      (this.state = e.state || y5()),
      this.setOptions(e.options),
      this.scheduleGc();
  }
  setOptions(e) {
    (this.options = { ...this.defaultOptions, ...e }),
      this.updateCacheTime(this.options.cacheTime);
  }
  get meta() {
    return this.options.meta;
  }
  setState(e) {
    this.dispatch({ type: "setState", state: e });
  }
  addObserver(e) {
    this.observers.includes(e) ||
      (this.observers.push(e),
      this.clearGcTimeout(),
      this.mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer: e,
      }));
  }
  removeObserver(e) {
    (this.observers = this.observers.filter((t) => t !== e)),
      this.scheduleGc(),
      this.mutationCache.notify({
        type: "observerRemoved",
        mutation: this,
        observer: e,
      });
  }
  optionalRemove() {
    this.observers.length ||
      (this.state.status === "loading"
        ? this.scheduleGc()
        : this.mutationCache.remove(this));
  }
  continue() {
    var e, t;
    return (e = (t = this.retryer) == null ? void 0 : t.continue()) != null
      ? e
      : this.execute();
  }
  async execute() {
    const e = () => {
        var _;
        return (
          (this.retryer = h5({
            fn: () =>
              this.options.mutationFn
                ? this.options.mutationFn(this.state.variables)
                : Promise.reject("No mutationFn found"),
            onFail: (S, W) => {
              this.dispatch({ type: "failed", failureCount: S, error: W });
            },
            onPause: () => {
              this.dispatch({ type: "pause" });
            },
            onContinue: () => {
              this.dispatch({ type: "continue" });
            },
            retry: (_ = this.options.retry) != null ? _ : 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
          })),
          this.retryer.promise
        );
      },
      t = this.state.status === "loading";
    try {
      var r, a, i, s, o, c, l, u;
      if (!t) {
        var d, f, p, m;
        this.dispatch({ type: "loading", variables: this.options.variables }),
          await ((d = (f = this.mutationCache.config).onMutate) == null
            ? void 0
            : d.call(f, this.state.variables, this));
        const S = await ((p = (m = this.options).onMutate) == null
          ? void 0
          : p.call(m, this.state.variables));
        S !== this.state.context &&
          this.dispatch({
            type: "loading",
            context: S,
            variables: this.state.variables,
          });
      }
      const _ = await e();
      return (
        await ((r = (a = this.mutationCache.config).onSuccess) == null
          ? void 0
          : r.call(a, _, this.state.variables, this.state.context, this)),
        await ((i = (s = this.options).onSuccess) == null
          ? void 0
          : i.call(s, _, this.state.variables, this.state.context)),
        await ((o = (c = this.mutationCache.config).onSettled) == null
          ? void 0
          : o.call(c, _, null, this.state.variables, this.state.context, this)),
        await ((l = (u = this.options).onSettled) == null
          ? void 0
          : l.call(u, _, null, this.state.variables, this.state.context)),
        this.dispatch({ type: "success", data: _ }),
        _
      );
    } catch (_) {
      try {
        var y, h, g, v, w, T, A, E;
        throw (
          (await ((y = (h = this.mutationCache.config).onError) == null
            ? void 0
            : y.call(h, _, this.state.variables, this.state.context, this)),
          await ((g = (v = this.options).onError) == null
            ? void 0
            : g.call(v, _, this.state.variables, this.state.context)),
          await ((w = (T = this.mutationCache.config).onSettled) == null
            ? void 0
            : w.call(
                T,
                void 0,
                _,
                this.state.variables,
                this.state.context,
                this,
              )),
          await ((A = (E = this.options).onSettled) == null
            ? void 0
            : A.call(E, void 0, _, this.state.variables, this.state.context)),
          _)
        );
      } finally {
        this.dispatch({ type: "error", error: _ });
      }
    }
  }
  dispatch(e) {
    const t = (r) => {
      switch (e.type) {
        case "failed":
          return { ...r, failureCount: e.failureCount, failureReason: e.error };
        case "pause":
          return { ...r, isPaused: !0 };
        case "continue":
          return { ...r, isPaused: !1 };
        case "loading":
          return {
            ...r,
            context: e.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !qd(this.options.networkMode),
            status: "loading",
            variables: e.variables,
          };
        case "success":
          return {
            ...r,
            data: e.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1,
          };
        case "error":
          return {
            ...r,
            data: void 0,
            error: e.error,
            failureCount: r.failureCount + 1,
            failureReason: e.error,
            isPaused: !1,
            status: "error",
          };
        case "setState":
          return { ...r, ...e.state };
      }
    };
    (this.state = t(this.state)),
      pt.batch(() => {
        this.observers.forEach((r) => {
          r.onMutationUpdate(e);
        }),
          this.mutationCache.notify({
            mutation: this,
            type: "updated",
            action: e,
          });
      });
  }
}
function y5() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
  };
}
class h9 extends ao {
  constructor(e) {
    super(),
      (this.config = e || {}),
      (this.mutations = []),
      (this.mutationId = 0);
  }
  build(e, t, r) {
    const a = new p9({
      mutationCache: this,
      logger: e.getLogger(),
      mutationId: ++this.mutationId,
      options: e.defaultMutationOptions(t),
      state: r,
      defaultOptions: t.mutationKey
        ? e.getMutationDefaults(t.mutationKey)
        : void 0,
    });
    return this.add(a), a;
  }
  add(e) {
    this.mutations.push(e), this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    (this.mutations = this.mutations.filter((t) => t !== e)),
      this.notify({ type: "removed", mutation: e });
  }
  clear() {
    pt.batch(() => {
      this.mutations.forEach((e) => {
        this.remove(e);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(e) {
    return (
      typeof e.exact > "u" && (e.exact = !0),
      this.mutations.find((t) => k1(e, t))
    );
  }
  findAll(e) {
    return this.mutations.filter((t) => k1(e, t));
  }
  notify(e) {
    pt.batch(() => {
      this.listeners.forEach(({ listener: t }) => {
        t(e);
      });
    });
  }
  resumePausedMutations() {
    var e;
    return (
      (this.resuming = ((e = this.resuming) != null ? e : Promise.resolve())
        .then(() => {
          const t = this.mutations.filter((r) => r.state.isPaused);
          return pt.batch(() =>
            t.reduce(
              (r, a) => r.then(() => a.continue().catch(Kn)),
              Promise.resolve(),
            ),
          );
        })
        .then(() => {
          this.resuming = void 0;
        })),
      this.resuming
    );
  }
}
function m9() {
  return {
    onFetch: (n) => {
      n.fetchFn = () => {
        var e, t, r, a, i, s;
        const o =
            (e = n.fetchOptions) == null || (t = e.meta) == null
              ? void 0
              : t.refetchPage,
          c =
            (r = n.fetchOptions) == null || (a = r.meta) == null
              ? void 0
              : a.fetchMore,
          l = c == null ? void 0 : c.pageParam,
          u = (c == null ? void 0 : c.direction) === "forward",
          d = (c == null ? void 0 : c.direction) === "backward",
          f = ((i = n.state.data) == null ? void 0 : i.pages) || [],
          p = ((s = n.state.data) == null ? void 0 : s.pageParams) || [];
        let m = p,
          y = !1;
        const h = (E) => {
            Object.defineProperty(E, "signal", {
              enumerable: !0,
              get: () => {
                var _;
                if ((_ = n.signal) != null && _.aborted) y = !0;
                else {
                  var S;
                  (S = n.signal) == null ||
                    S.addEventListener("abort", () => {
                      y = !0;
                    });
                }
                return n.signal;
              },
            });
          },
          g =
            n.options.queryFn ||
            (() =>
              Promise.reject(
                "Missing queryFn for queryKey '" + n.options.queryHash + "'",
              )),
          v = (E, _, S, W) => (
            (m = W ? [_, ...m] : [...m, _]), W ? [S, ...E] : [...E, S]
          ),
          w = (E, _, S, W) => {
            if (y) return Promise.reject("Cancelled");
            if (typeof S > "u" && !_ && E.length) return Promise.resolve(E);
            const D = {
              queryKey: n.queryKey,
              pageParam: S,
              meta: n.options.meta,
            };
            h(D);
            const L = g(D);
            return Promise.resolve(L).then((q) => v(E, S, q, W));
          };
        let T;
        if (!f.length) T = w([]);
        else if (u) {
          const E = typeof l < "u",
            _ = E ? l : R1(n.options, f);
          T = w(f, E, _);
        } else if (d) {
          const E = typeof l < "u",
            _ = E ? l : y9(n.options, f);
          T = w(f, E, _, !0);
        } else {
          m = [];
          const E = typeof n.options.getNextPageParam > "u";
          T = (o && f[0] ? o(f[0], 0, f) : !0)
            ? w([], E, p[0])
            : Promise.resolve(v([], p[0], f[0]));
          for (let S = 1; S < f.length; S++)
            T = T.then((W) => {
              if (o && f[S] ? o(f[S], S, f) : !0) {
                const L = E ? p[S] : R1(n.options, W);
                return w(W, E, L);
              }
              return Promise.resolve(v(W, p[S], f[S]));
            });
        }
        return T.then((E) => ({ pages: E, pageParams: m }));
      };
    },
  };
}
function R1(n, e) {
  return n.getNextPageParam == null
    ? void 0
    : n.getNextPageParam(e[e.length - 1], e);
}
function y9(n, e) {
  return n.getPreviousPageParam == null
    ? void 0
    : n.getPreviousPageParam(e[0], e);
}
class g9 {
  constructor(e = {}) {
    (this.queryCache = e.queryCache || new f9()),
      (this.mutationCache = e.mutationCache || new h9()),
      (this.logger = e.logger || qh),
      (this.defaultOptions = e.defaultOptions || {}),
      (this.queryDefaults = []),
      (this.mutationDefaults = []),
      (this.mountCount = 0);
  }
  mount() {
    this.mountCount++,
      this.mountCount === 1 &&
        ((this.unsubscribeFocus = bu.subscribe(() => {
          bu.isFocused() &&
            (this.resumePausedMutations(), this.queryCache.onFocus());
        })),
        (this.unsubscribeOnline = xu.subscribe(() => {
          xu.isOnline() &&
            (this.resumePausedMutations(), this.queryCache.onOnline());
        })));
  }
  unmount() {
    var e, t;
    this.mountCount--,
      this.mountCount === 0 &&
        ((e = this.unsubscribeFocus) == null || e.call(this),
        (this.unsubscribeFocus = void 0),
        (t = this.unsubscribeOnline) == null || t.call(this),
        (this.unsubscribeOnline = void 0));
  }
  isFetching(e, t) {
    const [r] = Sa(e, t);
    return (r.fetchStatus = "fetching"), this.queryCache.findAll(r).length;
  }
  isMutating(e) {
    return this.mutationCache.findAll({ ...e, fetching: !0 }).length;
  }
  getQueryData(e, t) {
    var r;
    return (r = this.queryCache.find(e, t)) == null ? void 0 : r.state.data;
  }
  ensureQueryData(e, t, r) {
    const a = $o(e, t, r),
      i = this.getQueryData(a.queryKey);
    return i ? Promise.resolve(i) : this.fetchQuery(a);
  }
  getQueriesData(e) {
    return this.getQueryCache()
      .findAll(e)
      .map(({ queryKey: t, state: r }) => {
        const a = r.data;
        return [t, a];
      });
  }
  setQueryData(e, t, r) {
    const a = this.queryCache.find(e),
      i = a == null ? void 0 : a.state.data,
      s = r9(t, i);
    if (typeof s > "u") return;
    const o = $o(e),
      c = this.defaultQueryOptions(o);
    return this.queryCache.build(this, c).setData(s, { ...r, manual: !0 });
  }
  setQueriesData(e, t, r) {
    return pt.batch(() =>
      this.getQueryCache()
        .findAll(e)
        .map(({ queryKey: a }) => [a, this.setQueryData(a, t, r)]),
    );
  }
  getQueryState(e, t) {
    var r;
    return (r = this.queryCache.find(e, t)) == null ? void 0 : r.state;
  }
  removeQueries(e, t) {
    const [r] = Sa(e, t),
      a = this.queryCache;
    pt.batch(() => {
      a.findAll(r).forEach((i) => {
        a.remove(i);
      });
    });
  }
  resetQueries(e, t, r) {
    const [a, i] = Sa(e, t, r),
      s = this.queryCache,
      o = { type: "active", ...a };
    return pt.batch(
      () => (
        s.findAll(a).forEach((c) => {
          c.reset();
        }),
        this.refetchQueries(o, i)
      ),
    );
  }
  cancelQueries(e, t, r) {
    const [a, i = {}] = Sa(e, t, r);
    typeof i.revert > "u" && (i.revert = !0);
    const s = pt.batch(() =>
      this.queryCache.findAll(a).map((o) => o.cancel(i)),
    );
    return Promise.all(s).then(Kn).catch(Kn);
  }
  invalidateQueries(e, t, r) {
    const [a, i] = Sa(e, t, r);
    return pt.batch(() => {
      var s, o;
      if (
        (this.queryCache.findAll(a).forEach((l) => {
          l.invalidate();
        }),
        a.refetchType === "none")
      )
        return Promise.resolve();
      const c = {
        ...a,
        type:
          (s = (o = a.refetchType) != null ? o : a.type) != null ? s : "active",
      };
      return this.refetchQueries(c, i);
    });
  }
  refetchQueries(e, t, r) {
    const [a, i] = Sa(e, t, r),
      s = pt.batch(() =>
        this.queryCache
          .findAll(a)
          .filter((c) => !c.isDisabled())
          .map((c) => {
            var l;
            return c.fetch(void 0, {
              ...i,
              cancelRefetch:
                (l = i == null ? void 0 : i.cancelRefetch) != null ? l : !0,
              meta: { refetchPage: a.refetchPage },
            });
          }),
      );
    let o = Promise.all(s).then(Kn);
    return (i != null && i.throwOnError) || (o = o.catch(Kn)), o;
  }
  fetchQuery(e, t, r) {
    const a = $o(e, t, r),
      i = this.defaultQueryOptions(a);
    typeof i.retry > "u" && (i.retry = !1);
    const s = this.queryCache.build(this, i);
    return s.isStaleByTime(i.staleTime)
      ? s.fetch(i)
      : Promise.resolve(s.state.data);
  }
  prefetchQuery(e, t, r) {
    return this.fetchQuery(e, t, r).then(Kn).catch(Kn);
  }
  fetchInfiniteQuery(e, t, r) {
    const a = $o(e, t, r);
    return (a.behavior = m9()), this.fetchQuery(a);
  }
  prefetchInfiniteQuery(e, t, r) {
    return this.fetchInfiniteQuery(e, t, r).then(Kn).catch(Kn);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(e) {
    this.defaultOptions = e;
  }
  setQueryDefaults(e, t) {
    const r = this.queryDefaults.find((a) => vi(e) === vi(a.queryKey));
    r
      ? (r.defaultOptions = t)
      : this.queryDefaults.push({ queryKey: e, defaultOptions: t });
  }
  getQueryDefaults(e) {
    if (!e) return;
    const t = this.queryDefaults.find((r) => gu(e, r.queryKey));
    return t == null ? void 0 : t.defaultOptions;
  }
  setMutationDefaults(e, t) {
    const r = this.mutationDefaults.find((a) => vi(e) === vi(a.mutationKey));
    r
      ? (r.defaultOptions = t)
      : this.mutationDefaults.push({ mutationKey: e, defaultOptions: t });
  }
  getMutationDefaults(e) {
    if (!e) return;
    const t = this.mutationDefaults.find((r) => gu(e, r.mutationKey));
    return t == null ? void 0 : t.defaultOptions;
  }
  defaultQueryOptions(e) {
    if (e != null && e._defaulted) return e;
    const t = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(e == null ? void 0 : e.queryKey),
      ...e,
      _defaulted: !0,
    };
    return (
      !t.queryHash && t.queryKey && (t.queryHash = Hh(t.queryKey, t)),
      typeof t.refetchOnReconnect > "u" &&
        (t.refetchOnReconnect = t.networkMode !== "always"),
      typeof t.useErrorBoundary > "u" && (t.useErrorBoundary = !!t.suspense),
      t
    );
  }
  defaultMutationOptions(e) {
    return e != null && e._defaulted
      ? e
      : {
          ...this.defaultOptions.mutations,
          ...this.getMutationDefaults(e == null ? void 0 : e.mutationKey),
          ...e,
          _defaulted: !0,
        };
  }
  clear() {
    this.queryCache.clear(), this.mutationCache.clear();
  }
}
class b9 extends ao {
  constructor(e, t) {
    super(),
      (this.client = e),
      (this.options = t),
      (this.trackedProps = new Set()),
      (this.selectError = null),
      this.bindMethods(),
      this.setOptions(t);
  }
  bindMethods() {
    (this.remove = this.remove.bind(this)),
      (this.refetch = this.refetch.bind(this));
  }
  onSubscribe() {
    this.listeners.size === 1 &&
      (this.currentQuery.addObserver(this),
      M1(this.currentQuery, this.options) && this.executeFetch(),
      this.updateTimers());
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return Pp(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return Pp(
      this.currentQuery,
      this.options,
      this.options.refetchOnWindowFocus,
    );
  }
  destroy() {
    (this.listeners = new Set()),
      this.clearStaleTimeout(),
      this.clearRefetchInterval(),
      this.currentQuery.removeObserver(this);
  }
  setOptions(e, t) {
    const r = this.options,
      a = this.currentQuery;
    if (
      ((this.options = this.client.defaultQueryOptions(e)),
      kp(r, this.options) ||
        this.client
          .getQueryCache()
          .notify({
            type: "observerOptionsUpdated",
            query: this.currentQuery,
            observer: this,
          }),
      typeof this.options.enabled < "u" &&
        typeof this.options.enabled != "boolean")
    )
      throw new Error("Expected enabled to be a boolean");
    this.options.queryKey || (this.options.queryKey = r.queryKey),
      this.updateQuery();
    const i = this.hasListeners();
    i && B1(this.currentQuery, a, this.options, r) && this.executeFetch(),
      this.updateResult(t),
      i &&
        (this.currentQuery !== a ||
          this.options.enabled !== r.enabled ||
          this.options.staleTime !== r.staleTime) &&
        this.updateStaleTimeout();
    const s = this.computeRefetchInterval();
    i &&
      (this.currentQuery !== a ||
        this.options.enabled !== r.enabled ||
        s !== this.currentRefetchInterval) &&
      this.updateRefetchInterval(s);
  }
  getOptimisticResult(e) {
    const t = this.client.getQueryCache().build(this.client, e),
      r = this.createResult(t, e);
    return (
      v9(this, r, e) &&
        ((this.currentResult = r),
        (this.currentResultOptions = this.options),
        (this.currentResultState = this.currentQuery.state)),
      r
    );
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(e) {
    const t = {};
    return (
      Object.keys(e).forEach((r) => {
        Object.defineProperty(t, r, {
          configurable: !1,
          enumerable: !0,
          get: () => (this.trackedProps.add(r), e[r]),
        });
      }),
      t
    );
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({ refetchPage: e, ...t } = {}) {
    return this.fetch({ ...t, meta: { refetchPage: e } });
  }
  fetchOptimistic(e) {
    const t = this.client.defaultQueryOptions(e),
      r = this.client.getQueryCache().build(this.client, t);
    return (
      (r.isFetchingOptimistic = !0),
      r.fetch().then(() => this.createResult(r, t))
    );
  }
  fetch(e) {
    var t;
    return this.executeFetch({
      ...e,
      cancelRefetch: (t = e.cancelRefetch) != null ? t : !0,
    }).then(() => (this.updateResult(), this.currentResult));
  }
  executeFetch(e) {
    this.updateQuery();
    let t = this.currentQuery.fetch(this.options, e);
    return (e != null && e.throwOnError) || (t = t.catch(Kn)), t;
  }
  updateStaleTimeout() {
    if (
      (this.clearStaleTimeout(),
      sc || this.currentResult.isStale || !Ep(this.options.staleTime))
    )
      return;
    const t = l5(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;
    this.staleTimeoutId = setTimeout(() => {
      this.currentResult.isStale || this.updateResult();
    }, t);
  }
  computeRefetchInterval() {
    var e;
    return typeof this.options.refetchInterval == "function"
      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)
      : (e = this.options.refetchInterval) != null
      ? e
      : !1;
  }
  updateRefetchInterval(e) {
    this.clearRefetchInterval(),
      (this.currentRefetchInterval = e),
      !(
        sc ||
        this.options.enabled === !1 ||
        !Ep(this.currentRefetchInterval) ||
        this.currentRefetchInterval === 0
      ) &&
        (this.refetchIntervalId = setInterval(() => {
          (this.options.refetchIntervalInBackground || bu.isFocused()) &&
            this.executeFetch();
        }, this.currentRefetchInterval));
  }
  updateTimers() {
    this.updateStaleTimeout(),
      this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    this.staleTimeoutId &&
      (clearTimeout(this.staleTimeoutId), (this.staleTimeoutId = void 0));
  }
  clearRefetchInterval() {
    this.refetchIntervalId &&
      (clearInterval(this.refetchIntervalId),
      (this.refetchIntervalId = void 0));
  }
  createResult(e, t) {
    const r = this.currentQuery,
      a = this.options,
      i = this.currentResult,
      s = this.currentResultState,
      o = this.currentResultOptions,
      c = e !== r,
      l = c ? e.state : this.currentQueryInitialState,
      u = c ? this.currentResult : this.previousQueryResult,
      { state: d } = e;
    let {
        dataUpdatedAt: f,
        error: p,
        errorUpdatedAt: m,
        fetchStatus: y,
        status: h,
      } = d,
      g = !1,
      v = !1,
      w;
    if (t._optimisticResults) {
      const S = this.hasListeners(),
        W = !S && M1(e, t),
        D = S && B1(e, r, t, a);
      (W || D) &&
        ((y = qd(e.options.networkMode) ? "fetching" : "paused"),
        f || (h = "loading")),
        t._optimisticResults === "isRestoring" && (y = "idle");
    }
    if (
      t.keepPreviousData &&
      !d.dataUpdatedAt &&
      u != null &&
      u.isSuccess &&
      h !== "error"
    )
      (w = u.data), (f = u.dataUpdatedAt), (h = u.status), (g = !0);
    else if (t.select && typeof d.data < "u")
      if (
        i &&
        d.data === (s == null ? void 0 : s.data) &&
        t.select === this.selectFn
      )
        w = this.selectResult;
      else
        try {
          (this.selectFn = t.select),
            (w = t.select(d.data)),
            (w = Sp(i == null ? void 0 : i.data, w, t)),
            (this.selectResult = w),
            (this.selectError = null);
        } catch (S) {
          this.selectError = S;
        }
    else w = d.data;
    if (typeof t.placeholderData < "u" && typeof w > "u" && h === "loading") {
      let S;
      if (
        i != null &&
        i.isPlaceholderData &&
        t.placeholderData === (o == null ? void 0 : o.placeholderData)
      )
        S = i.data;
      else if (
        ((S =
          typeof t.placeholderData == "function"
            ? t.placeholderData()
            : t.placeholderData),
        t.select && typeof S < "u")
      )
        try {
          (S = t.select(S)), (this.selectError = null);
        } catch (W) {
          this.selectError = W;
        }
      typeof S < "u" &&
        ((h = "success"),
        (w = Sp(i == null ? void 0 : i.data, S, t)),
        (v = !0));
    }
    this.selectError &&
      ((p = this.selectError),
      (w = this.selectResult),
      (m = Date.now()),
      (h = "error"));
    const T = y === "fetching",
      A = h === "loading",
      E = h === "error";
    return {
      status: h,
      fetchStatus: y,
      isLoading: A,
      isSuccess: h === "success",
      isError: E,
      isInitialLoading: A && T,
      data: w,
      dataUpdatedAt: f,
      error: p,
      errorUpdatedAt: m,
      failureCount: d.fetchFailureCount,
      failureReason: d.fetchFailureReason,
      errorUpdateCount: d.errorUpdateCount,
      isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0,
      isFetchedAfterMount:
        d.dataUpdateCount > l.dataUpdateCount ||
        d.errorUpdateCount > l.errorUpdateCount,
      isFetching: T,
      isRefetching: T && !A,
      isLoadingError: E && d.dataUpdatedAt === 0,
      isPaused: y === "paused",
      isPlaceholderData: v,
      isPreviousData: g,
      isRefetchError: E && d.dataUpdatedAt !== 0,
      isStale: Vh(e, t),
      refetch: this.refetch,
      remove: this.remove,
    };
  }
  updateResult(e) {
    const t = this.currentResult,
      r = this.createResult(this.currentQuery, this.options);
    if (
      ((this.currentResultState = this.currentQuery.state),
      (this.currentResultOptions = this.options),
      kp(r, t))
    )
      return;
    this.currentResult = r;
    const a = { cache: !0 },
      i = () => {
        if (!t) return !0;
        const { notifyOnChangeProps: s } = this.options,
          o = typeof s == "function" ? s() : s;
        if (o === "all" || (!o && !this.trackedProps.size)) return !0;
        const c = new Set(o ?? this.trackedProps);
        return (
          this.options.useErrorBoundary && c.add("error"),
          Object.keys(this.currentResult).some((l) => {
            const u = l;
            return this.currentResult[u] !== t[u] && c.has(u);
          })
        );
      };
    (e == null ? void 0 : e.listeners) !== !1 && i() && (a.listeners = !0),
      this.notify({ ...a, ...e });
  }
  updateQuery() {
    const e = this.client.getQueryCache().build(this.client, this.options);
    if (e === this.currentQuery) return;
    const t = this.currentQuery;
    (this.currentQuery = e),
      (this.currentQueryInitialState = e.state),
      (this.previousQueryResult = this.currentResult),
      this.hasListeners() &&
        (t == null || t.removeObserver(this), e.addObserver(this));
  }
  onQueryUpdate(e) {
    const t = {};
    e.type === "success"
      ? (t.onSuccess = !e.manual)
      : e.type === "error" && !Gl(e.error) && (t.onError = !0),
      this.updateResult(t),
      this.hasListeners() && this.updateTimers();
  }
  notify(e) {
    pt.batch(() => {
      if (e.onSuccess) {
        var t, r, a, i;
        (t = (r = this.options).onSuccess) == null ||
          t.call(r, this.currentResult.data),
          (a = (i = this.options).onSettled) == null ||
            a.call(i, this.currentResult.data, null);
      } else if (e.onError) {
        var s, o, c, l;
        (s = (o = this.options).onError) == null ||
          s.call(o, this.currentResult.error),
          (c = (l = this.options).onSettled) == null ||
            c.call(l, void 0, this.currentResult.error);
      }
      e.listeners &&
        this.listeners.forEach(({ listener: u }) => {
          u(this.currentResult);
        }),
        e.cache &&
          this.client
            .getQueryCache()
            .notify({
              query: this.currentQuery,
              type: "observerResultsUpdated",
            });
    });
  }
}
function x9(n, e) {
  return (
    e.enabled !== !1 &&
    !n.state.dataUpdatedAt &&
    !(n.state.status === "error" && e.retryOnMount === !1)
  );
}
function M1(n, e) {
  return x9(n, e) || (n.state.dataUpdatedAt > 0 && Pp(n, e, e.refetchOnMount));
}
function Pp(n, e, t) {
  if (e.enabled !== !1) {
    const r = typeof t == "function" ? t(n) : t;
    return r === "always" || (r !== !1 && Vh(n, e));
  }
  return !1;
}
function B1(n, e, t, r) {
  return (
    t.enabled !== !1 &&
    (n !== e || r.enabled === !1) &&
    (!t.suspense || n.state.status !== "error") &&
    Vh(n, t)
  );
}
function Vh(n, e) {
  return n.isStaleByTime(e.staleTime);
}
function v9(n, e, t) {
  return t.keepPreviousData
    ? !1
    : t.placeholderData !== void 0
    ? e.isPlaceholderData
    : n.getCurrentResult() !== e;
}
let w9 = class extends ao {
  constructor(e, t) {
    super(),
      (this.client = e),
      this.setOptions(t),
      this.bindMethods(),
      this.updateResult();
  }
  bindMethods() {
    (this.mutate = this.mutate.bind(this)),
      (this.reset = this.reset.bind(this));
  }
  setOptions(e) {
    var t;
    const r = this.options;
    (this.options = this.client.defaultMutationOptions(e)),
      kp(r, this.options) ||
        this.client
          .getMutationCache()
          .notify({
            type: "observerOptionsUpdated",
            mutation: this.currentMutation,
            observer: this,
          }),
      (t = this.currentMutation) == null || t.setOptions(this.options);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var e;
      (e = this.currentMutation) == null || e.removeObserver(this);
    }
  }
  onMutationUpdate(e) {
    this.updateResult();
    const t = { listeners: !0 };
    e.type === "success"
      ? (t.onSuccess = !0)
      : e.type === "error" && (t.onError = !0),
      this.notify(t);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  reset() {
    (this.currentMutation = void 0),
      this.updateResult(),
      this.notify({ listeners: !0 });
  }
  mutate(e, t) {
    return (
      (this.mutateOptions = t),
      this.currentMutation && this.currentMutation.removeObserver(this),
      (this.currentMutation = this.client
        .getMutationCache()
        .build(this.client, {
          ...this.options,
          variables: typeof e < "u" ? e : this.options.variables,
        })),
      this.currentMutation.addObserver(this),
      this.currentMutation.execute()
    );
  }
  updateResult() {
    const e = this.currentMutation ? this.currentMutation.state : y5(),
      t = {
        ...e,
        isLoading: e.status === "loading",
        isSuccess: e.status === "success",
        isError: e.status === "error",
        isIdle: e.status === "idle",
        mutate: this.mutate,
        reset: this.reset,
      };
    this.currentResult = t;
  }
  notify(e) {
    pt.batch(() => {
      if (this.mutateOptions && this.hasListeners()) {
        if (e.onSuccess) {
          var t, r, a, i;
          (t = (r = this.mutateOptions).onSuccess) == null ||
            t.call(
              r,
              this.currentResult.data,
              this.currentResult.variables,
              this.currentResult.context,
            ),
            (a = (i = this.mutateOptions).onSettled) == null ||
              a.call(
                i,
                this.currentResult.data,
                null,
                this.currentResult.variables,
                this.currentResult.context,
              );
        } else if (e.onError) {
          var s, o, c, l;
          (s = (o = this.mutateOptions).onError) == null ||
            s.call(
              o,
              this.currentResult.error,
              this.currentResult.variables,
              this.currentResult.context,
            ),
            (c = (l = this.mutateOptions).onSettled) == null ||
              c.call(
                l,
                void 0,
                this.currentResult.error,
                this.currentResult.variables,
                this.currentResult.context,
              );
        }
      }
      e.listeners &&
        this.listeners.forEach(({ listener: u }) => {
          u(this.currentResult);
        });
    });
  }
};
var g5 = { exports: {} },
  b5 = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Fs = C;
function T9(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var C9 = typeof Object.is == "function" ? Object.is : T9,
  A9 = Fs.useState,
  E9 = Fs.useEffect,
  k9 = Fs.useLayoutEffect,
  _9 = Fs.useDebugValue;
function S9(n, e) {
  var t = e(),
    r = A9({ inst: { value: t, getSnapshot: e } }),
    a = r[0].inst,
    i = r[1];
  return (
    k9(
      function () {
        (a.value = t), (a.getSnapshot = e), t0(a) && i({ inst: a });
      },
      [n, t, e],
    ),
    E9(
      function () {
        return (
          t0(a) && i({ inst: a }),
          n(function () {
            t0(a) && i({ inst: a });
          })
        );
      },
      [n],
    ),
    _9(t),
    t
  );
}
function t0(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !C9(n, t);
  } catch {
    return !0;
  }
}
function P9(n, e) {
  return e();
}
var I9 =
  typeof window > "u" ||
  typeof window.document > "u" ||
  typeof window.document.createElement > "u"
    ? P9
    : S9;
b5.useSyncExternalStore =
  Fs.useSyncExternalStore !== void 0 ? Fs.useSyncExternalStore : I9;
g5.exports = b5;
var R9 = g5.exports;
const x5 = R9.useSyncExternalStore,
  D1 = C.createContext(void 0),
  v5 = C.createContext(!1);
function w5(n, e) {
  return (
    n ||
    (e && typeof window < "u"
      ? (window.ReactQueryClientContext ||
          (window.ReactQueryClientContext = D1),
        window.ReactQueryClientContext)
      : D1)
  );
}
const Hc = ({ context: n } = {}) => {
    const e = C.useContext(w5(n, C.useContext(v5)));
    if (!e)
      throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return e;
  },
  M9 = ({ client: n, children: e, context: t, contextSharing: r = !1 }) => {
    C.useEffect(
      () => (
        n.mount(),
        () => {
          n.unmount();
        }
      ),
      [n],
    );
    const a = w5(t, r);
    return C.createElement(
      v5.Provider,
      { value: !t && r },
      C.createElement(a.Provider, { value: n }, e),
    );
  },
  T5 = C.createContext(!1),
  B9 = () => C.useContext(T5);
T5.Provider;
function D9() {
  let n = !1;
  return {
    clearReset: () => {
      n = !1;
    },
    reset: () => {
      n = !0;
    },
    isReset: () => n,
  };
}
const O9 = C.createContext(D9()),
  N9 = () => C.useContext(O9);
function C5(n, e) {
  return typeof n == "function" ? n(...e) : !!n;
}
const F9 = (n, e) => {
    (n.suspense || n.useErrorBoundary) &&
      (e.isReset() || (n.retryOnMount = !1));
  },
  L9 = (n) => {
    C.useEffect(() => {
      n.clearReset();
    }, [n]);
  },
  $9 = ({ result: n, errorResetBoundary: e, useErrorBoundary: t, query: r }) =>
    n.isError && !e.isReset() && !n.isFetching && C5(t, [n.error, r]),
  W9 = (n) => {
    n.suspense && typeof n.staleTime != "number" && (n.staleTime = 1e3);
  },
  U9 = (n, e) => n.isLoading && n.isFetching && !e,
  j9 = (n, e, t) => (n == null ? void 0 : n.suspense) && U9(e, t),
  z9 = (n, e, t) =>
    e
      .fetchOptimistic(n)
      .then(({ data: r }) => {
        n.onSuccess == null || n.onSuccess(r),
          n.onSettled == null || n.onSettled(r, null);
      })
      .catch((r) => {
        t.clearReset(),
          n.onError == null || n.onError(r),
          n.onSettled == null || n.onSettled(void 0, r);
      });
function H9(n, e) {
  const t = Hc({ context: n.context }),
    r = B9(),
    a = N9(),
    i = t.defaultQueryOptions(n);
  (i._optimisticResults = r ? "isRestoring" : "optimistic"),
    i.onError && (i.onError = pt.batchCalls(i.onError)),
    i.onSuccess && (i.onSuccess = pt.batchCalls(i.onSuccess)),
    i.onSettled && (i.onSettled = pt.batchCalls(i.onSettled)),
    W9(i),
    F9(i, a),
    L9(a);
  const [s] = C.useState(() => new e(t, i)),
    o = s.getOptimisticResult(i);
  if (
    (x5(
      C.useCallback(
        (c) => {
          const l = r ? () => {} : s.subscribe(pt.batchCalls(c));
          return s.updateResult(), l;
        },
        [s, r],
      ),
      () => s.getCurrentResult(),
      () => s.getCurrentResult(),
    ),
    C.useEffect(() => {
      s.setOptions(i, { listeners: !1 });
    }, [i, s]),
    j9(i, o, r))
  )
    throw z9(i, s, a);
  if (
    $9({
      result: o,
      errorResetBoundary: a,
      useErrorBoundary: i.useErrorBoundary,
      query: s.getCurrentQuery(),
    })
  )
    throw o.error;
  return i.notifyOnChangeProps ? o : s.trackResult(o);
}
function q9(n, e, t) {
  const r = $o(n, e, t);
  return H9(r, b9);
}
function A5(n, e, t) {
  const r = a9(n, e, t),
    a = Hc({ context: r.context }),
    [i] = C.useState(() => new w9(a, r));
  C.useEffect(() => {
    i.setOptions(r);
  }, [i, r]);
  const s = x5(
      C.useCallback((c) => i.subscribe(pt.batchCalls(c)), [i]),
      () => i.getCurrentResult(),
      () => i.getCurrentResult(),
    ),
    o = C.useCallback(
      (c, l) => {
        i.mutate(c, l).catch(V9);
      },
      [i],
    );
  if (s.error && C5(i.options.useErrorBoundary, [s.error])) throw s.error;
  return { ...s, mutate: o, mutateAsync: s.mutate };
}
function V9() {}
var G9 = !0,
  n0 = "Invariant failed";
function ce(n, e) {
  if (!n) {
    if (G9) throw new Error(n0);
    var t = typeof e == "function" ? e() : e,
      r = t ? "".concat(n0, ": ").concat(t) : n0;
    throw new Error(r);
  }
}
var K9 = {
    name: "Ethereum Mainnet",
    chain: "ETH",
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    rpc: [
      "https://ethereum.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://mainnet.infura.io/v3/${INFURA_API_KEY}",
      "wss://mainnet.infura.io/ws/v3/${INFURA_API_KEY}",
      "https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://api.mycryptoapi.com/eth",
      "https://cloudflare-eth.com",
      "https://ethereum.publicnode.com",
    ],
    features: [{ name: "EIP1559" }, { name: "EIP155" }],
    faucets: [],
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    infoURL: "https://ethereum.org",
    shortName: "eth",
    chainId: 1,
    networkId: 1,
    slip44: 60,
    ens: { registry: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    explorers: [
      { name: "etherscan", url: "https://etherscan.io", standard: "EIP3091" },
      {
        name: "blockscout",
        url: "https://eth.blockscout.com",
        icon: {
          url: "ipfs://QmYtUimyqHkkFxYdbXXRbUqNg2VLPUg6Uu2C2nmFWowiZM",
          width: 551,
          height: 540,
          format: "png",
        },
        standard: "EIP3091",
      },
    ],
    testnet: !1,
    slug: "ethereum",
  },
  Q9 = {
    name: "Goerli",
    title: "Ethereum Testnet Goerli",
    chain: "ETH",
    rpc: [
      "https://goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://goerli.infura.io/v3/${INFURA_API_KEY}",
      "wss://goerli.infura.io/v3/${INFURA_API_KEY}",
      "https://eth-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://rpc.goerli.mudit.blog/",
      "https://ethereum-goerli.publicnode.com",
    ],
    faucets: [
      "https://faucet.paradigm.xyz/",
      "http://fauceth.komputing.org?chain=5&address=${ADDRESS}",
      "https://goerli-faucet.slock.it?address=${ADDRESS}",
      "https://faucet.goerli.mudit.blog",
    ],
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    infoURL: "https://goerli.net/#about",
    shortName: "gor",
    chainId: 5,
    networkId: 5,
    ens: { registry: "0x112234455c3a32fd11230c42e7bccd4a84e02010" },
    explorers: [
      {
        name: "etherscan-goerli",
        url: "https://goerli.etherscan.io",
        standard: "EIP3091",
      },
      {
        name: "blockscout-goerli",
        url: "https://eth-goerli.blockscout.com",
        icon: {
          url: "ipfs://QmYtUimyqHkkFxYdbXXRbUqNg2VLPUg6Uu2C2nmFWowiZM",
          width: 551,
          height: 540,
          format: "png",
        },
        standard: "EIP3091",
      },
    ],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    testnet: !0,
    slug: "goerli",
  },
  Y9 = {
    name: "OP Mainnet",
    chain: "ETH",
    rpc: [
      "https://optimism.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://optimism-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://opt-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://mainnet.optimism.io",
      "https://optimism.publicnode.com",
    ],
    faucets: [],
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    infoURL: "https://optimism.io",
    shortName: "oeth",
    chainId: 10,
    networkId: 10,
    explorers: [
      {
        name: "etherscan",
        url: "https://optimistic.etherscan.io",
        standard: "EIP3091",
      },
      {
        name: "blockscout",
        url: "https://optimism.blockscout.com",
        icon: {
          url: "ipfs://QmYtUimyqHkkFxYdbXXRbUqNg2VLPUg6Uu2C2nmFWowiZM",
          width: 551,
          height: 540,
          format: "png",
        },
        standard: "EIP3091",
      },
    ],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/optimism/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    testnet: !1,
    slug: "optimism",
  },
  J9 = {
    name: "BNB Smart Chain Mainnet",
    chain: "BSC",
    rpc: [
      "https://binance.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "wss://bsc-ws-node.nariox.org",
      "https://bsc.publicnode.com",
      "https://bsc-dataseed4.ninicoin.io",
      "https://bsc-dataseed3.ninicoin.io",
      "https://bsc-dataseed2.ninicoin.io",
      "https://bsc-dataseed1.ninicoin.io",
      "https://bsc-dataseed4.defibit.io",
      "https://bsc-dataseed3.defibit.io",
      "https://bsc-dataseed2.defibit.io",
      "https://bsc-dataseed1.defibit.io",
      "https://bsc-dataseed4.bnbchain.org",
      "https://bsc-dataseed3.bnbchain.org",
      "https://bsc-dataseed2.bnbchain.org",
      "https://bsc-dataseed1.bnbchain.org",
    ],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    nativeCurrency: {
      name: "BNB Chain Native Token",
      symbol: "BNB",
      decimals: 18,
    },
    infoURL: "https://www.bnbchain.org/en",
    shortName: "bnb",
    chainId: 56,
    networkId: 56,
    slip44: 714,
    explorers: [
      { name: "bscscan", url: "https://bscscan.com", standard: "EIP3091" },
    ],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/binance-coin/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    testnet: !1,
    slug: "binance",
  },
  X9 = {
    name: "BNB Smart Chain Testnet",
    chain: "BSC",
    rpc: [
      "https://binance-testnet.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://bsc-testnet.publicnode.com",
      "https://data-seed-prebsc-2-s3.bnbchain.org:8545",
      "https://data-seed-prebsc-1-s3.bnbchain.org:8545",
      "https://data-seed-prebsc-2-s2.bnbchain.org:8545",
      "https://data-seed-prebsc-1-s2.bnbchain.org:8545",
      "https://data-seed-prebsc-2-s1.bnbchain.org:8545",
      "https://data-seed-prebsc-1-s1.bnbchain.org:8545",
    ],
    faucets: ["https://testnet.bnbchain.org/faucet-smart"],
    nativeCurrency: {
      name: "BNB Chain Native Token",
      symbol: "tBNB",
      decimals: 18,
    },
    infoURL: "https://www.bnbchain.org/en",
    shortName: "bnbt",
    chainId: 97,
    networkId: 97,
    explorers: [
      {
        name: "bscscan-testnet",
        url: "https://testnet.bscscan.com",
        standard: "EIP3091",
      },
    ],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/binance-coin/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    testnet: !0,
    slug: "binance-testnet",
  },
  Z9 = {
    name: "Polygon Mainnet",
    chain: "Polygon",
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/polygon/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    rpc: [
      "https://polygon.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://polygon-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://polygon-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://polygon-rpc.com/",
      "https://rpc-mainnet.matic.network",
      "https://matic-mainnet.chainstacklabs.com",
      "https://rpc-mainnet.maticvigil.com",
      "https://rpc-mainnet.matic.quiknode.pro",
      "https://matic-mainnet-full-rpc.bwarelabs.com",
      "https://polygon-bor.publicnode.com",
    ],
    faucets: [],
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    infoURL: "https://polygon.technology/",
    shortName: "matic",
    chainId: 137,
    networkId: 137,
    slip44: 966,
    explorers: [
      {
        name: "polygonscan",
        url: "https://polygonscan.com",
        standard: "EIP3091",
      },
    ],
    testnet: !1,
    slug: "polygon",
  },
  ek = {
    name: "Fantom Opera",
    chain: "FTM",
    rpc: [
      "https://fantom.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://fantom.publicnode.com",
      "https://rpc.ftm.tools",
    ],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    nativeCurrency: { name: "Fantom", symbol: "FTM", decimals: 18 },
    infoURL: "https://fantom.foundation",
    shortName: "ftm",
    chainId: 250,
    networkId: 250,
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/fantom/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    explorers: [
      {
        name: "ftmscan",
        url: "https://ftmscan.com",
        icon: {
          url: "ipfs://QmRqbK449Fo9sJ3xMpkPbg6uV1weQj4yVV1xNMP9cdPmjf",
          width: 73,
          height: 73,
          format: "png",
        },
        standard: "EIP3091",
      },
    ],
    testnet: !1,
    slug: "fantom",
  },
  tk = {
    name: "Optimism Goerli Testnet",
    chain: "ETH",
    rpc: [
      "https://optimism-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://optimism-goerli.infura.io/v3/${INFURA_API_KEY}",
      "https://opt-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://goerli.optimism.io",
      "https://optimism-goerli.publicnode.com",
    ],
    faucets: ["https://coinbase.com/faucets/optimism-goerli-faucet"],
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    infoURL: "https://optimism.io",
    shortName: "ogor",
    chainId: 420,
    networkId: 420,
    explorers: [
      {
        name: "blockscout",
        url: "https://optimism-goerli.blockscout.com",
        icon: {
          url: "ipfs://QmYtUimyqHkkFxYdbXXRbUqNg2VLPUg6Uu2C2nmFWowiZM",
          width: 551,
          height: 540,
          format: "png",
        },
        standard: "EIP3091",
      },
    ],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/optimism/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    testnet: !0,
    slug: "optimism-goerli",
  },
  nk = {
    name: "Fantom Testnet",
    chain: "FTM",
    rpc: [
      "https://fantom-testnet.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://fantom-testnet.publicnode.com",
      "https://rpc.testnet.fantom.network",
    ],
    faucets: ["https://faucet.fantom.network"],
    nativeCurrency: { name: "Fantom", symbol: "FTM", decimals: 18 },
    infoURL:
      "https://docs.fantom.foundation/quick-start/short-guide#fantom-testnet",
    shortName: "tftm",
    chainId: 4002,
    networkId: 4002,
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/fantom/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    explorers: [
      {
        name: "ftmscan",
        url: "https://testnet.ftmscan.com",
        icon: {
          url: "ipfs://QmRqbK449Fo9sJ3xMpkPbg6uV1weQj4yVV1xNMP9cdPmjf",
          width: 73,
          height: 73,
          format: "png",
        },
        standard: "EIP3091",
      },
    ],
    testnet: !0,
    slug: "fantom-testnet",
  },
  rk = {
    name: "Base",
    chain: "ETH",
    rpc: [
      "https://base.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://mainnet.base.org/",
    ],
    faucets: [],
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    infoURL: "https://base.org",
    shortName: "base",
    chainId: 8453,
    networkId: 8453,
    icon: {
      url: "ipfs://QmW5Vn15HeRkScMfPcW12ZdZcC2yUASpu6eCsECRdEmjjj/base-512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    explorers: [
      {
        name: "basescout",
        url: "https://base.blockscout.com",
        icon: {
          url: "ipfs://QmYtUimyqHkkFxYdbXXRbUqNg2VLPUg6Uu2C2nmFWowiZM",
          width: 551,
          height: 540,
          format: "png",
        },
        standard: "EIP3091",
      },
      { name: "basescan", url: "https://basescan.org", standard: "none" },
    ],
    status: "active",
    testnet: !1,
    slug: "base",
  },
  ak = {
    name: "Arbitrum One",
    chainId: 42161,
    shortName: "arb1",
    chain: "ETH",
    networkId: 42161,
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpc: [
      "https://arbitrum.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://arbitrum-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://arb1.arbitrum.io/rpc",
      "https://arbitrum-one.publicnode.com",
    ],
    faucets: [],
    explorers: [
      {
        name: "Arbitrum Explorer",
        url: "https://explorer.arbitrum.io",
        standard: "EIP3091",
      },
      { name: "Arbiscan", url: "https://arbiscan.io", standard: "EIP3091" },
    ],
    infoURL: "https://arbitrum.io",
    parent: {
      type: "L2",
      chain: "eip155-1",
      bridges: [{ url: "https://bridge.arbitrum.io" }],
    },
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/arbitrum/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    testnet: !1,
    slug: "arbitrum",
  },
  ik = {
    name: "Avalanche Fuji Testnet",
    chain: "AVAX",
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/avalanche/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    rpc: [
      "https://avalanche-fuji.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://avalanche-fuji.infura.io/v3/${INFURA_API_KEY}",
      "https://api.avax-test.network/ext/bc/C/rpc",
      "https://avalanche-fuji-c-chain.publicnode.com",
    ],
    faucets: [
      "https://faucet.avax.network/",
      "https://faucet.avax-test.network/",
    ],
    nativeCurrency: { name: "Avalanche", symbol: "AVAX", decimals: 18 },
    infoURL: "https://cchain.explorer.avax-test.network",
    shortName: "Fuji",
    chainId: 43113,
    networkId: 1,
    explorers: [
      {
        name: "snowtrace",
        url: "https://testnet.snowtrace.io",
        standard: "EIP3091",
      },
    ],
    testnet: !0,
    slug: "avalanche-fuji",
  },
  sk = {
    name: "Avalanche C-Chain",
    chain: "AVAX",
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/avalanche/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    rpc: [
      "https://avalanche.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://avalanche-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://api.avax.network/ext/bc/C/rpc",
      "https://avalanche-c-chain.publicnode.com",
    ],
    features: [{ name: "EIP1559" }],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    nativeCurrency: { name: "Avalanche", symbol: "AVAX", decimals: 18 },
    infoURL: "https://www.avax.network/",
    shortName: "avax",
    chainId: 43114,
    networkId: 43114,
    slip44: 9005,
    explorers: [
      { name: "snowtrace", url: "https://snowtrace.io", standard: "EIP3091" },
    ],
    testnet: !1,
    slug: "avalanche",
  },
  ok = {
    name: "Mumbai",
    title: "Polygon Testnet Mumbai",
    chain: "Polygon",
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/polygon/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    rpc: [
      "https://mumbai.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://polygon-mumbai.infura.io/v3/${INFURA_API_KEY}",
      "https://polygon-mumbai.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://matic-mumbai.chainstacklabs.com",
      "https://rpc-mumbai.maticvigil.com",
      "https://matic-testnet-archive-rpc.bwarelabs.com",
      "https://polygon-mumbai-bor.publicnode.com",
    ],
    faucets: ["https://faucet.polygon.technology/"],
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    infoURL: "https://polygon.technology/",
    shortName: "maticmum",
    chainId: 80001,
    networkId: 80001,
    explorers: [
      {
        name: "polygonscan",
        url: "https://mumbai.polygonscan.com",
        standard: "EIP3091",
      },
    ],
    testnet: !0,
    slug: "mumbai",
  },
  ck = {
    name: "Base Goerli Testnet",
    chain: "ETH",
    rpc: [
      "https://base-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://goerli.base.org",
    ],
    faucets: ["https://www.coinbase.com/faucets/base-ethereum-goerli-faucet"],
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    infoURL: "https://base.org",
    shortName: "basegor",
    chainId: 84531,
    networkId: 84531,
    icon: {
      url: "ipfs://QmW5Vn15HeRkScMfPcW12ZdZcC2yUASpu6eCsECRdEmjjj/base-512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    explorers: [
      {
        name: "basescout",
        url: "https://base-goerli.blockscout.com",
        icon: {
          url: "ipfs://QmYtUimyqHkkFxYdbXXRbUqNg2VLPUg6Uu2C2nmFWowiZM",
          width: 551,
          height: 540,
          format: "png",
        },
        standard: "EIP3091",
      },
      {
        name: "basescan",
        url: "https://goerli.basescan.org",
        standard: "none",
      },
    ],
    testnet: !0,
    slug: "base-goerli",
  },
  lk = {
    name: "Arbitrum Goerli",
    title: "Arbitrum Goerli Rollup Testnet",
    chainId: 421613,
    shortName: "arb-goerli",
    chain: "ETH",
    networkId: 421613,
    nativeCurrency: {
      name: "Arbitrum Goerli Ether",
      symbol: "AGOR",
      decimals: 18,
    },
    rpc: [
      "https://arbitrum-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://arbitrum-goerli.infura.io/v3/${INFURA_API_KEY}",
      "https://arb-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://goerli-rollup.arbitrum.io/rpc",
      "https://arbitrum-goerli.publicnode.com",
    ],
    faucets: [],
    infoURL: "https://arbitrum.io/",
    explorers: [
      {
        name: "Arbitrum Goerli Rollup Explorer",
        url: "https://goerli-rollup-explorer.arbitrum.io",
        standard: "EIP3091",
      },
    ],
    parent: {
      type: "L2",
      chain: "eip155-5",
      bridges: [{ url: "https://bridge.arbitrum.io/" }],
    },
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/arbitrum/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    testnet: !0,
    slug: "arbitrum-goerli",
  },
  uk = {
    name: "Localhost",
    chain: "ETH",
    rpc: ["http://localhost:8545"],
    faucets: [],
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      height: 512,
      width: 512,
      format: "png",
    },
    shortName: "local",
    chainId: 1337,
    networkId: 1337,
    testnet: !0,
    slug: "localhost",
  };
function Vd(n, e) {
  let t =
    arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "http";
  const r = [];
  if (
    (n.rpc.forEach((a) => {
      if (
        !(t === "http" && !a.startsWith("http")) &&
        !(t === "ws" && !a.startsWith("ws"))
      )
        if (a.includes("${THIRDWEB_API_KEY}"))
          e
            ? r.push(
                a.replace("${THIRDWEB_API_KEY}", e) +
                  (typeof globalThis < "u" && "APP_BUNDLE_ID" in globalThis
                    ? `/?bundleId=${globalThis.APP_BUNDLE_ID}`
                    : ""),
              )
            : r.push(a.replace("${THIRDWEB_API_KEY}", ""));
        else {
          if (a.includes("${")) return;
          r.push(a);
        }
    }),
    r.length === 0)
  )
    throw new Error(
      `No RPC available for chainId "${n.chainId}" with mode ${t}`,
    );
  return r;
}
function vu(n, e) {
  try {
    return { ...n, rpc: Vd(n, e) };
  } catch {
    return n;
  }
}
const oi = [K9, Q9, rk, ck, Z9, ok, ak, lk, Y9, tk, J9, X9, ek, nk, sk, ik, uk],
  dk = (n) => {
    let { queryClient: e, children: t } = n;
    const r = C.useMemo(() => e || new g9(), [e]);
    return I.jsx(M9, { client: r, children: t });
  },
  O1 = (() => M.instanceof(File))(),
  fk = (() =>
    M.union([
      O1,
      M.object({ data: M.union([O1, M.string()]), name: M.string() }),
    ]))(),
  Di = (() => M.union([fk, M.string()]))(),
  E5 = 1e4,
  pk = (() => M.union([M.array(M.number()), M.string()]))(),
  k5 = (() =>
    M.union([
      M.bigint(),
      M.custom((n) => O.isBigNumber(n)),
      M.custom((n) => Te.isBN(n)),
    ]).transform((n) =>
      Te.isBN(n) ? new Te(n).toString() : O.from(n).toString(),
    ))(),
  io = M.number().max(E5, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
  hk = M.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
  mk = (() =>
    M.union([
      M.string().regex(
        /^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,
        "Invalid hex color",
      ),
      M.string()
        .regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color")
        .transform((n) => n.replace("#", "")),
      M.string().length(0),
    ]))(),
  Cn = (() =>
    M.union([
      M.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"),
      M.number().min(0, "Amount cannot be negative"),
    ]).transform((n) => (typeof n == "number" ? n.toString() : n)))(),
  Ls = (() => M.union([Cn, M.literal("unlimited")]).default("unlimited"))(),
  N1 = (() => M.object({}).catchall(M.union([k5, M.unknown()])))(),
  F1 = (() =>
    M.union([M.array(N1), N1])
      .optional()
      .nullable())(),
  _5 = (() =>
    M.object({
      name: M.union([M.string(), M.number()]).optional().nullable(),
      description: M.string().nullable().optional().nullable(),
      image: Di.nullable().optional(),
      animation_url: Di.optional().nullable(),
    }))(),
  Xa = (() =>
    _5
      .extend({
        external_url: Di.nullable().optional(),
        background_color: mk.optional().nullable(),
        properties: F1,
        attributes: F1,
      })
      .catchall(M.union([k5, M.unknown()])))(),
  Gd = (() => M.union([Xa, M.string()]))(),
  Ip = (() =>
    Xa.extend({
      id: M.string(),
      uri: M.string(),
      image: M.string().nullable().optional(),
      external_url: M.string().nullable().optional(),
      animation_url: M.string().nullable().optional(),
    }))(),
  Ko = 100;
var so = {},
  Rp = { exports: {} };
function yk(n) {
  if (n.length >= 255) throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), t = 0; t < e.length; t++) e[t] = 255;
  for (var r = 0; r < n.length; r++) {
    var a = n.charAt(r),
      i = a.charCodeAt(0);
    if (e[i] !== 255) throw new TypeError(a + " is ambiguous");
    e[i] = r;
  }
  var s = n.length,
    o = n.charAt(0),
    c = Math.log(s) / Math.log(256),
    l = Math.log(256) / Math.log(s);
  function u(p) {
    if (
      (p instanceof Uint8Array ||
        (ArrayBuffer.isView(p)
          ? (p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength))
          : Array.isArray(p) && (p = Uint8Array.from(p))),
      !(p instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (p.length === 0) return "";
    for (var m = 0, y = 0, h = 0, g = p.length; h !== g && p[h] === 0; )
      h++, m++;
    for (var v = ((g - h) * l + 1) >>> 0, w = new Uint8Array(v); h !== g; ) {
      for (
        var T = p[h], A = 0, E = v - 1;
        (T !== 0 || A < y) && E !== -1;
        E--, A++
      )
        (T += (256 * w[E]) >>> 0), (w[E] = T % s >>> 0), (T = (T / s) >>> 0);
      if (T !== 0) throw new Error("Non-zero carry");
      (y = A), h++;
    }
    for (var _ = v - y; _ !== v && w[_] === 0; ) _++;
    for (var S = o.repeat(m); _ < v; ++_) S += n.charAt(w[_]);
    return S;
  }
  function d(p) {
    if (typeof p != "string") throw new TypeError("Expected String");
    if (p.length === 0) return new Uint8Array();
    var m = 0;
    if (p[m] !== " ") {
      for (var y = 0, h = 0; p[m] === o; ) y++, m++;
      for (
        var g = ((p.length - m) * c + 1) >>> 0, v = new Uint8Array(g);
        p[m];

      ) {
        var w = e[p.charCodeAt(m)];
        if (w === 255) return;
        for (var T = 0, A = g - 1; (w !== 0 || T < h) && A !== -1; A--, T++)
          (w += (s * v[A]) >>> 0),
            (v[A] = w % 256 >>> 0),
            (w = (w / 256) >>> 0);
        if (w !== 0) throw new Error("Non-zero carry");
        (h = T), m++;
      }
      if (p[m] !== " ") {
        for (var E = g - h; E !== g && v[E] === 0; ) E++;
        for (var _ = new Uint8Array(y + (g - E)), S = y; E !== g; )
          _[S++] = v[E++];
        return _;
      }
    }
  }
  function f(p) {
    var m = d(p);
    if (m) return m;
    throw new Error("Non-base" + s + " character");
  }
  return { encode: u, decodeUnsafe: d, decode: f };
}
var gk = yk;
const bk = new TextDecoder(),
  xk = (n) => bk.decode(n),
  vk = new TextEncoder(),
  wk = (n) => vk.encode(n);
function Tk(n, e) {
  const t = new Uint8Array(e);
  let r = 0;
  for (const a of n) t.set(a, r), (r += a.length);
  return t;
}
var Gh = { decodeText: xk, encodeText: wk, concat: Tk };
const { encodeText: Ck } = Gh;
let Ak = class {
  constructor(e, t, r, a) {
    (this.name = e),
      (this.code = t),
      (this.codeBuf = Ck(this.code)),
      (this.alphabet = a),
      (this.codec = r(a));
  }
  encode(e) {
    return this.codec.encode(e);
  }
  decode(e) {
    for (const t of e)
      if (this.alphabet && this.alphabet.indexOf(t) < 0)
        throw new Error(`invalid character '${t}' in '${e}'`);
    return this.codec.decode(e);
  }
};
var Ek = Ak;
const kk = (n, e, t) => {
    const r = {};
    for (let l = 0; l < e.length; ++l) r[e[l]] = l;
    let a = n.length;
    for (; n[a - 1] === "="; ) --a;
    const i = new Uint8Array(((a * t) / 8) | 0);
    let s = 0,
      o = 0,
      c = 0;
    for (let l = 0; l < a; ++l) {
      const u = r[n[l]];
      if (u === void 0) throw new SyntaxError("Invalid character " + n[l]);
      (o = (o << t) | u),
        (s += t),
        s >= 8 && ((s -= 8), (i[c++] = 255 & (o >> s)));
    }
    if (s >= t || 255 & (o << (8 - s)))
      throw new SyntaxError("Unexpected end of data");
    return i;
  },
  _k = (n, e, t) => {
    const r = e[e.length - 1] === "=",
      a = (1 << t) - 1;
    let i = "",
      s = 0,
      o = 0;
    for (let c = 0; c < n.length; ++c)
      for (o = (o << 8) | n[c], s += 8; s > t; )
        (s -= t), (i += e[a & (o >> s)]);
    if ((s && (i += e[a & (o << (t - s))]), r))
      for (; (i.length * t) & 7; ) i += "=";
    return i;
  },
  Sk = (n) => (e) => ({
    encode(t) {
      return _k(t, e, n);
    },
    decode(t) {
      return kk(t, e, n);
    },
  });
var Pk = { rfc4648: Sk };
const Io = gk,
  Ik = Ek,
  { rfc4648: Nt } = Pk,
  { decodeText: Rk, encodeText: Mk } = Gh,
  Bk = () => ({ encode: Rk, decode: Mk }),
  S5 = [
    ["identity", "\0", Bk, ""],
    ["base2", "0", Nt(1), "01"],
    ["base8", "7", Nt(3), "01234567"],
    ["base10", "9", Io, "0123456789"],
    ["base16", "f", Nt(4), "0123456789abcdef"],
    ["base16upper", "F", Nt(4), "0123456789ABCDEF"],
    ["base32hex", "v", Nt(5), "0123456789abcdefghijklmnopqrstuv"],
    ["base32hexupper", "V", Nt(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
    ["base32hexpad", "t", Nt(5), "0123456789abcdefghijklmnopqrstuv="],
    ["base32hexpadupper", "T", Nt(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
    ["base32", "b", Nt(5), "abcdefghijklmnopqrstuvwxyz234567"],
    ["base32upper", "B", Nt(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
    ["base32pad", "c", Nt(5), "abcdefghijklmnopqrstuvwxyz234567="],
    ["base32padupper", "C", Nt(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
    ["base32z", "h", Nt(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
    ["base36", "k", Io, "0123456789abcdefghijklmnopqrstuvwxyz"],
    ["base36upper", "K", Io, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
    [
      "base58btc",
      "z",
      Io,
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
    ],
    [
      "base58flickr",
      "Z",
      Io,
      "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
    ],
    [
      "base64",
      "m",
      Nt(6),
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    ],
    [
      "base64pad",
      "M",
      Nt(6),
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    ],
    [
      "base64url",
      "u",
      Nt(6),
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    ],
    [
      "base64urlpad",
      "U",
      Nt(6),
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    ],
  ],
  P5 = S5.reduce((n, e) => ((n[e[0]] = new Ik(e[0], e[1], e[2], e[3])), n), {}),
  Dk = S5.reduce((n, e) => ((n[e[1]] = P5[e[0]]), n), {});
var Ok = { names: P5, codes: Dk };
(function (n, e) {
  const t = Ok,
    { encodeText: r, decodeText: a, concat: i } = Gh;
  function s(y, h) {
    if (!h) throw new Error("requires an encoded Uint8Array");
    const { name: g, codeBuf: v } = d(y);
    return u(g, h), i([v, h], v.length + h.length);
  }
  function o(y, h) {
    const g = d(y),
      v = r(g.encode(h));
    return i([g.codeBuf, v], g.codeBuf.length + v.length);
  }
  function c(y) {
    y instanceof Uint8Array && (y = a(y));
    const h = y[0];
    return (
      [
        "f",
        "F",
        "v",
        "V",
        "t",
        "T",
        "b",
        "B",
        "c",
        "C",
        "h",
        "k",
        "K",
      ].includes(h) && (y = y.toLowerCase()),
      d(y[0]).decode(y.substring(1))
    );
  }
  function l(y) {
    if (
      (y instanceof Uint8Array && (y = a(y)),
      Object.prototype.toString.call(y) !== "[object String]")
    )
      return !1;
    try {
      return d(y[0]).name;
    } catch {
      return !1;
    }
  }
  function u(y, h) {
    d(y).decode(a(h));
  }
  function d(y) {
    if (Object.prototype.hasOwnProperty.call(t.names, y)) return t.names[y];
    if (Object.prototype.hasOwnProperty.call(t.codes, y)) return t.codes[y];
    throw new Error(`Unsupported encoding: ${y}`);
  }
  function f(y) {
    return y instanceof Uint8Array && (y = a(y)), d(y[0]);
  }
  (e = n.exports = s),
    (e.encode = o),
    (e.decode = c),
    (e.isEncoded = l),
    (e.encoding = d),
    (e.encodingFromData = f);
  const p = Object.freeze(t.names),
    m = Object.freeze(t.codes);
  (e.names = p), (e.codes = m);
})(Rp, Rp.exports);
var Kd = Rp.exports,
  Nk = I5,
  L1 = 128,
  Fk = 127,
  Lk = ~Fk,
  $k = Math.pow(2, 31);
function I5(n, e, t) {
  (e = e || []), (t = t || 0);
  for (var r = t; n >= $k; ) (e[t++] = (n & 255) | L1), (n /= 128);
  for (; n & Lk; ) (e[t++] = (n & 255) | L1), (n >>>= 7);
  return (e[t] = n | 0), (I5.bytes = t - r + 1), e;
}
var Wk = Mp,
  Uk = 128,
  $1 = 127;
function Mp(n, r) {
  var t = 0,
    r = r || 0,
    a = 0,
    i = r,
    s,
    o = n.length;
  do {
    if (i >= o)
      throw ((Mp.bytes = 0), new RangeError("Could not decode varint"));
    (s = n[i++]),
      (t += a < 28 ? (s & $1) << a : (s & $1) * Math.pow(2, a)),
      (a += 7);
  } while (s >= Uk);
  return (Mp.bytes = i - r), t;
}
var jk = Math.pow(2, 7),
  zk = Math.pow(2, 14),
  Hk = Math.pow(2, 21),
  qk = Math.pow(2, 28),
  Vk = Math.pow(2, 35),
  Gk = Math.pow(2, 42),
  Kk = Math.pow(2, 49),
  Qk = Math.pow(2, 56),
  Yk = Math.pow(2, 63),
  Jk = function (n) {
    return n < jk
      ? 1
      : n < zk
      ? 2
      : n < Hk
      ? 3
      : n < qk
      ? 4
      : n < Vk
      ? 5
      : n < Gk
      ? 6
      : n < Kk
      ? 7
      : n < Qk
      ? 8
      : n < Yk
      ? 9
      : 10;
  },
  Xk = { encode: Nk, decode: Wk, encodingLength: Jk };
const Zk = Object.freeze({
  identity: 0,
  sha1: 17,
  "sha2-256": 18,
  "sha2-512": 19,
  "sha3-512": 20,
  "sha3-384": 21,
  "sha3-256": 22,
  "sha3-224": 23,
  "shake-128": 24,
  "shake-256": 25,
  "keccak-224": 26,
  "keccak-256": 27,
  "keccak-384": 28,
  "keccak-512": 29,
  blake3: 30,
  "murmur3-128": 34,
  "murmur3-32": 35,
  "dbl-sha2-256": 86,
  md4: 212,
  md5: 213,
  bmt: 214,
  "sha2-256-trunc254-padded": 4114,
  "ripemd-128": 4178,
  "ripemd-160": 4179,
  "ripemd-256": 4180,
  "ripemd-320": 4181,
  x11: 4352,
  kangarootwelve: 7425,
  "sm3-256": 21325,
  "blake2b-8": 45569,
  "blake2b-16": 45570,
  "blake2b-24": 45571,
  "blake2b-32": 45572,
  "blake2b-40": 45573,
  "blake2b-48": 45574,
  "blake2b-56": 45575,
  "blake2b-64": 45576,
  "blake2b-72": 45577,
  "blake2b-80": 45578,
  "blake2b-88": 45579,
  "blake2b-96": 45580,
  "blake2b-104": 45581,
  "blake2b-112": 45582,
  "blake2b-120": 45583,
  "blake2b-128": 45584,
  "blake2b-136": 45585,
  "blake2b-144": 45586,
  "blake2b-152": 45587,
  "blake2b-160": 45588,
  "blake2b-168": 45589,
  "blake2b-176": 45590,
  "blake2b-184": 45591,
  "blake2b-192": 45592,
  "blake2b-200": 45593,
  "blake2b-208": 45594,
  "blake2b-216": 45595,
  "blake2b-224": 45596,
  "blake2b-232": 45597,
  "blake2b-240": 45598,
  "blake2b-248": 45599,
  "blake2b-256": 45600,
  "blake2b-264": 45601,
  "blake2b-272": 45602,
  "blake2b-280": 45603,
  "blake2b-288": 45604,
  "blake2b-296": 45605,
  "blake2b-304": 45606,
  "blake2b-312": 45607,
  "blake2b-320": 45608,
  "blake2b-328": 45609,
  "blake2b-336": 45610,
  "blake2b-344": 45611,
  "blake2b-352": 45612,
  "blake2b-360": 45613,
  "blake2b-368": 45614,
  "blake2b-376": 45615,
  "blake2b-384": 45616,
  "blake2b-392": 45617,
  "blake2b-400": 45618,
  "blake2b-408": 45619,
  "blake2b-416": 45620,
  "blake2b-424": 45621,
  "blake2b-432": 45622,
  "blake2b-440": 45623,
  "blake2b-448": 45624,
  "blake2b-456": 45625,
  "blake2b-464": 45626,
  "blake2b-472": 45627,
  "blake2b-480": 45628,
  "blake2b-488": 45629,
  "blake2b-496": 45630,
  "blake2b-504": 45631,
  "blake2b-512": 45632,
  "blake2s-8": 45633,
  "blake2s-16": 45634,
  "blake2s-24": 45635,
  "blake2s-32": 45636,
  "blake2s-40": 45637,
  "blake2s-48": 45638,
  "blake2s-56": 45639,
  "blake2s-64": 45640,
  "blake2s-72": 45641,
  "blake2s-80": 45642,
  "blake2s-88": 45643,
  "blake2s-96": 45644,
  "blake2s-104": 45645,
  "blake2s-112": 45646,
  "blake2s-120": 45647,
  "blake2s-128": 45648,
  "blake2s-136": 45649,
  "blake2s-144": 45650,
  "blake2s-152": 45651,
  "blake2s-160": 45652,
  "blake2s-168": 45653,
  "blake2s-176": 45654,
  "blake2s-184": 45655,
  "blake2s-192": 45656,
  "blake2s-200": 45657,
  "blake2s-208": 45658,
  "blake2s-216": 45659,
  "blake2s-224": 45660,
  "blake2s-232": 45661,
  "blake2s-240": 45662,
  "blake2s-248": 45663,
  "blake2s-256": 45664,
  "skein256-8": 45825,
  "skein256-16": 45826,
  "skein256-24": 45827,
  "skein256-32": 45828,
  "skein256-40": 45829,
  "skein256-48": 45830,
  "skein256-56": 45831,
  "skein256-64": 45832,
  "skein256-72": 45833,
  "skein256-80": 45834,
  "skein256-88": 45835,
  "skein256-96": 45836,
  "skein256-104": 45837,
  "skein256-112": 45838,
  "skein256-120": 45839,
  "skein256-128": 45840,
  "skein256-136": 45841,
  "skein256-144": 45842,
  "skein256-152": 45843,
  "skein256-160": 45844,
  "skein256-168": 45845,
  "skein256-176": 45846,
  "skein256-184": 45847,
  "skein256-192": 45848,
  "skein256-200": 45849,
  "skein256-208": 45850,
  "skein256-216": 45851,
  "skein256-224": 45852,
  "skein256-232": 45853,
  "skein256-240": 45854,
  "skein256-248": 45855,
  "skein256-256": 45856,
  "skein512-8": 45857,
  "skein512-16": 45858,
  "skein512-24": 45859,
  "skein512-32": 45860,
  "skein512-40": 45861,
  "skein512-48": 45862,
  "skein512-56": 45863,
  "skein512-64": 45864,
  "skein512-72": 45865,
  "skein512-80": 45866,
  "skein512-88": 45867,
  "skein512-96": 45868,
  "skein512-104": 45869,
  "skein512-112": 45870,
  "skein512-120": 45871,
  "skein512-128": 45872,
  "skein512-136": 45873,
  "skein512-144": 45874,
  "skein512-152": 45875,
  "skein512-160": 45876,
  "skein512-168": 45877,
  "skein512-176": 45878,
  "skein512-184": 45879,
  "skein512-192": 45880,
  "skein512-200": 45881,
  "skein512-208": 45882,
  "skein512-216": 45883,
  "skein512-224": 45884,
  "skein512-232": 45885,
  "skein512-240": 45886,
  "skein512-248": 45887,
  "skein512-256": 45888,
  "skein512-264": 45889,
  "skein512-272": 45890,
  "skein512-280": 45891,
  "skein512-288": 45892,
  "skein512-296": 45893,
  "skein512-304": 45894,
  "skein512-312": 45895,
  "skein512-320": 45896,
  "skein512-328": 45897,
  "skein512-336": 45898,
  "skein512-344": 45899,
  "skein512-352": 45900,
  "skein512-360": 45901,
  "skein512-368": 45902,
  "skein512-376": 45903,
  "skein512-384": 45904,
  "skein512-392": 45905,
  "skein512-400": 45906,
  "skein512-408": 45907,
  "skein512-416": 45908,
  "skein512-424": 45909,
  "skein512-432": 45910,
  "skein512-440": 45911,
  "skein512-448": 45912,
  "skein512-456": 45913,
  "skein512-464": 45914,
  "skein512-472": 45915,
  "skein512-480": 45916,
  "skein512-488": 45917,
  "skein512-496": 45918,
  "skein512-504": 45919,
  "skein512-512": 45920,
  "skein1024-8": 45921,
  "skein1024-16": 45922,
  "skein1024-24": 45923,
  "skein1024-32": 45924,
  "skein1024-40": 45925,
  "skein1024-48": 45926,
  "skein1024-56": 45927,
  "skein1024-64": 45928,
  "skein1024-72": 45929,
  "skein1024-80": 45930,
  "skein1024-88": 45931,
  "skein1024-96": 45932,
  "skein1024-104": 45933,
  "skein1024-112": 45934,
  "skein1024-120": 45935,
  "skein1024-128": 45936,
  "skein1024-136": 45937,
  "skein1024-144": 45938,
  "skein1024-152": 45939,
  "skein1024-160": 45940,
  "skein1024-168": 45941,
  "skein1024-176": 45942,
  "skein1024-184": 45943,
  "skein1024-192": 45944,
  "skein1024-200": 45945,
  "skein1024-208": 45946,
  "skein1024-216": 45947,
  "skein1024-224": 45948,
  "skein1024-232": 45949,
  "skein1024-240": 45950,
  "skein1024-248": 45951,
  "skein1024-256": 45952,
  "skein1024-264": 45953,
  "skein1024-272": 45954,
  "skein1024-280": 45955,
  "skein1024-288": 45956,
  "skein1024-296": 45957,
  "skein1024-304": 45958,
  "skein1024-312": 45959,
  "skein1024-320": 45960,
  "skein1024-328": 45961,
  "skein1024-336": 45962,
  "skein1024-344": 45963,
  "skein1024-352": 45964,
  "skein1024-360": 45965,
  "skein1024-368": 45966,
  "skein1024-376": 45967,
  "skein1024-384": 45968,
  "skein1024-392": 45969,
  "skein1024-400": 45970,
  "skein1024-408": 45971,
  "skein1024-416": 45972,
  "skein1024-424": 45973,
  "skein1024-432": 45974,
  "skein1024-440": 45975,
  "skein1024-448": 45976,
  "skein1024-456": 45977,
  "skein1024-464": 45978,
  "skein1024-472": 45979,
  "skein1024-480": 45980,
  "skein1024-488": 45981,
  "skein1024-496": 45982,
  "skein1024-504": 45983,
  "skein1024-512": 45984,
  "skein1024-520": 45985,
  "skein1024-528": 45986,
  "skein1024-536": 45987,
  "skein1024-544": 45988,
  "skein1024-552": 45989,
  "skein1024-560": 45990,
  "skein1024-568": 45991,
  "skein1024-576": 45992,
  "skein1024-584": 45993,
  "skein1024-592": 45994,
  "skein1024-600": 45995,
  "skein1024-608": 45996,
  "skein1024-616": 45997,
  "skein1024-624": 45998,
  "skein1024-632": 45999,
  "skein1024-640": 46e3,
  "skein1024-648": 46001,
  "skein1024-656": 46002,
  "skein1024-664": 46003,
  "skein1024-672": 46004,
  "skein1024-680": 46005,
  "skein1024-688": 46006,
  "skein1024-696": 46007,
  "skein1024-704": 46008,
  "skein1024-712": 46009,
  "skein1024-720": 46010,
  "skein1024-728": 46011,
  "skein1024-736": 46012,
  "skein1024-744": 46013,
  "skein1024-752": 46014,
  "skein1024-760": 46015,
  "skein1024-768": 46016,
  "skein1024-776": 46017,
  "skein1024-784": 46018,
  "skein1024-792": 46019,
  "skein1024-800": 46020,
  "skein1024-808": 46021,
  "skein1024-816": 46022,
  "skein1024-824": 46023,
  "skein1024-832": 46024,
  "skein1024-840": 46025,
  "skein1024-848": 46026,
  "skein1024-856": 46027,
  "skein1024-864": 46028,
  "skein1024-872": 46029,
  "skein1024-880": 46030,
  "skein1024-888": 46031,
  "skein1024-896": 46032,
  "skein1024-904": 46033,
  "skein1024-912": 46034,
  "skein1024-920": 46035,
  "skein1024-928": 46036,
  "skein1024-936": 46037,
  "skein1024-944": 46038,
  "skein1024-952": 46039,
  "skein1024-960": 46040,
  "skein1024-968": 46041,
  "skein1024-976": 46042,
  "skein1024-984": 46043,
  "skein1024-992": 46044,
  "skein1024-1000": 46045,
  "skein1024-1008": 46046,
  "skein1024-1016": 46047,
  "skein1024-1024": 46048,
  "poseidon-bls12_381-a2-fc1": 46081,
  "poseidon-bls12_381-a2-fc1-sc": 46082,
});
var e_ = { names: Zk };
function t_(n, e) {
  if (n.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), r = 0; r < t.length; r++) t[r] = 255;
  for (var a = 0; a < n.length; a++) {
    var i = n.charAt(a),
      s = i.charCodeAt(0);
    if (t[s] !== 255) throw new TypeError(i + " is ambiguous");
    t[s] = a;
  }
  var o = n.length,
    c = n.charAt(0),
    l = Math.log(o) / Math.log(256),
    u = Math.log(256) / Math.log(o);
  function d(m) {
    if (
      (m instanceof Uint8Array ||
        (ArrayBuffer.isView(m)
          ? (m = new Uint8Array(m.buffer, m.byteOffset, m.byteLength))
          : Array.isArray(m) && (m = Uint8Array.from(m))),
      !(m instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (m.length === 0) return "";
    for (var y = 0, h = 0, g = 0, v = m.length; g !== v && m[g] === 0; )
      g++, y++;
    for (var w = ((v - g) * u + 1) >>> 0, T = new Uint8Array(w); g !== v; ) {
      for (
        var A = m[g], E = 0, _ = w - 1;
        (A !== 0 || E < h) && _ !== -1;
        _--, E++
      )
        (A += (256 * T[_]) >>> 0), (T[_] = A % o >>> 0), (A = (A / o) >>> 0);
      if (A !== 0) throw new Error("Non-zero carry");
      (h = E), g++;
    }
    for (var S = w - h; S !== w && T[S] === 0; ) S++;
    for (var W = c.repeat(y); S < w; ++S) W += n.charAt(T[S]);
    return W;
  }
  function f(m) {
    if (typeof m != "string") throw new TypeError("Expected String");
    if (m.length === 0) return new Uint8Array();
    var y = 0;
    if (m[y] !== " ") {
      for (var h = 0, g = 0; m[y] === c; ) h++, y++;
      for (
        var v = ((m.length - y) * l + 1) >>> 0, w = new Uint8Array(v);
        m[y];

      ) {
        var T = t[m.charCodeAt(y)];
        if (T === 255) return;
        for (var A = 0, E = v - 1; (T !== 0 || A < g) && E !== -1; E--, A++)
          (T += (o * w[E]) >>> 0),
            (w[E] = T % 256 >>> 0),
            (T = (T / 256) >>> 0);
        if (T !== 0) throw new Error("Non-zero carry");
        (g = A), y++;
      }
      if (m[y] !== " ") {
        for (var _ = v - g; _ !== v && w[_] === 0; ) _++;
        for (var S = new Uint8Array(h + (v - _)), W = h; _ !== v; )
          S[W++] = w[_++];
        return S;
      }
    }
  }
  function p(m) {
    var y = f(m);
    if (y) return y;
    throw new Error(`Non-${e} character`);
  }
  return { encode: d, decodeUnsafe: f, decode: p };
}
var n_ = t_,
  r_ = n_;
const R5 = new Uint8Array(0),
  a_ = (n) => n.reduce((e, t) => e + t.toString(16).padStart(2, "0"), ""),
  i_ = (n) => {
    const e = n.match(/../g);
    return e ? new Uint8Array(e.map((t) => parseInt(t, 16))) : R5;
  },
  M5 = (n, e) => {
    if (n === e) return !0;
    if (n.byteLength !== e.byteLength) return !1;
    for (let t = 0; t < n.byteLength; t++) if (n[t] !== e[t]) return !1;
    return !0;
  },
  Gi = (n) => {
    if (n instanceof Uint8Array && n.constructor.name === "Uint8Array")
      return n;
    if (n instanceof ArrayBuffer) return new Uint8Array(n);
    if (ArrayBuffer.isView(n))
      return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
    throw new Error("Unknown type, must be binary type");
  },
  s_ = (n) => n instanceof ArrayBuffer || ArrayBuffer.isView(n),
  B5 = (n) => new TextEncoder().encode(n),
  D5 = (n) => new TextDecoder().decode(n),
  o_ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        coerce: Gi,
        empty: R5,
        equals: M5,
        fromHex: i_,
        fromString: B5,
        isBinary: s_,
        toHex: a_,
        toString: D5,
      },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  );
class c_ {
  constructor(e, t, r) {
    (this.name = e), (this.prefix = t), (this.baseEncode = r);
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
let l_ = class {
  constructor(e, t, r) {
    if (((this.name = e), (this.prefix = t), t.codePointAt(0) === void 0))
      throw new Error("Invalid prefix character");
    (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(e)}, ${
            this.name
          } decoder only supports inputs prefixed with ${this.prefix}`,
        );
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return O5(this, e);
  }
};
class u_ {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return O5(this, e);
  }
  decode(e) {
    const t = e[0],
      r = this.decoders[t];
    if (r) return r.decode(e);
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(
        e,
      )}, only inputs prefixed with ${Object.keys(
        this.decoders,
      )} are supported`,
    );
  }
}
const O5 = (n, e) =>
  new u_({
    ...(n.decoders || { [n.prefix]: n }),
    ...(e.decoders || { [e.prefix]: e }),
  });
class d_ {
  constructor(e, t, r, a) {
    (this.name = e),
      (this.prefix = t),
      (this.baseEncode = r),
      (this.baseDecode = a),
      (this.encoder = new c_(e, t, r)),
      (this.decoder = new l_(e, t, a));
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Qd = ({ name: n, prefix: e, encode: t, decode: r }) => new d_(n, e, t, r),
  qc = ({ prefix: n, name: e, alphabet: t }) => {
    const { encode: r, decode: a } = r_(t, e);
    return Qd({ prefix: n, name: e, encode: r, decode: (i) => Gi(a(i)) });
  },
  f_ = (n, e, t, r) => {
    const a = {};
    for (let u = 0; u < e.length; ++u) a[e[u]] = u;
    let i = n.length;
    for (; n[i - 1] === "="; ) --i;
    const s = new Uint8Array(((i * t) / 8) | 0);
    let o = 0,
      c = 0,
      l = 0;
    for (let u = 0; u < i; ++u) {
      const d = a[n[u]];
      if (d === void 0) throw new SyntaxError(`Non-${r} character`);
      (c = (c << t) | d),
        (o += t),
        o >= 8 && ((o -= 8), (s[l++] = 255 & (c >> o)));
    }
    if (o >= t || 255 & (c << (8 - o)))
      throw new SyntaxError("Unexpected end of data");
    return s;
  },
  p_ = (n, e, t) => {
    const r = e[e.length - 1] === "=",
      a = (1 << t) - 1;
    let i = "",
      s = 0,
      o = 0;
    for (let c = 0; c < n.length; ++c)
      for (o = (o << 8) | n[c], s += 8; s > t; )
        (s -= t), (i += e[a & (o >> s)]);
    if ((s && (i += e[a & (o << (t - s))]), r))
      for (; (i.length * t) & 7; ) i += "=";
    return i;
  },
  Kt = ({ name: n, prefix: e, bitsPerChar: t, alphabet: r }) =>
    Qd({
      prefix: e,
      name: n,
      encode(a) {
        return p_(a, r, t);
      },
      decode(a) {
        return f_(a, r, t, n);
      },
    }),
  h_ = Qd({
    prefix: "\0",
    name: "identity",
    encode: (n) => D5(n),
    decode: (n) => B5(n),
  }),
  m_ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, identity: h_ },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  y_ = Kt({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }),
  g_ = Object.freeze(
    Object.defineProperty({ __proto__: null, base2: y_ }, Symbol.toStringTag, {
      value: "Module",
    }),
  ),
  b_ = Kt({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 }),
  x_ = Object.freeze(
    Object.defineProperty({ __proto__: null, base8: b_ }, Symbol.toStringTag, {
      value: "Module",
    }),
  ),
  v_ = qc({ prefix: "9", name: "base10", alphabet: "0123456789" }),
  w_ = Object.freeze(
    Object.defineProperty({ __proto__: null, base10: v_ }, Symbol.toStringTag, {
      value: "Module",
    }),
  ),
  T_ = Kt({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4,
  }),
  C_ = Kt({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4,
  }),
  A_ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base16: T_, base16upper: C_ },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  Qo = Kt({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5,
  }),
  E_ = Kt({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5,
  }),
  k_ = Kt({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5,
  }),
  __ = Kt({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5,
  }),
  S_ = Kt({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5,
  }),
  P_ = Kt({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5,
  }),
  I_ = Kt({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5,
  }),
  R_ = Kt({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5,
  }),
  M_ = Kt({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5,
  }),
  B_ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base32: Qo,
        base32hex: S_,
        base32hexpad: I_,
        base32hexpadupper: R_,
        base32hexupper: P_,
        base32pad: k_,
        base32padupper: __,
        base32upper: E_,
        base32z: M_,
      },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  D_ = qc({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
  }),
  O_ = qc({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  }),
  N_ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base36: D_, base36upper: O_ },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  ta = qc({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  }),
  F_ = qc({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
  }),
  L_ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base58btc: ta, base58flickr: F_ },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  $_ = Kt({
    prefix: "m",
    name: "base64",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6,
  }),
  W_ = Kt({
    prefix: "M",
    name: "base64pad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6,
  }),
  U_ = Kt({
    prefix: "u",
    name: "base64url",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6,
  }),
  j_ = Kt({
    prefix: "U",
    name: "base64urlpad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6,
  }),
  z_ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base64: $_,
        base64pad: W_,
        base64url: U_,
        base64urlpad: j_,
      },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  N5 = Array.from(
    "🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂",
  ),
  H_ = N5.reduce((n, e, t) => ((n[t] = e), n), []),
  q_ = N5.reduce((n, e, t) => ((n[e.codePointAt(0)] = t), n), []);
function V_(n) {
  return n.reduce((e, t) => ((e += H_[t]), e), "");
}
function G_(n) {
  const e = [];
  for (const t of n) {
    const r = q_[t.codePointAt(0)];
    if (r === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const K_ = Qd({ prefix: "🚀", name: "base256emoji", encode: V_, decode: G_ }),
  Q_ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base256emoji: K_ },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  );
var Y_ = F5,
  W1 = 128,
  J_ = 127,
  X_ = ~J_,
  Z_ = Math.pow(2, 31);
function F5(n, e, t) {
  (e = e || []), (t = t || 0);
  for (var r = t; n >= Z_; ) (e[t++] = (n & 255) | W1), (n /= 128);
  for (; n & X_; ) (e[t++] = (n & 255) | W1), (n >>>= 7);
  return (e[t] = n | 0), (F5.bytes = t - r + 1), e;
}
var eS = Bp,
  tS = 128,
  U1 = 127;
function Bp(n, r) {
  var t = 0,
    r = r || 0,
    a = 0,
    i = r,
    s,
    o = n.length;
  do {
    if (i >= o)
      throw ((Bp.bytes = 0), new RangeError("Could not decode varint"));
    (s = n[i++]),
      (t += a < 28 ? (s & U1) << a : (s & U1) * Math.pow(2, a)),
      (a += 7);
  } while (s >= tS);
  return (Bp.bytes = i - r), t;
}
var nS = Math.pow(2, 7),
  rS = Math.pow(2, 14),
  aS = Math.pow(2, 21),
  iS = Math.pow(2, 28),
  sS = Math.pow(2, 35),
  oS = Math.pow(2, 42),
  cS = Math.pow(2, 49),
  lS = Math.pow(2, 56),
  uS = Math.pow(2, 63),
  dS = function (n) {
    return n < nS
      ? 1
      : n < rS
      ? 2
      : n < aS
      ? 3
      : n < iS
      ? 4
      : n < sS
      ? 5
      : n < oS
      ? 6
      : n < cS
      ? 7
      : n < lS
      ? 8
      : n < uS
      ? 9
      : 10;
  },
  fS = { encode: Y_, decode: eS, encodingLength: dS },
  wu = fS;
const Tu = (n, e = 0) => [wu.decode(n, e), wu.decode.bytes],
  oc = (n, e, t = 0) => (wu.encode(n, e, t), e),
  cc = (n) => wu.encodingLength(n),
  pS = Object.freeze(
    Object.defineProperty(
      { __proto__: null, decode: Tu, encodeTo: oc, encodingLength: cc },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  lc = (n, e) => {
    const t = e.byteLength,
      r = cc(n),
      a = r + cc(t),
      i = new Uint8Array(a + t);
    return oc(n, i, 0), oc(t, i, r), i.set(e, a), new Yd(n, t, e, i);
  },
  L5 = (n) => {
    const e = Gi(n),
      [t, r] = Tu(e),
      [a, i] = Tu(e.subarray(r)),
      s = e.subarray(r + i);
    if (s.byteLength !== a) throw new Error("Incorrect length");
    return new Yd(t, a, s, e);
  },
  $5 = (n, e) =>
    n === e
      ? !0
      : n.code === e.code && n.size === e.size && M5(n.bytes, e.bytes);
class Yd {
  constructor(e, t, r, a) {
    (this.code = e), (this.size = t), (this.digest = r), (this.bytes = a);
  }
}
const hS = Object.freeze(
    Object.defineProperty(
      { __proto__: null, Digest: Yd, create: lc, decode: L5, equals: $5 },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  Kh = ({ name: n, code: e, encode: t }) => new W5(n, e, t);
class W5 {
  constructor(e, t, r) {
    (this.name = e), (this.code = t), (this.encode = r);
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array
        ? lc(this.code, t)
        : t.then((r) => lc(this.code, r));
    } else throw Error("Unknown type, must be binary type");
  }
}
const mS = Object.freeze(
    Object.defineProperty(
      { __proto__: null, Hasher: W5, from: Kh },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  U5 = (n) => async (e) => new Uint8Array(await crypto.subtle.digest(n, e)),
  yS = Kh({ name: "sha2-256", code: 18, encode: U5("SHA-256") }),
  gS = Kh({ name: "sha2-512", code: 19, encode: U5("SHA-512") }),
  bS = Object.freeze(
    Object.defineProperty(
      { __proto__: null, sha256: yS, sha512: gS },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  j5 = 0,
  xS = "identity",
  z5 = Gi,
  vS = (n) => lc(j5, z5(n)),
  wS = { code: j5, name: xS, encode: z5, digest: vS },
  TS = Object.freeze(
    Object.defineProperty(
      { __proto__: null, identity: wS },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  CS = "raw",
  AS = 85,
  ES = (n) => Gi(n),
  kS = (n) => Gi(n),
  _S = Object.freeze(
    Object.defineProperty(
      { __proto__: null, code: AS, decode: kS, encode: ES, name: CS },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  SS = new TextEncoder(),
  PS = new TextDecoder(),
  IS = "json",
  RS = 512,
  MS = (n) => SS.encode(JSON.stringify(n)),
  BS = (n) => JSON.parse(PS.decode(n)),
  DS = Object.freeze(
    Object.defineProperty(
      { __proto__: null, code: RS, decode: BS, encode: MS, name: IS },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  );
let OS = class un {
  constructor(e, t, r, a) {
    (this.code = t),
      (this.version = e),
      (this.multihash = r),
      (this.bytes = a),
      (this.byteOffset = a.byteOffset),
      (this.byteLength = a.byteLength),
      (this.asCID = this),
      (this._baseCache = new Map()),
      Object.defineProperties(this, {
        byteOffset: wl,
        byteLength: wl,
        code: vl,
        version: vl,
        multihash: vl,
        bytes: vl,
        _baseCache: wl,
        asCID: wl,
      });
  }
  toV0() {
    switch (this.version) {
      case 0:
        return this;
      default: {
        const { code: e, multihash: t } = this;
        if (e !== Ro)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (t.code !== $S)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return un.createV0(t);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: t } = this.multihash,
          r = lc(e, t);
        return un.createV1(this.code, r);
      }
      case 1:
        return this;
      default:
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`,
        );
    }
  }
  equals(e) {
    return (
      e &&
      this.code === e.code &&
      this.version === e.version &&
      $5(this.multihash, e.multihash)
    );
  }
  toString(e) {
    const { bytes: t, version: r, _baseCache: a } = this;
    switch (r) {
      case 0:
        return FS(t, a, e || ta.encoder);
      default:
        return LS(t, a, e || Qo.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes,
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(e) {
    return US(/^0\.0/, jS), !!(e && (e[z1] || e.asCID === e));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error(
      '"codec" property is deprecated, use integer "code" property instead',
    );
  }
  get buffer() {
    throw new Error(
      "Deprecated .buffer property, use .bytes to get Uint8Array instead",
    );
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(e) {
    if (e instanceof un) return e;
    if (e != null && e.asCID === e) {
      const { version: t, code: r, multihash: a, bytes: i } = e;
      return new un(t, r, a, i || j1(t, r, a.bytes));
    } else if (e != null && e[z1] === !0) {
      const { version: t, multihash: r, code: a } = e,
        i = L5(r);
      return un.create(t, a, i);
    } else return null;
  }
  static create(e, t, r) {
    if (typeof t != "number")
      throw new Error("String codecs are no longer supported");
    switch (e) {
      case 0: {
        if (t !== Ro)
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${Ro}) block encoding`,
          );
        return new un(e, t, r, r.bytes);
      }
      case 1: {
        const a = j1(e, t, r.bytes);
        return new un(e, t, r, a);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(e) {
    return un.create(0, Ro, e);
  }
  static createV1(e, t) {
    return un.create(1, e, t);
  }
  static decode(e) {
    const [t, r] = un.decodeFirst(e);
    if (r.length) throw new Error("Incorrect length");
    return t;
  }
  static decodeFirst(e) {
    const t = un.inspectBytes(e),
      r = t.size - t.multihashSize,
      a = Gi(e.subarray(r, r + t.multihashSize));
    if (a.byteLength !== t.multihashSize) throw new Error("Incorrect length");
    const i = a.subarray(t.multihashSize - t.digestSize),
      s = new Yd(t.multihashCode, t.digestSize, i, a);
    return [
      t.version === 0 ? un.createV0(s) : un.createV1(t.codec, s),
      e.subarray(t.size),
    ];
  }
  static inspectBytes(e) {
    let t = 0;
    const r = () => {
      const [d, f] = Tu(e.subarray(t));
      return (t += f), d;
    };
    let a = r(),
      i = Ro;
    if (
      (a === 18 ? ((a = 0), (t = 0)) : a === 1 && (i = r()), a !== 0 && a !== 1)
    )
      throw new RangeError(`Invalid CID version ${a}`);
    const s = t,
      o = r(),
      c = r(),
      l = t + c,
      u = l - s;
    return {
      version: a,
      codec: i,
      multihashCode: o,
      digestSize: c,
      multihashSize: u,
      size: l,
    };
  }
  static parse(e, t) {
    const [r, a] = NS(e, t),
      i = un.decode(a);
    return i._baseCache.set(r, e), i;
  }
};
const NS = (n, e) => {
    switch (n[0]) {
      case "Q": {
        const t = e || ta;
        return [ta.prefix, t.decode(`${ta.prefix}${n}`)];
      }
      case ta.prefix: {
        const t = e || ta;
        return [ta.prefix, t.decode(n)];
      }
      case Qo.prefix: {
        const t = e || Qo;
        return [Qo.prefix, t.decode(n)];
      }
      default: {
        if (e == null)
          throw Error(
            "To parse non base32 or base58btc encoded CID multibase decoder must be provided",
          );
        return [n[0], e.decode(n)];
      }
    }
  },
  FS = (n, e, t) => {
    const { prefix: r } = t;
    if (r !== ta.prefix)
      throw Error(`Cannot string encode V0 in ${t.name} encoding`);
    const a = e.get(r);
    if (a == null) {
      const i = t.encode(n).slice(1);
      return e.set(r, i), i;
    } else return a;
  },
  LS = (n, e, t) => {
    const { prefix: r } = t,
      a = e.get(r);
    if (a == null) {
      const i = t.encode(n);
      return e.set(r, i), i;
    } else return a;
  },
  Ro = 112,
  $S = 18,
  j1 = (n, e, t) => {
    const r = cc(n),
      a = r + cc(e),
      i = new Uint8Array(a + t.byteLength);
    return oc(n, i, 0), oc(e, i, r), i.set(t, a), i;
  },
  z1 = Symbol.for("@ipld/js-cid/CID"),
  vl = { writable: !1, configurable: !1, enumerable: !0 },
  wl = { writable: !1, enumerable: !1, configurable: !1 },
  WS = "0.0.0-dev",
  US = (n, e) => {
    if (n.test(WS)) console.warn(e);
    else throw new Error(e);
  },
  jS = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
  Dp = { ...m_, ...g_, ...x_, ...w_, ...A_, ...B_, ...N_, ...L_, ...z_, ...Q_ },
  zS = { ...bS, ...TS },
  HS = { raw: _S, json: DS },
  qS = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        CID: OS,
        bases: Dp,
        bytes: o_,
        codecs: HS,
        digest: hS,
        hasher: mS,
        hashes: zS,
        varint: pS,
      },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  );
function Qh(n) {
  return globalThis.Buffer != null
    ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength)
    : n;
}
function H5(n = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? Qh(globalThis.Buffer.allocUnsafe(n))
    : new Uint8Array(n);
}
function q5(n, e, t, r) {
  return {
    name: n,
    prefix: e,
    encoder: { name: n, prefix: e, encode: t },
    decoder: { decode: r },
  };
}
const H1 = q5(
    "utf8",
    "u",
    (n) => "u" + new TextDecoder("utf8").decode(n),
    (n) => new TextEncoder().encode(n.substring(1)),
  ),
  r0 = q5(
    "ascii",
    "a",
    (n) => {
      let e = "a";
      for (let t = 0; t < n.length; t++) e += String.fromCharCode(n[t]);
      return e;
    },
    (n) => {
      n = n.substring(1);
      const e = H5(n.length);
      for (let t = 0; t < n.length; t++) e[t] = n.charCodeAt(t);
      return e;
    },
  ),
  V5 = {
    utf8: H1,
    "utf-8": H1,
    hex: Dp.base16,
    latin1: r0,
    ascii: r0,
    binary: r0,
    ...Dp,
  };
function VS(n, e = "utf8") {
  const t = V5[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString(
        "utf8",
      )
    : t.encoder.encode(n).substring(1);
}
const GS = Object.freeze(
    Object.defineProperty(
      { __proto__: null, toString: VS },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  Yh = Fc(GS);
function KS(n, e = "utf8") {
  const t = V5[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? Qh(globalThis.Buffer.from(n, "utf-8"))
    : t.decoder.decode(`${t.prefix}${n}`);
}
const QS = Object.freeze(
    Object.defineProperty(
      { __proto__: null, fromString: KS },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  G5 = Fc(QS);
function YS(n, e) {
  e || (e = n.reduce((a, i) => a + i.length, 0));
  const t = H5(e);
  let r = 0;
  for (const a of n) t.set(a, r), (r += a.length);
  return Qh(t);
}
const JS = Object.freeze(
    Object.defineProperty({ __proto__: null, concat: YS }, Symbol.toStringTag, {
      value: "Module",
    }),
  ),
  Jh = Fc(JS),
  K5 = Kd,
  gs = Xk,
  { names: uc } = e_,
  { toString: Jd } = Yh,
  { fromString: XS } = G5,
  { concat: ZS } = Jh,
  oo = {};
for (const n in uc) {
  const e = n;
  oo[uc[e]] = e;
}
Object.freeze(oo);
function eP(n) {
  if (!(n instanceof Uint8Array))
    throw new Error("must be passed a Uint8Array");
  return Jd(n, "base16");
}
function tP(n) {
  return XS(n, "base16");
}
function nP(n) {
  if (!(n instanceof Uint8Array))
    throw new Error("must be passed a Uint8Array");
  return Jd(K5.encode("base58btc", n)).slice(1);
}
function rP(n) {
  const e = n instanceof Uint8Array ? Jd(n) : n;
  return K5.decode("z" + e);
}
function Q5(n) {
  if (!(n instanceof Uint8Array))
    throw new Error("multihash must be a Uint8Array");
  if (n.length < 2) throw new Error("multihash too short. must be > 2 bytes.");
  const e = gs.decode(n);
  if (!J5(e))
    throw new Error(`multihash unknown function code: 0x${e.toString(16)}`);
  n = n.slice(gs.decode.bytes);
  const t = gs.decode(n);
  if (t < 0) throw new Error(`multihash invalid length: ${t}`);
  if (((n = n.slice(gs.decode.bytes)), n.length !== t))
    throw new Error(`multihash length inconsistent: 0x${Jd(n, "base16")}`);
  return { code: e, name: oo[e], length: t, digest: n };
}
function aP(n, e, t) {
  if (!n || e === void 0)
    throw new Error(
      "multihash encode requires at least two args: digest, code",
    );
  const r = Y5(e);
  if (!(n instanceof Uint8Array))
    throw new Error("digest should be a Uint8Array");
  if ((t == null && (t = n.length), t && n.length !== t))
    throw new Error("digest length should be equal to specified length.");
  const a = gs.encode(r),
    i = gs.encode(t);
  return ZS([a, i, n], a.length + i.length + n.length);
}
function Y5(n) {
  let e = n;
  if (typeof n == "string") {
    if (uc[n] === void 0)
      throw new Error(`Unrecognized hash function named: ${n}`);
    e = uc[n];
  }
  if (typeof e != "number")
    throw new Error(`Hash function code should be a number. Got: ${e}`);
  if (oo[e] === void 0 && !Xh(e))
    throw new Error(`Unrecognized function code: ${e}`);
  return e;
}
function Xh(n) {
  return n > 0 && n < 16;
}
function J5(n) {
  return !!(Xh(n) || oo[n]);
}
function X5(n) {
  Q5(n);
}
function iP(n) {
  return X5(n), n.subarray(0, 2);
}
var Xd = {
    names: uc,
    codes: oo,
    toHexString: eP,
    fromHexString: tP,
    toB58String: nP,
    fromB58String: rP,
    decode: Q5,
    encode: aP,
    coerceCode: Y5,
    isAppCode: Xh,
    validate: X5,
    prefix: iP,
    isValidCode: J5,
  },
  sP = Op,
  q1 = 128,
  oP = 127,
  cP = ~oP,
  lP = Math.pow(2, 31);
function Op(n, e, t) {
  if (Number.MAX_SAFE_INTEGER && n > Number.MAX_SAFE_INTEGER)
    throw ((Op.bytes = 0), new RangeError("Could not encode varint"));
  (e = e || []), (t = t || 0);
  for (var r = t; n >= lP; ) (e[t++] = (n & 255) | q1), (n /= 128);
  for (; n & cP; ) (e[t++] = (n & 255) | q1), (n >>>= 7);
  return (e[t] = n | 0), (Op.bytes = t - r + 1), e;
}
var uP = Np,
  dP = 128,
  V1 = 127;
function Np(n, r) {
  var t = 0,
    r = r || 0,
    a = 0,
    i = r,
    s,
    o = n.length;
  do {
    if (i >= o || a > 49)
      throw ((Np.bytes = 0), new RangeError("Could not decode varint"));
    (s = n[i++]),
      (t += a < 28 ? (s & V1) << a : (s & V1) * Math.pow(2, a)),
      (a += 7);
  } while (s >= dP);
  return (Np.bytes = i - r), t;
}
var fP = Math.pow(2, 7),
  pP = Math.pow(2, 14),
  hP = Math.pow(2, 21),
  mP = Math.pow(2, 28),
  yP = Math.pow(2, 35),
  gP = Math.pow(2, 42),
  bP = Math.pow(2, 49),
  xP = Math.pow(2, 56),
  vP = Math.pow(2, 63),
  wP = function (n) {
    return n < fP
      ? 1
      : n < pP
      ? 2
      : n < hP
      ? 3
      : n < mP
      ? 4
      : n < yP
      ? 5
      : n < gP
      ? 6
      : n < bP
      ? 7
      : n < xP
      ? 8
      : n < vP
      ? 9
      : 10;
  },
  Z5 = { encode: sP, decode: uP, encodingLength: wP };
const e6 = Z5,
  { toString: TP } = Yh,
  { fromString: CP } = G5;
var t6 = {
  numberToUint8Array: AP,
  uint8ArrayToNumber: n6,
  varintUint8ArrayEncode: EP,
  varintEncode: kP,
};
function n6(n) {
  return parseInt(TP(n, "base16"), 16);
}
function AP(n) {
  let e = n.toString(16);
  return e.length % 2 === 1 && (e = "0" + e), CP(e, "base16");
}
function EP(n) {
  return Uint8Array.from(e6.encode(n6(n)));
}
function kP(n) {
  return Uint8Array.from(e6.encode(n));
}
const _P = Object.freeze({
  identity: 0,
  cidv1: 1,
  cidv2: 2,
  cidv3: 3,
  ip4: 4,
  tcp: 6,
  sha1: 17,
  "sha2-256": 18,
  "sha2-512": 19,
  "sha3-512": 20,
  "sha3-384": 21,
  "sha3-256": 22,
  "sha3-224": 23,
  "shake-128": 24,
  "shake-256": 25,
  "keccak-224": 26,
  "keccak-256": 27,
  "keccak-384": 28,
  "keccak-512": 29,
  blake3: 30,
  dccp: 33,
  "murmur3-128": 34,
  "murmur3-32": 35,
  ip6: 41,
  ip6zone: 42,
  path: 47,
  multicodec: 48,
  multihash: 49,
  multiaddr: 50,
  multibase: 51,
  dns: 53,
  dns4: 54,
  dns6: 55,
  dnsaddr: 56,
  protobuf: 80,
  cbor: 81,
  raw: 85,
  "dbl-sha2-256": 86,
  rlp: 96,
  bencode: 99,
  "dag-pb": 112,
  "dag-cbor": 113,
  "libp2p-key": 114,
  "git-raw": 120,
  "torrent-info": 123,
  "torrent-file": 124,
  "leofcoin-block": 129,
  "leofcoin-tx": 130,
  "leofcoin-pr": 131,
  sctp: 132,
  "dag-jose": 133,
  "dag-cose": 134,
  "eth-block": 144,
  "eth-block-list": 145,
  "eth-tx-trie": 146,
  "eth-tx": 147,
  "eth-tx-receipt-trie": 148,
  "eth-tx-receipt": 149,
  "eth-state-trie": 150,
  "eth-account-snapshot": 151,
  "eth-storage-trie": 152,
  "eth-receipt-log-trie": 153,
  "eth-reciept-log": 154,
  "bitcoin-block": 176,
  "bitcoin-tx": 177,
  "bitcoin-witness-commitment": 178,
  "zcash-block": 192,
  "zcash-tx": 193,
  "caip-50": 202,
  streamid: 206,
  "stellar-block": 208,
  "stellar-tx": 209,
  md4: 212,
  md5: 213,
  bmt: 214,
  "decred-block": 224,
  "decred-tx": 225,
  "ipld-ns": 226,
  "ipfs-ns": 227,
  "swarm-ns": 228,
  "ipns-ns": 229,
  zeronet: 230,
  "secp256k1-pub": 231,
  "bls12_381-g1-pub": 234,
  "bls12_381-g2-pub": 235,
  "x25519-pub": 236,
  "ed25519-pub": 237,
  "bls12_381-g1g2-pub": 238,
  "dash-block": 240,
  "dash-tx": 241,
  "swarm-manifest": 250,
  "swarm-feed": 251,
  udp: 273,
  "p2p-webrtc-star": 275,
  "p2p-webrtc-direct": 276,
  "p2p-stardust": 277,
  "p2p-circuit": 290,
  "dag-json": 297,
  udt: 301,
  utp: 302,
  unix: 400,
  thread: 406,
  p2p: 421,
  ipfs: 421,
  https: 443,
  onion: 444,
  onion3: 445,
  garlic64: 446,
  garlic32: 447,
  tls: 448,
  noise: 454,
  quic: 460,
  ws: 477,
  wss: 478,
  "p2p-websocket-star": 479,
  http: 480,
  "swhid-1-snp": 496,
  json: 512,
  messagepack: 513,
  "libp2p-peer-record": 769,
  "libp2p-relay-rsvp": 770,
  "car-index-sorted": 1024,
  "sha2-256-trunc254-padded": 4114,
  "ripemd-128": 4178,
  "ripemd-160": 4179,
  "ripemd-256": 4180,
  "ripemd-320": 4181,
  x11: 4352,
  "p256-pub": 4608,
  "p384-pub": 4609,
  "p521-pub": 4610,
  "ed448-pub": 4611,
  "x448-pub": 4612,
  "ed25519-priv": 4864,
  "secp256k1-priv": 4865,
  "x25519-priv": 4866,
  kangarootwelve: 7425,
  "sm3-256": 21325,
  "blake2b-8": 45569,
  "blake2b-16": 45570,
  "blake2b-24": 45571,
  "blake2b-32": 45572,
  "blake2b-40": 45573,
  "blake2b-48": 45574,
  "blake2b-56": 45575,
  "blake2b-64": 45576,
  "blake2b-72": 45577,
  "blake2b-80": 45578,
  "blake2b-88": 45579,
  "blake2b-96": 45580,
  "blake2b-104": 45581,
  "blake2b-112": 45582,
  "blake2b-120": 45583,
  "blake2b-128": 45584,
  "blake2b-136": 45585,
  "blake2b-144": 45586,
  "blake2b-152": 45587,
  "blake2b-160": 45588,
  "blake2b-168": 45589,
  "blake2b-176": 45590,
  "blake2b-184": 45591,
  "blake2b-192": 45592,
  "blake2b-200": 45593,
  "blake2b-208": 45594,
  "blake2b-216": 45595,
  "blake2b-224": 45596,
  "blake2b-232": 45597,
  "blake2b-240": 45598,
  "blake2b-248": 45599,
  "blake2b-256": 45600,
  "blake2b-264": 45601,
  "blake2b-272": 45602,
  "blake2b-280": 45603,
  "blake2b-288": 45604,
  "blake2b-296": 45605,
  "blake2b-304": 45606,
  "blake2b-312": 45607,
  "blake2b-320": 45608,
  "blake2b-328": 45609,
  "blake2b-336": 45610,
  "blake2b-344": 45611,
  "blake2b-352": 45612,
  "blake2b-360": 45613,
  "blake2b-368": 45614,
  "blake2b-376": 45615,
  "blake2b-384": 45616,
  "blake2b-392": 45617,
  "blake2b-400": 45618,
  "blake2b-408": 45619,
  "blake2b-416": 45620,
  "blake2b-424": 45621,
  "blake2b-432": 45622,
  "blake2b-440": 45623,
  "blake2b-448": 45624,
  "blake2b-456": 45625,
  "blake2b-464": 45626,
  "blake2b-472": 45627,
  "blake2b-480": 45628,
  "blake2b-488": 45629,
  "blake2b-496": 45630,
  "blake2b-504": 45631,
  "blake2b-512": 45632,
  "blake2s-8": 45633,
  "blake2s-16": 45634,
  "blake2s-24": 45635,
  "blake2s-32": 45636,
  "blake2s-40": 45637,
  "blake2s-48": 45638,
  "blake2s-56": 45639,
  "blake2s-64": 45640,
  "blake2s-72": 45641,
  "blake2s-80": 45642,
  "blake2s-88": 45643,
  "blake2s-96": 45644,
  "blake2s-104": 45645,
  "blake2s-112": 45646,
  "blake2s-120": 45647,
  "blake2s-128": 45648,
  "blake2s-136": 45649,
  "blake2s-144": 45650,
  "blake2s-152": 45651,
  "blake2s-160": 45652,
  "blake2s-168": 45653,
  "blake2s-176": 45654,
  "blake2s-184": 45655,
  "blake2s-192": 45656,
  "blake2s-200": 45657,
  "blake2s-208": 45658,
  "blake2s-216": 45659,
  "blake2s-224": 45660,
  "blake2s-232": 45661,
  "blake2s-240": 45662,
  "blake2s-248": 45663,
  "blake2s-256": 45664,
  "skein256-8": 45825,
  "skein256-16": 45826,
  "skein256-24": 45827,
  "skein256-32": 45828,
  "skein256-40": 45829,
  "skein256-48": 45830,
  "skein256-56": 45831,
  "skein256-64": 45832,
  "skein256-72": 45833,
  "skein256-80": 45834,
  "skein256-88": 45835,
  "skein256-96": 45836,
  "skein256-104": 45837,
  "skein256-112": 45838,
  "skein256-120": 45839,
  "skein256-128": 45840,
  "skein256-136": 45841,
  "skein256-144": 45842,
  "skein256-152": 45843,
  "skein256-160": 45844,
  "skein256-168": 45845,
  "skein256-176": 45846,
  "skein256-184": 45847,
  "skein256-192": 45848,
  "skein256-200": 45849,
  "skein256-208": 45850,
  "skein256-216": 45851,
  "skein256-224": 45852,
  "skein256-232": 45853,
  "skein256-240": 45854,
  "skein256-248": 45855,
  "skein256-256": 45856,
  "skein512-8": 45857,
  "skein512-16": 45858,
  "skein512-24": 45859,
  "skein512-32": 45860,
  "skein512-40": 45861,
  "skein512-48": 45862,
  "skein512-56": 45863,
  "skein512-64": 45864,
  "skein512-72": 45865,
  "skein512-80": 45866,
  "skein512-88": 45867,
  "skein512-96": 45868,
  "skein512-104": 45869,
  "skein512-112": 45870,
  "skein512-120": 45871,
  "skein512-128": 45872,
  "skein512-136": 45873,
  "skein512-144": 45874,
  "skein512-152": 45875,
  "skein512-160": 45876,
  "skein512-168": 45877,
  "skein512-176": 45878,
  "skein512-184": 45879,
  "skein512-192": 45880,
  "skein512-200": 45881,
  "skein512-208": 45882,
  "skein512-216": 45883,
  "skein512-224": 45884,
  "skein512-232": 45885,
  "skein512-240": 45886,
  "skein512-248": 45887,
  "skein512-256": 45888,
  "skein512-264": 45889,
  "skein512-272": 45890,
  "skein512-280": 45891,
  "skein512-288": 45892,
  "skein512-296": 45893,
  "skein512-304": 45894,
  "skein512-312": 45895,
  "skein512-320": 45896,
  "skein512-328": 45897,
  "skein512-336": 45898,
  "skein512-344": 45899,
  "skein512-352": 45900,
  "skein512-360": 45901,
  "skein512-368": 45902,
  "skein512-376": 45903,
  "skein512-384": 45904,
  "skein512-392": 45905,
  "skein512-400": 45906,
  "skein512-408": 45907,
  "skein512-416": 45908,
  "skein512-424": 45909,
  "skein512-432": 45910,
  "skein512-440": 45911,
  "skein512-448": 45912,
  "skein512-456": 45913,
  "skein512-464": 45914,
  "skein512-472": 45915,
  "skein512-480": 45916,
  "skein512-488": 45917,
  "skein512-496": 45918,
  "skein512-504": 45919,
  "skein512-512": 45920,
  "skein1024-8": 45921,
  "skein1024-16": 45922,
  "skein1024-24": 45923,
  "skein1024-32": 45924,
  "skein1024-40": 45925,
  "skein1024-48": 45926,
  "skein1024-56": 45927,
  "skein1024-64": 45928,
  "skein1024-72": 45929,
  "skein1024-80": 45930,
  "skein1024-88": 45931,
  "skein1024-96": 45932,
  "skein1024-104": 45933,
  "skein1024-112": 45934,
  "skein1024-120": 45935,
  "skein1024-128": 45936,
  "skein1024-136": 45937,
  "skein1024-144": 45938,
  "skein1024-152": 45939,
  "skein1024-160": 45940,
  "skein1024-168": 45941,
  "skein1024-176": 45942,
  "skein1024-184": 45943,
  "skein1024-192": 45944,
  "skein1024-200": 45945,
  "skein1024-208": 45946,
  "skein1024-216": 45947,
  "skein1024-224": 45948,
  "skein1024-232": 45949,
  "skein1024-240": 45950,
  "skein1024-248": 45951,
  "skein1024-256": 45952,
  "skein1024-264": 45953,
  "skein1024-272": 45954,
  "skein1024-280": 45955,
  "skein1024-288": 45956,
  "skein1024-296": 45957,
  "skein1024-304": 45958,
  "skein1024-312": 45959,
  "skein1024-320": 45960,
  "skein1024-328": 45961,
  "skein1024-336": 45962,
  "skein1024-344": 45963,
  "skein1024-352": 45964,
  "skein1024-360": 45965,
  "skein1024-368": 45966,
  "skein1024-376": 45967,
  "skein1024-384": 45968,
  "skein1024-392": 45969,
  "skein1024-400": 45970,
  "skein1024-408": 45971,
  "skein1024-416": 45972,
  "skein1024-424": 45973,
  "skein1024-432": 45974,
  "skein1024-440": 45975,
  "skein1024-448": 45976,
  "skein1024-456": 45977,
  "skein1024-464": 45978,
  "skein1024-472": 45979,
  "skein1024-480": 45980,
  "skein1024-488": 45981,
  "skein1024-496": 45982,
  "skein1024-504": 45983,
  "skein1024-512": 45984,
  "skein1024-520": 45985,
  "skein1024-528": 45986,
  "skein1024-536": 45987,
  "skein1024-544": 45988,
  "skein1024-552": 45989,
  "skein1024-560": 45990,
  "skein1024-568": 45991,
  "skein1024-576": 45992,
  "skein1024-584": 45993,
  "skein1024-592": 45994,
  "skein1024-600": 45995,
  "skein1024-608": 45996,
  "skein1024-616": 45997,
  "skein1024-624": 45998,
  "skein1024-632": 45999,
  "skein1024-640": 46e3,
  "skein1024-648": 46001,
  "skein1024-656": 46002,
  "skein1024-664": 46003,
  "skein1024-672": 46004,
  "skein1024-680": 46005,
  "skein1024-688": 46006,
  "skein1024-696": 46007,
  "skein1024-704": 46008,
  "skein1024-712": 46009,
  "skein1024-720": 46010,
  "skein1024-728": 46011,
  "skein1024-736": 46012,
  "skein1024-744": 46013,
  "skein1024-752": 46014,
  "skein1024-760": 46015,
  "skein1024-768": 46016,
  "skein1024-776": 46017,
  "skein1024-784": 46018,
  "skein1024-792": 46019,
  "skein1024-800": 46020,
  "skein1024-808": 46021,
  "skein1024-816": 46022,
  "skein1024-824": 46023,
  "skein1024-832": 46024,
  "skein1024-840": 46025,
  "skein1024-848": 46026,
  "skein1024-856": 46027,
  "skein1024-864": 46028,
  "skein1024-872": 46029,
  "skein1024-880": 46030,
  "skein1024-888": 46031,
  "skein1024-896": 46032,
  "skein1024-904": 46033,
  "skein1024-912": 46034,
  "skein1024-920": 46035,
  "skein1024-928": 46036,
  "skein1024-936": 46037,
  "skein1024-944": 46038,
  "skein1024-952": 46039,
  "skein1024-960": 46040,
  "skein1024-968": 46041,
  "skein1024-976": 46042,
  "skein1024-984": 46043,
  "skein1024-992": 46044,
  "skein1024-1000": 46045,
  "skein1024-1008": 46046,
  "skein1024-1016": 46047,
  "skein1024-1024": 46048,
  "poseidon-bls12_381-a2-fc1": 46081,
  "poseidon-bls12_381-a2-fc1-sc": 46082,
  "zeroxcert-imprint-256": 52753,
  "fil-commitment-unsealed": 61697,
  "fil-commitment-sealed": 61698,
  "holochain-adr-v0": 8417572,
  "holochain-adr-v1": 8483108,
  "holochain-key-v0": 9728292,
  "holochain-key-v1": 9793828,
  "holochain-sig-v0": 10645796,
  "holochain-sig-v1": 10711332,
  "skynet-ns": 11639056,
  "arweave-ns": 11704592,
});
var SP = { baseTable: _P };
const { baseTable: Fp } = SP,
  PP = t6.varintEncode,
  Zh = {},
  em = {},
  Cu = {};
for (const n in Fp) {
  const e = n,
    t = Fp[e];
  Zh[e] = PP(t);
  const r = e.toUpperCase().replace(/-/g, "_");
  (em[r] = t), Cu[t] || (Cu[t] = e);
}
Object.freeze(Zh);
Object.freeze(em);
Object.freeze(Cu);
const IP = Object.freeze(Fp);
var RP = {
  nameToVarint: Zh,
  constantToCode: em,
  nameToCode: IP,
  codeToName: Cu,
};
const Au = Z5,
  { concat: MP } = Jh,
  r6 = t6,
  { nameToVarint: Eu, constantToCode: BP, nameToCode: a6, codeToName: tm } = RP;
function DP(n, e) {
  let t;
  if (n instanceof Uint8Array) t = r6.varintUint8ArrayEncode(n);
  else if (Eu[n]) t = Eu[n];
  else throw new Error("multicodec not recognized");
  return MP([t, e], t.length + e.length);
}
function OP(n) {
  return Au.decode(n), n.slice(Au.decode.bytes);
}
function i6(n) {
  const e = Au.decode(n),
    t = tm[e];
  if (t === void 0) throw new Error(`Code "${e}" not found`);
  return t;
}
function s6(n) {
  return tm[n];
}
function o6(n) {
  const e = a6[n];
  if (e === void 0) throw new Error(`Codec "${n}" not found`);
  return e;
}
function c6(n) {
  return Au.decode(n);
}
function l6(n) {
  const e = Eu[n];
  if (e === void 0) throw new Error(`Codec "${n}" not found`);
  return e;
}
function u6(n) {
  return r6.varintEncode(n);
}
function NP(n) {
  return i6(n);
}
function FP(n) {
  return s6(n);
}
function LP(n) {
  return o6(n);
}
function $P(n) {
  return c6(n);
}
function WP(n) {
  return l6(n);
}
function UP(n) {
  return Array.from(u6(n));
}
var jP = {
  addPrefix: DP,
  rmPrefix: OP,
  getNameFromData: i6,
  getNameFromCode: s6,
  getCodeFromName: o6,
  getCodeFromData: c6,
  getVarintFromName: l6,
  getVarintFromCode: u6,
  getCodec: NP,
  getName: FP,
  getNumber: LP,
  getCode: $P,
  getCodeVarint: WP,
  getVarint: UP,
  ...BP,
  nameToVarint: Eu,
  nameToCode: a6,
  codeToName: tm,
};
const zP = Xd,
  HP = {
    checkCIDComponents: function (n) {
      if (n == null) return "null values are not valid CIDs";
      if (!(n.version === 0 || n.version === 1))
        return "Invalid version, must be a number equal to 1 or 0";
      if (typeof n.codec != "string") return "codec must be string";
      if (n.version === 0) {
        if (n.codec !== "dag-pb") return "codec must be 'dag-pb' for CIDv0";
        if (n.multibaseName !== "base58btc")
          return "multibaseName must be 'base58btc' for CIDv0";
      }
      if (!(n.multihash instanceof Uint8Array))
        return "multihash must be a Uint8Array";
      try {
        zP.validate(n.multihash);
      } catch (e) {
        let t = e.message;
        return t || (t = "Multihash validation failed"), t;
      }
    },
  };
var qP = HP;
function VP(n, e) {
  if (n === e) return !0;
  if (n.byteLength !== e.byteLength) return !1;
  for (let t = 0; t < n.byteLength; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
const GP = Object.freeze(
    Object.defineProperty({ __proto__: null, equals: VP }, Symbol.toStringTag, {
      value: "Module",
    }),
  ),
  KP = Fc(GP),
  Tl = Xd,
  a0 = Kd,
  gi = jP,
  QP = qP,
  { concat: G1 } = Jh,
  { toString: YP } = Yh,
  { equals: JP } = KP,
  ku = gi.nameToCode,
  XP = Object.keys(ku).reduce((n, e) => ((n[ku[e]] = e), n), {}),
  K1 = Symbol.for("@ipld/js-cid/CID");
let d6 = class ka {
  constructor(e, t, r, a) {
    if (
      (this.version,
      this.codec,
      this.multihash,
      Object.defineProperty(this, K1, { value: !0 }),
      ka.isCID(e))
    ) {
      const i = e;
      (this.version = i.version),
        (this.codec = i.codec),
        (this.multihash = i.multihash),
        (this.multibaseName =
          i.multibaseName || (i.version === 0 ? "base58btc" : "base32"));
      return;
    }
    if (typeof e == "string") {
      const i = a0.isEncoded(e);
      if (i) {
        const s = a0.decode(e);
        (this.version = parseInt(s[0].toString(), 16)),
          (this.codec = gi.getCodec(s.slice(1))),
          (this.multihash = gi.rmPrefix(s.slice(1))),
          (this.multibaseName = i);
      } else
        (this.version = 0),
          (this.codec = "dag-pb"),
          (this.multihash = Tl.fromB58String(e)),
          (this.multibaseName = "base58btc");
      ka.validateCID(this), Object.defineProperty(this, "string", { value: e });
      return;
    }
    if (e instanceof Uint8Array) {
      const i = parseInt(e[0].toString(), 16);
      if (i === 1) {
        const s = e;
        (this.version = i),
          (this.codec = gi.getCodec(s.slice(1))),
          (this.multihash = gi.rmPrefix(s.slice(1))),
          (this.multibaseName = "base32");
      } else
        (this.version = 0),
          (this.codec = "dag-pb"),
          (this.multihash = e),
          (this.multibaseName = "base58btc");
      ka.validateCID(this);
      return;
    }
    (this.version = e),
      typeof t == "number" && (t = XP[t]),
      (this.codec = t),
      (this.multihash = r),
      (this.multibaseName = a || (e === 0 ? "base58btc" : "base32")),
      ka.validateCID(this);
  }
  get bytes() {
    let e = this._bytes;
    if (!e) {
      if (this.version === 0) e = this.multihash;
      else if (this.version === 1) {
        const t = gi.getCodeVarint(this.codec);
        e = G1(
          [[1], t, this.multihash],
          1 + t.byteLength + this.multihash.byteLength,
        );
      } else throw new Error("unsupported version");
      Object.defineProperty(this, "_bytes", { value: e });
    }
    return e;
  }
  get prefix() {
    const e = gi.getCodeVarint(this.codec),
      t = Tl.prefix(this.multihash);
    return G1([[this.version], e, t], 1 + e.byteLength + t.byteLength);
  }
  get code() {
    return ku[this.codec];
  }
  toV0() {
    if (this.codec !== "dag-pb")
      throw new Error("Cannot convert a non dag-pb CID to CIDv0");
    const { name: e, length: t } = Tl.decode(this.multihash);
    if (e !== "sha2-256")
      throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
    if (t !== 32)
      throw new Error("Cannot convert non 32 byte multihash CID to CIDv0");
    return new ka(0, this.codec, this.multihash);
  }
  toV1() {
    return new ka(1, this.codec, this.multihash, this.multibaseName);
  }
  toBaseEncodedString(e = this.multibaseName) {
    if (this.string && this.string.length !== 0 && e === this.multibaseName)
      return this.string;
    let t;
    if (this.version === 0) {
      if (e !== "base58btc")
        throw new Error(
          "not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()",
        );
      t = Tl.toB58String(this.multihash);
    } else if (this.version === 1) t = YP(a0.encode(e, this.bytes));
    else throw new Error("unsupported version");
    return (
      e === this.multibaseName &&
        Object.defineProperty(this, "string", { value: t }),
      t
    );
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  toString(e) {
    return this.toBaseEncodedString(e);
  }
  toJSON() {
    return { codec: this.codec, version: this.version, hash: this.multihash };
  }
  equals(e) {
    return (
      this.codec === e.codec &&
      this.version === e.version &&
      JP(this.multihash, e.multihash)
    );
  }
  static validateCID(e) {
    const t = QP.checkCIDComponents(e);
    if (t) throw new Error(t);
  }
  static isCID(e) {
    return e instanceof ka || !!(e && e[K1]);
  }
};
d6.codecs = ku;
var nm = d6,
  f6 = { exports: {} };
function Q1(n) {
  if (n.stack && n.name && n.message)
    return n.stack.substring(n.name.length + 3 + n.message.length).split(`
`);
  if (n.stack)
    return n.stack.split(`
`);
}
function ZP(n, e) {
  return n.filter(function (t) {
    return !~e.indexOf(t);
  });
}
f6.exports = function (n, e) {
  if (!(n.stack && n.name && n.message))
    return console.error(new Error("stackless error")), n;
  var t = new Error(e),
    r = ZP(Q1(t).slice(1), Q1(n)).join(`
`);
  return (
    (t.__proto__ = n),
    (t.stack =
      t.name +
      ": " +
      t.message +
      `
` +
      r +
      `
  ` +
      n.stack),
    t
  );
};
var p6 = f6.exports;
const eI = nm,
  tI = p6;
var nI = function (e) {
  try {
    e = new eI(e);
  } catch (t) {
    throw tI(t, `invalid cid: ${e}`);
  }
  return e.version !== 1 && (e = e.toV1()), e.toBaseEncodedString("base32");
};
const rI = Kd;
var h6 = function () {
  const e = [];
  for (const t of Object.values(rI.names))
    e.push({ name: t.name, code: t.code });
  return e;
};
const aI = nm;
var m6 = function () {
  const e = [];
  for (const [t, r] of Object.entries(aI.codecs)) e.push({ name: t, code: r });
  return e;
};
const iI = Fc(qS),
  { bases: Y1 } = iI;
function y6(n, e, t, r) {
  return {
    name: n,
    prefix: e,
    encoder: { name: n, prefix: e, encode: t },
    decoder: { decode: r },
  };
}
const J1 = y6(
    "utf8",
    "u",
    (n) => "u" + new TextDecoder("utf8").decode(n),
    (n) => new TextEncoder().encode(n.substring(1)),
  ),
  i0 = y6(
    "ascii",
    "a",
    (n) => {
      let e = "a";
      for (let t = 0; t < n.length; t++) e += String.fromCharCode(n[t]);
      return e;
    },
    (n) => {
      n = n.substring(1);
      const e = new Uint8Array(n.length);
      for (let t = 0; t < n.length; t++) e[t] = n.charCodeAt(t);
      return e;
    },
  ),
  sI = {
    utf8: J1,
    "utf-8": J1,
    hex: Y1.base16,
    latin1: i0,
    ascii: i0,
    binary: i0,
    ...Y1,
  };
var oI = sI;
const cI = oI;
function lI(n, e = "utf8") {
  const t = cI[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return t.encoder.encode(n).substring(1);
}
var uI = lI;
const dI = nm,
  fI = h6,
  pI = m6,
  hI = p6,
  Lp = Kd,
  ps = Xd,
  Mo = uI;
var mI = function (e, t) {
  t = t || {};
  let r = t.format || "%s";
  if ((r === "prefix" && (r = "%P"), !X1(r) || r.indexOf("%") === -1))
    throw new Error(`invalid format string: ${r}`);
  const a = e;
  try {
    e = new dI(e);
  } catch (s) {
    throw hI(s, `invalid cid: ${e}`);
  }
  if (t.cidVersion != null && e.version !== t.cidVersion)
    if (t.cidVersion === 0) e = e.toV0();
    else if (t.cidVersion === 1) e = e.toV1();
    else throw new Error(`invalid cid version: ${t.cidVersion}`);
  let i = "base58btc";
  return (
    t.base ? (i = g6(t.base).name) : X1(a) && (i = Lp.isEncoded(a) || i),
    r.replace(/%([a-zA-Z%])/g, yI(e, i))
  );
};
function X1(n) {
  return Object.prototype.toString.call(n) === "[object String]";
}
function yI(n, e) {
  return (r, a) => {
    switch (a) {
      case "%":
        return "%";
      case "b":
        return e;
      case "B":
        return g6(e).code;
      case "v":
        return `cidv${n.version}`;
      case "V":
        return n.version.toString();
      case "c":
        return n.codec;
      case "C":
        return gI(n).toString();
      case "h":
        return ps.decode(n.multihash).name;
      case "H":
        return ps.decode(n.multihash).code.toString();
      case "L":
        return ps.decode(n.multihash).length.toString();
      case "m":
        return Mo(Lp.encode(e, n.multihash));
      case "M":
        return Mo(n.multihash, e);
      case "d":
        return Mo(Lp.encode(e, ps.decode(n.multihash).digest));
      case "D":
        return Mo(ps.decode(n.multihash).digest, e);
      case "s":
        return n.toString(e);
      case "S":
        return n.version === 1 ? n.toString(e).slice(1) : Mo(n.bytes, e);
      case "P":
        return bI(n);
      default:
        throw new Error(`unrecognized specifier in format string: ${a}`);
    }
  };
}
function g6(n) {
  const e = fI().find((t) => t.code === n || t.name === n);
  if (!e) throw new Error(`invalid multibase: ${n}`);
  return e;
}
function gI(n) {
  const e = pI().find((t) => t.name === n.codec);
  if (!e) throw new Error(`invalid codec: ${n.codec}`);
  return e.code;
}
function bI(n) {
  const { name: e, length: t } = ps.decode(n.multihash);
  return `cidv${n.version}-${n.codec}-${e}-${t}`;
}
const xI = Xd;
var vI = function () {
  const e = [];
  for (const [t, r] of Object.entries(xI.names)) e.push({ name: t, code: r });
  return e;
};
so.base32 = nI;
so.bases = h6;
so.codecs = m6;
so.format = mI;
so.hashes = vI;
var wI = so;
const TI = ir(wI);
var $p = { exports: {} };
(function (n, e) {
  var t = typeof self < "u" ? self : Ae,
    r = (function () {
      function i() {
        (this.fetch = !1), (this.DOMException = t.DOMException);
      }
      return (i.prototype = t), new i();
    })();
  (function (i) {
    (function (s) {
      var o = {
        searchParams: "URLSearchParams" in i,
        iterable: "Symbol" in i && "iterator" in Symbol,
        blob:
          "FileReader" in i &&
          "Blob" in i &&
          (function () {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          })(),
        formData: "FormData" in i,
        arrayBuffer: "ArrayBuffer" in i,
      };
      function c(N) {
        return N && DataView.prototype.isPrototypeOf(N);
      }
      if (o.arrayBuffer)
        var l = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]",
          ],
          u =
            ArrayBuffer.isView ||
            function (N) {
              return N && l.indexOf(Object.prototype.toString.call(N)) > -1;
            };
      function d(N) {
        if (
          (typeof N != "string" && (N = String(N)),
          /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(N))
        )
          throw new TypeError("Invalid character in header field name");
        return N.toLowerCase();
      }
      function f(N) {
        return typeof N != "string" && (N = String(N)), N;
      }
      function p(N) {
        var H = {
          next: function () {
            var J = N.shift();
            return { done: J === void 0, value: J };
          },
        };
        return (
          o.iterable &&
            (H[Symbol.iterator] = function () {
              return H;
            }),
          H
        );
      }
      function m(N) {
        (this.map = {}),
          N instanceof m
            ? N.forEach(function (H, J) {
                this.append(J, H);
              }, this)
            : Array.isArray(N)
            ? N.forEach(function (H) {
                this.append(H[0], H[1]);
              }, this)
            : N &&
              Object.getOwnPropertyNames(N).forEach(function (H) {
                this.append(H, N[H]);
              }, this);
      }
      (m.prototype.append = function (N, H) {
        (N = d(N)), (H = f(H));
        var J = this.map[N];
        this.map[N] = J ? J + ", " + H : H;
      }),
        (m.prototype.delete = function (N) {
          delete this.map[d(N)];
        }),
        (m.prototype.get = function (N) {
          return (N = d(N)), this.has(N) ? this.map[N] : null;
        }),
        (m.prototype.has = function (N) {
          return this.map.hasOwnProperty(d(N));
        }),
        (m.prototype.set = function (N, H) {
          this.map[d(N)] = f(H);
        }),
        (m.prototype.forEach = function (N, H) {
          for (var J in this.map)
            this.map.hasOwnProperty(J) && N.call(H, this.map[J], J, this);
        }),
        (m.prototype.keys = function () {
          var N = [];
          return (
            this.forEach(function (H, J) {
              N.push(J);
            }),
            p(N)
          );
        }),
        (m.prototype.values = function () {
          var N = [];
          return (
            this.forEach(function (H) {
              N.push(H);
            }),
            p(N)
          );
        }),
        (m.prototype.entries = function () {
          var N = [];
          return (
            this.forEach(function (H, J) {
              N.push([J, H]);
            }),
            p(N)
          );
        }),
        o.iterable && (m.prototype[Symbol.iterator] = m.prototype.entries);
      function y(N) {
        if (N.bodyUsed) return Promise.reject(new TypeError("Already read"));
        N.bodyUsed = !0;
      }
      function h(N) {
        return new Promise(function (H, J) {
          (N.onload = function () {
            H(N.result);
          }),
            (N.onerror = function () {
              J(N.error);
            });
        });
      }
      function g(N) {
        var H = new FileReader(),
          J = h(H);
        return H.readAsArrayBuffer(N), J;
      }
      function v(N) {
        var H = new FileReader(),
          J = h(H);
        return H.readAsText(N), J;
      }
      function w(N) {
        for (
          var H = new Uint8Array(N), J = new Array(H.length), de = 0;
          de < H.length;
          de++
        )
          J[de] = String.fromCharCode(H[de]);
        return J.join("");
      }
      function T(N) {
        if (N.slice) return N.slice(0);
        var H = new Uint8Array(N.byteLength);
        return H.set(new Uint8Array(N)), H.buffer;
      }
      function A() {
        return (
          (this.bodyUsed = !1),
          (this._initBody = function (N) {
            (this._bodyInit = N),
              N
                ? typeof N == "string"
                  ? (this._bodyText = N)
                  : o.blob && Blob.prototype.isPrototypeOf(N)
                  ? (this._bodyBlob = N)
                  : o.formData && FormData.prototype.isPrototypeOf(N)
                  ? (this._bodyFormData = N)
                  : o.searchParams && URLSearchParams.prototype.isPrototypeOf(N)
                  ? (this._bodyText = N.toString())
                  : o.arrayBuffer && o.blob && c(N)
                  ? ((this._bodyArrayBuffer = T(N.buffer)),
                    (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                  : o.arrayBuffer &&
                    (ArrayBuffer.prototype.isPrototypeOf(N) || u(N))
                  ? (this._bodyArrayBuffer = T(N))
                  : (this._bodyText = N = Object.prototype.toString.call(N))
                : (this._bodyText = ""),
              this.headers.get("content-type") ||
                (typeof N == "string"
                  ? this.headers.set("content-type", "text/plain;charset=UTF-8")
                  : this._bodyBlob && this._bodyBlob.type
                  ? this.headers.set("content-type", this._bodyBlob.type)
                  : o.searchParams &&
                    URLSearchParams.prototype.isPrototypeOf(N) &&
                    this.headers.set(
                      "content-type",
                      "application/x-www-form-urlencoded;charset=UTF-8",
                    ));
          }),
          o.blob &&
            ((this.blob = function () {
              var N = y(this);
              if (N) return N;
              if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
              if (this._bodyArrayBuffer)
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as blob");
              return Promise.resolve(new Blob([this._bodyText]));
            }),
            (this.arrayBuffer = function () {
              return this._bodyArrayBuffer
                ? y(this) || Promise.resolve(this._bodyArrayBuffer)
                : this.blob().then(g);
            })),
          (this.text = function () {
            var N = y(this);
            if (N) return N;
            if (this._bodyBlob) return v(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(w(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }),
          o.formData &&
            (this.formData = function () {
              return this.text().then(W);
            }),
          (this.json = function () {
            return this.text().then(JSON.parse);
          }),
          this
        );
      }
      var E = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function _(N) {
        var H = N.toUpperCase();
        return E.indexOf(H) > -1 ? H : N;
      }
      function S(N, H) {
        H = H || {};
        var J = H.body;
        if (N instanceof S) {
          if (N.bodyUsed) throw new TypeError("Already read");
          (this.url = N.url),
            (this.credentials = N.credentials),
            H.headers || (this.headers = new m(N.headers)),
            (this.method = N.method),
            (this.mode = N.mode),
            (this.signal = N.signal),
            !J && N._bodyInit != null && ((J = N._bodyInit), (N.bodyUsed = !0));
        } else this.url = String(N);
        if (
          ((this.credentials =
            H.credentials || this.credentials || "same-origin"),
          (H.headers || !this.headers) && (this.headers = new m(H.headers)),
          (this.method = _(H.method || this.method || "GET")),
          (this.mode = H.mode || this.mode || null),
          (this.signal = H.signal || this.signal),
          (this.referrer = null),
          (this.method === "GET" || this.method === "HEAD") && J)
        )
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(J);
      }
      S.prototype.clone = function () {
        return new S(this, { body: this._bodyInit });
      };
      function W(N) {
        var H = new FormData();
        return (
          N.trim()
            .split("&")
            .forEach(function (J) {
              if (J) {
                var de = J.split("="),
                  le = de.shift().replace(/\+/g, " "),
                  Z = de.join("=").replace(/\+/g, " ");
                H.append(decodeURIComponent(le), decodeURIComponent(Z));
              }
            }),
          H
        );
      }
      function D(N) {
        var H = new m(),
          J = N.replace(/\r?\n[\t ]+/g, " ");
        return (
          J.split(/\r?\n/).forEach(function (de) {
            var le = de.split(":"),
              Z = le.shift().trim();
            if (Z) {
              var ue = le.join(":").trim();
              H.append(Z, ue);
            }
          }),
          H
        );
      }
      A.call(S.prototype);
      function L(N, H) {
        H || (H = {}),
          (this.type = "default"),
          (this.status = H.status === void 0 ? 200 : H.status),
          (this.ok = this.status >= 200 && this.status < 300),
          (this.statusText = "statusText" in H ? H.statusText : "OK"),
          (this.headers = new m(H.headers)),
          (this.url = H.url || ""),
          this._initBody(N);
      }
      A.call(L.prototype),
        (L.prototype.clone = function () {
          return new L(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new m(this.headers),
            url: this.url,
          });
        }),
        (L.error = function () {
          var N = new L(null, { status: 0, statusText: "" });
          return (N.type = "error"), N;
        });
      var G = [301, 302, 303, 307, 308];
      (L.redirect = function (N, H) {
        if (G.indexOf(H) === -1) throw new RangeError("Invalid status code");
        return new L(null, { status: H, headers: { location: N } });
      }),
        (s.DOMException = i.DOMException);
      try {
        new s.DOMException();
      } catch {
        (s.DOMException = function (H, J) {
          (this.message = H), (this.name = J);
          var de = Error(H);
          this.stack = de.stack;
        }),
          (s.DOMException.prototype = Object.create(Error.prototype)),
          (s.DOMException.prototype.constructor = s.DOMException);
      }
      function q(N, H) {
        return new Promise(function (J, de) {
          var le = new S(N, H);
          if (le.signal && le.signal.aborted)
            return de(new s.DOMException("Aborted", "AbortError"));
          var Z = new XMLHttpRequest();
          function ue() {
            Z.abort();
          }
          (Z.onload = function () {
            var P = {
              status: Z.status,
              statusText: Z.statusText,
              headers: D(Z.getAllResponseHeaders() || ""),
            };
            P.url =
              "responseURL" in Z
                ? Z.responseURL
                : P.headers.get("X-Request-URL");
            var B = "response" in Z ? Z.response : Z.responseText;
            J(new L(B, P));
          }),
            (Z.onerror = function () {
              de(new TypeError("Network request failed"));
            }),
            (Z.ontimeout = function () {
              de(new TypeError("Network request failed"));
            }),
            (Z.onabort = function () {
              de(new s.DOMException("Aborted", "AbortError"));
            }),
            Z.open(le.method, le.url, !0),
            le.credentials === "include"
              ? (Z.withCredentials = !0)
              : le.credentials === "omit" && (Z.withCredentials = !1),
            "responseType" in Z && o.blob && (Z.responseType = "blob"),
            le.headers.forEach(function (P, B) {
              Z.setRequestHeader(B, P);
            }),
            le.signal &&
              (le.signal.addEventListener("abort", ue),
              (Z.onreadystatechange = function () {
                Z.readyState === 4 &&
                  le.signal.removeEventListener("abort", ue);
              })),
            Z.send(typeof le._bodyInit > "u" ? null : le._bodyInit);
        });
      }
      return (
        (q.polyfill = !0),
        i.fetch ||
          ((i.fetch = q), (i.Headers = m), (i.Request = S), (i.Response = L)),
        (s.Headers = m),
        (s.Request = S),
        (s.Response = L),
        (s.fetch = q),
        Object.defineProperty(s, "__esModule", { value: !0 }),
        s
      );
    })({});
  })(r),
    (r.fetch.ponyfill = !0),
    delete r.fetch.polyfill;
  var a = r;
  (e = a.fetch),
    (e.default = a.fetch),
    (e.fetch = a.fetch),
    (e.Headers = a.Headers),
    (e.Request = a.Request),
    (e.Response = a.Response),
    (n.exports = e);
})($p, $p.exports);
var Wp = $p.exports;
const la = ir(Wp);
var CI = typeof self == "object" ? self.FormData : window.FormData;
const AI = ir(CI);
function EI(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return typeof process < "u" &&
    {
      TERM_PROGRAM: "vscode",
      NODE: "/opt/homebrew/Cellar/node/20.4.0/bin/node",
      INIT_CWD: "/Users/nemanjamijailovic/Desktop/react/nefentus",
      TERM: "xterm-256color",
      SHELL: "/bin/zsh",
      npm_config_metrics_registry: "https://registry.npmjs.org/",
      TMPDIR: "/var/folders/sf/_jxj1sq93p92nygnjzjz7wz40000gn/T/",
      npm_config_global_prefix: "/opt/homebrew",
      TERM_PROGRAM_VERSION: "1.83.1",
      ZDOTDIR: "/Users/nemanjamijailovic",
      ORIGINAL_XDG_CURRENT_DESKTOP: "undefined",
      MallocNanoZone: "0",
      COLOR: "1",
      npm_config_noproxy: "",
      npm_config_local_prefix:
        "/Users/nemanjamijailovic/Desktop/react/nefentus",
      USER: "nemanjamijailovic",
      COMMAND_MODE: "unix2003",
      npm_config_globalconfig: "/opt/homebrew/etc/npmrc",
      SSH_AUTH_SOCK: "/private/tmp/com.apple.launchd.v3QbEzlluP/Listeners",
      __CF_USER_TEXT_ENCODING: "0x1F5:0x0:0x0",
      npm_execpath: "/opt/homebrew/lib/node_modules/npm/bin/npm-cli.js",
      PATH: "/Users/nemanjamijailovic/Desktop/react/nefentus/node_modules/.bin:/Users/nemanjamijailovic/Desktop/react/node_modules/.bin:/Users/nemanjamijailovic/Desktop/node_modules/.bin:/Users/nemanjamijailovic/node_modules/.bin:/Users/node_modules/.bin:/node_modules/.bin:/opt/homebrew/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/opt/homebrew/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin",
      npm_package_json:
        "/Users/nemanjamijailovic/Desktop/react/nefentus/package.json",
      _: "/Users/nemanjamijailovic/Desktop/react/nefentus/node_modules/.bin/vite",
      LaunchInstanceID: "40140A37-FB8D-43E2-921C-067ECA7C31B9",
      npm_config_userconfig: "/Users/nemanjamijailovic/.npmrc",
      npm_config_init_module: "/Users/nemanjamijailovic/.npm-init.js",
      USER_ZDOTDIR: "/Users/nemanjamijailovic",
      __CFBundleIdentifier: "com.microsoft.VSCode",
      npm_command: "run-script",
      PWD: "/Users/nemanjamijailovic/Desktop/react/nefentus",
      npm_lifecycle_event: "build",
      EDITOR: "vi",
      npm_package_name: "nefentus",
      LANG: "en_US.UTF-8",
      npm_config_npm_version: "9.7.2",
      VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node",
      XPC_FLAGS: "0x0",
      npm_config_node_gyp:
        "/opt/homebrew/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js",
      npm_package_version: "0.1.0",
      XPC_SERVICE_NAME: "0",
      VSCODE_INJECTION: "1",
      SHLVL: "2",
      HOME: "/Users/nemanjamijailovic",
      VSCODE_GIT_ASKPASS_MAIN:
        "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js",
      npm_config_cache: "/Users/nemanjamijailovic/.npm",
      LOGNAME: "nemanjamijailovic",
      npm_lifecycle_script: "vite build",
      VSCODE_GIT_IPC_HANDLE:
        "/var/folders/sf/_jxj1sq93p92nygnjzjz7wz40000gn/T/vscode-git-ae8730b21b.sock",
      npm_config_user_agent:
        "npm/9.7.2 node/v20.4.0 darwin arm64 workspaces/false",
      VSCODE_GIT_ASKPASS_NODE:
        "/Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper (Plugin).app/Contents/MacOS/Code Helper (Plugin)",
      GIT_ASKPASS:
        "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh",
      SECURITYSESSIONID: "186b4",
      npm_node_execpath: "/opt/homebrew/Cellar/node/20.4.0/bin/node",
      npm_config_prefix: "/opt/homebrew",
      COLORTERM: "truecolor",
      NODE_ENV: "production",
      VITE_REACT_APP_BASE_ENDPOINT_API: "https://api.nefentus.com/api",
      VITE_REACT_APP_GA_ID: "G-HRH664KZ9E",
      VITE_REACT_APP_RECAPTCHA_SITE_KEY:
        "6Leb6H8oAAAAAM0q25gltEqlMOUUymzoDobq4NLc",
      VITE_REACT_APP_SECRET_WORD: "AppNefentusSuperPuperSecretWord",
    }[n]
    ? {
        TERM_PROGRAM: "vscode",
        NODE: "/opt/homebrew/Cellar/node/20.4.0/bin/node",
        INIT_CWD: "/Users/nemanjamijailovic/Desktop/react/nefentus",
        TERM: "xterm-256color",
        SHELL: "/bin/zsh",
        npm_config_metrics_registry: "https://registry.npmjs.org/",
        TMPDIR: "/var/folders/sf/_jxj1sq93p92nygnjzjz7wz40000gn/T/",
        npm_config_global_prefix: "/opt/homebrew",
        TERM_PROGRAM_VERSION: "1.83.1",
        ZDOTDIR: "/Users/nemanjamijailovic",
        ORIGINAL_XDG_CURRENT_DESKTOP: "undefined",
        MallocNanoZone: "0",
        COLOR: "1",
        npm_config_noproxy: "",
        npm_config_local_prefix:
          "/Users/nemanjamijailovic/Desktop/react/nefentus",
        USER: "nemanjamijailovic",
        COMMAND_MODE: "unix2003",
        npm_config_globalconfig: "/opt/homebrew/etc/npmrc",
        SSH_AUTH_SOCK: "/private/tmp/com.apple.launchd.v3QbEzlluP/Listeners",
        __CF_USER_TEXT_ENCODING: "0x1F5:0x0:0x0",
        npm_execpath: "/opt/homebrew/lib/node_modules/npm/bin/npm-cli.js",
        PATH: "/Users/nemanjamijailovic/Desktop/react/nefentus/node_modules/.bin:/Users/nemanjamijailovic/Desktop/react/node_modules/.bin:/Users/nemanjamijailovic/Desktop/node_modules/.bin:/Users/nemanjamijailovic/node_modules/.bin:/Users/node_modules/.bin:/node_modules/.bin:/opt/homebrew/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/opt/homebrew/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin",
        npm_package_json:
          "/Users/nemanjamijailovic/Desktop/react/nefentus/package.json",
        _: "/Users/nemanjamijailovic/Desktop/react/nefentus/node_modules/.bin/vite",
        LaunchInstanceID: "40140A37-FB8D-43E2-921C-067ECA7C31B9",
        npm_config_userconfig: "/Users/nemanjamijailovic/.npmrc",
        npm_config_init_module: "/Users/nemanjamijailovic/.npm-init.js",
        USER_ZDOTDIR: "/Users/nemanjamijailovic",
        __CFBundleIdentifier: "com.microsoft.VSCode",
        npm_command: "run-script",
        PWD: "/Users/nemanjamijailovic/Desktop/react/nefentus",
        npm_lifecycle_event: "build",
        EDITOR: "vi",
        npm_package_name: "nefentus",
        LANG: "en_US.UTF-8",
        npm_config_npm_version: "9.7.2",
        VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node",
        XPC_FLAGS: "0x0",
        npm_config_node_gyp:
          "/opt/homebrew/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js",
        npm_package_version: "0.1.0",
        XPC_SERVICE_NAME: "0",
        VSCODE_INJECTION: "1",
        SHLVL: "2",
        HOME: "/Users/nemanjamijailovic",
        VSCODE_GIT_ASKPASS_MAIN:
          "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js",
        npm_config_cache: "/Users/nemanjamijailovic/.npm",
        LOGNAME: "nemanjamijailovic",
        npm_lifecycle_script: "vite build",
        VSCODE_GIT_IPC_HANDLE:
          "/var/folders/sf/_jxj1sq93p92nygnjzjz7wz40000gn/T/vscode-git-ae8730b21b.sock",
        npm_config_user_agent:
          "npm/9.7.2 node/v20.4.0 darwin arm64 workspaces/false",
        VSCODE_GIT_ASKPASS_NODE:
          "/Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper (Plugin).app/Contents/MacOS/Code Helper (Plugin)",
        GIT_ASKPASS:
          "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh",
        SECURITYSESSIONID: "186b4",
        npm_node_execpath: "/opt/homebrew/Cellar/node/20.4.0/bin/node",
        npm_config_prefix: "/opt/homebrew",
        COLORTERM: "truecolor",
        NODE_ENV: "production",
        VITE_REACT_APP_BASE_ENDPOINT_API: "https://api.nefentus.com/api",
        VITE_REACT_APP_GA_ID: "G-HRH664KZ9E",
        VITE_REACT_APP_RECAPTCHA_SITE_KEY:
          "6Leb6H8oAAAAAM0q25gltEqlMOUUymzoDobq4NLc",
        VITE_REACT_APP_SECRET_WORD: "AppNefentusSuperPuperSecretWord",
      }[n]
    : e;
}
const b6 = ".ipfscdn.io",
  kI = [`https://{clientId}${b6}/ipfs/{cid}/{path}`];
function Z1(n) {
  return new URL(n).hostname.endsWith(b6);
}
const _I = [
    "https://{cid}.ipfs.cf-ipfs.com/{path}",
    "https://{cid}.ipfs.dweb.link/{path}",
    "https://ipfs.io/ipfs/{cid}/{path}",
    "https://cloudflare-ipfs.com/ipfs/{cid}/{path}",
    "https://{cid}.ipfs.w3s.link/{path}",
    "https://w3s.link/ipfs/{cid}/{path}",
    "https://nftstorage.link/ipfs/{cid}/{path}",
    "https://gateway.pinata.cloud/ipfs/{cid}/{path}",
  ],
  SI = { "ipfs://": [...kI, ..._I] },
  eg = EI("CUSTOM_UPLOAD_SERVER_URL", "https://storage.thirdweb.com");
function PI(n) {
  return Array.isArray(n) ? { "ipfs://": n } : n || {};
}
function II(n, e) {
  const t = e.split("/"),
    r = MI(t[0]),
    a = t.slice(1).join("/");
  let i = n;
  return (
    n.includes("{cid}") && n.includes("{path}")
      ? (i = i.replace("{cid}", r).replace("{path}", a))
      : n.includes("{cid}")
      ? (i = i.replace("{cid}", r))
      : (i += `${r}/${a}`),
    i
  );
}
function RI(n, e, t) {
  const r = { ...SI, ...n };
  for (const a of Object.keys(r)) {
    const i = r[a]
      .map((s) => {
        if (e && s.includes("{clientId}")) return s.replace("{clientId}", e);
        if (t && s.includes("{clientId}"))
          throw new Error("Cannot use secretKey in browser context");
        return s.includes("{clientId}") ? void 0 : s;
      })
      .filter((s) => s !== void 0);
    r[a] = i;
  }
  return r;
}
function MI(n) {
  let e;
  try {
    const t = n.split("/")[0];
    e = TI.base32(t);
  } catch {
    throw new Error(`The CID ${n} is not valid.`);
  }
  return e;
}
function _u(n) {
  return global.File && n instanceof File;
}
function bs(n) {
  return global.Buffer && n instanceof Buffer;
}
function Su(n) {
  return !!(
    n &&
    n.name &&
    n.data &&
    typeof n.name == "string" &&
    (typeof n.data == "string" || bs(n.data))
  );
}
function Oi(n) {
  return _u(n) || bs(n) || Su(n);
}
function BI(n, e) {
  if (_u(n) && _u(e)) {
    if (
      n.name === e.name &&
      n.lastModified === e.lastModified &&
      n.size === e.size
    )
      return !0;
  } else {
    if (bs(n) && bs(e)) return n.equals(e);
    if (Su(n) && Su(e) && n.name === e.name) {
      if (typeof n.data == "string" && typeof e.data == "string")
        return n.data === e.data;
      if (bs(n.data) && bs(e.data)) return n.data.equals(e.data);
    }
  }
  return !1;
}
function DI(n, e) {
  var i, s;
  const t = n
      .replace("{cid}", "(?<hash>[^/]+)")
      .replace("{path}", "(?<path>[^?#]+)"),
    r = new RegExp(t),
    a = e.match(r);
  if (a) {
    const o = (i = a.groups) == null ? void 0 : i.hash,
      c = (s = a.groups) == null ? void 0 : s.path,
      l = e.includes("?") ? e.substring(e.indexOf("?") + 1) : "";
    return { hash: o, path: c, query: l };
  }
}
function x6(n, e) {
  for (const t of Object.keys(e))
    for (const r of e[t])
      if (r.includes("{cid}")) {
        const a = DI(r, n);
        if (a != null && a.hash && a != null && a.path) {
          const i =
            a != null && a.query ? `?${a == null ? void 0 : a.query}` : "";
          return `${t}${a == null ? void 0 : a.hash}/${
            a == null ? void 0 : a.path
          }${i}`;
        } else return n;
      } else if (n.startsWith(r)) return n.replace(r, t);
  return n;
}
function rm(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const r = Object.keys(e).find((s) => n.startsWith(s)),
    a = r ? e[r] : [];
  if ((!r && t > 0) || (r && t >= a.length)) return;
  if (!r) return n;
  const i = n.replace(r, "");
  return II(a[t], i);
}
function Up(n, e) {
  return typeof n == "string"
    ? x6(n, e)
    : typeof n == "object"
    ? !n || Oi(n)
      ? n
      : Array.isArray(n)
      ? n.map((t) => Up(t, e))
      : Object.fromEntries(
          Object.entries(n).map((t) => {
            let [r, a] = t;
            return [r, Up(a, e)];
          }),
        )
    : n;
}
function Pu(n, e) {
  return typeof n == "string"
    ? rm(n, e)
    : typeof n == "object"
    ? !n || Oi(n)
      ? n
      : Array.isArray(n)
      ? n.map((t) => Pu(t, e))
      : Object.fromEntries(
          Object.entries(n).map((t) => {
            let [r, a] = t;
            return [r, Pu(a, e)];
          }),
        )
    : n;
}
function jp(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (Oi(n)) return e.push(n), e;
  if (typeof n == "object") {
    if (!n) return e;
    Array.isArray(n)
      ? n.forEach((t) => jp(t, e))
      : Object.keys(n).map((t) => jp(n[t], e));
  }
  return e;
}
function zp(n, e) {
  if (Oi(n)) {
    if (e.length) return (n = e.shift()), n;
    console.warn("Not enough URIs to replace all files in object.");
  }
  return typeof n == "object"
    ? n &&
        (Array.isArray(n)
          ? n.map((t) => zp(t, e))
          : Object.fromEntries(
              Object.entries(n).map((t) => {
                let [r, a] = t;
                return [r, zp(a, e)];
              }),
            ))
    : n;
}
class OI {
  constructor(e) {
    (this.secretKey = e.secretKey), (this.clientId = e.clientId);
  }
  async download(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    if (r > 3)
      return (
        console.error(
          "[FAILED_TO_DOWNLOAD_ERROR] Failed to download from URI - too many attempts failed.",
        ),
        new Wp.Response(JSON.stringify({ error: "Not Found" }), {
          status: 404,
          headers: { "Content-Type": "application/json" },
        })
      );
    let a = rm(e, t, r);
    if (a)
      r > 0 && console.warn(`Retrying download with backup gateway URL: ${a}`);
    else
      return (
        console.error(
          "[FAILED_TO_DOWNLOAD_ERROR] Unable to download from URI - all gateway URLs failed to respond.",
        ),
        new Wp.Response(JSON.stringify({ error: "Not Found" }), {
          status: 404,
          headers: { "Content-Type": "application/json" },
        })
      );
    let i = {};
    if (
      (Z1(a) &&
        (this.secretKey
          ? (i = { "x-secret-key": this.secretKey })
          : this.clientId &&
            (typeof globalThis < "u" &&
              "APP_BUNDLE_ID" in globalThis &&
              (a = a + `?bundleId=${globalThis.APP_BUNDLE_ID}`),
            (i = { "x-client-Id": this.clientId })),
        typeof globalThis < "u" &&
          "TW_AUTH_TOKEN" in globalThis &&
          (i = { ...i, authorization: `Bearer ${globalThis.TW_AUTH_TOKEN}` })),
      NI(a))
    )
      return this.download(e, t, r + 1);
    const s = new AbortController(),
      o = setTimeout(() => s.abort(), 5e3),
      c = await la(a, { headers: i, signal: s.signal }).catch((l) => l);
    return (
      o && clearTimeout(o),
      "status" in c
        ? c.ok
          ? c
          : c.status === 429
          ? (FI(a, c), this.download(e, t, r + 1))
          : c.status === 410
          ? (console.error(
              `Request to ${a} failed because this content seems to be blocklisted. Search VirusTotal for this URL to confirm: ${a} `,
            ),
            c)
          : (console.warn(
              `Request to ${a} failed with status ${c.status} - ${c.statusText}`,
            ),
            c.status === 404 && Z1(a)
              ? c
              : (c.status !== 408 && c.status !== 429 && c.status < 500,
                this.download(e, t, r + 1)))
        : this.download(e, t, r + 1)
    );
  }
}
const Hp = new Map();
function NI(n) {
  return Hp.has(n);
}
const s0 = new Map();
function FI(n, e) {
  s0.has(n) && clearTimeout(s0.get(n));
  const t = e.headers.get("Retry-After");
  let r = 5e3;
  if (t) {
    const a = parseInt(t);
    isNaN(a) || (r = a * 1e3);
  }
  Hp.set(n, !0),
    s0.set(
      n,
      setTimeout(() => Hp.delete(n), r),
    );
}
class LI {
  constructor(e) {
    (this.uploadWithGatewayUrl =
      (e == null ? void 0 : e.uploadWithGatewayUrl) || !1),
      (this.clientId = e == null ? void 0 : e.clientId),
      (this.secretKey = e == null ? void 0 : e.secretKey);
  }
  async uploadBatch(e, t) {
    if (t != null && t.uploadWithoutDirectory && e.length > 1)
      throw new Error(
        "[UPLOAD_WITHOUT_DIRECTORY_ERROR] Cannot upload more than one file or object without directory!",
      );
    const r = new AI(),
      { form: a, fileNames: i } = this.buildFormData(r, e, t);
    return this.uploadBatchBrowser(a, i, t);
  }
  buildFormData(e, t, r) {
    const a = new Map(),
      i = [];
    for (let o = 0; o < t.length; o++) {
      const c = t[o];
      let l = "",
        u = c;
      if (_u(c))
        if (r != null && r.rewriteFileNames) {
          let f = "";
          if (c.name) {
            const p = c.name.lastIndexOf(".");
            p > -1 && (f = c.name.substring(p));
          }
          l = `${o + r.rewriteFileNames.fileStartNumber}${f}`;
        } else l = `${c.name}`;
      else
        Su(c)
          ? ((u = c.data),
            r != null && r.rewriteFileNames
              ? (l = `${o + r.rewriteFileNames.fileStartNumber}`)
              : (l = `${c.name}`))
          : r != null && r.rewriteFileNames
          ? (l = `${o + r.rewriteFileNames.fileStartNumber}`)
          : (l = `${o}`);
      const d = r != null && r.uploadWithoutDirectory ? "files" : `files/${l}`;
      if (a.has(l)) {
        if (BI(a.get(l), c)) {
          i.push(l);
          continue;
        }
        throw new Error(
          `[DUPLICATE_FILE_NAME_ERROR] File name ${l} was passed for more than one different file.`,
        );
      }
      a.set(l, c), i.push(l), e.append("file", new Blob([u]), d);
    }
    const s = {
      name: "Storage SDK",
      keyvalues: { ...(r == null ? void 0 : r.metadata) },
    };
    return (
      e.append("pinataMetadata", JSON.stringify(s)),
      r != null &&
        r.uploadWithoutDirectory &&
        e.append("pinataOptions", JSON.stringify({ wrapWithDirectory: !1 })),
      { form: e, fileNames: i.map((o) => encodeURIComponent(o)) }
    );
  }
  async uploadBatchBrowser(e, t, r) {
    return new Promise((a, i) => {
      const s = new XMLHttpRequest();
      let o = setTimeout(() => {
        s.abort(),
          i(
            new Error(
              "Request to upload timed out! No upload progress received in 30s",
            ),
          );
      }, 3e4);
      s.upload.addEventListener("loadstart", () => {
        console.log(`[${Date.now()}] [IPFS] Started`);
      }),
        s.upload.addEventListener("progress", (c) => {
          console.log(`[IPFS] Progress Event ${c.loaded}/${c.total}`),
            clearTimeout(o),
            c.loaded < c.total
              ? (o = setTimeout(() => {
                  s.abort(),
                    i(
                      new Error(
                        "Request to upload timed out! No upload progress received in 30s",
                      ),
                    );
                }, 3e4))
              : console.log(
                  `[${Date.now()}] [IPFS] Uploaded files. Waiting for response.`,
                ),
            c.lengthComputable &&
              r != null &&
              r.onProgress &&
              (r == null ||
                r.onProgress({ progress: c.loaded, total: c.total }));
        }),
        s.addEventListener("load", () => {
          if (
            (console.log(`[${Date.now()}] [IPFS] Load`),
            clearTimeout(o),
            s.status >= 200 && s.status < 300)
          ) {
            let c;
            try {
              c = JSON.parse(s.responseText);
            } catch {
              return i(new Error("Failed to parse JSON from upload response"));
            }
            const l = c.IpfsHash;
            if (!l)
              throw new Error("Failed to get IPFS hash from upload response");
            return r != null && r.uploadWithoutDirectory
              ? a([`ipfs://${l}`])
              : a(t.map((u) => `ipfs://${l}/${u}`));
          }
          return i(
            new Error(
              `Upload failed with status ${s.status} - ${s.responseText}`,
            ),
          );
        }),
        s.addEventListener(
          "error",
          () => (
            console.log("[IPFS] Load"),
            clearTimeout(o),
            (s.readyState !== 0 && s.readyState !== 4) || s.status === 0
              ? i(
                  new Error(
                    "This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.",
                  ),
                )
              : i(new Error("Unknown upload error occured"))
          ),
        ),
        s.open("POST", `${eg}/ipfs/upload`),
        this.secretKey
          ? s.setRequestHeader("x-secret-key", this.secretKey)
          : this.clientId && s.setRequestHeader("x-client-id", this.clientId),
        typeof globalThis < "u" &&
          "APP_BUNDLE_ID" in globalThis &&
          s.setRequestHeader("x-bundle-id", globalThis.APP_BUNDLE_ID),
        typeof globalThis < "u" &&
          "TW_AUTH_TOKEN" in globalThis &&
          s.setRequestHeader(
            "authorization",
            `Bearer ${globalThis.TW_AUTH_TOKEN}`,
          ),
        s.send(e);
    });
  }
  async uploadBatchNode(e, t, r) {
    r != null &&
      r.onProgress &&
      console.warn("The onProgress option is only supported in the browser");
    const a = {};
    this.secretKey
      ? (a["x-secret-key"] = this.secretKey)
      : this.clientId && (a["x-client-id"] = this.clientId),
      typeof globalThis < "u" &&
        "APP_BUNDLE_ID" in globalThis &&
        (a["x-bundle-id"] = globalThis.APP_BUNDLE_ID),
      typeof globalThis < "u" &&
        "TW_AUTH_TOKEN" in globalThis &&
        (a.authorization = `Bearer ${globalThis.TW_AUTH_TOKEN}`);
    const i = await la(`${eg}/ipfs/upload`, {
        method: "POST",
        headers: { ...a, ...e.getHeaders() },
        body: e.getBuffer(),
      }),
      s = await i.json();
    if (!i.ok)
      throw (console.warn(s), new Error("Failed to upload files to IPFS"));
    const o = s.IpfsHash;
    if (!o) throw new Error("Failed to upload files to IPFS");
    return r != null && r.uploadWithoutDirectory
      ? [`ipfs://${o}`]
      : t.map((c) => `ipfs://${o}/${c}`);
  }
}
class tg {
  constructor(e) {
    (this.uploader =
      (e == null ? void 0 : e.uploader) ||
      new LI({
        clientId: e == null ? void 0 : e.clientId,
        secretKey: e == null ? void 0 : e.secretKey,
      })),
      (this.downloader =
        (e == null ? void 0 : e.downloader) ||
        new OI({
          secretKey: e == null ? void 0 : e.secretKey,
          clientId: e == null ? void 0 : e.clientId,
        })),
      (this.gatewayUrls = RI(
        PI(e == null ? void 0 : e.gatewayUrls),
        e == null ? void 0 : e.clientId,
        e == null ? void 0 : e.secretKey,
      ));
  }
  resolveScheme(e) {
    return rm(e, this.gatewayUrls);
  }
  async download(e) {
    return this.downloader.download(e, this.gatewayUrls);
  }
  async downloadJSON(e) {
    const r = await (await this.download(e)).json();
    return Pu(r, this.gatewayUrls);
  }
  async upload(e, t) {
    const [r] = await this.uploadBatch([e], t);
    return r;
  }
  async uploadBatch(e, t) {
    if (((e = e.filter((i) => i !== void 0)), !e.length)) return [];
    const r = e.map((i) => Oi(i) || typeof i == "string").every((i) => !!i);
    let a = [];
    if (r) a = await this.uploader.uploadBatch(e, t);
    else {
      const i = (await this.uploadAndReplaceFilesWithHashes(e, t)).map((s) =>
        typeof s == "string" ? s : JSON.stringify(s),
      );
      a = await this.uploader.uploadBatch(i, t);
    }
    return (t != null && t.uploadWithGatewayUrl) ||
      this.uploader.uploadWithGatewayUrl
      ? a.map((i) => this.resolveScheme(i))
      : a;
  }
  getGatewayUrls() {
    return this.gatewayUrls;
  }
  async uploadAndReplaceFilesWithHashes(e, t) {
    let r = e;
    r = Up(r, this.gatewayUrls);
    const a = jp(r);
    if (a.length) {
      const i = await this.uploader.uploadBatch(a, t);
      r = zp(r, i);
    }
    return (
      ((t != null && t.uploadWithGatewayUrl) ||
        this.uploader.uploadWithGatewayUrl) &&
        (r = Pu(r, this.gatewayUrls)),
      r
    );
  }
}
const $I = [
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function",
  },
];
var Kl = {},
  Vc = {},
  Gc = {},
  Zd = {};
Zd.byteLength = jI;
Zd.toByteArray = HI;
Zd.fromByteArray = GI;
var Rr = [],
  Gn = [],
  WI = typeof Uint8Array < "u" ? Uint8Array : Array,
  o0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var as = 0, UI = o0.length; as < UI; ++as)
  (Rr[as] = o0[as]), (Gn[o0.charCodeAt(as)] = as);
Gn["-".charCodeAt(0)] = 62;
Gn["_".charCodeAt(0)] = 63;
function v6(n) {
  var e = n.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var t = n.indexOf("=");
  t === -1 && (t = e);
  var r = t === e ? 0 : 4 - (t % 4);
  return [t, r];
}
function jI(n) {
  var e = v6(n),
    t = e[0],
    r = e[1];
  return ((t + r) * 3) / 4 - r;
}
function zI(n, e, t) {
  return ((e + t) * 3) / 4 - t;
}
function HI(n) {
  var e,
    t = v6(n),
    r = t[0],
    a = t[1],
    i = new WI(zI(n, r, a)),
    s = 0,
    o = a > 0 ? r - 4 : r,
    c;
  for (c = 0; c < o; c += 4)
    (e =
      (Gn[n.charCodeAt(c)] << 18) |
      (Gn[n.charCodeAt(c + 1)] << 12) |
      (Gn[n.charCodeAt(c + 2)] << 6) |
      Gn[n.charCodeAt(c + 3)]),
      (i[s++] = (e >> 16) & 255),
      (i[s++] = (e >> 8) & 255),
      (i[s++] = e & 255);
  return (
    a === 2 &&
      ((e = (Gn[n.charCodeAt(c)] << 2) | (Gn[n.charCodeAt(c + 1)] >> 4)),
      (i[s++] = e & 255)),
    a === 1 &&
      ((e =
        (Gn[n.charCodeAt(c)] << 10) |
        (Gn[n.charCodeAt(c + 1)] << 4) |
        (Gn[n.charCodeAt(c + 2)] >> 2)),
      (i[s++] = (e >> 8) & 255),
      (i[s++] = e & 255)),
    i
  );
}
function qI(n) {
  return (
    Rr[(n >> 18) & 63] + Rr[(n >> 12) & 63] + Rr[(n >> 6) & 63] + Rr[n & 63]
  );
}
function VI(n, e, t) {
  for (var r, a = [], i = e; i < t; i += 3)
    (r =
      ((n[i] << 16) & 16711680) + ((n[i + 1] << 8) & 65280) + (n[i + 2] & 255)),
      a.push(qI(r));
  return a.join("");
}
function GI(n) {
  for (
    var e, t = n.length, r = t % 3, a = [], i = 16383, s = 0, o = t - r;
    s < o;
    s += i
  )
    a.push(VI(n, s, s + i > o ? o : s + i));
  return (
    r === 1
      ? ((e = n[t - 1]), a.push(Rr[e >> 2] + Rr[(e << 4) & 63] + "=="))
      : r === 2 &&
        ((e = (n[t - 2] << 8) + n[t - 1]),
        a.push(Rr[e >> 10] + Rr[(e >> 4) & 63] + Rr[(e << 2) & 63] + "=")),
    a.join("")
  );
}
var am = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ am.read =
  function (n, e, t, r, a) {
    var i,
      s,
      o = a * 8 - r - 1,
      c = (1 << o) - 1,
      l = c >> 1,
      u = -7,
      d = t ? a - 1 : 0,
      f = t ? -1 : 1,
      p = n[e + d];
    for (
      d += f, i = p & ((1 << -u) - 1), p >>= -u, u += o;
      u > 0;
      i = i * 256 + n[e + d], d += f, u -= 8
    );
    for (
      s = i & ((1 << -u) - 1), i >>= -u, u += r;
      u > 0;
      s = s * 256 + n[e + d], d += f, u -= 8
    );
    if (i === 0) i = 1 - l;
    else {
      if (i === c) return s ? NaN : (p ? -1 : 1) * (1 / 0);
      (s = s + Math.pow(2, r)), (i = i - l);
    }
    return (p ? -1 : 1) * s * Math.pow(2, i - r);
  };
am.write = function (n, e, t, r, a, i) {
  var s,
    o,
    c,
    l = i * 8 - a - 1,
    u = (1 << l) - 1,
    d = u >> 1,
    f = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
    p = r ? 0 : i - 1,
    m = r ? 1 : -1,
    y = e < 0 || (e === 0 && 1 / e < 0) ? 1 : 0;
  for (
    e = Math.abs(e),
      isNaN(e) || e === 1 / 0
        ? ((o = isNaN(e) ? 1 : 0), (s = u))
        : ((s = Math.floor(Math.log(e) / Math.LN2)),
          e * (c = Math.pow(2, -s)) < 1 && (s--, (c *= 2)),
          s + d >= 1 ? (e += f / c) : (e += f * Math.pow(2, 1 - d)),
          e * c >= 2 && (s++, (c /= 2)),
          s + d >= u
            ? ((o = 0), (s = u))
            : s + d >= 1
            ? ((o = (e * c - 1) * Math.pow(2, a)), (s = s + d))
            : ((o = e * Math.pow(2, d - 1) * Math.pow(2, a)), (s = 0)));
    a >= 8;
    n[t + p] = o & 255, p += m, o /= 256, a -= 8
  );
  for (
    s = (s << a) | o, l += a;
    l > 0;
    n[t + p] = s & 255, p += m, s /= 256, l -= 8
  );
  n[t + p - m] |= y * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function (n) {
  const e = Zd,
    t = am,
    r =
      typeof Symbol == "function" && typeof Symbol.for == "function"
        ? Symbol.for("nodejs.util.inspect.custom")
        : null;
  (n.Buffer = o), (n.SlowBuffer = v), (n.INSPECT_MAX_BYTES = 50);
  const a = 2147483647;
  (n.kMaxLength = a),
    (o.TYPED_ARRAY_SUPPORT = i()),
    !o.TYPED_ARRAY_SUPPORT &&
      typeof console < "u" &&
      typeof console.error == "function" &&
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.",
      );
  function i() {
    try {
      const k = new Uint8Array(1),
        b = {
          foo: function () {
            return 42;
          },
        };
      return (
        Object.setPrototypeOf(b, Uint8Array.prototype),
        Object.setPrototypeOf(k, b),
        k.foo() === 42
      );
    } catch {
      return !1;
    }
  }
  Object.defineProperty(o.prototype, "parent", {
    enumerable: !0,
    get: function () {
      if (o.isBuffer(this)) return this.buffer;
    },
  }),
    Object.defineProperty(o.prototype, "offset", {
      enumerable: !0,
      get: function () {
        if (o.isBuffer(this)) return this.byteOffset;
      },
    });
  function s(k) {
    if (k > a)
      throw new RangeError(
        'The value "' + k + '" is invalid for option "size"',
      );
    const b = new Uint8Array(k);
    return Object.setPrototypeOf(b, o.prototype), b;
  }
  function o(k, b, x) {
    if (typeof k == "number") {
      if (typeof b == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number',
        );
      return d(k);
    }
    return c(k, b, x);
  }
  o.poolSize = 8192;
  function c(k, b, x) {
    if (typeof k == "string") return f(k, b);
    if (ArrayBuffer.isView(k)) return m(k);
    if (k == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof k,
      );
    if (
      ln(k, ArrayBuffer) ||
      (k && ln(k.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer < "u" &&
        (ln(k, SharedArrayBuffer) || (k && ln(k.buffer, SharedArrayBuffer))))
    )
      return y(k, b, x);
    if (typeof k == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number',
      );
    const R = k.valueOf && k.valueOf();
    if (R != null && R !== k) return o.from(R, b, x);
    const U = h(k);
    if (U) return U;
    if (
      typeof Symbol < "u" &&
      Symbol.toPrimitive != null &&
      typeof k[Symbol.toPrimitive] == "function"
    )
      return o.from(k[Symbol.toPrimitive]("string"), b, x);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
        typeof k,
    );
  }
  (o.from = function (k, b, x) {
    return c(k, b, x);
  }),
    Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(o, Uint8Array);
  function l(k) {
    if (typeof k != "number")
      throw new TypeError('"size" argument must be of type number');
    if (k < 0)
      throw new RangeError(
        'The value "' + k + '" is invalid for option "size"',
      );
  }
  function u(k, b, x) {
    return (
      l(k),
      k <= 0
        ? s(k)
        : b !== void 0
        ? typeof x == "string"
          ? s(k).fill(b, x)
          : s(k).fill(b)
        : s(k)
    );
  }
  o.alloc = function (k, b, x) {
    return u(k, b, x);
  };
  function d(k) {
    return l(k), s(k < 0 ? 0 : g(k) | 0);
  }
  (o.allocUnsafe = function (k) {
    return d(k);
  }),
    (o.allocUnsafeSlow = function (k) {
      return d(k);
    });
  function f(k, b) {
    if (((typeof b != "string" || b === "") && (b = "utf8"), !o.isEncoding(b)))
      throw new TypeError("Unknown encoding: " + b);
    const x = w(k, b) | 0;
    let R = s(x);
    const U = R.write(k, b);
    return U !== x && (R = R.slice(0, U)), R;
  }
  function p(k) {
    const b = k.length < 0 ? 0 : g(k.length) | 0,
      x = s(b);
    for (let R = 0; R < b; R += 1) x[R] = k[R] & 255;
    return x;
  }
  function m(k) {
    if (ln(k, Uint8Array)) {
      const b = new Uint8Array(k);
      return y(b.buffer, b.byteOffset, b.byteLength);
    }
    return p(k);
  }
  function y(k, b, x) {
    if (b < 0 || k.byteLength < b)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (k.byteLength < b + (x || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let R;
    return (
      b === void 0 && x === void 0
        ? (R = new Uint8Array(k))
        : x === void 0
        ? (R = new Uint8Array(k, b))
        : (R = new Uint8Array(k, b, x)),
      Object.setPrototypeOf(R, o.prototype),
      R
    );
  }
  function h(k) {
    if (o.isBuffer(k)) {
      const b = g(k.length) | 0,
        x = s(b);
      return x.length === 0 || k.copy(x, 0, 0, b), x;
    }
    if (k.length !== void 0)
      return typeof k.length != "number" || lr(k.length) ? s(0) : p(k);
    if (k.type === "Buffer" && Array.isArray(k.data)) return p(k.data);
  }
  function g(k) {
    if (k >= a)
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" +
          a.toString(16) +
          " bytes",
      );
    return k | 0;
  }
  function v(k) {
    return +k != k && (k = 0), o.alloc(+k);
  }
  (o.isBuffer = function (b) {
    return b != null && b._isBuffer === !0 && b !== o.prototype;
  }),
    (o.compare = function (b, x) {
      if (
        (ln(b, Uint8Array) && (b = o.from(b, b.offset, b.byteLength)),
        ln(x, Uint8Array) && (x = o.from(x, x.offset, x.byteLength)),
        !o.isBuffer(b) || !o.isBuffer(x))
      )
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array',
        );
      if (b === x) return 0;
      let R = b.length,
        U = x.length;
      for (let K = 0, X = Math.min(R, U); K < X; ++K)
        if (b[K] !== x[K]) {
          (R = b[K]), (U = x[K]);
          break;
        }
      return R < U ? -1 : U < R ? 1 : 0;
    }),
    (o.isEncoding = function (b) {
      switch (String(b).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }),
    (o.concat = function (b, x) {
      if (!Array.isArray(b))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (b.length === 0) return o.alloc(0);
      let R;
      if (x === void 0) for (x = 0, R = 0; R < b.length; ++R) x += b[R].length;
      const U = o.allocUnsafe(x);
      let K = 0;
      for (R = 0; R < b.length; ++R) {
        let X = b[R];
        if (ln(X, Uint8Array))
          K + X.length > U.length
            ? (o.isBuffer(X) || (X = o.from(X)), X.copy(U, K))
            : Uint8Array.prototype.set.call(U, X, K);
        else if (o.isBuffer(X)) X.copy(U, K);
        else throw new TypeError('"list" argument must be an Array of Buffers');
        K += X.length;
      }
      return U;
    });
  function w(k, b) {
    if (o.isBuffer(k)) return k.length;
    if (ArrayBuffer.isView(k) || ln(k, ArrayBuffer)) return k.byteLength;
    if (typeof k != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof k,
      );
    const x = k.length,
      R = arguments.length > 2 && arguments[2] === !0;
    if (!R && x === 0) return 0;
    let U = !1;
    for (;;)
      switch (b) {
        case "ascii":
        case "latin1":
        case "binary":
          return x;
        case "utf8":
        case "utf-8":
          return Cr(k).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return x * 2;
        case "hex":
          return x >>> 1;
        case "base64":
          return _n(k).length;
        default:
          if (U) return R ? -1 : Cr(k).length;
          (b = ("" + b).toLowerCase()), (U = !0);
      }
  }
  o.byteLength = w;
  function T(k, b, x) {
    let R = !1;
    if (
      ((b === void 0 || b < 0) && (b = 0),
      b > this.length ||
        ((x === void 0 || x > this.length) && (x = this.length), x <= 0) ||
        ((x >>>= 0), (b >>>= 0), x <= b))
    )
      return "";
    for (k || (k = "utf8"); ; )
      switch (k) {
        case "hex":
          return Z(this, b, x);
        case "utf8":
        case "utf-8":
          return N(this, b, x);
        case "ascii":
          return de(this, b, x);
        case "latin1":
        case "binary":
          return le(this, b, x);
        case "base64":
          return q(this, b, x);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ue(this, b, x);
        default:
          if (R) throw new TypeError("Unknown encoding: " + k);
          (k = (k + "").toLowerCase()), (R = !0);
      }
  }
  o.prototype._isBuffer = !0;
  function A(k, b, x) {
    const R = k[b];
    (k[b] = k[x]), (k[x] = R);
  }
  (o.prototype.swap16 = function () {
    const b = this.length;
    if (b % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let x = 0; x < b; x += 2) A(this, x, x + 1);
    return this;
  }),
    (o.prototype.swap32 = function () {
      const b = this.length;
      if (b % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let x = 0; x < b; x += 4) A(this, x, x + 3), A(this, x + 1, x + 2);
      return this;
    }),
    (o.prototype.swap64 = function () {
      const b = this.length;
      if (b % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let x = 0; x < b; x += 8)
        A(this, x, x + 7),
          A(this, x + 1, x + 6),
          A(this, x + 2, x + 5),
          A(this, x + 3, x + 4);
      return this;
    }),
    (o.prototype.toString = function () {
      const b = this.length;
      return b === 0
        ? ""
        : arguments.length === 0
        ? N(this, 0, b)
        : T.apply(this, arguments);
    }),
    (o.prototype.toLocaleString = o.prototype.toString),
    (o.prototype.equals = function (b) {
      if (!o.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      return this === b ? !0 : o.compare(this, b) === 0;
    }),
    (o.prototype.inspect = function () {
      let b = "";
      const x = n.INSPECT_MAX_BYTES;
      return (
        (b = this.toString("hex", 0, x)
          .replace(/(.{2})/g, "$1 ")
          .trim()),
        this.length > x && (b += " ... "),
        "<Buffer " + b + ">"
      );
    }),
    r && (o.prototype[r] = o.prototype.inspect),
    (o.prototype.compare = function (b, x, R, U, K) {
      if (
        (ln(b, Uint8Array) && (b = o.from(b, b.offset, b.byteLength)),
        !o.isBuffer(b))
      )
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
            typeof b,
        );
      if (
        (x === void 0 && (x = 0),
        R === void 0 && (R = b ? b.length : 0),
        U === void 0 && (U = 0),
        K === void 0 && (K = this.length),
        x < 0 || R > b.length || U < 0 || K > this.length)
      )
        throw new RangeError("out of range index");
      if (U >= K && x >= R) return 0;
      if (U >= K) return -1;
      if (x >= R) return 1;
      if (((x >>>= 0), (R >>>= 0), (U >>>= 0), (K >>>= 0), this === b))
        return 0;
      let X = K - U,
        Ee = R - x;
      const tt = Math.min(X, Ee),
        Xe = this.slice(U, K),
        it = b.slice(x, R);
      for (let He = 0; He < tt; ++He)
        if (Xe[He] !== it[He]) {
          (X = Xe[He]), (Ee = it[He]);
          break;
        }
      return X < Ee ? -1 : Ee < X ? 1 : 0;
    });
  function E(k, b, x, R, U) {
    if (k.length === 0) return -1;
    if (
      (typeof x == "string"
        ? ((R = x), (x = 0))
        : x > 2147483647
        ? (x = 2147483647)
        : x < -2147483648 && (x = -2147483648),
      (x = +x),
      lr(x) && (x = U ? 0 : k.length - 1),
      x < 0 && (x = k.length + x),
      x >= k.length)
    ) {
      if (U) return -1;
      x = k.length - 1;
    } else if (x < 0)
      if (U) x = 0;
      else return -1;
    if ((typeof b == "string" && (b = o.from(b, R)), o.isBuffer(b)))
      return b.length === 0 ? -1 : _(k, b, x, R, U);
    if (typeof b == "number")
      return (
        (b = b & 255),
        typeof Uint8Array.prototype.indexOf == "function"
          ? U
            ? Uint8Array.prototype.indexOf.call(k, b, x)
            : Uint8Array.prototype.lastIndexOf.call(k, b, x)
          : _(k, [b], x, R, U)
      );
    throw new TypeError("val must be string, number or Buffer");
  }
  function _(k, b, x, R, U) {
    let K = 1,
      X = k.length,
      Ee = b.length;
    if (
      R !== void 0 &&
      ((R = String(R).toLowerCase()),
      R === "ucs2" || R === "ucs-2" || R === "utf16le" || R === "utf-16le")
    ) {
      if (k.length < 2 || b.length < 2) return -1;
      (K = 2), (X /= 2), (Ee /= 2), (x /= 2);
    }
    function tt(it, He) {
      return K === 1 ? it[He] : it.readUInt16BE(He * K);
    }
    let Xe;
    if (U) {
      let it = -1;
      for (Xe = x; Xe < X; Xe++)
        if (tt(k, Xe) === tt(b, it === -1 ? 0 : Xe - it)) {
          if ((it === -1 && (it = Xe), Xe - it + 1 === Ee)) return it * K;
        } else it !== -1 && (Xe -= Xe - it), (it = -1);
    } else
      for (x + Ee > X && (x = X - Ee), Xe = x; Xe >= 0; Xe--) {
        let it = !0;
        for (let He = 0; He < Ee; He++)
          if (tt(k, Xe + He) !== tt(b, He)) {
            it = !1;
            break;
          }
        if (it) return Xe;
      }
    return -1;
  }
  (o.prototype.includes = function (b, x, R) {
    return this.indexOf(b, x, R) !== -1;
  }),
    (o.prototype.indexOf = function (b, x, R) {
      return E(this, b, x, R, !0);
    }),
    (o.prototype.lastIndexOf = function (b, x, R) {
      return E(this, b, x, R, !1);
    });
  function S(k, b, x, R) {
    x = Number(x) || 0;
    const U = k.length - x;
    R ? ((R = Number(R)), R > U && (R = U)) : (R = U);
    const K = b.length;
    R > K / 2 && (R = K / 2);
    let X;
    for (X = 0; X < R; ++X) {
      const Ee = parseInt(b.substr(X * 2, 2), 16);
      if (lr(Ee)) return X;
      k[x + X] = Ee;
    }
    return X;
  }
  function W(k, b, x, R) {
    return Yt(Cr(b, k.length - x), k, x, R);
  }
  function D(k, b, x, R) {
    return Yt(Qr(b), k, x, R);
  }
  function L(k, b, x, R) {
    return Yt(_n(b), k, x, R);
  }
  function G(k, b, x, R) {
    return Yt(di(b, k.length - x), k, x, R);
  }
  (o.prototype.write = function (b, x, R, U) {
    if (x === void 0) (U = "utf8"), (R = this.length), (x = 0);
    else if (R === void 0 && typeof x == "string")
      (U = x), (R = this.length), (x = 0);
    else if (isFinite(x))
      (x = x >>> 0),
        isFinite(R)
          ? ((R = R >>> 0), U === void 0 && (U = "utf8"))
          : ((U = R), (R = void 0));
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported",
      );
    const K = this.length - x;
    if (
      ((R === void 0 || R > K) && (R = K),
      (b.length > 0 && (R < 0 || x < 0)) || x > this.length)
    )
      throw new RangeError("Attempt to write outside buffer bounds");
    U || (U = "utf8");
    let X = !1;
    for (;;)
      switch (U) {
        case "hex":
          return S(this, b, x, R);
        case "utf8":
        case "utf-8":
          return W(this, b, x, R);
        case "ascii":
        case "latin1":
        case "binary":
          return D(this, b, x, R);
        case "base64":
          return L(this, b, x, R);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return G(this, b, x, R);
        default:
          if (X) throw new TypeError("Unknown encoding: " + U);
          (U = ("" + U).toLowerCase()), (X = !0);
      }
  }),
    (o.prototype.toJSON = function () {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0),
      };
    });
  function q(k, b, x) {
    return b === 0 && x === k.length
      ? e.fromByteArray(k)
      : e.fromByteArray(k.slice(b, x));
  }
  function N(k, b, x) {
    x = Math.min(k.length, x);
    const R = [];
    let U = b;
    for (; U < x; ) {
      const K = k[U];
      let X = null,
        Ee = K > 239 ? 4 : K > 223 ? 3 : K > 191 ? 2 : 1;
      if (U + Ee <= x) {
        let tt, Xe, it, He;
        switch (Ee) {
          case 1:
            K < 128 && (X = K);
            break;
          case 2:
            (tt = k[U + 1]),
              (tt & 192) === 128 &&
                ((He = ((K & 31) << 6) | (tt & 63)), He > 127 && (X = He));
            break;
          case 3:
            (tt = k[U + 1]),
              (Xe = k[U + 2]),
              (tt & 192) === 128 &&
                (Xe & 192) === 128 &&
                ((He = ((K & 15) << 12) | ((tt & 63) << 6) | (Xe & 63)),
                He > 2047 && (He < 55296 || He > 57343) && (X = He));
            break;
          case 4:
            (tt = k[U + 1]),
              (Xe = k[U + 2]),
              (it = k[U + 3]),
              (tt & 192) === 128 &&
                (Xe & 192) === 128 &&
                (it & 192) === 128 &&
                ((He =
                  ((K & 15) << 18) |
                  ((tt & 63) << 12) |
                  ((Xe & 63) << 6) |
                  (it & 63)),
                He > 65535 && He < 1114112 && (X = He));
        }
      }
      X === null
        ? ((X = 65533), (Ee = 1))
        : X > 65535 &&
          ((X -= 65536),
          R.push(((X >>> 10) & 1023) | 55296),
          (X = 56320 | (X & 1023))),
        R.push(X),
        (U += Ee);
    }
    return J(R);
  }
  const H = 4096;
  function J(k) {
    const b = k.length;
    if (b <= H) return String.fromCharCode.apply(String, k);
    let x = "",
      R = 0;
    for (; R < b; )
      x += String.fromCharCode.apply(String, k.slice(R, (R += H)));
    return x;
  }
  function de(k, b, x) {
    let R = "";
    x = Math.min(k.length, x);
    for (let U = b; U < x; ++U) R += String.fromCharCode(k[U] & 127);
    return R;
  }
  function le(k, b, x) {
    let R = "";
    x = Math.min(k.length, x);
    for (let U = b; U < x; ++U) R += String.fromCharCode(k[U]);
    return R;
  }
  function Z(k, b, x) {
    const R = k.length;
    (!b || b < 0) && (b = 0), (!x || x < 0 || x > R) && (x = R);
    let U = "";
    for (let K = b; K < x; ++K) U += Sn[k[K]];
    return U;
  }
  function ue(k, b, x) {
    const R = k.slice(b, x);
    let U = "";
    for (let K = 0; K < R.length - 1; K += 2)
      U += String.fromCharCode(R[K] + R[K + 1] * 256);
    return U;
  }
  o.prototype.slice = function (b, x) {
    const R = this.length;
    (b = ~~b),
      (x = x === void 0 ? R : ~~x),
      b < 0 ? ((b += R), b < 0 && (b = 0)) : b > R && (b = R),
      x < 0 ? ((x += R), x < 0 && (x = 0)) : x > R && (x = R),
      x < b && (x = b);
    const U = this.subarray(b, x);
    return Object.setPrototypeOf(U, o.prototype), U;
  };
  function P(k, b, x) {
    if (k % 1 !== 0 || k < 0) throw new RangeError("offset is not uint");
    if (k + b > x)
      throw new RangeError("Trying to access beyond buffer length");
  }
  (o.prototype.readUintLE = o.prototype.readUIntLE =
    function (b, x, R) {
      (b = b >>> 0), (x = x >>> 0), R || P(b, x, this.length);
      let U = this[b],
        K = 1,
        X = 0;
      for (; ++X < x && (K *= 256); ) U += this[b + X] * K;
      return U;
    }),
    (o.prototype.readUintBE = o.prototype.readUIntBE =
      function (b, x, R) {
        (b = b >>> 0), (x = x >>> 0), R || P(b, x, this.length);
        let U = this[b + --x],
          K = 1;
        for (; x > 0 && (K *= 256); ) U += this[b + --x] * K;
        return U;
      }),
    (o.prototype.readUint8 = o.prototype.readUInt8 =
      function (b, x) {
        return (b = b >>> 0), x || P(b, 1, this.length), this[b];
      }),
    (o.prototype.readUint16LE = o.prototype.readUInt16LE =
      function (b, x) {
        return (
          (b = b >>> 0), x || P(b, 2, this.length), this[b] | (this[b + 1] << 8)
        );
      }),
    (o.prototype.readUint16BE = o.prototype.readUInt16BE =
      function (b, x) {
        return (
          (b = b >>> 0), x || P(b, 2, this.length), (this[b] << 8) | this[b + 1]
        );
      }),
    (o.prototype.readUint32LE = o.prototype.readUInt32LE =
      function (b, x) {
        return (
          (b = b >>> 0),
          x || P(b, 4, this.length),
          (this[b] | (this[b + 1] << 8) | (this[b + 2] << 16)) +
            this[b + 3] * 16777216
        );
      }),
    (o.prototype.readUint32BE = o.prototype.readUInt32BE =
      function (b, x) {
        return (
          (b = b >>> 0),
          x || P(b, 4, this.length),
          this[b] * 16777216 +
            ((this[b + 1] << 16) | (this[b + 2] << 8) | this[b + 3])
        );
      }),
    (o.prototype.readBigUInt64LE = ur(function (b) {
      (b = b >>> 0), wt(b, "offset");
      const x = this[b],
        R = this[b + 7];
      (x === void 0 || R === void 0) && ot(b, this.length - 8);
      const U =
          x + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + this[++b] * 2 ** 24,
        K = this[++b] + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + R * 2 ** 24;
      return BigInt(U) + (BigInt(K) << BigInt(32));
    })),
    (o.prototype.readBigUInt64BE = ur(function (b) {
      (b = b >>> 0), wt(b, "offset");
      const x = this[b],
        R = this[b + 7];
      (x === void 0 || R === void 0) && ot(b, this.length - 8);
      const U =
          x * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + this[++b],
        K = this[++b] * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + R;
      return (BigInt(U) << BigInt(32)) + BigInt(K);
    })),
    (o.prototype.readIntLE = function (b, x, R) {
      (b = b >>> 0), (x = x >>> 0), R || P(b, x, this.length);
      let U = this[b],
        K = 1,
        X = 0;
      for (; ++X < x && (K *= 256); ) U += this[b + X] * K;
      return (K *= 128), U >= K && (U -= Math.pow(2, 8 * x)), U;
    }),
    (o.prototype.readIntBE = function (b, x, R) {
      (b = b >>> 0), (x = x >>> 0), R || P(b, x, this.length);
      let U = x,
        K = 1,
        X = this[b + --U];
      for (; U > 0 && (K *= 256); ) X += this[b + --U] * K;
      return (K *= 128), X >= K && (X -= Math.pow(2, 8 * x)), X;
    }),
    (o.prototype.readInt8 = function (b, x) {
      return (
        (b = b >>> 0),
        x || P(b, 1, this.length),
        this[b] & 128 ? (255 - this[b] + 1) * -1 : this[b]
      );
    }),
    (o.prototype.readInt16LE = function (b, x) {
      (b = b >>> 0), x || P(b, 2, this.length);
      const R = this[b] | (this[b + 1] << 8);
      return R & 32768 ? R | 4294901760 : R;
    }),
    (o.prototype.readInt16BE = function (b, x) {
      (b = b >>> 0), x || P(b, 2, this.length);
      const R = this[b + 1] | (this[b] << 8);
      return R & 32768 ? R | 4294901760 : R;
    }),
    (o.prototype.readInt32LE = function (b, x) {
      return (
        (b = b >>> 0),
        x || P(b, 4, this.length),
        this[b] | (this[b + 1] << 8) | (this[b + 2] << 16) | (this[b + 3] << 24)
      );
    }),
    (o.prototype.readInt32BE = function (b, x) {
      return (
        (b = b >>> 0),
        x || P(b, 4, this.length),
        (this[b] << 24) | (this[b + 1] << 16) | (this[b + 2] << 8) | this[b + 3]
      );
    }),
    (o.prototype.readBigInt64LE = ur(function (b) {
      (b = b >>> 0), wt(b, "offset");
      const x = this[b],
        R = this[b + 7];
      (x === void 0 || R === void 0) && ot(b, this.length - 8);
      const U =
        this[b + 4] + this[b + 5] * 2 ** 8 + this[b + 6] * 2 ** 16 + (R << 24);
      return (
        (BigInt(U) << BigInt(32)) +
        BigInt(
          x + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + this[++b] * 2 ** 24,
        )
      );
    })),
    (o.prototype.readBigInt64BE = ur(function (b) {
      (b = b >>> 0), wt(b, "offset");
      const x = this[b],
        R = this[b + 7];
      (x === void 0 || R === void 0) && ot(b, this.length - 8);
      const U =
        (x << 24) + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + this[++b];
      return (
        (BigInt(U) << BigInt(32)) +
        BigInt(
          this[++b] * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + R,
        )
      );
    })),
    (o.prototype.readFloatLE = function (b, x) {
      return (
        (b = b >>> 0), x || P(b, 4, this.length), t.read(this, b, !0, 23, 4)
      );
    }),
    (o.prototype.readFloatBE = function (b, x) {
      return (
        (b = b >>> 0), x || P(b, 4, this.length), t.read(this, b, !1, 23, 4)
      );
    }),
    (o.prototype.readDoubleLE = function (b, x) {
      return (
        (b = b >>> 0), x || P(b, 8, this.length), t.read(this, b, !0, 52, 8)
      );
    }),
    (o.prototype.readDoubleBE = function (b, x) {
      return (
        (b = b >>> 0), x || P(b, 8, this.length), t.read(this, b, !1, 52, 8)
      );
    });
  function B(k, b, x, R, U, K) {
    if (!o.isBuffer(k))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (b > U || b < K)
      throw new RangeError('"value" argument is out of bounds');
    if (x + R > k.length) throw new RangeError("Index out of range");
  }
  (o.prototype.writeUintLE = o.prototype.writeUIntLE =
    function (b, x, R, U) {
      if (((b = +b), (x = x >>> 0), (R = R >>> 0), !U)) {
        const Ee = Math.pow(2, 8 * R) - 1;
        B(this, b, x, R, Ee, 0);
      }
      let K = 1,
        X = 0;
      for (this[x] = b & 255; ++X < R && (K *= 256); )
        this[x + X] = (b / K) & 255;
      return x + R;
    }),
    (o.prototype.writeUintBE = o.prototype.writeUIntBE =
      function (b, x, R, U) {
        if (((b = +b), (x = x >>> 0), (R = R >>> 0), !U)) {
          const Ee = Math.pow(2, 8 * R) - 1;
          B(this, b, x, R, Ee, 0);
        }
        let K = R - 1,
          X = 1;
        for (this[x + K] = b & 255; --K >= 0 && (X *= 256); )
          this[x + K] = (b / X) & 255;
        return x + R;
      }),
    (o.prototype.writeUint8 = o.prototype.writeUInt8 =
      function (b, x, R) {
        return (
          (b = +b),
          (x = x >>> 0),
          R || B(this, b, x, 1, 255, 0),
          (this[x] = b & 255),
          x + 1
        );
      }),
    (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
      function (b, x, R) {
        return (
          (b = +b),
          (x = x >>> 0),
          R || B(this, b, x, 2, 65535, 0),
          (this[x] = b & 255),
          (this[x + 1] = b >>> 8),
          x + 2
        );
      }),
    (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
      function (b, x, R) {
        return (
          (b = +b),
          (x = x >>> 0),
          R || B(this, b, x, 2, 65535, 0),
          (this[x] = b >>> 8),
          (this[x + 1] = b & 255),
          x + 2
        );
      }),
    (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
      function (b, x, R) {
        return (
          (b = +b),
          (x = x >>> 0),
          R || B(this, b, x, 4, 4294967295, 0),
          (this[x + 3] = b >>> 24),
          (this[x + 2] = b >>> 16),
          (this[x + 1] = b >>> 8),
          (this[x] = b & 255),
          x + 4
        );
      }),
    (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
      function (b, x, R) {
        return (
          (b = +b),
          (x = x >>> 0),
          R || B(this, b, x, 4, 4294967295, 0),
          (this[x] = b >>> 24),
          (this[x + 1] = b >>> 16),
          (this[x + 2] = b >>> 8),
          (this[x + 3] = b & 255),
          x + 4
        );
      });
  function j(k, b, x, R, U) {
    cn(b, R, U, k, x, 7);
    let K = Number(b & BigInt(4294967295));
    (k[x++] = K),
      (K = K >> 8),
      (k[x++] = K),
      (K = K >> 8),
      (k[x++] = K),
      (K = K >> 8),
      (k[x++] = K);
    let X = Number((b >> BigInt(32)) & BigInt(4294967295));
    return (
      (k[x++] = X),
      (X = X >> 8),
      (k[x++] = X),
      (X = X >> 8),
      (k[x++] = X),
      (X = X >> 8),
      (k[x++] = X),
      x
    );
  }
  function F(k, b, x, R, U) {
    cn(b, R, U, k, x, 7);
    let K = Number(b & BigInt(4294967295));
    (k[x + 7] = K),
      (K = K >> 8),
      (k[x + 6] = K),
      (K = K >> 8),
      (k[x + 5] = K),
      (K = K >> 8),
      (k[x + 4] = K);
    let X = Number((b >> BigInt(32)) & BigInt(4294967295));
    return (
      (k[x + 3] = X),
      (X = X >> 8),
      (k[x + 2] = X),
      (X = X >> 8),
      (k[x + 1] = X),
      (X = X >> 8),
      (k[x] = X),
      x + 8
    );
  }
  (o.prototype.writeBigUInt64LE = ur(function (b, x = 0) {
    return j(this, b, x, BigInt(0), BigInt("0xffffffffffffffff"));
  })),
    (o.prototype.writeBigUInt64BE = ur(function (b, x = 0) {
      return F(this, b, x, BigInt(0), BigInt("0xffffffffffffffff"));
    })),
    (o.prototype.writeIntLE = function (b, x, R, U) {
      if (((b = +b), (x = x >>> 0), !U)) {
        const tt = Math.pow(2, 8 * R - 1);
        B(this, b, x, R, tt - 1, -tt);
      }
      let K = 0,
        X = 1,
        Ee = 0;
      for (this[x] = b & 255; ++K < R && (X *= 256); )
        b < 0 && Ee === 0 && this[x + K - 1] !== 0 && (Ee = 1),
          (this[x + K] = (((b / X) >> 0) - Ee) & 255);
      return x + R;
    }),
    (o.prototype.writeIntBE = function (b, x, R, U) {
      if (((b = +b), (x = x >>> 0), !U)) {
        const tt = Math.pow(2, 8 * R - 1);
        B(this, b, x, R, tt - 1, -tt);
      }
      let K = R - 1,
        X = 1,
        Ee = 0;
      for (this[x + K] = b & 255; --K >= 0 && (X *= 256); )
        b < 0 && Ee === 0 && this[x + K + 1] !== 0 && (Ee = 1),
          (this[x + K] = (((b / X) >> 0) - Ee) & 255);
      return x + R;
    }),
    (o.prototype.writeInt8 = function (b, x, R) {
      return (
        (b = +b),
        (x = x >>> 0),
        R || B(this, b, x, 1, 127, -128),
        b < 0 && (b = 255 + b + 1),
        (this[x] = b & 255),
        x + 1
      );
    }),
    (o.prototype.writeInt16LE = function (b, x, R) {
      return (
        (b = +b),
        (x = x >>> 0),
        R || B(this, b, x, 2, 32767, -32768),
        (this[x] = b & 255),
        (this[x + 1] = b >>> 8),
        x + 2
      );
    }),
    (o.prototype.writeInt16BE = function (b, x, R) {
      return (
        (b = +b),
        (x = x >>> 0),
        R || B(this, b, x, 2, 32767, -32768),
        (this[x] = b >>> 8),
        (this[x + 1] = b & 255),
        x + 2
      );
    }),
    (o.prototype.writeInt32LE = function (b, x, R) {
      return (
        (b = +b),
        (x = x >>> 0),
        R || B(this, b, x, 4, 2147483647, -2147483648),
        (this[x] = b & 255),
        (this[x + 1] = b >>> 8),
        (this[x + 2] = b >>> 16),
        (this[x + 3] = b >>> 24),
        x + 4
      );
    }),
    (o.prototype.writeInt32BE = function (b, x, R) {
      return (
        (b = +b),
        (x = x >>> 0),
        R || B(this, b, x, 4, 2147483647, -2147483648),
        b < 0 && (b = 4294967295 + b + 1),
        (this[x] = b >>> 24),
        (this[x + 1] = b >>> 16),
        (this[x + 2] = b >>> 8),
        (this[x + 3] = b & 255),
        x + 4
      );
    }),
    (o.prototype.writeBigInt64LE = ur(function (b, x = 0) {
      return j(
        this,
        b,
        x,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff"),
      );
    })),
    (o.prototype.writeBigInt64BE = ur(function (b, x = 0) {
      return F(
        this,
        b,
        x,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff"),
      );
    }));
  function V(k, b, x, R, U, K) {
    if (x + R > k.length) throw new RangeError("Index out of range");
    if (x < 0) throw new RangeError("Index out of range");
  }
  function re(k, b, x, R, U) {
    return (
      (b = +b),
      (x = x >>> 0),
      U || V(k, b, x, 4),
      t.write(k, b, x, R, 23, 4),
      x + 4
    );
  }
  (o.prototype.writeFloatLE = function (b, x, R) {
    return re(this, b, x, !0, R);
  }),
    (o.prototype.writeFloatBE = function (b, x, R) {
      return re(this, b, x, !1, R);
    });
  function we(k, b, x, R, U) {
    return (
      (b = +b),
      (x = x >>> 0),
      U || V(k, b, x, 8),
      t.write(k, b, x, R, 52, 8),
      x + 8
    );
  }
  (o.prototype.writeDoubleLE = function (b, x, R) {
    return we(this, b, x, !0, R);
  }),
    (o.prototype.writeDoubleBE = function (b, x, R) {
      return we(this, b, x, !1, R);
    }),
    (o.prototype.copy = function (b, x, R, U) {
      if (!o.isBuffer(b)) throw new TypeError("argument should be a Buffer");
      if (
        (R || (R = 0),
        !U && U !== 0 && (U = this.length),
        x >= b.length && (x = b.length),
        x || (x = 0),
        U > 0 && U < R && (U = R),
        U === R || b.length === 0 || this.length === 0)
      )
        return 0;
      if (x < 0) throw new RangeError("targetStart out of bounds");
      if (R < 0 || R >= this.length) throw new RangeError("Index out of range");
      if (U < 0) throw new RangeError("sourceEnd out of bounds");
      U > this.length && (U = this.length),
        b.length - x < U - R && (U = b.length - x + R);
      const K = U - R;
      return (
        this === b && typeof Uint8Array.prototype.copyWithin == "function"
          ? this.copyWithin(x, R, U)
          : Uint8Array.prototype.set.call(b, this.subarray(R, U), x),
        K
      );
    }),
    (o.prototype.fill = function (b, x, R, U) {
      if (typeof b == "string") {
        if (
          (typeof x == "string"
            ? ((U = x), (x = 0), (R = this.length))
            : typeof R == "string" && ((U = R), (R = this.length)),
          U !== void 0 && typeof U != "string")
        )
          throw new TypeError("encoding must be a string");
        if (typeof U == "string" && !o.isEncoding(U))
          throw new TypeError("Unknown encoding: " + U);
        if (b.length === 1) {
          const X = b.charCodeAt(0);
          ((U === "utf8" && X < 128) || U === "latin1") && (b = X);
        }
      } else
        typeof b == "number"
          ? (b = b & 255)
          : typeof b == "boolean" && (b = Number(b));
      if (x < 0 || this.length < x || this.length < R)
        throw new RangeError("Out of range index");
      if (R <= x) return this;
      (x = x >>> 0), (R = R === void 0 ? this.length : R >>> 0), b || (b = 0);
      let K;
      if (typeof b == "number") for (K = x; K < R; ++K) this[K] = b;
      else {
        const X = o.isBuffer(b) ? b : o.from(b, U),
          Ee = X.length;
        if (Ee === 0)
          throw new TypeError(
            'The value "' + b + '" is invalid for argument "value"',
          );
        for (K = 0; K < R - x; ++K) this[K + x] = X[K % Ee];
      }
      return this;
    });
  const se = {};
  function be(k, b, x) {
    se[k] = class extends x {
      constructor() {
        super(),
          Object.defineProperty(this, "message", {
            value: b.apply(this, arguments),
            writable: !0,
            configurable: !0,
          }),
          (this.name = `${this.name} [${k}]`),
          this.stack,
          delete this.name;
      }
      get code() {
        return k;
      }
      set code(U) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: U,
          writable: !0,
        });
      }
      toString() {
        return `${this.name} [${k}]: ${this.message}`;
      }
    };
  }
  be(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function (k) {
      return k
        ? `${k} is outside of buffer bounds`
        : "Attempt to access memory outside buffer bounds";
    },
    RangeError,
  ),
    be(
      "ERR_INVALID_ARG_TYPE",
      function (k, b) {
        return `The "${k}" argument must be of type number. Received type ${typeof b}`;
      },
      TypeError,
    ),
    be(
      "ERR_OUT_OF_RANGE",
      function (k, b, x) {
        let R = `The value of "${k}" is out of range.`,
          U = x;
        return (
          Number.isInteger(x) && Math.abs(x) > 2 ** 32
            ? (U = Ke(String(x)))
            : typeof x == "bigint" &&
              ((U = String(x)),
              (x > BigInt(2) ** BigInt(32) || x < -(BigInt(2) ** BigInt(32))) &&
                (U = Ke(U)),
              (U += "n")),
          (R += ` It must be ${b}. Received ${U}`),
          R
        );
      },
      RangeError,
    );
  function Ke(k) {
    let b = "",
      x = k.length;
    const R = k[0] === "-" ? 1 : 0;
    for (; x >= R + 4; x -= 3) b = `_${k.slice(x - 3, x)}${b}`;
    return `${k.slice(0, x)}${b}`;
  }
  function dt(k, b, x) {
    wt(b, "offset"),
      (k[b] === void 0 || k[b + x] === void 0) && ot(b, k.length - (x + 1));
  }
  function cn(k, b, x, R, U, K) {
    if (k > x || k < b) {
      const X = typeof b == "bigint" ? "n" : "";
      let Ee;
      throw (
        (K > 3
          ? b === 0 || b === BigInt(0)
            ? (Ee = `>= 0${X} and < 2${X} ** ${(K + 1) * 8}${X}`)
            : (Ee = `>= -(2${X} ** ${(K + 1) * 8 - 1}${X}) and < 2 ** ${
                (K + 1) * 8 - 1
              }${X}`)
          : (Ee = `>= ${b}${X} and <= ${x}${X}`),
        new se.ERR_OUT_OF_RANGE("value", Ee, k))
      );
    }
    dt(R, U, K);
  }
  function wt(k, b) {
    if (typeof k != "number") throw new se.ERR_INVALID_ARG_TYPE(b, "number", k);
  }
  function ot(k, b, x) {
    throw Math.floor(k) !== k
      ? (wt(k, x), new se.ERR_OUT_OF_RANGE(x || "offset", "an integer", k))
      : b < 0
      ? new se.ERR_BUFFER_OUT_OF_BOUNDS()
      : new se.ERR_OUT_OF_RANGE(
          x || "offset",
          `>= ${x ? 1 : 0} and <= ${b}`,
          k,
        );
  }
  const ba = /[^+/0-9A-Za-z-_]/g;
  function Kr(k) {
    if (((k = k.split("=")[0]), (k = k.trim().replace(ba, "")), k.length < 2))
      return "";
    for (; k.length % 4 !== 0; ) k = k + "=";
    return k;
  }
  function Cr(k, b) {
    b = b || 1 / 0;
    let x;
    const R = k.length;
    let U = null;
    const K = [];
    for (let X = 0; X < R; ++X) {
      if (((x = k.charCodeAt(X)), x > 55295 && x < 57344)) {
        if (!U) {
          if (x > 56319) {
            (b -= 3) > -1 && K.push(239, 191, 189);
            continue;
          } else if (X + 1 === R) {
            (b -= 3) > -1 && K.push(239, 191, 189);
            continue;
          }
          U = x;
          continue;
        }
        if (x < 56320) {
          (b -= 3) > -1 && K.push(239, 191, 189), (U = x);
          continue;
        }
        x = (((U - 55296) << 10) | (x - 56320)) + 65536;
      } else U && (b -= 3) > -1 && K.push(239, 191, 189);
      if (((U = null), x < 128)) {
        if ((b -= 1) < 0) break;
        K.push(x);
      } else if (x < 2048) {
        if ((b -= 2) < 0) break;
        K.push((x >> 6) | 192, (x & 63) | 128);
      } else if (x < 65536) {
        if ((b -= 3) < 0) break;
        K.push((x >> 12) | 224, ((x >> 6) & 63) | 128, (x & 63) | 128);
      } else if (x < 1114112) {
        if ((b -= 4) < 0) break;
        K.push(
          (x >> 18) | 240,
          ((x >> 12) & 63) | 128,
          ((x >> 6) & 63) | 128,
          (x & 63) | 128,
        );
      } else throw new Error("Invalid code point");
    }
    return K;
  }
  function Qr(k) {
    const b = [];
    for (let x = 0; x < k.length; ++x) b.push(k.charCodeAt(x) & 255);
    return b;
  }
  function di(k, b) {
    let x, R, U;
    const K = [];
    for (let X = 0; X < k.length && !((b -= 2) < 0); ++X)
      (x = k.charCodeAt(X)), (R = x >> 8), (U = x % 256), K.push(U), K.push(R);
    return K;
  }
  function _n(k) {
    return e.toByteArray(Kr(k));
  }
  function Yt(k, b, x, R) {
    let U;
    for (U = 0; U < R && !(U + x >= b.length || U >= k.length); ++U)
      b[U + x] = k[U];
    return U;
  }
  function ln(k, b) {
    return (
      k instanceof b ||
      (k != null &&
        k.constructor != null &&
        k.constructor.name != null &&
        k.constructor.name === b.name)
    );
  }
  function lr(k) {
    return k !== k;
  }
  const Sn = (function () {
    const k = "0123456789abcdef",
      b = new Array(256);
    for (let x = 0; x < 16; ++x) {
      const R = x * 16;
      for (let U = 0; U < 16; ++U) b[R + U] = k[x] + k[U];
    }
    return b;
  })();
  function ur(k) {
    return typeof BigInt > "u" ? xa : k;
  }
  function xa() {
    throw new Error("BigInt not supported");
  }
})(Gc);
var KI = function (e) {
    for (
      var t = new Buffer(e.length), r = 0, a = e.length - 1;
      r <= a;
      ++r, --a
    )
      (t[r] = e[a]), (t[a] = e[r]);
    return t;
  },
  w6 = { exports: {} },
  c0 = { exports: {} },
  ng;
function Le() {
  return (
    ng ||
      ((ng = 1),
      (function (n, e) {
        (function (t, r) {
          n.exports = r();
        })(Ae, function () {
          var t =
            t ||
            (function (r, a) {
              var i =
                  Object.create ||
                  (function () {
                    function h() {}
                    return function (g) {
                      var v;
                      return (
                        (h.prototype = g),
                        (v = new h()),
                        (h.prototype = null),
                        v
                      );
                    };
                  })(),
                s = {},
                o = (s.lib = {}),
                c = (o.Base = (function () {
                  return {
                    extend: function (h) {
                      var g = i(this);
                      return (
                        h && g.mixIn(h),
                        (!g.hasOwnProperty("init") || this.init === g.init) &&
                          (g.init = function () {
                            g.$super.init.apply(this, arguments);
                          }),
                        (g.init.prototype = g),
                        (g.$super = this),
                        g
                      );
                    },
                    create: function () {
                      var h = this.extend();
                      return h.init.apply(h, arguments), h;
                    },
                    init: function () {},
                    mixIn: function (h) {
                      for (var g in h) h.hasOwnProperty(g) && (this[g] = h[g]);
                      h.hasOwnProperty("toString") &&
                        (this.toString = h.toString);
                    },
                    clone: function () {
                      return this.init.prototype.extend(this);
                    },
                  };
                })()),
                l = (o.WordArray = c.extend({
                  init: function (h, g) {
                    (h = this.words = h || []),
                      g != a
                        ? (this.sigBytes = g)
                        : (this.sigBytes = h.length * 4);
                  },
                  toString: function (h) {
                    return (h || d).stringify(this);
                  },
                  concat: function (h) {
                    var g = this.words,
                      v = h.words,
                      w = this.sigBytes,
                      T = h.sigBytes;
                    if ((this.clamp(), w % 4))
                      for (var A = 0; A < T; A++) {
                        var E = (v[A >>> 2] >>> (24 - (A % 4) * 8)) & 255;
                        g[(w + A) >>> 2] |= E << (24 - ((w + A) % 4) * 8);
                      }
                    else
                      for (var A = 0; A < T; A += 4)
                        g[(w + A) >>> 2] = v[A >>> 2];
                    return (this.sigBytes += T), this;
                  },
                  clamp: function () {
                    var h = this.words,
                      g = this.sigBytes;
                    (h[g >>> 2] &= 4294967295 << (32 - (g % 4) * 8)),
                      (h.length = r.ceil(g / 4));
                  },
                  clone: function () {
                    var h = c.clone.call(this);
                    return (h.words = this.words.slice(0)), h;
                  },
                  random: function (h) {
                    for (
                      var g = [],
                        v = function (_) {
                          var _ = _,
                            S = 987654321,
                            W = 4294967295;
                          return function () {
                            (S = (36969 * (S & 65535) + (S >> 16)) & W),
                              (_ = (18e3 * (_ & 65535) + (_ >> 16)) & W);
                            var D = ((S << 16) + _) & W;
                            return (
                              (D /= 4294967296),
                              (D += 0.5),
                              D * (r.random() > 0.5 ? 1 : -1)
                            );
                          };
                        },
                        w = 0,
                        T;
                      w < h;
                      w += 4
                    ) {
                      var A = v((T || r.random()) * 4294967296);
                      (T = A() * 987654071), g.push((A() * 4294967296) | 0);
                    }
                    return new l.init(g, h);
                  },
                })),
                u = (s.enc = {}),
                d = (u.Hex = {
                  stringify: function (h) {
                    for (
                      var g = h.words, v = h.sigBytes, w = [], T = 0;
                      T < v;
                      T++
                    ) {
                      var A = (g[T >>> 2] >>> (24 - (T % 4) * 8)) & 255;
                      w.push((A >>> 4).toString(16)),
                        w.push((A & 15).toString(16));
                    }
                    return w.join("");
                  },
                  parse: function (h) {
                    for (var g = h.length, v = [], w = 0; w < g; w += 2)
                      v[w >>> 3] |=
                        parseInt(h.substr(w, 2), 16) << (24 - (w % 8) * 4);
                    return new l.init(v, g / 2);
                  },
                }),
                f = (u.Latin1 = {
                  stringify: function (h) {
                    for (
                      var g = h.words, v = h.sigBytes, w = [], T = 0;
                      T < v;
                      T++
                    ) {
                      var A = (g[T >>> 2] >>> (24 - (T % 4) * 8)) & 255;
                      w.push(String.fromCharCode(A));
                    }
                    return w.join("");
                  },
                  parse: function (h) {
                    for (var g = h.length, v = [], w = 0; w < g; w++)
                      v[w >>> 2] |=
                        (h.charCodeAt(w) & 255) << (24 - (w % 4) * 8);
                    return new l.init(v, g);
                  },
                }),
                p = (u.Utf8 = {
                  stringify: function (h) {
                    try {
                      return decodeURIComponent(escape(f.stringify(h)));
                    } catch {
                      throw new Error("Malformed UTF-8 data");
                    }
                  },
                  parse: function (h) {
                    return f.parse(unescape(encodeURIComponent(h)));
                  },
                }),
                m = (o.BufferedBlockAlgorithm = c.extend({
                  reset: function () {
                    (this._data = new l.init()), (this._nDataBytes = 0);
                  },
                  _append: function (h) {
                    typeof h == "string" && (h = p.parse(h)),
                      this._data.concat(h),
                      (this._nDataBytes += h.sigBytes);
                  },
                  _process: function (h) {
                    var g = this._data,
                      v = g.words,
                      w = g.sigBytes,
                      T = this.blockSize,
                      A = T * 4,
                      E = w / A;
                    h
                      ? (E = r.ceil(E))
                      : (E = r.max((E | 0) - this._minBufferSize, 0));
                    var _ = E * T,
                      S = r.min(_ * 4, w);
                    if (_) {
                      for (var W = 0; W < _; W += T) this._doProcessBlock(v, W);
                      var D = v.splice(0, _);
                      g.sigBytes -= S;
                    }
                    return new l.init(D, S);
                  },
                  clone: function () {
                    var h = c.clone.call(this);
                    return (h._data = this._data.clone()), h;
                  },
                  _minBufferSize: 0,
                }));
              o.Hasher = m.extend({
                cfg: c.extend(),
                init: function (h) {
                  (this.cfg = this.cfg.extend(h)), this.reset();
                },
                reset: function () {
                  m.reset.call(this), this._doReset();
                },
                update: function (h) {
                  return this._append(h), this._process(), this;
                },
                finalize: function (h) {
                  h && this._append(h);
                  var g = this._doFinalize();
                  return g;
                },
                blockSize: 16,
                _createHelper: function (h) {
                  return function (g, v) {
                    return new h.init(v).finalize(g);
                  };
                },
                _createHmacHelper: function (h) {
                  return function (g, v) {
                    return new y.HMAC.init(h, v).finalize(g);
                  };
                },
              });
              var y = (s.algo = {});
              return s;
            })(Math);
          return t;
        });
      })(c0)),
    c0.exports
  );
}
(function (n, e) {
  (function (t, r) {
    n.exports = r(Le());
  })(Ae, function (t) {
    return (
      (function (r) {
        var a = t,
          i = a.lib,
          s = i.WordArray,
          o = i.Hasher,
          c = a.algo,
          l = [],
          u = [];
        (function () {
          function p(g) {
            for (var v = r.sqrt(g), w = 2; w <= v; w++) if (!(g % w)) return !1;
            return !0;
          }
          function m(g) {
            return ((g - (g | 0)) * 4294967296) | 0;
          }
          for (var y = 2, h = 0; h < 64; )
            p(y) &&
              (h < 8 && (l[h] = m(r.pow(y, 1 / 2))),
              (u[h] = m(r.pow(y, 1 / 3))),
              h++),
              y++;
        })();
        var d = [],
          f = (c.SHA256 = o.extend({
            _doReset: function () {
              this._hash = new s.init(l.slice(0));
            },
            _doProcessBlock: function (p, m) {
              for (
                var y = this._hash.words,
                  h = y[0],
                  g = y[1],
                  v = y[2],
                  w = y[3],
                  T = y[4],
                  A = y[5],
                  E = y[6],
                  _ = y[7],
                  S = 0;
                S < 64;
                S++
              ) {
                if (S < 16) d[S] = p[m + S] | 0;
                else {
                  var W = d[S - 15],
                    D =
                      ((W << 25) | (W >>> 7)) ^
                      ((W << 14) | (W >>> 18)) ^
                      (W >>> 3),
                    L = d[S - 2],
                    G =
                      ((L << 15) | (L >>> 17)) ^
                      ((L << 13) | (L >>> 19)) ^
                      (L >>> 10);
                  d[S] = D + d[S - 7] + G + d[S - 16];
                }
                var q = (T & A) ^ (~T & E),
                  N = (h & g) ^ (h & v) ^ (g & v),
                  H =
                    ((h << 30) | (h >>> 2)) ^
                    ((h << 19) | (h >>> 13)) ^
                    ((h << 10) | (h >>> 22)),
                  J =
                    ((T << 26) | (T >>> 6)) ^
                    ((T << 21) | (T >>> 11)) ^
                    ((T << 7) | (T >>> 25)),
                  de = _ + J + q + u[S] + d[S],
                  le = H + N;
                (_ = E),
                  (E = A),
                  (A = T),
                  (T = (w + de) | 0),
                  (w = v),
                  (v = g),
                  (g = h),
                  (h = (de + le) | 0);
              }
              (y[0] = (y[0] + h) | 0),
                (y[1] = (y[1] + g) | 0),
                (y[2] = (y[2] + v) | 0),
                (y[3] = (y[3] + w) | 0),
                (y[4] = (y[4] + T) | 0),
                (y[5] = (y[5] + A) | 0),
                (y[6] = (y[6] + E) | 0),
                (y[7] = (y[7] + _) | 0);
            },
            _doFinalize: function () {
              var p = this._data,
                m = p.words,
                y = this._nDataBytes * 8,
                h = p.sigBytes * 8;
              return (
                (m[h >>> 5] |= 128 << (24 - (h % 32))),
                (m[(((h + 64) >>> 9) << 4) + 14] = r.floor(y / 4294967296)),
                (m[(((h + 64) >>> 9) << 4) + 15] = y),
                (p.sigBytes = m.length * 4),
                this._process(),
                this._hash
              );
            },
            clone: function () {
              var p = o.clone.call(this);
              return (p._hash = this._hash.clone()), p;
            },
          }));
        (a.SHA256 = o._createHelper(f)),
          (a.HmacSHA256 = o._createHmacHelper(f));
      })(Math),
      t.SHA256
    );
  });
})(w6);
var ef = w6.exports,
  T6 = { exports: {} };
(function (n, e) {
  (function (t, r) {
    n.exports = r();
  })(Ae, function () {
    function t(s, o) {
      var c = o ? "└" : "├";
      return s ? (c += "─ ") : (c += "──┐"), c;
    }
    function r(s, o) {
      var c = [];
      for (var l in s)
        s.hasOwnProperty(l) && ((o && typeof s[l] == "function") || c.push(l));
      return c;
    }
    function a(s, o, c, l, u, d, f) {
      var p = "",
        m = 0,
        y,
        h,
        g = l.slice(0);
      if (
        (g.push([o, c]) &&
          l.length > 0 &&
          (l.forEach(function (w, T) {
            T > 0 && (p += (w[1] ? " " : "│") + "  "),
              !h && w[0] === o && (h = !0);
          }),
          (p += t(s, c) + s),
          u && (typeof o != "object" || o instanceof Date) && (p += ": " + o),
          h && (p += " (circular ref.)"),
          f(p)),
        !h && typeof o == "object")
      ) {
        var v = r(o, d);
        v.forEach(function (w) {
          (y = ++m === v.length), a(w, o[w], y, g, u, d, f);
        });
      }
    }
    var i = {};
    return (
      (i.asLines = function (s, o, c, l) {
        var u = typeof c != "function" ? c : !1;
        a(".", s, !1, [], o, u, l || c);
      }),
      (i.asTree = function (s, o, c) {
        var l = "";
        return (
          a(".", s, !1, [], o, c, function (u) {
            l +=
              u +
              `
`;
          }),
          l
        );
      }),
      i
    );
  });
})(T6);
var QI = T6.exports,
  co = {},
  C6 = { exports: {} },
  l0 = { exports: {} },
  rg;
function tf() {
  return (
    rg ||
      ((rg = 1),
      (function (n, e) {
        (function (t, r) {
          n.exports = r(Le());
        })(Ae, function (t) {
          return (
            (function (r) {
              var a = t,
                i = a.lib,
                s = i.Base,
                o = i.WordArray,
                c = (a.x64 = {});
              (c.Word = s.extend({
                init: function (l, u) {
                  (this.high = l), (this.low = u);
                },
              })),
                (c.WordArray = s.extend({
                  init: function (l, u) {
                    (l = this.words = l || []),
                      u != r
                        ? (this.sigBytes = u)
                        : (this.sigBytes = l.length * 8);
                  },
                  toX32: function () {
                    for (
                      var l = this.words, u = l.length, d = [], f = 0;
                      f < u;
                      f++
                    ) {
                      var p = l[f];
                      d.push(p.high), d.push(p.low);
                    }
                    return o.create(d, this.sigBytes);
                  },
                  clone: function () {
                    for (
                      var l = s.clone.call(this),
                        u = (l.words = this.words.slice(0)),
                        d = u.length,
                        f = 0;
                      f < d;
                      f++
                    )
                      u[f] = u[f].clone();
                    return l;
                  },
                }));
            })(),
            t
          );
        });
      })(l0)),
    l0.exports
  );
}
var u0 = { exports: {} },
  ag;
function YI() {
  return (
    ag ||
      ((ag = 1),
      (function (n, e) {
        (function (t, r) {
          n.exports = r(Le());
        })(Ae, function (t) {
          return (
            (function () {
              if (typeof ArrayBuffer == "function") {
                var r = t,
                  a = r.lib,
                  i = a.WordArray,
                  s = i.init,
                  o = (i.init = function (c) {
                    if (
                      (c instanceof ArrayBuffer && (c = new Uint8Array(c)),
                      (c instanceof Int8Array ||
                        (typeof Uint8ClampedArray < "u" &&
                          c instanceof Uint8ClampedArray) ||
                        c instanceof Int16Array ||
                        c instanceof Uint16Array ||
                        c instanceof Int32Array ||
                        c instanceof Uint32Array ||
                        c instanceof Float32Array ||
                        c instanceof Float64Array) &&
                        (c = new Uint8Array(
                          c.buffer,
                          c.byteOffset,
                          c.byteLength,
                        )),
                      c instanceof Uint8Array)
                    ) {
                      for (var l = c.byteLength, u = [], d = 0; d < l; d++)
                        u[d >>> 2] |= c[d] << (24 - (d % 4) * 8);
                      s.call(this, u, l);
                    } else s.apply(this, arguments);
                  });
                o.prototype = i;
              }
            })(),
            t.lib.WordArray
          );
        });
      })(u0)),
    u0.exports
  );
}
var d0 = { exports: {} },
  ig;
function JI() {
  return (
    ig ||
      ((ig = 1),
      (function (n, e) {
        (function (t, r) {
          n.exports = r(Le());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.WordArray,
                s = r.enc;
              (s.Utf16 = s.Utf16BE =
                {
                  stringify: function (c) {
                    for (
                      var l = c.words, u = c.sigBytes, d = [], f = 0;
                      f < u;
                      f += 2
                    ) {
                      var p = (l[f >>> 2] >>> (16 - (f % 4) * 8)) & 65535;
                      d.push(String.fromCharCode(p));
                    }
                    return d.join("");
                  },
                  parse: function (c) {
                    for (var l = c.length, u = [], d = 0; d < l; d++)
                      u[d >>> 1] |= c.charCodeAt(d) << (16 - (d % 2) * 16);
                    return i.create(u, l * 2);
                  },
                }),
                (s.Utf16LE = {
                  stringify: function (c) {
                    for (
                      var l = c.words, u = c.sigBytes, d = [], f = 0;
                      f < u;
                      f += 2
                    ) {
                      var p = o((l[f >>> 2] >>> (16 - (f % 4) * 8)) & 65535);
                      d.push(String.fromCharCode(p));
                    }
                    return d.join("");
                  },
                  parse: function (c) {
                    for (var l = c.length, u = [], d = 0; d < l; d++)
                      u[d >>> 1] |= o(c.charCodeAt(d) << (16 - (d % 2) * 16));
                    return i.create(u, l * 2);
                  },
                });
              function o(c) {
                return ((c << 8) & 4278255360) | ((c >>> 8) & 16711935);
              }
            })(),
            t.enc.Utf16
          );
        });
      })(d0)),
    d0.exports
  );
}
var f0 = { exports: {} },
  sg;
function lo() {
  return (
    sg ||
      ((sg = 1),
      (function (n, e) {
        (function (t, r) {
          n.exports = r(Le());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.WordArray,
                s = r.enc;
              s.Base64 = {
                stringify: function (c) {
                  var l = c.words,
                    u = c.sigBytes,
                    d = this._map;
                  c.clamp();
                  for (var f = [], p = 0; p < u; p += 3)
                    for (
                      var m = (l[p >>> 2] >>> (24 - (p % 4) * 8)) & 255,
                        y =
                          (l[(p + 1) >>> 2] >>> (24 - ((p + 1) % 4) * 8)) & 255,
                        h =
                          (l[(p + 2) >>> 2] >>> (24 - ((p + 2) % 4) * 8)) & 255,
                        g = (m << 16) | (y << 8) | h,
                        v = 0;
                      v < 4 && p + v * 0.75 < u;
                      v++
                    )
                      f.push(d.charAt((g >>> (6 * (3 - v))) & 63));
                  var w = d.charAt(64);
                  if (w) for (; f.length % 4; ) f.push(w);
                  return f.join("");
                },
                parse: function (c) {
                  var l = c.length,
                    u = this._map,
                    d = this._reverseMap;
                  if (!d) {
                    d = this._reverseMap = [];
                    for (var f = 0; f < u.length; f++) d[u.charCodeAt(f)] = f;
                  }
                  var p = u.charAt(64);
                  if (p) {
                    var m = c.indexOf(p);
                    m !== -1 && (l = m);
                  }
                  return o(c, l, d);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
              };
              function o(c, l, u) {
                for (var d = [], f = 0, p = 0; p < l; p++)
                  if (p % 4) {
                    var m = u[c.charCodeAt(p - 1)] << ((p % 4) * 2),
                      y = u[c.charCodeAt(p)] >>> (6 - (p % 4) * 2);
                    (d[f >>> 2] |= (m | y) << (24 - (f % 4) * 8)), f++;
                  }
                return i.create(d, f);
              }
            })(),
            t.enc.Base64
          );
        });
      })(f0)),
    f0.exports
  );
}
var p0 = { exports: {} },
  og;
function uo() {
  return (
    og ||
      ((og = 1),
      (function (n, e) {
        (function (t, r) {
          n.exports = r(Le());
        })(Ae, function (t) {
          return (
            (function (r) {
              var a = t,
                i = a.lib,
                s = i.WordArray,
                o = i.Hasher,
                c = a.algo,
                l = [];
              (function () {
                for (var y = 0; y < 64; y++)
                  l[y] = (r.abs(r.sin(y + 1)) * 4294967296) | 0;
              })();
              var u = (c.MD5 = o.extend({
                _doReset: function () {
                  this._hash = new s.init([
                    1732584193, 4023233417, 2562383102, 271733878,
                  ]);
                },
                _doProcessBlock: function (y, h) {
                  for (var g = 0; g < 16; g++) {
                    var v = h + g,
                      w = y[v];
                    y[v] =
                      (((w << 8) | (w >>> 24)) & 16711935) |
                      (((w << 24) | (w >>> 8)) & 4278255360);
                  }
                  var T = this._hash.words,
                    A = y[h + 0],
                    E = y[h + 1],
                    _ = y[h + 2],
                    S = y[h + 3],
                    W = y[h + 4],
                    D = y[h + 5],
                    L = y[h + 6],
                    G = y[h + 7],
                    q = y[h + 8],
                    N = y[h + 9],
                    H = y[h + 10],
                    J = y[h + 11],
                    de = y[h + 12],
                    le = y[h + 13],
                    Z = y[h + 14],
                    ue = y[h + 15],
                    P = T[0],
                    B = T[1],
                    j = T[2],
                    F = T[3];
                  (P = d(P, B, j, F, A, 7, l[0])),
                    (F = d(F, P, B, j, E, 12, l[1])),
                    (j = d(j, F, P, B, _, 17, l[2])),
                    (B = d(B, j, F, P, S, 22, l[3])),
                    (P = d(P, B, j, F, W, 7, l[4])),
                    (F = d(F, P, B, j, D, 12, l[5])),
                    (j = d(j, F, P, B, L, 17, l[6])),
                    (B = d(B, j, F, P, G, 22, l[7])),
                    (P = d(P, B, j, F, q, 7, l[8])),
                    (F = d(F, P, B, j, N, 12, l[9])),
                    (j = d(j, F, P, B, H, 17, l[10])),
                    (B = d(B, j, F, P, J, 22, l[11])),
                    (P = d(P, B, j, F, de, 7, l[12])),
                    (F = d(F, P, B, j, le, 12, l[13])),
                    (j = d(j, F, P, B, Z, 17, l[14])),
                    (B = d(B, j, F, P, ue, 22, l[15])),
                    (P = f(P, B, j, F, E, 5, l[16])),
                    (F = f(F, P, B, j, L, 9, l[17])),
                    (j = f(j, F, P, B, J, 14, l[18])),
                    (B = f(B, j, F, P, A, 20, l[19])),
                    (P = f(P, B, j, F, D, 5, l[20])),
                    (F = f(F, P, B, j, H, 9, l[21])),
                    (j = f(j, F, P, B, ue, 14, l[22])),
                    (B = f(B, j, F, P, W, 20, l[23])),
                    (P = f(P, B, j, F, N, 5, l[24])),
                    (F = f(F, P, B, j, Z, 9, l[25])),
                    (j = f(j, F, P, B, S, 14, l[26])),
                    (B = f(B, j, F, P, q, 20, l[27])),
                    (P = f(P, B, j, F, le, 5, l[28])),
                    (F = f(F, P, B, j, _, 9, l[29])),
                    (j = f(j, F, P, B, G, 14, l[30])),
                    (B = f(B, j, F, P, de, 20, l[31])),
                    (P = p(P, B, j, F, D, 4, l[32])),
                    (F = p(F, P, B, j, q, 11, l[33])),
                    (j = p(j, F, P, B, J, 16, l[34])),
                    (B = p(B, j, F, P, Z, 23, l[35])),
                    (P = p(P, B, j, F, E, 4, l[36])),
                    (F = p(F, P, B, j, W, 11, l[37])),
                    (j = p(j, F, P, B, G, 16, l[38])),
                    (B = p(B, j, F, P, H, 23, l[39])),
                    (P = p(P, B, j, F, le, 4, l[40])),
                    (F = p(F, P, B, j, A, 11, l[41])),
                    (j = p(j, F, P, B, S, 16, l[42])),
                    (B = p(B, j, F, P, L, 23, l[43])),
                    (P = p(P, B, j, F, N, 4, l[44])),
                    (F = p(F, P, B, j, de, 11, l[45])),
                    (j = p(j, F, P, B, ue, 16, l[46])),
                    (B = p(B, j, F, P, _, 23, l[47])),
                    (P = m(P, B, j, F, A, 6, l[48])),
                    (F = m(F, P, B, j, G, 10, l[49])),
                    (j = m(j, F, P, B, Z, 15, l[50])),
                    (B = m(B, j, F, P, D, 21, l[51])),
                    (P = m(P, B, j, F, de, 6, l[52])),
                    (F = m(F, P, B, j, S, 10, l[53])),
                    (j = m(j, F, P, B, H, 15, l[54])),
                    (B = m(B, j, F, P, E, 21, l[55])),
                    (P = m(P, B, j, F, q, 6, l[56])),
                    (F = m(F, P, B, j, ue, 10, l[57])),
                    (j = m(j, F, P, B, L, 15, l[58])),
                    (B = m(B, j, F, P, le, 21, l[59])),
                    (P = m(P, B, j, F, W, 6, l[60])),
                    (F = m(F, P, B, j, J, 10, l[61])),
                    (j = m(j, F, P, B, _, 15, l[62])),
                    (B = m(B, j, F, P, N, 21, l[63])),
                    (T[0] = (T[0] + P) | 0),
                    (T[1] = (T[1] + B) | 0),
                    (T[2] = (T[2] + j) | 0),
                    (T[3] = (T[3] + F) | 0);
                },
                _doFinalize: function () {
                  var y = this._data,
                    h = y.words,
                    g = this._nDataBytes * 8,
                    v = y.sigBytes * 8;
                  h[v >>> 5] |= 128 << (24 - (v % 32));
                  var w = r.floor(g / 4294967296),
                    T = g;
                  (h[(((v + 64) >>> 9) << 4) + 15] =
                    (((w << 8) | (w >>> 24)) & 16711935) |
                    (((w << 24) | (w >>> 8)) & 4278255360)),
                    (h[(((v + 64) >>> 9) << 4) + 14] =
                      (((T << 8) | (T >>> 24)) & 16711935) |
                      (((T << 24) | (T >>> 8)) & 4278255360)),
                    (y.sigBytes = (h.length + 1) * 4),
                    this._process();
                  for (var A = this._hash, E = A.words, _ = 0; _ < 4; _++) {
                    var S = E[_];
                    E[_] =
                      (((S << 8) | (S >>> 24)) & 16711935) |
                      (((S << 24) | (S >>> 8)) & 4278255360);
                  }
                  return A;
                },
                clone: function () {
                  var y = o.clone.call(this);
                  return (y._hash = this._hash.clone()), y;
                },
              }));
              function d(y, h, g, v, w, T, A) {
                var E = y + ((h & g) | (~h & v)) + w + A;
                return ((E << T) | (E >>> (32 - T))) + h;
              }
              function f(y, h, g, v, w, T, A) {
                var E = y + ((h & v) | (g & ~v)) + w + A;
                return ((E << T) | (E >>> (32 - T))) + h;
              }
              function p(y, h, g, v, w, T, A) {
                var E = y + (h ^ g ^ v) + w + A;
                return ((E << T) | (E >>> (32 - T))) + h;
              }
              function m(y, h, g, v, w, T, A) {
                var E = y + (g ^ (h | ~v)) + w + A;
                return ((E << T) | (E >>> (32 - T))) + h;
              }
              (a.MD5 = o._createHelper(u)),
                (a.HmacMD5 = o._createHmacHelper(u));
            })(Math),
            t.MD5
          );
        });
      })(p0)),
    p0.exports
  );
}
var h0 = { exports: {} },
  cg;
function im() {
  return (
    cg ||
      ((cg = 1),
      (function (n, e) {
        (function (t, r) {
          n.exports = r(Le());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.WordArray,
                s = a.Hasher,
                o = r.algo,
                c = [],
                l = (o.SHA1 = s.extend({
                  _doReset: function () {
                    this._hash = new i.init([
                      1732584193, 4023233417, 2562383102, 271733878, 3285377520,
                    ]);
                  },
                  _doProcessBlock: function (u, d) {
                    for (
                      var f = this._hash.words,
                        p = f[0],
                        m = f[1],
                        y = f[2],
                        h = f[3],
                        g = f[4],
                        v = 0;
                      v < 80;
                      v++
                    ) {
                      if (v < 16) c[v] = u[d + v] | 0;
                      else {
                        var w = c[v - 3] ^ c[v - 8] ^ c[v - 14] ^ c[v - 16];
                        c[v] = (w << 1) | (w >>> 31);
                      }
                      var T = ((p << 5) | (p >>> 27)) + g + c[v];
                      v < 20
                        ? (T += ((m & y) | (~m & h)) + 1518500249)
                        : v < 40
                        ? (T += (m ^ y ^ h) + 1859775393)
                        : v < 60
                        ? (T += ((m & y) | (m & h) | (y & h)) - 1894007588)
                        : (T += (m ^ y ^ h) - 899497514),
                        (g = h),
                        (h = y),
                        (y = (m << 30) | (m >>> 2)),
                        (m = p),
                        (p = T);
                    }
                    (f[0] = (f[0] + p) | 0),
                      (f[1] = (f[1] + m) | 0),
                      (f[2] = (f[2] + y) | 0),
                      (f[3] = (f[3] + h) | 0),
                      (f[4] = (f[4] + g) | 0);
                  },
                  _doFinalize: function () {
                    var u = this._data,
                      d = u.words,
                      f = this._nDataBytes * 8,
                      p = u.sigBytes * 8;
                    return (
                      (d[p >>> 5] |= 128 << (24 - (p % 32))),
                      (d[(((p + 64) >>> 9) << 4) + 14] = Math.floor(
                        f / 4294967296,
                      )),
                      (d[(((p + 64) >>> 9) << 4) + 15] = f),
                      (u.sigBytes = d.length * 4),
                      this._process(),
                      this._hash
                    );
                  },
                  clone: function () {
                    var u = s.clone.call(this);
                    return (u._hash = this._hash.clone()), u;
                  },
                }));
              (r.SHA1 = s._createHelper(l)),
                (r.HmacSHA1 = s._createHmacHelper(l));
            })(),
            t.SHA1
          );
        });
      })(h0)),
    h0.exports
  );
}
var m0 = { exports: {} },
  lg;
function XI() {
  return (
    lg ||
      ((lg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), ef);
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.WordArray,
                s = r.algo,
                o = s.SHA256,
                c = (s.SHA224 = o.extend({
                  _doReset: function () {
                    this._hash = new i.init([
                      3238371032, 914150663, 812702999, 4144912697, 4290775857,
                      1750603025, 1694076839, 3204075428,
                    ]);
                  },
                  _doFinalize: function () {
                    var l = o._doFinalize.call(this);
                    return (l.sigBytes -= 4), l;
                  },
                }));
              (r.SHA224 = o._createHelper(c)),
                (r.HmacSHA224 = o._createHmacHelper(c));
            })(),
            t.SHA224
          );
        });
      })(m0)),
    m0.exports
  );
}
var y0 = { exports: {} },
  ug;
function A6() {
  return (
    ug ||
      ((ug = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), tf());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.Hasher,
                s = r.x64,
                o = s.Word,
                c = s.WordArray,
                l = r.algo;
              function u() {
                return o.create.apply(o, arguments);
              }
              var d = [
                  u(1116352408, 3609767458),
                  u(1899447441, 602891725),
                  u(3049323471, 3964484399),
                  u(3921009573, 2173295548),
                  u(961987163, 4081628472),
                  u(1508970993, 3053834265),
                  u(2453635748, 2937671579),
                  u(2870763221, 3664609560),
                  u(3624381080, 2734883394),
                  u(310598401, 1164996542),
                  u(607225278, 1323610764),
                  u(1426881987, 3590304994),
                  u(1925078388, 4068182383),
                  u(2162078206, 991336113),
                  u(2614888103, 633803317),
                  u(3248222580, 3479774868),
                  u(3835390401, 2666613458),
                  u(4022224774, 944711139),
                  u(264347078, 2341262773),
                  u(604807628, 2007800933),
                  u(770255983, 1495990901),
                  u(1249150122, 1856431235),
                  u(1555081692, 3175218132),
                  u(1996064986, 2198950837),
                  u(2554220882, 3999719339),
                  u(2821834349, 766784016),
                  u(2952996808, 2566594879),
                  u(3210313671, 3203337956),
                  u(3336571891, 1034457026),
                  u(3584528711, 2466948901),
                  u(113926993, 3758326383),
                  u(338241895, 168717936),
                  u(666307205, 1188179964),
                  u(773529912, 1546045734),
                  u(1294757372, 1522805485),
                  u(1396182291, 2643833823),
                  u(1695183700, 2343527390),
                  u(1986661051, 1014477480),
                  u(2177026350, 1206759142),
                  u(2456956037, 344077627),
                  u(2730485921, 1290863460),
                  u(2820302411, 3158454273),
                  u(3259730800, 3505952657),
                  u(3345764771, 106217008),
                  u(3516065817, 3606008344),
                  u(3600352804, 1432725776),
                  u(4094571909, 1467031594),
                  u(275423344, 851169720),
                  u(430227734, 3100823752),
                  u(506948616, 1363258195),
                  u(659060556, 3750685593),
                  u(883997877, 3785050280),
                  u(958139571, 3318307427),
                  u(1322822218, 3812723403),
                  u(1537002063, 2003034995),
                  u(1747873779, 3602036899),
                  u(1955562222, 1575990012),
                  u(2024104815, 1125592928),
                  u(2227730452, 2716904306),
                  u(2361852424, 442776044),
                  u(2428436474, 593698344),
                  u(2756734187, 3733110249),
                  u(3204031479, 2999351573),
                  u(3329325298, 3815920427),
                  u(3391569614, 3928383900),
                  u(3515267271, 566280711),
                  u(3940187606, 3454069534),
                  u(4118630271, 4000239992),
                  u(116418474, 1914138554),
                  u(174292421, 2731055270),
                  u(289380356, 3203993006),
                  u(460393269, 320620315),
                  u(685471733, 587496836),
                  u(852142971, 1086792851),
                  u(1017036298, 365543100),
                  u(1126000580, 2618297676),
                  u(1288033470, 3409855158),
                  u(1501505948, 4234509866),
                  u(1607167915, 987167468),
                  u(1816402316, 1246189591),
                ],
                f = [];
              (function () {
                for (var m = 0; m < 80; m++) f[m] = u();
              })();
              var p = (l.SHA512 = i.extend({
                _doReset: function () {
                  this._hash = new c.init([
                    new o.init(1779033703, 4089235720),
                    new o.init(3144134277, 2227873595),
                    new o.init(1013904242, 4271175723),
                    new o.init(2773480762, 1595750129),
                    new o.init(1359893119, 2917565137),
                    new o.init(2600822924, 725511199),
                    new o.init(528734635, 4215389547),
                    new o.init(1541459225, 327033209),
                  ]);
                },
                _doProcessBlock: function (m, y) {
                  for (
                    var h = this._hash.words,
                      g = h[0],
                      v = h[1],
                      w = h[2],
                      T = h[3],
                      A = h[4],
                      E = h[5],
                      _ = h[6],
                      S = h[7],
                      W = g.high,
                      D = g.low,
                      L = v.high,
                      G = v.low,
                      q = w.high,
                      N = w.low,
                      H = T.high,
                      J = T.low,
                      de = A.high,
                      le = A.low,
                      Z = E.high,
                      ue = E.low,
                      P = _.high,
                      B = _.low,
                      j = S.high,
                      F = S.low,
                      V = W,
                      re = D,
                      we = L,
                      se = G,
                      be = q,
                      Ke = N,
                      dt = H,
                      cn = J,
                      wt = de,
                      ot = le,
                      ba = Z,
                      Kr = ue,
                      Cr = P,
                      Qr = B,
                      di = j,
                      _n = F,
                      Yt = 0;
                    Yt < 80;
                    Yt++
                  ) {
                    var ln = f[Yt];
                    if (Yt < 16)
                      var lr = (ln.high = m[y + Yt * 2] | 0),
                        Sn = (ln.low = m[y + Yt * 2 + 1] | 0);
                    else {
                      var ur = f[Yt - 15],
                        xa = ur.high,
                        k = ur.low,
                        b =
                          ((xa >>> 1) | (k << 31)) ^
                          ((xa >>> 8) | (k << 24)) ^
                          (xa >>> 7),
                        x =
                          ((k >>> 1) | (xa << 31)) ^
                          ((k >>> 8) | (xa << 24)) ^
                          ((k >>> 7) | (xa << 25)),
                        R = f[Yt - 2],
                        U = R.high,
                        K = R.low,
                        X =
                          ((U >>> 19) | (K << 13)) ^
                          ((U << 3) | (K >>> 29)) ^
                          (U >>> 6),
                        Ee =
                          ((K >>> 19) | (U << 13)) ^
                          ((K << 3) | (U >>> 29)) ^
                          ((K >>> 6) | (U << 26)),
                        tt = f[Yt - 7],
                        Xe = tt.high,
                        it = tt.low,
                        He = f[Yt - 16],
                        g8 = He.high,
                        hy = He.low,
                        Sn = x + it,
                        lr = b + Xe + (Sn >>> 0 < x >>> 0 ? 1 : 0),
                        Sn = Sn + Ee,
                        lr = lr + X + (Sn >>> 0 < Ee >>> 0 ? 1 : 0),
                        Sn = Sn + hy,
                        lr = lr + g8 + (Sn >>> 0 < hy >>> 0 ? 1 : 0);
                      (ln.high = lr), (ln.low = Sn);
                    }
                    var b8 = (wt & ba) ^ (~wt & Cr),
                      my = (ot & Kr) ^ (~ot & Qr),
                      x8 = (V & we) ^ (V & be) ^ (we & be),
                      v8 = (re & se) ^ (re & Ke) ^ (se & Ke),
                      w8 =
                        ((V >>> 28) | (re << 4)) ^
                        ((V << 30) | (re >>> 2)) ^
                        ((V << 25) | (re >>> 7)),
                      yy =
                        ((re >>> 28) | (V << 4)) ^
                        ((re << 30) | (V >>> 2)) ^
                        ((re << 25) | (V >>> 7)),
                      T8 =
                        ((wt >>> 14) | (ot << 18)) ^
                        ((wt >>> 18) | (ot << 14)) ^
                        ((wt << 23) | (ot >>> 9)),
                      C8 =
                        ((ot >>> 14) | (wt << 18)) ^
                        ((ot >>> 18) | (wt << 14)) ^
                        ((ot << 23) | (wt >>> 9)),
                      gy = d[Yt],
                      A8 = gy.high,
                      by = gy.low,
                      Pn = _n + C8,
                      va = di + T8 + (Pn >>> 0 < _n >>> 0 ? 1 : 0),
                      Pn = Pn + my,
                      va = va + b8 + (Pn >>> 0 < my >>> 0 ? 1 : 0),
                      Pn = Pn + by,
                      va = va + A8 + (Pn >>> 0 < by >>> 0 ? 1 : 0),
                      Pn = Pn + Sn,
                      va = va + lr + (Pn >>> 0 < Sn >>> 0 ? 1 : 0),
                      xy = yy + v8,
                      E8 = w8 + x8 + (xy >>> 0 < yy >>> 0 ? 1 : 0);
                    (di = Cr),
                      (_n = Qr),
                      (Cr = ba),
                      (Qr = Kr),
                      (ba = wt),
                      (Kr = ot),
                      (ot = (cn + Pn) | 0),
                      (wt = (dt + va + (ot >>> 0 < cn >>> 0 ? 1 : 0)) | 0),
                      (dt = be),
                      (cn = Ke),
                      (be = we),
                      (Ke = se),
                      (we = V),
                      (se = re),
                      (re = (Pn + xy) | 0),
                      (V = (va + E8 + (re >>> 0 < Pn >>> 0 ? 1 : 0)) | 0);
                  }
                  (D = g.low = D + re),
                    (g.high = W + V + (D >>> 0 < re >>> 0 ? 1 : 0)),
                    (G = v.low = G + se),
                    (v.high = L + we + (G >>> 0 < se >>> 0 ? 1 : 0)),
                    (N = w.low = N + Ke),
                    (w.high = q + be + (N >>> 0 < Ke >>> 0 ? 1 : 0)),
                    (J = T.low = J + cn),
                    (T.high = H + dt + (J >>> 0 < cn >>> 0 ? 1 : 0)),
                    (le = A.low = le + ot),
                    (A.high = de + wt + (le >>> 0 < ot >>> 0 ? 1 : 0)),
                    (ue = E.low = ue + Kr),
                    (E.high = Z + ba + (ue >>> 0 < Kr >>> 0 ? 1 : 0)),
                    (B = _.low = B + Qr),
                    (_.high = P + Cr + (B >>> 0 < Qr >>> 0 ? 1 : 0)),
                    (F = S.low = F + _n),
                    (S.high = j + di + (F >>> 0 < _n >>> 0 ? 1 : 0));
                },
                _doFinalize: function () {
                  var m = this._data,
                    y = m.words,
                    h = this._nDataBytes * 8,
                    g = m.sigBytes * 8;
                  (y[g >>> 5] |= 128 << (24 - (g % 32))),
                    (y[(((g + 128) >>> 10) << 5) + 30] = Math.floor(
                      h / 4294967296,
                    )),
                    (y[(((g + 128) >>> 10) << 5) + 31] = h),
                    (m.sigBytes = y.length * 4),
                    this._process();
                  var v = this._hash.toX32();
                  return v;
                },
                clone: function () {
                  var m = i.clone.call(this);
                  return (m._hash = this._hash.clone()), m;
                },
                blockSize: 1024 / 32,
              }));
              (r.SHA512 = i._createHelper(p)),
                (r.HmacSHA512 = i._createHmacHelper(p));
            })(),
            t.SHA512
          );
        });
      })(y0)),
    y0.exports
  );
}
var g0 = { exports: {} },
  dg;
function ZI() {
  return (
    dg ||
      ((dg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), tf(), A6());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.x64,
                i = a.Word,
                s = a.WordArray,
                o = r.algo,
                c = o.SHA512,
                l = (o.SHA384 = c.extend({
                  _doReset: function () {
                    this._hash = new s.init([
                      new i.init(3418070365, 3238371032),
                      new i.init(1654270250, 914150663),
                      new i.init(2438529370, 812702999),
                      new i.init(355462360, 4144912697),
                      new i.init(1731405415, 4290775857),
                      new i.init(2394180231, 1750603025),
                      new i.init(3675008525, 1694076839),
                      new i.init(1203062813, 3204075428),
                    ]);
                  },
                  _doFinalize: function () {
                    var u = c._doFinalize.call(this);
                    return (u.sigBytes -= 16), u;
                  },
                }));
              (r.SHA384 = c._createHelper(l)),
                (r.HmacSHA384 = c._createHmacHelper(l));
            })(),
            t.SHA384
          );
        });
      })(g0)),
    g0.exports
  );
}
var b0 = { exports: {} },
  fg;
function eR() {
  return (
    fg ||
      ((fg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), tf());
        })(Ae, function (t) {
          return (
            (function (r) {
              var a = t,
                i = a.lib,
                s = i.WordArray,
                o = i.Hasher,
                c = a.x64,
                l = c.Word,
                u = a.algo,
                d = [],
                f = [],
                p = [];
              (function () {
                for (var h = 1, g = 0, v = 0; v < 24; v++) {
                  d[h + 5 * g] = (((v + 1) * (v + 2)) / 2) % 64;
                  var w = g % 5,
                    T = (2 * h + 3 * g) % 5;
                  (h = w), (g = T);
                }
                for (var h = 0; h < 5; h++)
                  for (var g = 0; g < 5; g++)
                    f[h + 5 * g] = g + ((2 * h + 3 * g) % 5) * 5;
                for (var A = 1, E = 0; E < 24; E++) {
                  for (var _ = 0, S = 0, W = 0; W < 7; W++) {
                    if (A & 1) {
                      var D = (1 << W) - 1;
                      D < 32 ? (S ^= 1 << D) : (_ ^= 1 << (D - 32));
                    }
                    A & 128 ? (A = (A << 1) ^ 113) : (A <<= 1);
                  }
                  p[E] = l.create(_, S);
                }
              })();
              var m = [];
              (function () {
                for (var h = 0; h < 25; h++) m[h] = l.create();
              })();
              var y = (u.SHA3 = o.extend({
                cfg: o.cfg.extend({ outputLength: 512 }),
                _doReset: function () {
                  for (var h = (this._state = []), g = 0; g < 25; g++)
                    h[g] = new l.init();
                  this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                },
                _doProcessBlock: function (h, g) {
                  for (
                    var v = this._state, w = this.blockSize / 2, T = 0;
                    T < w;
                    T++
                  ) {
                    var A = h[g + 2 * T],
                      E = h[g + 2 * T + 1];
                    (A =
                      (((A << 8) | (A >>> 24)) & 16711935) |
                      (((A << 24) | (A >>> 8)) & 4278255360)),
                      (E =
                        (((E << 8) | (E >>> 24)) & 16711935) |
                        (((E << 24) | (E >>> 8)) & 4278255360));
                    var _ = v[T];
                    (_.high ^= E), (_.low ^= A);
                  }
                  for (var S = 0; S < 24; S++) {
                    for (var W = 0; W < 5; W++) {
                      for (var D = 0, L = 0, G = 0; G < 5; G++) {
                        var _ = v[W + 5 * G];
                        (D ^= _.high), (L ^= _.low);
                      }
                      var q = m[W];
                      (q.high = D), (q.low = L);
                    }
                    for (var W = 0; W < 5; W++)
                      for (
                        var N = m[(W + 4) % 5],
                          H = m[(W + 1) % 5],
                          J = H.high,
                          de = H.low,
                          D = N.high ^ ((J << 1) | (de >>> 31)),
                          L = N.low ^ ((de << 1) | (J >>> 31)),
                          G = 0;
                        G < 5;
                        G++
                      ) {
                        var _ = v[W + 5 * G];
                        (_.high ^= D), (_.low ^= L);
                      }
                    for (var le = 1; le < 25; le++) {
                      var _ = v[le],
                        Z = _.high,
                        ue = _.low,
                        P = d[le];
                      if (P < 32)
                        var D = (Z << P) | (ue >>> (32 - P)),
                          L = (ue << P) | (Z >>> (32 - P));
                      else
                        var D = (ue << (P - 32)) | (Z >>> (64 - P)),
                          L = (Z << (P - 32)) | (ue >>> (64 - P));
                      var B = m[f[le]];
                      (B.high = D), (B.low = L);
                    }
                    var j = m[0],
                      F = v[0];
                    (j.high = F.high), (j.low = F.low);
                    for (var W = 0; W < 5; W++)
                      for (var G = 0; G < 5; G++) {
                        var le = W + 5 * G,
                          _ = v[le],
                          V = m[le],
                          re = m[((W + 1) % 5) + 5 * G],
                          we = m[((W + 2) % 5) + 5 * G];
                        (_.high = V.high ^ (~re.high & we.high)),
                          (_.low = V.low ^ (~re.low & we.low));
                      }
                    var _ = v[0],
                      se = p[S];
                    (_.high ^= se.high), (_.low ^= se.low);
                  }
                },
                _doFinalize: function () {
                  var h = this._data,
                    g = h.words;
                  this._nDataBytes * 8;
                  var v = h.sigBytes * 8,
                    w = this.blockSize * 32;
                  (g[v >>> 5] |= 1 << (24 - (v % 32))),
                    (g[((r.ceil((v + 1) / w) * w) >>> 5) - 1] |= 128),
                    (h.sigBytes = g.length * 4),
                    this._process();
                  for (
                    var T = this._state,
                      A = this.cfg.outputLength / 8,
                      E = A / 8,
                      _ = [],
                      S = 0;
                    S < E;
                    S++
                  ) {
                    var W = T[S],
                      D = W.high,
                      L = W.low;
                    (D =
                      (((D << 8) | (D >>> 24)) & 16711935) |
                      (((D << 24) | (D >>> 8)) & 4278255360)),
                      (L =
                        (((L << 8) | (L >>> 24)) & 16711935) |
                        (((L << 24) | (L >>> 8)) & 4278255360)),
                      _.push(L),
                      _.push(D);
                  }
                  return new s.init(_, A);
                },
                clone: function () {
                  for (
                    var h = o.clone.call(this),
                      g = (h._state = this._state.slice(0)),
                      v = 0;
                    v < 25;
                    v++
                  )
                    g[v] = g[v].clone();
                  return h;
                },
              }));
              (a.SHA3 = o._createHelper(y)),
                (a.HmacSHA3 = o._createHmacHelper(y));
            })(Math),
            t.SHA3
          );
        });
      })(b0)),
    b0.exports
  );
}
var x0 = { exports: {} },
  pg;
function tR() {
  return (
    pg ||
      ((pg = 1),
      (function (n, e) {
        (function (t, r) {
          n.exports = r(Le());
        })(Ae, function (t) {
          /** @preserve
			(c) 2012 by Cédric Mesnil. All rights reserved.

			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
			*/ return (
            (function (r) {
              var a = t,
                i = a.lib,
                s = i.WordArray,
                o = i.Hasher,
                c = a.algo,
                l = s.create([
                  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4,
                  13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4,
                  9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8,
                  12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10,
                  14, 1, 3, 8, 11, 6, 15, 13,
                ]),
                u = s.create([
                  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11,
                  3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7,
                  14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15,
                  0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6,
                  2, 13, 14, 0, 3, 9, 11,
                ]),
                d = s.create([
                  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6,
                  8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6,
                  7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15,
                  14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8,
                  13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
                ]),
                f = s.create([
                  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13,
                  15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11,
                  8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14,
                  14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14,
                  6, 8, 13, 6, 5, 15, 13, 11, 11,
                ]),
                p = s.create([
                  0, 1518500249, 1859775393, 2400959708, 2840853838,
                ]),
                m = s.create([
                  1352829926, 1548603684, 1836072691, 2053994217, 0,
                ]),
                y = (c.RIPEMD160 = o.extend({
                  _doReset: function () {
                    this._hash = s.create([
                      1732584193, 4023233417, 2562383102, 271733878, 3285377520,
                    ]);
                  },
                  _doProcessBlock: function (E, _) {
                    for (var S = 0; S < 16; S++) {
                      var W = _ + S,
                        D = E[W];
                      E[W] =
                        (((D << 8) | (D >>> 24)) & 16711935) |
                        (((D << 24) | (D >>> 8)) & 4278255360);
                    }
                    var L = this._hash.words,
                      G = p.words,
                      q = m.words,
                      N = l.words,
                      H = u.words,
                      J = d.words,
                      de = f.words,
                      le,
                      Z,
                      ue,
                      P,
                      B,
                      j,
                      F,
                      V,
                      re,
                      we;
                    (j = le = L[0]),
                      (F = Z = L[1]),
                      (V = ue = L[2]),
                      (re = P = L[3]),
                      (we = B = L[4]);
                    for (var se, S = 0; S < 80; S += 1)
                      (se = (le + E[_ + N[S]]) | 0),
                        S < 16
                          ? (se += h(Z, ue, P) + G[0])
                          : S < 32
                          ? (se += g(Z, ue, P) + G[1])
                          : S < 48
                          ? (se += v(Z, ue, P) + G[2])
                          : S < 64
                          ? (se += w(Z, ue, P) + G[3])
                          : (se += T(Z, ue, P) + G[4]),
                        (se = se | 0),
                        (se = A(se, J[S])),
                        (se = (se + B) | 0),
                        (le = B),
                        (B = P),
                        (P = A(ue, 10)),
                        (ue = Z),
                        (Z = se),
                        (se = (j + E[_ + H[S]]) | 0),
                        S < 16
                          ? (se += T(F, V, re) + q[0])
                          : S < 32
                          ? (se += w(F, V, re) + q[1])
                          : S < 48
                          ? (se += v(F, V, re) + q[2])
                          : S < 64
                          ? (se += g(F, V, re) + q[3])
                          : (se += h(F, V, re) + q[4]),
                        (se = se | 0),
                        (se = A(se, de[S])),
                        (se = (se + we) | 0),
                        (j = we),
                        (we = re),
                        (re = A(V, 10)),
                        (V = F),
                        (F = se);
                    (se = (L[1] + ue + re) | 0),
                      (L[1] = (L[2] + P + we) | 0),
                      (L[2] = (L[3] + B + j) | 0),
                      (L[3] = (L[4] + le + F) | 0),
                      (L[4] = (L[0] + Z + V) | 0),
                      (L[0] = se);
                  },
                  _doFinalize: function () {
                    var E = this._data,
                      _ = E.words,
                      S = this._nDataBytes * 8,
                      W = E.sigBytes * 8;
                    (_[W >>> 5] |= 128 << (24 - (W % 32))),
                      (_[(((W + 64) >>> 9) << 4) + 14] =
                        (((S << 8) | (S >>> 24)) & 16711935) |
                        (((S << 24) | (S >>> 8)) & 4278255360)),
                      (E.sigBytes = (_.length + 1) * 4),
                      this._process();
                    for (var D = this._hash, L = D.words, G = 0; G < 5; G++) {
                      var q = L[G];
                      L[G] =
                        (((q << 8) | (q >>> 24)) & 16711935) |
                        (((q << 24) | (q >>> 8)) & 4278255360);
                    }
                    return D;
                  },
                  clone: function () {
                    var E = o.clone.call(this);
                    return (E._hash = this._hash.clone()), E;
                  },
                }));
              function h(E, _, S) {
                return E ^ _ ^ S;
              }
              function g(E, _, S) {
                return (E & _) | (~E & S);
              }
              function v(E, _, S) {
                return (E | ~_) ^ S;
              }
              function w(E, _, S) {
                return (E & S) | (_ & ~S);
              }
              function T(E, _, S) {
                return E ^ (_ | ~S);
              }
              function A(E, _) {
                return (E << _) | (E >>> (32 - _));
              }
              (a.RIPEMD160 = o._createHelper(y)),
                (a.HmacRIPEMD160 = o._createHmacHelper(y));
            })(),
            t.RIPEMD160
          );
        });
      })(x0)),
    x0.exports
  );
}
var v0 = { exports: {} },
  hg;
function sm() {
  return (
    hg ||
      ((hg = 1),
      (function (n, e) {
        (function (t, r) {
          n.exports = r(Le());
        })(Ae, function (t) {
          (function () {
            var r = t,
              a = r.lib,
              i = a.Base,
              s = r.enc,
              o = s.Utf8,
              c = r.algo;
            c.HMAC = i.extend({
              init: function (l, u) {
                (l = this._hasher = new l.init()),
                  typeof u == "string" && (u = o.parse(u));
                var d = l.blockSize,
                  f = d * 4;
                u.sigBytes > f && (u = l.finalize(u)), u.clamp();
                for (
                  var p = (this._oKey = u.clone()),
                    m = (this._iKey = u.clone()),
                    y = p.words,
                    h = m.words,
                    g = 0;
                  g < d;
                  g++
                )
                  (y[g] ^= 1549556828), (h[g] ^= 909522486);
                (p.sigBytes = m.sigBytes = f), this.reset();
              },
              reset: function () {
                var l = this._hasher;
                l.reset(), l.update(this._iKey);
              },
              update: function (l) {
                return this._hasher.update(l), this;
              },
              finalize: function (l) {
                var u = this._hasher,
                  d = u.finalize(l);
                u.reset();
                var f = u.finalize(this._oKey.clone().concat(d));
                return f;
              },
            });
          })();
        });
      })(v0)),
    v0.exports
  );
}
var w0 = { exports: {} },
  mg;
function nR() {
  return (
    mg ||
      ((mg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), im(), sm());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.Base,
                s = a.WordArray,
                o = r.algo,
                c = o.SHA1,
                l = o.HMAC,
                u = (o.PBKDF2 = i.extend({
                  cfg: i.extend({
                    keySize: 128 / 32,
                    hasher: c,
                    iterations: 1,
                  }),
                  init: function (d) {
                    this.cfg = this.cfg.extend(d);
                  },
                  compute: function (d, f) {
                    for (
                      var p = this.cfg,
                        m = l.create(p.hasher, d),
                        y = s.create(),
                        h = s.create([1]),
                        g = y.words,
                        v = h.words,
                        w = p.keySize,
                        T = p.iterations;
                      g.length < w;

                    ) {
                      var A = m.update(f).finalize(h);
                      m.reset();
                      for (
                        var E = A.words, _ = E.length, S = A, W = 1;
                        W < T;
                        W++
                      ) {
                        (S = m.finalize(S)), m.reset();
                        for (var D = S.words, L = 0; L < _; L++) E[L] ^= D[L];
                      }
                      y.concat(A), v[0]++;
                    }
                    return (y.sigBytes = w * 4), y;
                  },
                }));
              r.PBKDF2 = function (d, f, p) {
                return u.create(p).compute(d, f);
              };
            })(),
            t.PBKDF2
          );
        });
      })(w0)),
    w0.exports
  );
}
var T0 = { exports: {} },
  yg;
function Ki() {
  return (
    yg ||
      ((yg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), im(), sm());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.Base,
                s = a.WordArray,
                o = r.algo,
                c = o.MD5,
                l = (o.EvpKDF = i.extend({
                  cfg: i.extend({
                    keySize: 128 / 32,
                    hasher: c,
                    iterations: 1,
                  }),
                  init: function (u) {
                    this.cfg = this.cfg.extend(u);
                  },
                  compute: function (u, d) {
                    for (
                      var f = this.cfg,
                        p = f.hasher.create(),
                        m = s.create(),
                        y = m.words,
                        h = f.keySize,
                        g = f.iterations;
                      y.length < h;

                    ) {
                      v && p.update(v);
                      var v = p.update(u).finalize(d);
                      p.reset();
                      for (var w = 1; w < g; w++)
                        (v = p.finalize(v)), p.reset();
                      m.concat(v);
                    }
                    return (m.sigBytes = h * 4), m;
                  },
                }));
              r.EvpKDF = function (u, d, f) {
                return l.create(f).compute(u, d);
              };
            })(),
            t.EvpKDF
          );
        });
      })(T0)),
    T0.exports
  );
}
var C0 = { exports: {} },
  gg;
function Qt() {
  return (
    gg ||
      ((gg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Ki());
        })(Ae, function (t) {
          t.lib.Cipher ||
            (function (r) {
              var a = t,
                i = a.lib,
                s = i.Base,
                o = i.WordArray,
                c = i.BufferedBlockAlgorithm,
                l = a.enc;
              l.Utf8;
              var u = l.Base64,
                d = a.algo,
                f = d.EvpKDF,
                p = (i.Cipher = c.extend({
                  cfg: s.extend(),
                  createEncryptor: function (D, L) {
                    return this.create(this._ENC_XFORM_MODE, D, L);
                  },
                  createDecryptor: function (D, L) {
                    return this.create(this._DEC_XFORM_MODE, D, L);
                  },
                  init: function (D, L, G) {
                    (this.cfg = this.cfg.extend(G)),
                      (this._xformMode = D),
                      (this._key = L),
                      this.reset();
                  },
                  reset: function () {
                    c.reset.call(this), this._doReset();
                  },
                  process: function (D) {
                    return this._append(D), this._process();
                  },
                  finalize: function (D) {
                    D && this._append(D);
                    var L = this._doFinalize();
                    return L;
                  },
                  keySize: 128 / 32,
                  ivSize: 128 / 32,
                  _ENC_XFORM_MODE: 1,
                  _DEC_XFORM_MODE: 2,
                  _createHelper: (function () {
                    function D(L) {
                      return typeof L == "string" ? W : E;
                    }
                    return function (L) {
                      return {
                        encrypt: function (G, q, N) {
                          return D(q).encrypt(L, G, q, N);
                        },
                        decrypt: function (G, q, N) {
                          return D(q).decrypt(L, G, q, N);
                        },
                      };
                    };
                  })(),
                }));
              i.StreamCipher = p.extend({
                _doFinalize: function () {
                  var D = this._process(!0);
                  return D;
                },
                blockSize: 1,
              });
              var m = (a.mode = {}),
                y = (i.BlockCipherMode = s.extend({
                  createEncryptor: function (D, L) {
                    return this.Encryptor.create(D, L);
                  },
                  createDecryptor: function (D, L) {
                    return this.Decryptor.create(D, L);
                  },
                  init: function (D, L) {
                    (this._cipher = D), (this._iv = L);
                  },
                })),
                h = (m.CBC = (function () {
                  var D = y.extend();
                  (D.Encryptor = D.extend({
                    processBlock: function (G, q) {
                      var N = this._cipher,
                        H = N.blockSize;
                      L.call(this, G, q, H),
                        N.encryptBlock(G, q),
                        (this._prevBlock = G.slice(q, q + H));
                    },
                  })),
                    (D.Decryptor = D.extend({
                      processBlock: function (G, q) {
                        var N = this._cipher,
                          H = N.blockSize,
                          J = G.slice(q, q + H);
                        N.decryptBlock(G, q),
                          L.call(this, G, q, H),
                          (this._prevBlock = J);
                      },
                    }));
                  function L(G, q, N) {
                    var H = this._iv;
                    if (H) {
                      var J = H;
                      this._iv = r;
                    } else var J = this._prevBlock;
                    for (var de = 0; de < N; de++) G[q + de] ^= J[de];
                  }
                  return D;
                })()),
                g = (a.pad = {}),
                v = (g.Pkcs7 = {
                  pad: function (D, L) {
                    for (
                      var G = L * 4,
                        q = G - (D.sigBytes % G),
                        N = (q << 24) | (q << 16) | (q << 8) | q,
                        H = [],
                        J = 0;
                      J < q;
                      J += 4
                    )
                      H.push(N);
                    var de = o.create(H, q);
                    D.concat(de);
                  },
                  unpad: function (D) {
                    var L = D.words[(D.sigBytes - 1) >>> 2] & 255;
                    D.sigBytes -= L;
                  },
                });
              i.BlockCipher = p.extend({
                cfg: p.cfg.extend({ mode: h, padding: v }),
                reset: function () {
                  p.reset.call(this);
                  var D = this.cfg,
                    L = D.iv,
                    G = D.mode;
                  if (this._xformMode == this._ENC_XFORM_MODE)
                    var q = G.createEncryptor;
                  else {
                    var q = G.createDecryptor;
                    this._minBufferSize = 1;
                  }
                  this._mode && this._mode.__creator == q
                    ? this._mode.init(this, L && L.words)
                    : ((this._mode = q.call(G, this, L && L.words)),
                      (this._mode.__creator = q));
                },
                _doProcessBlock: function (D, L) {
                  this._mode.processBlock(D, L);
                },
                _doFinalize: function () {
                  var D = this.cfg.padding;
                  if (this._xformMode == this._ENC_XFORM_MODE) {
                    D.pad(this._data, this.blockSize);
                    var L = this._process(!0);
                  } else {
                    var L = this._process(!0);
                    D.unpad(L);
                  }
                  return L;
                },
                blockSize: 128 / 32,
              });
              var w = (i.CipherParams = s.extend({
                  init: function (D) {
                    this.mixIn(D);
                  },
                  toString: function (D) {
                    return (D || this.formatter).stringify(this);
                  },
                })),
                T = (a.format = {}),
                A = (T.OpenSSL = {
                  stringify: function (D) {
                    var L = D.ciphertext,
                      G = D.salt;
                    if (G)
                      var q = o
                        .create([1398893684, 1701076831])
                        .concat(G)
                        .concat(L);
                    else var q = L;
                    return q.toString(u);
                  },
                  parse: function (D) {
                    var L = u.parse(D),
                      G = L.words;
                    if (G[0] == 1398893684 && G[1] == 1701076831) {
                      var q = o.create(G.slice(2, 4));
                      G.splice(0, 4), (L.sigBytes -= 16);
                    }
                    return w.create({ ciphertext: L, salt: q });
                  },
                }),
                E = (i.SerializableCipher = s.extend({
                  cfg: s.extend({ format: A }),
                  encrypt: function (D, L, G, q) {
                    q = this.cfg.extend(q);
                    var N = D.createEncryptor(G, q),
                      H = N.finalize(L),
                      J = N.cfg;
                    return w.create({
                      ciphertext: H,
                      key: G,
                      iv: J.iv,
                      algorithm: D,
                      mode: J.mode,
                      padding: J.padding,
                      blockSize: D.blockSize,
                      formatter: q.format,
                    });
                  },
                  decrypt: function (D, L, G, q) {
                    (q = this.cfg.extend(q)), (L = this._parse(L, q.format));
                    var N = D.createDecryptor(G, q).finalize(L.ciphertext);
                    return N;
                  },
                  _parse: function (D, L) {
                    return typeof D == "string" ? L.parse(D, this) : D;
                  },
                })),
                _ = (a.kdf = {}),
                S = (_.OpenSSL = {
                  execute: function (D, L, G, q) {
                    q || (q = o.random(64 / 8));
                    var N = f.create({ keySize: L + G }).compute(D, q),
                      H = o.create(N.words.slice(L), G * 4);
                    return (
                      (N.sigBytes = L * 4), w.create({ key: N, iv: H, salt: q })
                    );
                  },
                }),
                W = (i.PasswordBasedCipher = E.extend({
                  cfg: E.cfg.extend({ kdf: S }),
                  encrypt: function (D, L, G, q) {
                    q = this.cfg.extend(q);
                    var N = q.kdf.execute(G, D.keySize, D.ivSize);
                    q.iv = N.iv;
                    var H = E.encrypt.call(this, D, L, N.key, q);
                    return H.mixIn(N), H;
                  },
                  decrypt: function (D, L, G, q) {
                    (q = this.cfg.extend(q)), (L = this._parse(L, q.format));
                    var N = q.kdf.execute(G, D.keySize, D.ivSize, L.salt);
                    q.iv = N.iv;
                    var H = E.decrypt.call(this, D, L, N.key, q);
                    return H;
                  },
                }));
            })();
        });
      })(C0)),
    C0.exports
  );
}
var A0 = { exports: {} },
  bg;
function rR() {
  return (
    bg ||
      ((bg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Qt());
        })(Ae, function (t) {
          return (
            (t.mode.CFB = (function () {
              var r = t.lib.BlockCipherMode.extend();
              (r.Encryptor = r.extend({
                processBlock: function (i, s) {
                  var o = this._cipher,
                    c = o.blockSize;
                  a.call(this, i, s, c, o),
                    (this._prevBlock = i.slice(s, s + c));
                },
              })),
                (r.Decryptor = r.extend({
                  processBlock: function (i, s) {
                    var o = this._cipher,
                      c = o.blockSize,
                      l = i.slice(s, s + c);
                    a.call(this, i, s, c, o), (this._prevBlock = l);
                  },
                }));
              function a(i, s, o, c) {
                var l = this._iv;
                if (l) {
                  var u = l.slice(0);
                  this._iv = void 0;
                } else var u = this._prevBlock;
                c.encryptBlock(u, 0);
                for (var d = 0; d < o; d++) i[s + d] ^= u[d];
              }
              return r;
            })()),
            t.mode.CFB
          );
        });
      })(A0)),
    A0.exports
  );
}
var E0 = { exports: {} },
  xg;
function aR() {
  return (
    xg ||
      ((xg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Qt());
        })(Ae, function (t) {
          return (
            (t.mode.CTR = (function () {
              var r = t.lib.BlockCipherMode.extend(),
                a = (r.Encryptor = r.extend({
                  processBlock: function (i, s) {
                    var o = this._cipher,
                      c = o.blockSize,
                      l = this._iv,
                      u = this._counter;
                    l &&
                      ((u = this._counter = l.slice(0)), (this._iv = void 0));
                    var d = u.slice(0);
                    o.encryptBlock(d, 0), (u[c - 1] = (u[c - 1] + 1) | 0);
                    for (var f = 0; f < c; f++) i[s + f] ^= d[f];
                  },
                }));
              return (r.Decryptor = a), r;
            })()),
            t.mode.CTR
          );
        });
      })(E0)),
    E0.exports
  );
}
var k0 = { exports: {} },
  vg;
function iR() {
  return (
    vg ||
      ((vg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Qt());
        })(Ae, function (t) {
          /** @preserve
           * Counter block mode compatible with  Dr Brian Gladman fileenc.c
           * derived from CryptoJS.mode.CTR
           * Jan Hruby jhruby.web@gmail.com
           */ return (
            (t.mode.CTRGladman = (function () {
              var r = t.lib.BlockCipherMode.extend();
              function a(o) {
                if (((o >> 24) & 255) === 255) {
                  var c = (o >> 16) & 255,
                    l = (o >> 8) & 255,
                    u = o & 255;
                  c === 255
                    ? ((c = 0),
                      l === 255 ? ((l = 0), u === 255 ? (u = 0) : ++u) : ++l)
                    : ++c,
                    (o = 0),
                    (o += c << 16),
                    (o += l << 8),
                    (o += u);
                } else o += 1 << 24;
                return o;
              }
              function i(o) {
                return (o[0] = a(o[0])) === 0 && (o[1] = a(o[1])), o;
              }
              var s = (r.Encryptor = r.extend({
                processBlock: function (o, c) {
                  var l = this._cipher,
                    u = l.blockSize,
                    d = this._iv,
                    f = this._counter;
                  d && ((f = this._counter = d.slice(0)), (this._iv = void 0)),
                    i(f);
                  var p = f.slice(0);
                  l.encryptBlock(p, 0);
                  for (var m = 0; m < u; m++) o[c + m] ^= p[m];
                },
              }));
              return (r.Decryptor = s), r;
            })()),
            t.mode.CTRGladman
          );
        });
      })(k0)),
    k0.exports
  );
}
var _0 = { exports: {} },
  wg;
function sR() {
  return (
    wg ||
      ((wg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Qt());
        })(Ae, function (t) {
          return (
            (t.mode.OFB = (function () {
              var r = t.lib.BlockCipherMode.extend(),
                a = (r.Encryptor = r.extend({
                  processBlock: function (i, s) {
                    var o = this._cipher,
                      c = o.blockSize,
                      l = this._iv,
                      u = this._keystream;
                    l &&
                      ((u = this._keystream = l.slice(0)), (this._iv = void 0)),
                      o.encryptBlock(u, 0);
                    for (var d = 0; d < c; d++) i[s + d] ^= u[d];
                  },
                }));
              return (r.Decryptor = a), r;
            })()),
            t.mode.OFB
          );
        });
      })(_0)),
    _0.exports
  );
}
var S0 = { exports: {} },
  Tg;
function oR() {
  return (
    Tg ||
      ((Tg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Qt());
        })(Ae, function (t) {
          return (
            (t.mode.ECB = (function () {
              var r = t.lib.BlockCipherMode.extend();
              return (
                (r.Encryptor = r.extend({
                  processBlock: function (a, i) {
                    this._cipher.encryptBlock(a, i);
                  },
                })),
                (r.Decryptor = r.extend({
                  processBlock: function (a, i) {
                    this._cipher.decryptBlock(a, i);
                  },
                })),
                r
              );
            })()),
            t.mode.ECB
          );
        });
      })(S0)),
    S0.exports
  );
}
var P0 = { exports: {} },
  Cg;
function cR() {
  return (
    Cg ||
      ((Cg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Qt());
        })(Ae, function (t) {
          return (
            (t.pad.AnsiX923 = {
              pad: function (r, a) {
                var i = r.sigBytes,
                  s = a * 4,
                  o = s - (i % s),
                  c = i + o - 1;
                r.clamp(),
                  (r.words[c >>> 2] |= o << (24 - (c % 4) * 8)),
                  (r.sigBytes += o);
              },
              unpad: function (r) {
                var a = r.words[(r.sigBytes - 1) >>> 2] & 255;
                r.sigBytes -= a;
              },
            }),
            t.pad.Ansix923
          );
        });
      })(P0)),
    P0.exports
  );
}
var I0 = { exports: {} },
  Ag;
function lR() {
  return (
    Ag ||
      ((Ag = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Qt());
        })(Ae, function (t) {
          return (
            (t.pad.Iso10126 = {
              pad: function (r, a) {
                var i = a * 4,
                  s = i - (r.sigBytes % i);
                r.concat(t.lib.WordArray.random(s - 1)).concat(
                  t.lib.WordArray.create([s << 24], 1),
                );
              },
              unpad: function (r) {
                var a = r.words[(r.sigBytes - 1) >>> 2] & 255;
                r.sigBytes -= a;
              },
            }),
            t.pad.Iso10126
          );
        });
      })(I0)),
    I0.exports
  );
}
var R0 = { exports: {} },
  Eg;
function uR() {
  return (
    Eg ||
      ((Eg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Qt());
        })(Ae, function (t) {
          return (
            (t.pad.Iso97971 = {
              pad: function (r, a) {
                r.concat(t.lib.WordArray.create([2147483648], 1)),
                  t.pad.ZeroPadding.pad(r, a);
              },
              unpad: function (r) {
                t.pad.ZeroPadding.unpad(r), r.sigBytes--;
              },
            }),
            t.pad.Iso97971
          );
        });
      })(R0)),
    R0.exports
  );
}
var M0 = { exports: {} },
  kg;
function dR() {
  return (
    kg ||
      ((kg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Qt());
        })(Ae, function (t) {
          return (
            (t.pad.ZeroPadding = {
              pad: function (r, a) {
                var i = a * 4;
                r.clamp(), (r.sigBytes += i - (r.sigBytes % i || i));
              },
              unpad: function (r) {
                for (
                  var a = r.words, i = r.sigBytes - 1;
                  !((a[i >>> 2] >>> (24 - (i % 4) * 8)) & 255);

                )
                  i--;
                r.sigBytes = i + 1;
              },
            }),
            t.pad.ZeroPadding
          );
        });
      })(M0)),
    M0.exports
  );
}
var B0 = { exports: {} },
  _g;
function fR() {
  return (
    _g ||
      ((_g = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Qt());
        })(Ae, function (t) {
          return (
            (t.pad.NoPadding = { pad: function () {}, unpad: function () {} }),
            t.pad.NoPadding
          );
        });
      })(B0)),
    B0.exports
  );
}
var D0 = { exports: {} },
  Sg;
function pR() {
  return (
    Sg ||
      ((Sg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), Qt());
        })(Ae, function (t) {
          return (
            (function (r) {
              var a = t,
                i = a.lib,
                s = i.CipherParams,
                o = a.enc,
                c = o.Hex,
                l = a.format;
              l.Hex = {
                stringify: function (u) {
                  return u.ciphertext.toString(c);
                },
                parse: function (u) {
                  var d = c.parse(u);
                  return s.create({ ciphertext: d });
                },
              };
            })(),
            t.format.Hex
          );
        });
      })(D0)),
    D0.exports
  );
}
var O0 = { exports: {} },
  Pg;
function hR() {
  return (
    Pg ||
      ((Pg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), lo(), uo(), Ki(), Qt());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.BlockCipher,
                s = r.algo,
                o = [],
                c = [],
                l = [],
                u = [],
                d = [],
                f = [],
                p = [],
                m = [],
                y = [],
                h = [];
              (function () {
                for (var w = [], T = 0; T < 256; T++)
                  T < 128 ? (w[T] = T << 1) : (w[T] = (T << 1) ^ 283);
                for (var A = 0, E = 0, T = 0; T < 256; T++) {
                  var _ = E ^ (E << 1) ^ (E << 2) ^ (E << 3) ^ (E << 4);
                  (_ = (_ >>> 8) ^ (_ & 255) ^ 99), (o[A] = _), (c[_] = A);
                  var S = w[A],
                    W = w[S],
                    D = w[W],
                    L = (w[_] * 257) ^ (_ * 16843008);
                  (l[A] = (L << 24) | (L >>> 8)),
                    (u[A] = (L << 16) | (L >>> 16)),
                    (d[A] = (L << 8) | (L >>> 24)),
                    (f[A] = L);
                  var L =
                    (D * 16843009) ^ (W * 65537) ^ (S * 257) ^ (A * 16843008);
                  (p[_] = (L << 24) | (L >>> 8)),
                    (m[_] = (L << 16) | (L >>> 16)),
                    (y[_] = (L << 8) | (L >>> 24)),
                    (h[_] = L),
                    A
                      ? ((A = S ^ w[w[w[D ^ S]]]), (E ^= w[w[E]]))
                      : (A = E = 1);
                }
              })();
              var g = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
                v = (s.AES = i.extend({
                  _doReset: function () {
                    if (!(this._nRounds && this._keyPriorReset === this._key)) {
                      for (
                        var w = (this._keyPriorReset = this._key),
                          T = w.words,
                          A = w.sigBytes / 4,
                          E = (this._nRounds = A + 6),
                          _ = (E + 1) * 4,
                          S = (this._keySchedule = []),
                          W = 0;
                        W < _;
                        W++
                      )
                        if (W < A) S[W] = T[W];
                        else {
                          var D = S[W - 1];
                          W % A
                            ? A > 6 &&
                              W % A == 4 &&
                              (D =
                                (o[D >>> 24] << 24) |
                                (o[(D >>> 16) & 255] << 16) |
                                (o[(D >>> 8) & 255] << 8) |
                                o[D & 255])
                            : ((D = (D << 8) | (D >>> 24)),
                              (D =
                                (o[D >>> 24] << 24) |
                                (o[(D >>> 16) & 255] << 16) |
                                (o[(D >>> 8) & 255] << 8) |
                                o[D & 255]),
                              (D ^= g[(W / A) | 0] << 24)),
                            (S[W] = S[W - A] ^ D);
                        }
                      for (
                        var L = (this._invKeySchedule = []), G = 0;
                        G < _;
                        G++
                      ) {
                        var W = _ - G;
                        if (G % 4) var D = S[W];
                        else var D = S[W - 4];
                        G < 4 || W <= 4
                          ? (L[G] = D)
                          : (L[G] =
                              p[o[D >>> 24]] ^
                              m[o[(D >>> 16) & 255]] ^
                              y[o[(D >>> 8) & 255]] ^
                              h[o[D & 255]]);
                      }
                    }
                  },
                  encryptBlock: function (w, T) {
                    this._doCryptBlock(w, T, this._keySchedule, l, u, d, f, o);
                  },
                  decryptBlock: function (w, T) {
                    var A = w[T + 1];
                    (w[T + 1] = w[T + 3]),
                      (w[T + 3] = A),
                      this._doCryptBlock(
                        w,
                        T,
                        this._invKeySchedule,
                        p,
                        m,
                        y,
                        h,
                        c,
                      );
                    var A = w[T + 1];
                    (w[T + 1] = w[T + 3]), (w[T + 3] = A);
                  },
                  _doCryptBlock: function (w, T, A, E, _, S, W, D) {
                    for (
                      var L = this._nRounds,
                        G = w[T] ^ A[0],
                        q = w[T + 1] ^ A[1],
                        N = w[T + 2] ^ A[2],
                        H = w[T + 3] ^ A[3],
                        J = 4,
                        de = 1;
                      de < L;
                      de++
                    ) {
                      var le =
                          E[G >>> 24] ^
                          _[(q >>> 16) & 255] ^
                          S[(N >>> 8) & 255] ^
                          W[H & 255] ^
                          A[J++],
                        Z =
                          E[q >>> 24] ^
                          _[(N >>> 16) & 255] ^
                          S[(H >>> 8) & 255] ^
                          W[G & 255] ^
                          A[J++],
                        ue =
                          E[N >>> 24] ^
                          _[(H >>> 16) & 255] ^
                          S[(G >>> 8) & 255] ^
                          W[q & 255] ^
                          A[J++],
                        P =
                          E[H >>> 24] ^
                          _[(G >>> 16) & 255] ^
                          S[(q >>> 8) & 255] ^
                          W[N & 255] ^
                          A[J++];
                      (G = le), (q = Z), (N = ue), (H = P);
                    }
                    var le =
                        ((D[G >>> 24] << 24) |
                          (D[(q >>> 16) & 255] << 16) |
                          (D[(N >>> 8) & 255] << 8) |
                          D[H & 255]) ^
                        A[J++],
                      Z =
                        ((D[q >>> 24] << 24) |
                          (D[(N >>> 16) & 255] << 16) |
                          (D[(H >>> 8) & 255] << 8) |
                          D[G & 255]) ^
                        A[J++],
                      ue =
                        ((D[N >>> 24] << 24) |
                          (D[(H >>> 16) & 255] << 16) |
                          (D[(G >>> 8) & 255] << 8) |
                          D[q & 255]) ^
                        A[J++],
                      P =
                        ((D[H >>> 24] << 24) |
                          (D[(G >>> 16) & 255] << 16) |
                          (D[(q >>> 8) & 255] << 8) |
                          D[N & 255]) ^
                        A[J++];
                    (w[T] = le),
                      (w[T + 1] = Z),
                      (w[T + 2] = ue),
                      (w[T + 3] = P);
                  },
                  keySize: 256 / 32,
                }));
              r.AES = i._createHelper(v);
            })(),
            t.AES
          );
        });
      })(O0)),
    O0.exports
  );
}
var N0 = { exports: {} },
  Ig;
function mR() {
  return (
    Ig ||
      ((Ig = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), lo(), uo(), Ki(), Qt());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.WordArray,
                s = a.BlockCipher,
                o = r.algo,
                c = [
                  57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2,
                  59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39,
                  31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37,
                  29, 21, 13, 5, 28, 20, 12, 4,
                ],
                l = [
                  14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26,
                  8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51,
                  45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32,
                ],
                u = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
                d = [
                  {
                    0: 8421888,
                    268435456: 32768,
                    536870912: 8421378,
                    805306368: 2,
                    1073741824: 512,
                    1342177280: 8421890,
                    1610612736: 8389122,
                    1879048192: 8388608,
                    2147483648: 514,
                    2415919104: 8389120,
                    2684354560: 33280,
                    2952790016: 8421376,
                    3221225472: 32770,
                    3489660928: 8388610,
                    3758096384: 0,
                    4026531840: 33282,
                    134217728: 0,
                    402653184: 8421890,
                    671088640: 33282,
                    939524096: 32768,
                    1207959552: 8421888,
                    1476395008: 512,
                    1744830464: 8421378,
                    2013265920: 2,
                    2281701376: 8389120,
                    2550136832: 33280,
                    2818572288: 8421376,
                    3087007744: 8389122,
                    3355443200: 8388610,
                    3623878656: 32770,
                    3892314112: 514,
                    4160749568: 8388608,
                    1: 32768,
                    268435457: 2,
                    536870913: 8421888,
                    805306369: 8388608,
                    1073741825: 8421378,
                    1342177281: 33280,
                    1610612737: 512,
                    1879048193: 8389122,
                    2147483649: 8421890,
                    2415919105: 8421376,
                    2684354561: 8388610,
                    2952790017: 33282,
                    3221225473: 514,
                    3489660929: 8389120,
                    3758096385: 32770,
                    4026531841: 0,
                    134217729: 8421890,
                    402653185: 8421376,
                    671088641: 8388608,
                    939524097: 512,
                    1207959553: 32768,
                    1476395009: 8388610,
                    1744830465: 2,
                    2013265921: 33282,
                    2281701377: 32770,
                    2550136833: 8389122,
                    2818572289: 514,
                    3087007745: 8421888,
                    3355443201: 8389120,
                    3623878657: 0,
                    3892314113: 33280,
                    4160749569: 8421378,
                  },
                  {
                    0: 1074282512,
                    16777216: 16384,
                    33554432: 524288,
                    50331648: 1074266128,
                    67108864: 1073741840,
                    83886080: 1074282496,
                    100663296: 1073758208,
                    117440512: 16,
                    134217728: 540672,
                    150994944: 1073758224,
                    167772160: 1073741824,
                    184549376: 540688,
                    201326592: 524304,
                    218103808: 0,
                    234881024: 16400,
                    251658240: 1074266112,
                    8388608: 1073758208,
                    25165824: 540688,
                    41943040: 16,
                    58720256: 1073758224,
                    75497472: 1074282512,
                    92274688: 1073741824,
                    109051904: 524288,
                    125829120: 1074266128,
                    142606336: 524304,
                    159383552: 0,
                    176160768: 16384,
                    192937984: 1074266112,
                    209715200: 1073741840,
                    226492416: 540672,
                    243269632: 1074282496,
                    260046848: 16400,
                    268435456: 0,
                    285212672: 1074266128,
                    301989888: 1073758224,
                    318767104: 1074282496,
                    335544320: 1074266112,
                    352321536: 16,
                    369098752: 540688,
                    385875968: 16384,
                    402653184: 16400,
                    419430400: 524288,
                    436207616: 524304,
                    452984832: 1073741840,
                    469762048: 540672,
                    486539264: 1073758208,
                    503316480: 1073741824,
                    520093696: 1074282512,
                    276824064: 540688,
                    293601280: 524288,
                    310378496: 1074266112,
                    327155712: 16384,
                    343932928: 1073758208,
                    360710144: 1074282512,
                    377487360: 16,
                    394264576: 1073741824,
                    411041792: 1074282496,
                    427819008: 1073741840,
                    444596224: 1073758224,
                    461373440: 524304,
                    478150656: 0,
                    494927872: 16400,
                    511705088: 1074266128,
                    528482304: 540672,
                  },
                  {
                    0: 260,
                    1048576: 0,
                    2097152: 67109120,
                    3145728: 65796,
                    4194304: 65540,
                    5242880: 67108868,
                    6291456: 67174660,
                    7340032: 67174400,
                    8388608: 67108864,
                    9437184: 67174656,
                    10485760: 65792,
                    11534336: 67174404,
                    12582912: 67109124,
                    13631488: 65536,
                    14680064: 4,
                    15728640: 256,
                    524288: 67174656,
                    1572864: 67174404,
                    2621440: 0,
                    3670016: 67109120,
                    4718592: 67108868,
                    5767168: 65536,
                    6815744: 65540,
                    7864320: 260,
                    8912896: 4,
                    9961472: 256,
                    11010048: 67174400,
                    12058624: 65796,
                    13107200: 65792,
                    14155776: 67109124,
                    15204352: 67174660,
                    16252928: 67108864,
                    16777216: 67174656,
                    17825792: 65540,
                    18874368: 65536,
                    19922944: 67109120,
                    20971520: 256,
                    22020096: 67174660,
                    23068672: 67108868,
                    24117248: 0,
                    25165824: 67109124,
                    26214400: 67108864,
                    27262976: 4,
                    28311552: 65792,
                    29360128: 67174400,
                    30408704: 260,
                    31457280: 65796,
                    32505856: 67174404,
                    17301504: 67108864,
                    18350080: 260,
                    19398656: 67174656,
                    20447232: 0,
                    21495808: 65540,
                    22544384: 67109120,
                    23592960: 256,
                    24641536: 67174404,
                    25690112: 65536,
                    26738688: 67174660,
                    27787264: 65796,
                    28835840: 67108868,
                    29884416: 67109124,
                    30932992: 67174400,
                    31981568: 4,
                    33030144: 65792,
                  },
                  {
                    0: 2151682048,
                    65536: 2147487808,
                    131072: 4198464,
                    196608: 2151677952,
                    262144: 0,
                    327680: 4198400,
                    393216: 2147483712,
                    458752: 4194368,
                    524288: 2147483648,
                    589824: 4194304,
                    655360: 64,
                    720896: 2147487744,
                    786432: 2151678016,
                    851968: 4160,
                    917504: 4096,
                    983040: 2151682112,
                    32768: 2147487808,
                    98304: 64,
                    163840: 2151678016,
                    229376: 2147487744,
                    294912: 4198400,
                    360448: 2151682112,
                    425984: 0,
                    491520: 2151677952,
                    557056: 4096,
                    622592: 2151682048,
                    688128: 4194304,
                    753664: 4160,
                    819200: 2147483648,
                    884736: 4194368,
                    950272: 4198464,
                    1015808: 2147483712,
                    1048576: 4194368,
                    1114112: 4198400,
                    1179648: 2147483712,
                    1245184: 0,
                    1310720: 4160,
                    1376256: 2151678016,
                    1441792: 2151682048,
                    1507328: 2147487808,
                    1572864: 2151682112,
                    1638400: 2147483648,
                    1703936: 2151677952,
                    1769472: 4198464,
                    1835008: 2147487744,
                    1900544: 4194304,
                    1966080: 64,
                    2031616: 4096,
                    1081344: 2151677952,
                    1146880: 2151682112,
                    1212416: 0,
                    1277952: 4198400,
                    1343488: 4194368,
                    1409024: 2147483648,
                    1474560: 2147487808,
                    1540096: 64,
                    1605632: 2147483712,
                    1671168: 4096,
                    1736704: 2147487744,
                    1802240: 2151678016,
                    1867776: 4160,
                    1933312: 2151682048,
                    1998848: 4194304,
                    2064384: 4198464,
                  },
                  {
                    0: 128,
                    4096: 17039360,
                    8192: 262144,
                    12288: 536870912,
                    16384: 537133184,
                    20480: 16777344,
                    24576: 553648256,
                    28672: 262272,
                    32768: 16777216,
                    36864: 537133056,
                    40960: 536871040,
                    45056: 553910400,
                    49152: 553910272,
                    53248: 0,
                    57344: 17039488,
                    61440: 553648128,
                    2048: 17039488,
                    6144: 553648256,
                    10240: 128,
                    14336: 17039360,
                    18432: 262144,
                    22528: 537133184,
                    26624: 553910272,
                    30720: 536870912,
                    34816: 537133056,
                    38912: 0,
                    43008: 553910400,
                    47104: 16777344,
                    51200: 536871040,
                    55296: 553648128,
                    59392: 16777216,
                    63488: 262272,
                    65536: 262144,
                    69632: 128,
                    73728: 536870912,
                    77824: 553648256,
                    81920: 16777344,
                    86016: 553910272,
                    90112: 537133184,
                    94208: 16777216,
                    98304: 553910400,
                    102400: 553648128,
                    106496: 17039360,
                    110592: 537133056,
                    114688: 262272,
                    118784: 536871040,
                    122880: 0,
                    126976: 17039488,
                    67584: 553648256,
                    71680: 16777216,
                    75776: 17039360,
                    79872: 537133184,
                    83968: 536870912,
                    88064: 17039488,
                    92160: 128,
                    96256: 553910272,
                    100352: 262272,
                    104448: 553910400,
                    108544: 0,
                    112640: 553648128,
                    116736: 16777344,
                    120832: 262144,
                    124928: 537133056,
                    129024: 536871040,
                  },
                  {
                    0: 268435464,
                    256: 8192,
                    512: 270532608,
                    768: 270540808,
                    1024: 268443648,
                    1280: 2097152,
                    1536: 2097160,
                    1792: 268435456,
                    2048: 0,
                    2304: 268443656,
                    2560: 2105344,
                    2816: 8,
                    3072: 270532616,
                    3328: 2105352,
                    3584: 8200,
                    3840: 270540800,
                    128: 270532608,
                    384: 270540808,
                    640: 8,
                    896: 2097152,
                    1152: 2105352,
                    1408: 268435464,
                    1664: 268443648,
                    1920: 8200,
                    2176: 2097160,
                    2432: 8192,
                    2688: 268443656,
                    2944: 270532616,
                    3200: 0,
                    3456: 270540800,
                    3712: 2105344,
                    3968: 268435456,
                    4096: 268443648,
                    4352: 270532616,
                    4608: 270540808,
                    4864: 8200,
                    5120: 2097152,
                    5376: 268435456,
                    5632: 268435464,
                    5888: 2105344,
                    6144: 2105352,
                    6400: 0,
                    6656: 8,
                    6912: 270532608,
                    7168: 8192,
                    7424: 268443656,
                    7680: 270540800,
                    7936: 2097160,
                    4224: 8,
                    4480: 2105344,
                    4736: 2097152,
                    4992: 268435464,
                    5248: 268443648,
                    5504: 8200,
                    5760: 270540808,
                    6016: 270532608,
                    6272: 270540800,
                    6528: 270532616,
                    6784: 8192,
                    7040: 2105352,
                    7296: 2097160,
                    7552: 0,
                    7808: 268435456,
                    8064: 268443656,
                  },
                  {
                    0: 1048576,
                    16: 33555457,
                    32: 1024,
                    48: 1049601,
                    64: 34604033,
                    80: 0,
                    96: 1,
                    112: 34603009,
                    128: 33555456,
                    144: 1048577,
                    160: 33554433,
                    176: 34604032,
                    192: 34603008,
                    208: 1025,
                    224: 1049600,
                    240: 33554432,
                    8: 34603009,
                    24: 0,
                    40: 33555457,
                    56: 34604032,
                    72: 1048576,
                    88: 33554433,
                    104: 33554432,
                    120: 1025,
                    136: 1049601,
                    152: 33555456,
                    168: 34603008,
                    184: 1048577,
                    200: 1024,
                    216: 34604033,
                    232: 1,
                    248: 1049600,
                    256: 33554432,
                    272: 1048576,
                    288: 33555457,
                    304: 34603009,
                    320: 1048577,
                    336: 33555456,
                    352: 34604032,
                    368: 1049601,
                    384: 1025,
                    400: 34604033,
                    416: 1049600,
                    432: 1,
                    448: 0,
                    464: 34603008,
                    480: 33554433,
                    496: 1024,
                    264: 1049600,
                    280: 33555457,
                    296: 34603009,
                    312: 1,
                    328: 33554432,
                    344: 1048576,
                    360: 1025,
                    376: 34604032,
                    392: 33554433,
                    408: 34603008,
                    424: 0,
                    440: 34604033,
                    456: 1049601,
                    472: 1024,
                    488: 33555456,
                    504: 1048577,
                  },
                  {
                    0: 134219808,
                    1: 131072,
                    2: 134217728,
                    3: 32,
                    4: 131104,
                    5: 134350880,
                    6: 134350848,
                    7: 2048,
                    8: 134348800,
                    9: 134219776,
                    10: 133120,
                    11: 134348832,
                    12: 2080,
                    13: 0,
                    14: 134217760,
                    15: 133152,
                    2147483648: 2048,
                    2147483649: 134350880,
                    2147483650: 134219808,
                    2147483651: 134217728,
                    2147483652: 134348800,
                    2147483653: 133120,
                    2147483654: 133152,
                    2147483655: 32,
                    2147483656: 134217760,
                    2147483657: 2080,
                    2147483658: 131104,
                    2147483659: 134350848,
                    2147483660: 0,
                    2147483661: 134348832,
                    2147483662: 134219776,
                    2147483663: 131072,
                    16: 133152,
                    17: 134350848,
                    18: 32,
                    19: 2048,
                    20: 134219776,
                    21: 134217760,
                    22: 134348832,
                    23: 131072,
                    24: 0,
                    25: 131104,
                    26: 134348800,
                    27: 134219808,
                    28: 134350880,
                    29: 133120,
                    30: 2080,
                    31: 134217728,
                    2147483664: 131072,
                    2147483665: 2048,
                    2147483666: 134348832,
                    2147483667: 133152,
                    2147483668: 32,
                    2147483669: 134348800,
                    2147483670: 134217728,
                    2147483671: 134219808,
                    2147483672: 134350880,
                    2147483673: 134217760,
                    2147483674: 134219776,
                    2147483675: 0,
                    2147483676: 133120,
                    2147483677: 2080,
                    2147483678: 131104,
                    2147483679: 134350848,
                  },
                ],
                f = [
                  4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504,
                  2147483679,
                ],
                p = (o.DES = s.extend({
                  _doReset: function () {
                    for (
                      var g = this._key, v = g.words, w = [], T = 0;
                      T < 56;
                      T++
                    ) {
                      var A = c[T] - 1;
                      w[T] = (v[A >>> 5] >>> (31 - (A % 32))) & 1;
                    }
                    for (var E = (this._subKeys = []), _ = 0; _ < 16; _++) {
                      for (var S = (E[_] = []), W = u[_], T = 0; T < 24; T++)
                        (S[(T / 6) | 0] |=
                          w[(l[T] - 1 + W) % 28] << (31 - (T % 6))),
                          (S[4 + ((T / 6) | 0)] |=
                            w[28 + ((l[T + 24] - 1 + W) % 28)] <<
                            (31 - (T % 6)));
                      S[0] = (S[0] << 1) | (S[0] >>> 31);
                      for (var T = 1; T < 7; T++)
                        S[T] = S[T] >>> ((T - 1) * 4 + 3);
                      S[7] = (S[7] << 5) | (S[7] >>> 27);
                    }
                    for (var D = (this._invSubKeys = []), T = 0; T < 16; T++)
                      D[T] = E[15 - T];
                  },
                  encryptBlock: function (g, v) {
                    this._doCryptBlock(g, v, this._subKeys);
                  },
                  decryptBlock: function (g, v) {
                    this._doCryptBlock(g, v, this._invSubKeys);
                  },
                  _doCryptBlock: function (g, v, w) {
                    (this._lBlock = g[v]),
                      (this._rBlock = g[v + 1]),
                      m.call(this, 4, 252645135),
                      m.call(this, 16, 65535),
                      y.call(this, 2, 858993459),
                      y.call(this, 8, 16711935),
                      m.call(this, 1, 1431655765);
                    for (var T = 0; T < 16; T++) {
                      for (
                        var A = w[T],
                          E = this._lBlock,
                          _ = this._rBlock,
                          S = 0,
                          W = 0;
                        W < 8;
                        W++
                      )
                        S |= d[W][((_ ^ A[W]) & f[W]) >>> 0];
                      (this._lBlock = _), (this._rBlock = E ^ S);
                    }
                    var D = this._lBlock;
                    (this._lBlock = this._rBlock),
                      (this._rBlock = D),
                      m.call(this, 1, 1431655765),
                      y.call(this, 8, 16711935),
                      y.call(this, 2, 858993459),
                      m.call(this, 16, 65535),
                      m.call(this, 4, 252645135),
                      (g[v] = this._lBlock),
                      (g[v + 1] = this._rBlock);
                  },
                  keySize: 64 / 32,
                  ivSize: 64 / 32,
                  blockSize: 64 / 32,
                }));
              function m(g, v) {
                var w = ((this._lBlock >>> g) ^ this._rBlock) & v;
                (this._rBlock ^= w), (this._lBlock ^= w << g);
              }
              function y(g, v) {
                var w = ((this._rBlock >>> g) ^ this._lBlock) & v;
                (this._lBlock ^= w), (this._rBlock ^= w << g);
              }
              r.DES = s._createHelper(p);
              var h = (o.TripleDES = s.extend({
                _doReset: function () {
                  var g = this._key,
                    v = g.words;
                  (this._des1 = p.createEncryptor(i.create(v.slice(0, 2)))),
                    (this._des2 = p.createEncryptor(i.create(v.slice(2, 4)))),
                    (this._des3 = p.createEncryptor(i.create(v.slice(4, 6))));
                },
                encryptBlock: function (g, v) {
                  this._des1.encryptBlock(g, v),
                    this._des2.decryptBlock(g, v),
                    this._des3.encryptBlock(g, v);
                },
                decryptBlock: function (g, v) {
                  this._des3.decryptBlock(g, v),
                    this._des2.encryptBlock(g, v),
                    this._des1.decryptBlock(g, v);
                },
                keySize: 192 / 32,
                ivSize: 64 / 32,
                blockSize: 64 / 32,
              }));
              r.TripleDES = s._createHelper(h);
            })(),
            t.TripleDES
          );
        });
      })(N0)),
    N0.exports
  );
}
var F0 = { exports: {} },
  Rg;
function yR() {
  return (
    Rg ||
      ((Rg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), lo(), uo(), Ki(), Qt());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.StreamCipher,
                s = r.algo,
                o = (s.RC4 = i.extend({
                  _doReset: function () {
                    for (
                      var u = this._key,
                        d = u.words,
                        f = u.sigBytes,
                        p = (this._S = []),
                        m = 0;
                      m < 256;
                      m++
                    )
                      p[m] = m;
                    for (var m = 0, y = 0; m < 256; m++) {
                      var h = m % f,
                        g = (d[h >>> 2] >>> (24 - (h % 4) * 8)) & 255;
                      y = (y + p[m] + g) % 256;
                      var v = p[m];
                      (p[m] = p[y]), (p[y] = v);
                    }
                    this._i = this._j = 0;
                  },
                  _doProcessBlock: function (u, d) {
                    u[d] ^= c.call(this);
                  },
                  keySize: 256 / 32,
                  ivSize: 0,
                }));
              function c() {
                for (
                  var u = this._S, d = this._i, f = this._j, p = 0, m = 0;
                  m < 4;
                  m++
                ) {
                  (d = (d + 1) % 256), (f = (f + u[d]) % 256);
                  var y = u[d];
                  (u[d] = u[f]),
                    (u[f] = y),
                    (p |= u[(u[d] + u[f]) % 256] << (24 - m * 8));
                }
                return (this._i = d), (this._j = f), p;
              }
              r.RC4 = i._createHelper(o);
              var l = (s.RC4Drop = o.extend({
                cfg: o.cfg.extend({ drop: 192 }),
                _doReset: function () {
                  o._doReset.call(this);
                  for (var u = this.cfg.drop; u > 0; u--) c.call(this);
                },
              }));
              r.RC4Drop = i._createHelper(l);
            })(),
            t.RC4
          );
        });
      })(F0)),
    F0.exports
  );
}
var L0 = { exports: {} },
  Mg;
function gR() {
  return (
    Mg ||
      ((Mg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), lo(), uo(), Ki(), Qt());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.StreamCipher,
                s = r.algo,
                o = [],
                c = [],
                l = [],
                u = (s.Rabbit = i.extend({
                  _doReset: function () {
                    for (
                      var f = this._key.words, p = this.cfg.iv, m = 0;
                      m < 4;
                      m++
                    )
                      f[m] =
                        (((f[m] << 8) | (f[m] >>> 24)) & 16711935) |
                        (((f[m] << 24) | (f[m] >>> 8)) & 4278255360);
                    var y = (this._X = [
                        f[0],
                        (f[3] << 16) | (f[2] >>> 16),
                        f[1],
                        (f[0] << 16) | (f[3] >>> 16),
                        f[2],
                        (f[1] << 16) | (f[0] >>> 16),
                        f[3],
                        (f[2] << 16) | (f[1] >>> 16),
                      ]),
                      h = (this._C = [
                        (f[2] << 16) | (f[2] >>> 16),
                        (f[0] & 4294901760) | (f[1] & 65535),
                        (f[3] << 16) | (f[3] >>> 16),
                        (f[1] & 4294901760) | (f[2] & 65535),
                        (f[0] << 16) | (f[0] >>> 16),
                        (f[2] & 4294901760) | (f[3] & 65535),
                        (f[1] << 16) | (f[1] >>> 16),
                        (f[3] & 4294901760) | (f[0] & 65535),
                      ]);
                    this._b = 0;
                    for (var m = 0; m < 4; m++) d.call(this);
                    for (var m = 0; m < 8; m++) h[m] ^= y[(m + 4) & 7];
                    if (p) {
                      var g = p.words,
                        v = g[0],
                        w = g[1],
                        T =
                          (((v << 8) | (v >>> 24)) & 16711935) |
                          (((v << 24) | (v >>> 8)) & 4278255360),
                        A =
                          (((w << 8) | (w >>> 24)) & 16711935) |
                          (((w << 24) | (w >>> 8)) & 4278255360),
                        E = (T >>> 16) | (A & 4294901760),
                        _ = (A << 16) | (T & 65535);
                      (h[0] ^= T),
                        (h[1] ^= E),
                        (h[2] ^= A),
                        (h[3] ^= _),
                        (h[4] ^= T),
                        (h[5] ^= E),
                        (h[6] ^= A),
                        (h[7] ^= _);
                      for (var m = 0; m < 4; m++) d.call(this);
                    }
                  },
                  _doProcessBlock: function (f, p) {
                    var m = this._X;
                    d.call(this),
                      (o[0] = m[0] ^ (m[5] >>> 16) ^ (m[3] << 16)),
                      (o[1] = m[2] ^ (m[7] >>> 16) ^ (m[5] << 16)),
                      (o[2] = m[4] ^ (m[1] >>> 16) ^ (m[7] << 16)),
                      (o[3] = m[6] ^ (m[3] >>> 16) ^ (m[1] << 16));
                    for (var y = 0; y < 4; y++)
                      (o[y] =
                        (((o[y] << 8) | (o[y] >>> 24)) & 16711935) |
                        (((o[y] << 24) | (o[y] >>> 8)) & 4278255360)),
                        (f[p + y] ^= o[y]);
                  },
                  blockSize: 128 / 32,
                  ivSize: 64 / 32,
                }));
              function d() {
                for (var f = this._X, p = this._C, m = 0; m < 8; m++)
                  c[m] = p[m];
                (p[0] = (p[0] + 1295307597 + this._b) | 0),
                  (p[1] =
                    (p[1] + 3545052371 + (p[0] >>> 0 < c[0] >>> 0 ? 1 : 0)) |
                    0),
                  (p[2] =
                    (p[2] + 886263092 + (p[1] >>> 0 < c[1] >>> 0 ? 1 : 0)) | 0),
                  (p[3] =
                    (p[3] + 1295307597 + (p[2] >>> 0 < c[2] >>> 0 ? 1 : 0)) |
                    0),
                  (p[4] =
                    (p[4] + 3545052371 + (p[3] >>> 0 < c[3] >>> 0 ? 1 : 0)) |
                    0),
                  (p[5] =
                    (p[5] + 886263092 + (p[4] >>> 0 < c[4] >>> 0 ? 1 : 0)) | 0),
                  (p[6] =
                    (p[6] + 1295307597 + (p[5] >>> 0 < c[5] >>> 0 ? 1 : 0)) |
                    0),
                  (p[7] =
                    (p[7] + 3545052371 + (p[6] >>> 0 < c[6] >>> 0 ? 1 : 0)) |
                    0),
                  (this._b = p[7] >>> 0 < c[7] >>> 0 ? 1 : 0);
                for (var m = 0; m < 8; m++) {
                  var y = f[m] + p[m],
                    h = y & 65535,
                    g = y >>> 16,
                    v = ((((h * h) >>> 17) + h * g) >>> 15) + g * g,
                    w = (((y & 4294901760) * y) | 0) + (((y & 65535) * y) | 0);
                  l[m] = v ^ w;
                }
                (f[0] =
                  (l[0] +
                    ((l[7] << 16) | (l[7] >>> 16)) +
                    ((l[6] << 16) | (l[6] >>> 16))) |
                  0),
                  (f[1] = (l[1] + ((l[0] << 8) | (l[0] >>> 24)) + l[7]) | 0),
                  (f[2] =
                    (l[2] +
                      ((l[1] << 16) | (l[1] >>> 16)) +
                      ((l[0] << 16) | (l[0] >>> 16))) |
                    0),
                  (f[3] = (l[3] + ((l[2] << 8) | (l[2] >>> 24)) + l[1]) | 0),
                  (f[4] =
                    (l[4] +
                      ((l[3] << 16) | (l[3] >>> 16)) +
                      ((l[2] << 16) | (l[2] >>> 16))) |
                    0),
                  (f[5] = (l[5] + ((l[4] << 8) | (l[4] >>> 24)) + l[3]) | 0),
                  (f[6] =
                    (l[6] +
                      ((l[5] << 16) | (l[5] >>> 16)) +
                      ((l[4] << 16) | (l[4] >>> 16))) |
                    0),
                  (f[7] = (l[7] + ((l[6] << 8) | (l[6] >>> 24)) + l[5]) | 0);
              }
              r.Rabbit = i._createHelper(u);
            })(),
            t.Rabbit
          );
        });
      })(L0)),
    L0.exports
  );
}
var $0 = { exports: {} },
  Bg;
function bR() {
  return (
    Bg ||
      ((Bg = 1),
      (function (n, e) {
        (function (t, r, a) {
          n.exports = r(Le(), lo(), uo(), Ki(), Qt());
        })(Ae, function (t) {
          return (
            (function () {
              var r = t,
                a = r.lib,
                i = a.StreamCipher,
                s = r.algo,
                o = [],
                c = [],
                l = [],
                u = (s.RabbitLegacy = i.extend({
                  _doReset: function () {
                    var f = this._key.words,
                      p = this.cfg.iv,
                      m = (this._X = [
                        f[0],
                        (f[3] << 16) | (f[2] >>> 16),
                        f[1],
                        (f[0] << 16) | (f[3] >>> 16),
                        f[2],
                        (f[1] << 16) | (f[0] >>> 16),
                        f[3],
                        (f[2] << 16) | (f[1] >>> 16),
                      ]),
                      y = (this._C = [
                        (f[2] << 16) | (f[2] >>> 16),
                        (f[0] & 4294901760) | (f[1] & 65535),
                        (f[3] << 16) | (f[3] >>> 16),
                        (f[1] & 4294901760) | (f[2] & 65535),
                        (f[0] << 16) | (f[0] >>> 16),
                        (f[2] & 4294901760) | (f[3] & 65535),
                        (f[1] << 16) | (f[1] >>> 16),
                        (f[3] & 4294901760) | (f[0] & 65535),
                      ]);
                    this._b = 0;
                    for (var h = 0; h < 4; h++) d.call(this);
                    for (var h = 0; h < 8; h++) y[h] ^= m[(h + 4) & 7];
                    if (p) {
                      var g = p.words,
                        v = g[0],
                        w = g[1],
                        T =
                          (((v << 8) | (v >>> 24)) & 16711935) |
                          (((v << 24) | (v >>> 8)) & 4278255360),
                        A =
                          (((w << 8) | (w >>> 24)) & 16711935) |
                          (((w << 24) | (w >>> 8)) & 4278255360),
                        E = (T >>> 16) | (A & 4294901760),
                        _ = (A << 16) | (T & 65535);
                      (y[0] ^= T),
                        (y[1] ^= E),
                        (y[2] ^= A),
                        (y[3] ^= _),
                        (y[4] ^= T),
                        (y[5] ^= E),
                        (y[6] ^= A),
                        (y[7] ^= _);
                      for (var h = 0; h < 4; h++) d.call(this);
                    }
                  },
                  _doProcessBlock: function (f, p) {
                    var m = this._X;
                    d.call(this),
                      (o[0] = m[0] ^ (m[5] >>> 16) ^ (m[3] << 16)),
                      (o[1] = m[2] ^ (m[7] >>> 16) ^ (m[5] << 16)),
                      (o[2] = m[4] ^ (m[1] >>> 16) ^ (m[7] << 16)),
                      (o[3] = m[6] ^ (m[3] >>> 16) ^ (m[1] << 16));
                    for (var y = 0; y < 4; y++)
                      (o[y] =
                        (((o[y] << 8) | (o[y] >>> 24)) & 16711935) |
                        (((o[y] << 24) | (o[y] >>> 8)) & 4278255360)),
                        (f[p + y] ^= o[y]);
                  },
                  blockSize: 128 / 32,
                  ivSize: 64 / 32,
                }));
              function d() {
                for (var f = this._X, p = this._C, m = 0; m < 8; m++)
                  c[m] = p[m];
                (p[0] = (p[0] + 1295307597 + this._b) | 0),
                  (p[1] =
                    (p[1] + 3545052371 + (p[0] >>> 0 < c[0] >>> 0 ? 1 : 0)) |
                    0),
                  (p[2] =
                    (p[2] + 886263092 + (p[1] >>> 0 < c[1] >>> 0 ? 1 : 0)) | 0),
                  (p[3] =
                    (p[3] + 1295307597 + (p[2] >>> 0 < c[2] >>> 0 ? 1 : 0)) |
                    0),
                  (p[4] =
                    (p[4] + 3545052371 + (p[3] >>> 0 < c[3] >>> 0 ? 1 : 0)) |
                    0),
                  (p[5] =
                    (p[5] + 886263092 + (p[4] >>> 0 < c[4] >>> 0 ? 1 : 0)) | 0),
                  (p[6] =
                    (p[6] + 1295307597 + (p[5] >>> 0 < c[5] >>> 0 ? 1 : 0)) |
                    0),
                  (p[7] =
                    (p[7] + 3545052371 + (p[6] >>> 0 < c[6] >>> 0 ? 1 : 0)) |
                    0),
                  (this._b = p[7] >>> 0 < c[7] >>> 0 ? 1 : 0);
                for (var m = 0; m < 8; m++) {
                  var y = f[m] + p[m],
                    h = y & 65535,
                    g = y >>> 16,
                    v = ((((h * h) >>> 17) + h * g) >>> 15) + g * g,
                    w = (((y & 4294901760) * y) | 0) + (((y & 65535) * y) | 0);
                  l[m] = v ^ w;
                }
                (f[0] =
                  (l[0] +
                    ((l[7] << 16) | (l[7] >>> 16)) +
                    ((l[6] << 16) | (l[6] >>> 16))) |
                  0),
                  (f[1] = (l[1] + ((l[0] << 8) | (l[0] >>> 24)) + l[7]) | 0),
                  (f[2] =
                    (l[2] +
                      ((l[1] << 16) | (l[1] >>> 16)) +
                      ((l[0] << 16) | (l[0] >>> 16))) |
                    0),
                  (f[3] = (l[3] + ((l[2] << 8) | (l[2] >>> 24)) + l[1]) | 0),
                  (f[4] =
                    (l[4] +
                      ((l[3] << 16) | (l[3] >>> 16)) +
                      ((l[2] << 16) | (l[2] >>> 16))) |
                    0),
                  (f[5] = (l[5] + ((l[4] << 8) | (l[4] >>> 24)) + l[3]) | 0),
                  (f[6] =
                    (l[6] +
                      ((l[5] << 16) | (l[5] >>> 16)) +
                      ((l[4] << 16) | (l[4] >>> 16))) |
                    0),
                  (f[7] = (l[7] + ((l[6] << 8) | (l[6] >>> 24)) + l[5]) | 0);
              }
              r.RabbitLegacy = i._createHelper(u);
            })(),
            t.RabbitLegacy
          );
        });
      })($0)),
    $0.exports
  );
}
(function (n, e) {
  (function (t, r, a) {
    n.exports = r(
      Le(),
      tf(),
      YI(),
      JI(),
      lo(),
      uo(),
      im(),
      ef,
      XI(),
      A6(),
      ZI(),
      eR(),
      tR(),
      sm(),
      nR(),
      Ki(),
      Qt(),
      rR(),
      aR(),
      iR(),
      sR(),
      oR(),
      cR(),
      lR(),
      uR(),
      dR(),
      fR(),
      pR(),
      hR(),
      mR(),
      yR(),
      gR(),
      bR(),
    );
  })(Ae, function (t) {
    return t;
  });
})(C6);
var xR = C6.exports,
  vR =
    (Ae && Ae.__importDefault) ||
    function (n) {
      return n && n.__esModule ? n : { default: n };
    };
Object.defineProperty(co, "__esModule", { value: !0 });
co.Base = void 0;
const zn = Gc,
  W0 = vR(xR);
class Ma {
  print() {
    Ma.print(this);
  }
  _bufferIndexOf(e, t) {
    for (let r = 0; r < e.length; r++) if (t.equals(e[r])) return r;
    return -1;
  }
  static bufferify(e) {
    if (!zn.Buffer.isBuffer(e)) {
      if (typeof e == "object" && e.words)
        return zn.Buffer.from(e.toString(W0.default.enc.Hex), "hex");
      if (Ma.isHexString(e)) return zn.Buffer.from(e.replace(/^0x/, ""), "hex");
      if (typeof e == "string") return zn.Buffer.from(e);
      if (typeof e == "number") {
        let t = e.toString();
        return t.length % 2 && (t = `0${t}`), zn.Buffer.from(t, "hex");
      } else if (ArrayBuffer.isView(e))
        return zn.Buffer.from(e.buffer, e.byteOffset, e.byteLength);
    }
    return e;
  }
  static isHexString(e) {
    return typeof e == "string" && /^(0x)?[0-9A-Fa-f]*$/.test(e);
  }
  static print(e) {
    console.log(e.toString());
  }
  bufferToHex(e, t = !0) {
    return Ma.bufferToHex(e, t);
  }
  static bufferToHex(e, t = !0) {
    return `${t ? "0x" : ""}${(e || zn.Buffer.alloc(0)).toString("hex")}`;
  }
  bufferify(e) {
    return Ma.bufferify(e);
  }
  bufferifyFn(e) {
    return (t) => {
      const r = e(t);
      return zn.Buffer.isBuffer(r)
        ? r
        : this._isHexString(r)
        ? zn.Buffer.from(r.replace("0x", ""), "hex")
        : typeof r == "string"
        ? zn.Buffer.from(r)
        : ArrayBuffer.isView(r)
        ? zn.Buffer.from(r.buffer, r.byteOffset, r.byteLength)
        : zn.Buffer.from(
            e(W0.default.enc.Hex.parse(t.toString("hex"))).toString(
              W0.default.enc.Hex,
            ),
            "hex",
          );
    };
  }
  _isHexString(e) {
    return Ma.isHexString(e);
  }
  _log2(e) {
    return e === 1 ? 0 : 1 + this._log2((e / 2) | 0);
  }
  _zip(e, t) {
    return e.map((r, a) => [r, t[a]]);
  }
}
co.Base = Ma;
co.default = Ma;
var nf =
  (Ae && Ae.__importDefault) ||
  function (n) {
    return n && n.__esModule ? n : { default: n };
  };
Object.defineProperty(Vc, "__esModule", { value: !0 });
Vc.MerkleTree = void 0;
const Ze = Gc,
  Yr = nf(KI),
  Dg = nf(ef),
  wR = nf(QI),
  TR = nf(co);
class Qn extends TR.default {
  constructor(e, t = Dg.default, r = {}) {
    if (
      (super(),
      (this.duplicateOdd = !1),
      (this.hashLeaves = !1),
      (this.isBitcoinTree = !1),
      (this.leaves = []),
      (this.layers = []),
      (this.sortLeaves = !1),
      (this.sortPairs = !1),
      (this.sort = !1),
      (this.fillDefaultHash = null),
      (this.isBitcoinTree = !!r.isBitcoinTree),
      (this.hashLeaves = !!r.hashLeaves),
      (this.sortLeaves = !!r.sortLeaves),
      (this.sortPairs = !!r.sortPairs),
      r.fillDefaultHash)
    )
      if (typeof r.fillDefaultHash == "function")
        this.fillDefaultHash = r.fillDefaultHash;
      else if (
        Ze.Buffer.isBuffer(r.fillDefaultHash) ||
        typeof r.fillDefaultHash == "string"
      )
        this.fillDefaultHash = (a, i) => r.fillDefaultHash;
      else
        throw new Error(
          'method "fillDefaultHash" must be a function, Buffer, or string',
        );
    (this.sort = !!r.sort),
      this.sort && ((this.sortLeaves = !0), (this.sortPairs = !0)),
      (this.duplicateOdd = !!r.duplicateOdd),
      (this.hashFn = this.bufferifyFn(t)),
      this.processLeaves(e);
  }
  processLeaves(e) {
    if (
      (this.hashLeaves && (e = e.map(this.hashFn)),
      (this.leaves = e.map(this.bufferify)),
      this.sortLeaves && (this.leaves = this.leaves.sort(Ze.Buffer.compare)),
      this.fillDefaultHash)
    )
      for (
        let t = 0;
        t < Math.pow(2, Math.ceil(Math.log2(this.leaves.length)));
        t++
      )
        t >= this.leaves.length &&
          this.leaves.push(
            this.bufferify(this.fillDefaultHash(t, this.hashFn)),
          );
    (this.layers = [this.leaves]), this._createHashes(this.leaves);
  }
  _createHashes(e) {
    for (; e.length > 1; ) {
      const t = this.layers.length;
      this.layers.push([]);
      for (let r = 0; r < e.length; r += 2) {
        if (r + 1 === e.length && e.length % 2 === 1) {
          let l = e[e.length - 1],
            u = l;
          if (this.isBitcoinTree) {
            (l = Ze.Buffer.concat([Yr.default(l), Yr.default(l)])),
              (u = this.hashFn(l)),
              (u = Yr.default(this.hashFn(u))),
              this.layers[t].push(u);
            continue;
          } else if (!this.duplicateOdd) {
            this.layers[t].push(e[r]);
            continue;
          }
        }
        const a = e[r],
          i = r + 1 === e.length ? a : e[r + 1];
        let s = null,
          o = null;
        this.isBitcoinTree
          ? (o = [Yr.default(a), Yr.default(i)])
          : (o = [a, i]),
          this.sortPairs && o.sort(Ze.Buffer.compare),
          (s = Ze.Buffer.concat(o));
        let c = this.hashFn(s);
        this.isBitcoinTree && (c = Yr.default(this.hashFn(c))),
          this.layers[t].push(c);
      }
      e = this.layers[t];
    }
  }
  addLeaf(e, t = !1) {
    t && (e = this.hashFn(e)), this.processLeaves(this.leaves.concat(e));
  }
  addLeaves(e, t = !1) {
    t && (e = e.map(this.hashFn)), this.processLeaves(this.leaves.concat(e));
  }
  getLeaves(e) {
    return Array.isArray(e)
      ? (this.hashLeaves &&
          ((e = e.map(this.hashFn)),
          this.sortLeaves && (e = e.sort(Ze.Buffer.compare))),
        this.leaves.filter((t) => this._bufferIndexOf(e, t) !== -1))
      : this.leaves;
  }
  getLeaf(e) {
    return e < 0 || e > this.leaves.length - 1
      ? Ze.Buffer.from([])
      : this.leaves[e];
  }
  getLeafIndex(e) {
    e = this.bufferify(e);
    const t = this.getLeaves();
    for (let r = 0; r < t.length; r++) if (t[r].equals(e)) return r;
    return -1;
  }
  getLeafCount() {
    return this.leaves.length;
  }
  getHexLeaves() {
    return this.leaves.map((e) => this.bufferToHex(e));
  }
  static marshalLeaves(e) {
    return JSON.stringify(
      e.map((t) => Qn.bufferToHex(t)),
      null,
      2,
    );
  }
  static unmarshalLeaves(e) {
    let t = null;
    if (typeof e == "string") t = JSON.parse(e);
    else if (e instanceof Object) t = e;
    else throw new Error("Expected type of string or object");
    if (!t) return [];
    if (!Array.isArray(t)) throw new Error("Expected JSON string to be array");
    return t.map(Qn.bufferify);
  }
  getLayers() {
    return this.layers;
  }
  getHexLayers() {
    return this.layers.reduce(
      (e, t) => (
        Array.isArray(t)
          ? e.push(t.map((r) => this.bufferToHex(r)))
          : e.push(t),
        e
      ),
      [],
    );
  }
  getLayersFlat() {
    const e = this.layers.reduce(
      (t, r) => (Array.isArray(r) ? t.unshift(...r) : t.unshift(r), t),
      [],
    );
    return e.unshift(Ze.Buffer.from([0])), e;
  }
  getHexLayersFlat() {
    return this.getLayersFlat().map((e) => this.bufferToHex(e));
  }
  getLayerCount() {
    return this.getLayers().length;
  }
  getRoot() {
    return this.layers.length === 0
      ? Ze.Buffer.from([])
      : this.layers[this.layers.length - 1][0] || Ze.Buffer.from([]);
  }
  getHexRoot() {
    return this.bufferToHex(this.getRoot());
  }
  getProof(e, t) {
    if (typeof e > "u") throw new Error("leaf is required");
    e = this.bufferify(e);
    const r = [];
    if (!Number.isInteger(t)) {
      t = -1;
      for (let a = 0; a < this.leaves.length; a++)
        Ze.Buffer.compare(e, this.leaves[a]) === 0 && (t = a);
    }
    if (t <= -1) return [];
    for (let a = 0; a < this.layers.length; a++) {
      const i = this.layers[a],
        s = t % 2,
        o = s
          ? t - 1
          : this.isBitcoinTree &&
            t === i.length - 1 &&
            a < this.layers.length - 1
          ? t
          : t + 1;
      o < i.length && r.push({ position: s ? "left" : "right", data: i[o] }),
        (t = (t / 2) | 0);
    }
    return r;
  }
  getHexProof(e, t) {
    return this.getProof(e, t).map((r) => this.bufferToHex(r.data));
  }
  getPositionalHexProof(e, t) {
    return this.getProof(e, t).map((r) => [
      r.position === "left" ? 0 : 1,
      this.bufferToHex(r.data),
    ]);
  }
  static marshalProof(e) {
    const t = e.map((r) =>
      typeof r == "string"
        ? r
        : Ze.Buffer.isBuffer(r)
        ? Qn.bufferToHex(r)
        : { position: r.position, data: Qn.bufferToHex(r.data) },
    );
    return JSON.stringify(t, null, 2);
  }
  static unmarshalProof(e) {
    let t = null;
    if (typeof e == "string") t = JSON.parse(e);
    else if (e instanceof Object) t = e;
    else throw new Error("Expected type of string or object");
    if (!t) return [];
    if (!Array.isArray(t)) throw new Error("Expected JSON string to be array");
    return t.map((r) => {
      if (typeof r == "string") return Qn.bufferify(r);
      if (r instanceof Object)
        return { position: r.position, data: Qn.bufferify(r.data) };
      throw new Error("Expected item to be of type string or object");
    });
  }
  getProofIndices(e, t) {
    const r = Math.pow(2, t);
    let a = new Set();
    for (const l of e) {
      let u = r + l;
      for (; u > 1; ) a.add(u ^ 1), (u = (u / 2) | 0);
    }
    const i = e.map((l) => r + l),
      s = Array.from(a)
        .sort((l, u) => l - u)
        .reverse();
    a = i.concat(s);
    const o = new Set(),
      c = [];
    for (let l of a)
      if (!o.has(l))
        for (c.push(l); l > 1 && (o.add(l), !!o.has(l ^ 1)); ) l = (l / 2) | 0;
    return c.filter((l) => !e.includes(l - r));
  }
  getProofIndicesForUnevenTree(e, t) {
    const r = Math.ceil(Math.log2(t)),
      a = [];
    for (let o = 0; o < r; o++)
      t % 2 !== 0 && a.push({ index: o, leavesCount: t }),
        (t = Math.ceil(t / 2));
    const i = [];
    let s = e;
    for (let o = 0; o < r; o++) {
      let l = s
        .map((d) => (d % 2 === 0 ? d + 1 : d - 1))
        .filter((d) => !s.includes(d));
      const u = a.find(({ index: d }) => d === o);
      u && s.includes(u.leavesCount - 1) && (l = l.slice(0, -1)),
        i.push(l),
        (s = [
          ...new Set(
            s.map((d) =>
              d % 2 === 0 ? d / 2 : d % 2 === 0 ? (d + 1) / 2 : (d - 1) / 2,
            ),
          ),
        ]);
    }
    return i;
  }
  getMultiProof(e, t) {
    if (
      (t || ((t = e), (e = this.getLayersFlat())),
      this.isUnevenTree() && t.every(Number.isInteger))
    )
      return this.getMultiProofForUnevenTree(t);
    if (!t.every(Number.isInteger)) {
      let a = t;
      this.sortPairs && (a = a.sort(Ze.Buffer.compare));
      let i = a
        .map((l) => this._bufferIndexOf(this.leaves, l))
        .sort((l, u) => (l === u ? 0 : l > u ? 1 : -1));
      if (!i.every((l) => l !== -1))
        throw new Error("Element does not exist in Merkle tree");
      const s = [],
        o = [];
      let c = [];
      for (let l = 0; l < this.layers.length; l++) {
        const u = this.layers[l];
        for (let d = 0; d < i.length; d++) {
          const f = i[d],
            p = this._getPairNode(u, f);
          s.push(u[f]), p && o.push(p), c.push((f / 2) | 0);
        }
        (i = c.filter((d, f, p) => p.indexOf(d) === f)), (c = []);
      }
      return o.filter((l) => !s.includes(l));
    }
    return this.getProofIndices(t, this._log2((e.length / 2) | 0)).map(
      (a) => e[a],
    );
  }
  getMultiProofForUnevenTree(e, t) {
    t || ((t = e), (e = this.getLayers()));
    let r = [],
      a = t;
    for (const i of e) {
      const s = [];
      for (const c of a) {
        if (c % 2 === 0) {
          const u = c + 1;
          if (!a.includes(u) && i[u]) {
            s.push(i[u]);
            continue;
          }
        }
        const l = c - 1;
        if (!a.includes(l) && i[l]) {
          s.push(i[l]);
          continue;
        }
      }
      r = r.concat(s);
      const o = new Set();
      for (const c of a) {
        if (c % 2 === 0) {
          o.add(c / 2);
          continue;
        }
        if (c % 2 === 0) {
          o.add((c + 1) / 2);
          continue;
        }
        o.add((c - 1) / 2);
      }
      a = Array.from(o);
    }
    return r;
  }
  getHexMultiProof(e, t) {
    return this.getMultiProof(e, t).map((r) => this.bufferToHex(r));
  }
  getProofFlags(e, t) {
    if (!Array.isArray(e) || e.length <= 0) throw new Error("Invalid Inputs!");
    let r;
    if (
      (e.every(Number.isInteger)
        ? (r = e.sort((o, c) => (o === c ? 0 : o > c ? 1 : -1)))
        : (r = e
            .map((o) => this._bufferIndexOf(this.leaves, o))
            .sort((o, c) => (o === c ? 0 : o > c ? 1 : -1))),
      !r.every((o) => o !== -1))
    )
      throw new Error("Element does not exist in Merkle tree");
    const a = t.map((o) => this.bufferify(o)),
      i = [],
      s = [];
    for (let o = 0; o < this.layers.length; o++) {
      const c = this.layers[o];
      r = r.reduce((l, u) => {
        if (!i.includes(c[u])) {
          const f = this._getPairNode(c, u),
            p = a.includes(c[u]) || a.includes(f);
          f && s.push(!p), i.push(c[u]), i.push(f);
        }
        return l.push((u / 2) | 0), l;
      }, []);
    }
    return s;
  }
  verify(e, t, r) {
    let a = this.bufferify(t);
    if (((r = this.bufferify(r)), !Array.isArray(e) || !t || !r)) return !1;
    for (let i = 0; i < e.length; i++) {
      const s = e[i];
      let o = null,
        c = null;
      if (typeof s == "string") (o = this.bufferify(s)), (c = !0);
      else if (Array.isArray(s)) (c = s[0] === 0), (o = this.bufferify(s[1]));
      else if (Ze.Buffer.isBuffer(s)) (o = s), (c = !0);
      else if (s instanceof Object)
        (o = this.bufferify(s.data)), (c = s.position === "left");
      else throw new Error("Expected node to be of type string or object");
      const l = [];
      this.isBitcoinTree
        ? (l.push(Yr.default(a)),
          l[c ? "unshift" : "push"](Yr.default(o)),
          (a = this.hashFn(Ze.Buffer.concat(l))),
          (a = Yr.default(this.hashFn(a))))
        : this.sortPairs
        ? Ze.Buffer.compare(a, o) === -1
          ? (l.push(a, o), (a = this.hashFn(Ze.Buffer.concat(l))))
          : (l.push(o, a), (a = this.hashFn(Ze.Buffer.concat(l))))
        : (l.push(a),
          l[c ? "unshift" : "push"](o),
          (a = this.hashFn(Ze.Buffer.concat(l))));
    }
    return Ze.Buffer.compare(a, r) === 0;
  }
  verifyMultiProof(e, t, r, a, i) {
    if (this.isUnevenTree())
      return this.verifyMultiProofForUnevenTree(e, t, r, a, i);
    const o = Math.ceil(Math.log2(a));
    (e = this.bufferify(e)),
      (r = r.map((d) => this.bufferify(d))),
      (i = i.map((d) => this.bufferify(d)));
    const c = {};
    for (const [d, f] of this._zip(t, r)) c[Math.pow(2, o) + d] = f;
    for (const [d, f] of this._zip(this.getProofIndices(t, o), i)) c[d] = f;
    let l = Object.keys(c)
      .map((d) => +d)
      .sort((d, f) => d - f);
    l = l.slice(0, l.length - 1);
    let u = 0;
    for (; u < l.length; ) {
      const d = l[u];
      if (d >= 2 && {}.hasOwnProperty.call(c, d ^ 1)) {
        let f = [c[d - (d % 2)], c[d - (d % 2) + 1]];
        this.sortPairs && (f = f.sort(Ze.Buffer.compare));
        const p = f[1] ? this.hashFn(Ze.Buffer.concat(f)) : f[0];
        (c[(d / 2) | 0] = p), l.push((d / 2) | 0);
      }
      u += 1;
    }
    return !t.length || ({}.hasOwnProperty.call(c, 1) && c[1].equals(e));
  }
  verifyMultiProofWithFlags(e, t, r, a) {
    (e = this.bufferify(e)),
      (t = t.map(this.bufferify)),
      (r = r.map(this.bufferify));
    const i = t.length,
      s = a.length,
      o = [];
    let c = 0,
      l = 0,
      u = 0;
    for (let d = 0; d < s; d++) {
      const f = a[d] ? (c < i ? t[c++] : o[l++]) : r[u++],
        p = c < i ? t[c++] : o[l++],
        m = [f, p].sort(Ze.Buffer.compare);
      o[d] = this.hashFn(Ze.Buffer.concat(m));
    }
    return Ze.Buffer.compare(o[s - 1], e) === 0;
  }
  verifyMultiProofForUnevenTree(e, t, r, a, i) {
    (e = this.bufferify(e)),
      (r = r.map((o) => this.bufferify(o))),
      (i = i.map((o) => this.bufferify(o)));
    const s = this.calculateRootForUnevenTree(t, r, a, i);
    return e.equals(s);
  }
  getDepth() {
    return this.getLayers().length - 1;
  }
  getLayersAsObject() {
    const e = this.getLayers().map((r) =>
        r.map((a) => this.bufferToHex(a, !1)),
      ),
      t = [];
    for (let r = 0; r < e.length; r++) {
      const a = [];
      for (let i = 0; i < e[r].length; i++) {
        const s = { [e[r][i]]: null };
        if (t.length) {
          s[e[r][i]] = {};
          const o = t.shift(),
            c = Object.keys(o)[0];
          if (((s[e[r][i]][c] = o[c]), t.length)) {
            const l = t.shift(),
              u = Object.keys(l)[0];
            s[e[r][i]][u] = l[u];
          }
        }
        a.push(s);
      }
      t.push(...a);
    }
    return t[0];
  }
  static verify(e, t, r, a = Dg.default, i = {}) {
    return new Qn([], a, i).verify(e, t, r);
  }
  static getMultiProof(e, t) {
    return new Qn([]).getMultiProof(e, t);
  }
  resetTree() {
    (this.leaves = []), (this.layers = []);
  }
  _getPairNode(e, t) {
    const r = t % 2 === 0 ? t + 1 : t - 1;
    return r < e.length ? e[r] : null;
  }
  _toTreeString() {
    const e = this.getLayersAsObject();
    return wR.default.asTree(e, !0);
  }
  toString() {
    return this._toTreeString();
  }
  isUnevenTree(e) {
    const t = (e == null ? void 0 : e.length) || this.getDepth();
    return !this.isPowOf2(t);
  }
  isPowOf2(e) {
    return e && !(e & (e - 1));
  }
  calculateRootForUnevenTree(e, t, r, a) {
    const i = this._zip(e, t).sort(([d], [f]) => d - f),
      s = i.map(([d]) => d),
      o = this.getProofIndicesForUnevenTree(s, r);
    let c = 0;
    const l = [];
    for (let d = 0; d < o.length; d++) {
      const f = o[d],
        p = c;
      (c += f.length), (l[d] = this._zip(f, a.slice(p, c)));
    }
    const u = [i];
    for (let d = 0; d < l.length; d++) {
      const f = l[d]
          .concat(u[d])
          .sort(([h], [g]) => h - g)
          .map(([, h]) => h),
        p = u[d].map(([h]) => h),
        m = [
          ...new Set(
            p.map((h) =>
              h % 2 === 0 ? h / 2 : h % 2 === 0 ? (h + 1) / 2 : (h - 1) / 2,
            ),
          ),
        ],
        y = [];
      for (let h = 0; h < m.length; h++) {
        const g = m[h],
          v = f[h * 2],
          w = f[h * 2 + 1],
          T = w ? this.hashFn(Ze.Buffer.concat([v, w])) : v;
        y.push([g, T]);
      }
      u.push(y);
    }
    return u[u.length - 1][0][1];
  }
}
Vc.MerkleTree = Qn;
typeof window < "u" && (window.MerkleTree = Qn);
Vc.default = Qn;
var Kc = {},
  E6 =
    (Ae && Ae.__importDefault) ||
    function (n) {
      return n && n.__esModule ? n : { default: n };
    };
Object.defineProperty(Kc, "__esModule", { value: !0 });
Kc.MerkleMountainRange = void 0;
const Bo = Gc,
  CR = E6(ef),
  AR = E6(co);
class k6 extends AR.default {
  constructor(e = CR.default, t = [], r, a, i) {
    super(),
      (this.root = Bo.Buffer.alloc(0)),
      (this.size = 0),
      (this.width = 0),
      (this.hashes = {}),
      (this.data = {}),
      (t = t.map(this.bufferify)),
      (this.hashFn = this.bufferifyFn(e)),
      (this.hashLeafFn = r),
      (this.peakBaggingFn = a),
      (this.hashBranchFn = i);
    for (const s of t) this.append(s);
  }
  append(e) {
    e = this.bufferify(e);
    const t = this.hashFn(e),
      r = this.bufferToHex(t);
    (!this.data[r] || this.bufferToHex(this.hashFn(this.data[r])) !== r) &&
      (this.data[r] = e);
    const a = this.hashLeaf(this.size + 1, t);
    (this.hashes[this.size + 1] = a), (this.width += 1);
    const i = this.getPeakIndexes(this.width);
    this.size = this.getSize(this.width);
    const s = [];
    for (let o = 0; o < i.length; o++) s[o] = this._getOrCreateNode(i[o]);
    this.root = this.peakBagging(this.width, s);
  }
  hashLeaf(e, t) {
    return (
      (t = this.bufferify(t)),
      this.hashLeafFn
        ? this.bufferify(this.hashLeafFn(e, t))
        : this.hashFn(Bo.Buffer.concat([this.bufferify(e), t]))
    );
  }
  hashBranch(e, t, r) {
    return this.hashBranchFn
      ? this.bufferify(this.hashBranchFn(e, t, r))
      : this.hashFn(
          Bo.Buffer.concat([
            this.bufferify(e),
            this.bufferify(t),
            this.bufferify(r),
          ]),
        );
  }
  getPeaks() {
    const e = this.getPeakIndexes(this.width),
      t = [];
    for (let r = 0; r < e.length; r++) t[r] = this.hashes[e[r]];
    return t;
  }
  getLeafIndex(e) {
    return e % 2 === 1 ? this.getSize(e) : this.getSize(e - 1) + 1;
  }
  getPeakIndexes(e) {
    const t = this.numOfPeaks(e),
      r = [];
    let a = 0,
      i = 0;
    for (
      let s = 255;
      s > 0 &&
      !(
        e & (1 << (s - 1)) &&
        ((i = i + (1 << s) - 1), (r[a++] = i), r.length >= t)
      );
      s--
    );
    if (a !== r.length) throw new Error("invalid bit calculation");
    return r;
  }
  numOfPeaks(e) {
    let t = e,
      r = 0;
    for (; t > 0; ) t % 2 === 1 && r++, (t = t >> 1);
    return r;
  }
  peakBagging(e, t) {
    const r = this.getSize(e);
    if (this.numOfPeaks(e) !== t.length)
      throw new Error("received invalid number of peaks");
    return e === 0 && !t.length
      ? Bo.Buffer.alloc(0)
      : this.peakBaggingFn
      ? this.bufferify(this.peakBaggingFn(r, t))
      : this.hashFn(
          Bo.Buffer.concat([this.bufferify(r), ...t.map(this.bufferify)]),
        );
  }
  getSize(e) {
    return (e << 1) - this.numOfPeaks(e);
  }
  getRoot() {
    return this.root;
  }
  getHexRoot() {
    return this.bufferToHex(this.getRoot());
  }
  getNode(e) {
    return this.hashes[e];
  }
  mountainHeight(e) {
    let t = 1;
    for (; 1 << t <= e + t; ) t++;
    return t - 1;
  }
  heightAt(e) {
    let t = e,
      r = 0,
      a = 0;
    for (; t > r; )
      (t -= (1 << a) - 1), (a = this.mountainHeight(t)), (r = (1 << a) - 1);
    return a - (r - t);
  }
  isLeaf(e) {
    return this.heightAt(e) === 1;
  }
  getChildren(e) {
    const t = e - (1 << (this.heightAt(e) - 1)),
      r = e - 1;
    if (t === r) throw new Error("not a parent");
    return [t, r];
  }
  getMerkleProof(e) {
    if (e > this.size) throw new Error("out of range");
    if (!this.isLeaf(e)) throw new Error("not a leaf");
    const t = this.root,
      r = this.width,
      a = this.getPeakIndexes(this.width),
      i = [];
    let s = 0;
    for (let d = 0; d < a.length; d++)
      (i[d] = this.hashes[a[d]]), a[d] >= e && s === 0 && (s = a[d]);
    let o = 0,
      c = 0,
      l = this.heightAt(s);
    const u = [];
    for (; s !== e; )
      l--,
        ([o, c] = this.getChildren(s)),
        (s = e <= o ? o : c),
        (u[l - 1] = this.hashes[e <= o ? c : o]);
    return { root: t, width: r, peakBagging: i, siblings: u };
  }
  verify(e, t, r, a, i, s) {
    if (((a = this.bufferify(a)), this.getSize(t) < r))
      throw new Error("index is out of range");
    if (!e.equals(this.peakBagging(t, i)))
      throw new Error("invalid root hash from the peaks");
    let c = 0,
      l;
    const u = this.getPeakIndexes(t);
    for (let h = 0; h < u.length; h++)
      if (u[h] >= r) {
        (l = i[h]), (c = u[h]);
        break;
      }
    if (!l) throw new Error("target not found");
    let d = s.length + 1;
    const f = new Array(d);
    let p = 0,
      m = 0;
    for (; d > 0 && ((f[--d] = c), c !== r); )
      ([p, m] = this.getChildren(c)), (c = r > p ? m : p);
    let y;
    for (; d < f.length; )
      (c = f[d]),
        d === 0
          ? (y = this.hashLeaf(c, this.hashFn(a)))
          : c - 1 === f[d - 1]
          ? (y = this.hashBranch(c, s[d - 1], y))
          : (y = this.hashBranch(c, y, s[d - 1])),
        d++;
    if (!y.equals(l)) throw new Error("hashed peak is invalid");
    return !0;
  }
  peaksToPeakMap(e, t) {
    const r = {};
    let a = 0,
      i = 0,
      s = t.length;
    for (let o = 1; o <= 32; o++)
      (a = 32 - o), (i = 1 << (o - 1)), e & i ? (r[a] = t[--s]) : (r[a] = 0);
    if (s !== 0) throw new Error("invalid number of peaks");
    return r;
  }
  peakMapToPeaks(e, t) {
    const r = this.numOfPeaks(e),
      a = new Array(r);
    let i = 0;
    for (let s = 0; s < 32; s++) t[s] !== 0 && (a[i++] = t[s]);
    if (i !== r) throw new Error("invalid number of peaks");
    return a;
  }
  peakUpdate(e, t, r) {
    const a = {},
      i = e + 1;
    let s = this.getLeafIndex(i),
      o = this.hashLeaf(s, r),
      c = 0,
      l = 0,
      u = !1,
      d = !1,
      f = !1;
    for (let p = 1; p <= 32; p++)
      (c = 32 - p),
        f
          ? (a[c] = t[c])
          : ((l = 1 << (p - 1)),
            (u = (e & l) !== 0),
            (d = (i & l) !== 0),
            s++,
            u && (o = this.hashBranch(s, t[c], o)),
            d ? (u ? (a[c] = t[c]) : (a[c] = o), (f = !0)) : (a[c] = 0));
    return a;
  }
  rollUp(e, t, r, a) {
    if (!e.equals(this.peakBagging(t, r)))
      throw new Error("invalid root hash from the peaks");
    let i = t,
      s = this.peaksToPeakMap(t, r);
    for (let o = 0; o < a.length; o++) (s = this.peakUpdate(i, s, a[o])), i++;
    return this.peakBagging(i, this.peakMapToPeaks(i, s));
  }
  _getOrCreateNode(e) {
    if (e > this.size) throw new Error("out of range");
    if (!this.hashes[e]) {
      const [t, r] = this.getChildren(e),
        a = this._getOrCreateNode(t),
        i = this._getOrCreateNode(r);
      this.hashes[e] = this.hashBranch(e, a, i);
    }
    return this.hashes[e];
  }
}
Kc.MerkleMountainRange = k6;
Kc.default = k6;
(function (n) {
  var e =
    (Ae && Ae.__importDefault) ||
    function (a) {
      return a && a.__esModule ? a : { default: a };
    };
  Object.defineProperty(n, "__esModule", { value: !0 }),
    (n.MerkleTree = void 0);
  const t = e(Vc);
  n.MerkleTree = t.default;
  var r = Kc;
  Object.defineProperty(n, "MerkleMountainRange", {
    enumerable: !0,
    get: function () {
      return r.MerkleMountainRange;
    },
  }),
    (n.default = t.default);
})(Kl);
const mn = [
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      {
        indexed: !0,
        internalType: "address",
        name: "spender",
        type: "address",
      },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
    ],
    name: "Approval",
    type: "event",
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "from", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
    ],
    name: "Transfer",
    type: "event",
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [{ internalType: "address", name: "who", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function",
  },
];
var ER = function n(e, t) {
  if (e === t) return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor) return !1;
    var r, a, i;
    if (Array.isArray(e)) {
      if (((r = e.length), r != t.length)) return !1;
      for (a = r; a-- !== 0; ) if (!n(e[a], t[a])) return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (((i = Object.keys(e)), (r = i.length), r !== Object.keys(t).length))
      return !1;
    for (a = r; a-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, i[a])) return !1;
    for (a = r; a-- !== 0; ) {
      var s = i[a];
      if (!n(e[s], t[s])) return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
};
const _6 = ir(ER);
let Cl;
const kR = new Uint8Array(16);
function _R() {
  if (
    !Cl &&
    ((Cl =
      typeof crypto < "u" &&
      crypto.getRandomValues &&
      crypto.getRandomValues.bind(crypto)),
    !Cl)
  )
    throw new Error(
      "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported",
    );
  return Cl(kR);
}
const Ft = [];
for (let n = 0; n < 256; ++n) Ft.push((n + 256).toString(16).slice(1));
function SR(n, e = 0) {
  return (
    Ft[n[e + 0]] +
    Ft[n[e + 1]] +
    Ft[n[e + 2]] +
    Ft[n[e + 3]] +
    "-" +
    Ft[n[e + 4]] +
    Ft[n[e + 5]] +
    "-" +
    Ft[n[e + 6]] +
    Ft[n[e + 7]] +
    "-" +
    Ft[n[e + 8]] +
    Ft[n[e + 9]] +
    "-" +
    Ft[n[e + 10]] +
    Ft[n[e + 11]] +
    Ft[n[e + 12]] +
    Ft[n[e + 13]] +
    Ft[n[e + 14]] +
    Ft[n[e + 15]]
  ).toLowerCase();
}
const PR =
    typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  Og = { randomUUID: PR };
function IR(n, e, t) {
  if (Og.randomUUID && !e && !n) return Og.randomUUID();
  n = n || {};
  const r = n.random || (n.rng || _R)();
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), e)) {
    t = t || 0;
    for (let a = 0; a < 16; ++a) e[t + a] = r[a];
    return e;
  }
  return SR(r);
}
const rf = [
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  RR = [
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "_tokenId", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  MR = [
    {
      inputs: [{ internalType: "uint256", name: "_id", type: "uint256" }],
      name: "uri",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  BR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "index",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "revealedURI",
          type: "string",
        },
      ],
      name: "TokenURIRevealed",
      type: "event",
    },
    {
      inputs: [
        { internalType: "bytes", name: "data", type: "bytes" },
        { internalType: "bytes", name: "key", type: "bytes" },
      ],
      name: "encryptDecrypt",
      outputs: [{ internalType: "bytes", name: "result", type: "bytes" }],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "identifier", type: "uint256" },
      ],
      name: "encryptedBaseURI",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "identifier", type: "uint256" },
        { internalType: "bytes", name: "key", type: "bytes" },
      ],
      name: "reveal",
      outputs: [
        { internalType: "string", name: "revealedURI", type: "string" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  S6 = [
    {
      inputs: [],
      name: "contractType",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [],
      name: "contractURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "contractVersion",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [{ internalType: "string", name: "_uri", type: "string" }],
      name: "setContractURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Pt = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "_approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  yn = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "_owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "_operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "_approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "_operator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "_from",
          type: "address",
        },
        { indexed: !0, internalType: "address", name: "_to", type: "address" },
        {
          indexed: !1,
          internalType: "uint256[]",
          name: "_ids",
          type: "uint256[]",
        },
        {
          indexed: !1,
          internalType: "uint256[]",
          name: "_values",
          type: "uint256[]",
        },
      ],
      name: "TransferBatch",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "_operator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "_from",
          type: "address",
        },
        { indexed: !0, internalType: "address", name: "_to", type: "address" },
        { indexed: !1, internalType: "uint256", name: "_id", type: "uint256" },
        {
          indexed: !1,
          internalType: "uint256",
          name: "_value",
          type: "uint256",
        },
      ],
      name: "TransferSingle",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, internalType: "string", name: "_value", type: "string" },
        { indexed: !0, internalType: "uint256", name: "_id", type: "uint256" },
      ],
      name: "URI",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "_owner", type: "address" },
        { internalType: "uint256", name: "_id", type: "uint256" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address[]", name: "_owners", type: "address[]" },
        { internalType: "uint256[]", name: "_ids", type: "uint256[]" },
      ],
      name: "balanceOfBatch",
      outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_owner", type: "address" },
        { internalType: "address", name: "_operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_from", type: "address" },
        { internalType: "address", name: "_to", type: "address" },
        { internalType: "uint256[]", name: "_ids", type: "uint256[]" },
        { internalType: "uint256[]", name: "_values", type: "uint256[]" },
        { internalType: "bytes", name: "_data", type: "bytes" },
      ],
      name: "safeBatchTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_from", type: "address" },
        { internalType: "address", name: "_to", type: "address" },
        { internalType: "uint256", name: "_id", type: "uint256" },
        { internalType: "uint256", name: "_value", type: "uint256" },
        { internalType: "bytes", name: "_data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_operator", type: "address" },
        { internalType: "bool", name: "_approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ];
function DR(n) {
  if (n.length >= 255) throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), t = 0; t < e.length; t++) e[t] = 255;
  for (var r = 0; r < n.length; r++) {
    var a = n.charAt(r),
      i = a.charCodeAt(0);
    if (e[i] !== 255) throw new TypeError(a + " is ambiguous");
    e[i] = r;
  }
  var s = n.length,
    o = n.charAt(0),
    c = Math.log(s) / Math.log(256),
    l = Math.log(256) / Math.log(s);
  function u(p) {
    if (
      (p instanceof Uint8Array ||
        (ArrayBuffer.isView(p)
          ? (p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength))
          : Array.isArray(p) && (p = Uint8Array.from(p))),
      !(p instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (p.length === 0) return "";
    for (var m = 0, y = 0, h = 0, g = p.length; h !== g && p[h] === 0; )
      h++, m++;
    for (var v = ((g - h) * l + 1) >>> 0, w = new Uint8Array(v); h !== g; ) {
      for (
        var T = p[h], A = 0, E = v - 1;
        (T !== 0 || A < y) && E !== -1;
        E--, A++
      )
        (T += (256 * w[E]) >>> 0), (w[E] = T % s >>> 0), (T = (T / s) >>> 0);
      if (T !== 0) throw new Error("Non-zero carry");
      (y = A), h++;
    }
    for (var _ = v - y; _ !== v && w[_] === 0; ) _++;
    for (var S = o.repeat(m); _ < v; ++_) S += n.charAt(w[_]);
    return S;
  }
  function d(p) {
    if (typeof p != "string") throw new TypeError("Expected String");
    if (p.length === 0) return new Uint8Array();
    for (var m = 0, y = 0, h = 0; p[m] === o; ) y++, m++;
    for (
      var g = ((p.length - m) * c + 1) >>> 0, v = new Uint8Array(g);
      p[m];

    ) {
      var w = e[p.charCodeAt(m)];
      if (w === 255) return;
      for (var T = 0, A = g - 1; (w !== 0 || T < h) && A !== -1; A--, T++)
        (w += (s * v[A]) >>> 0), (v[A] = w % 256 >>> 0), (w = (w / 256) >>> 0);
      if (w !== 0) throw new Error("Non-zero carry");
      (h = T), m++;
    }
    for (var E = g - h; E !== g && v[E] === 0; ) E++;
    for (var _ = new Uint8Array(y + (g - E)), S = y; E !== g; ) _[S++] = v[E++];
    return _;
  }
  function f(p) {
    var m = d(p);
    if (m) return m;
    throw new Error("Non-base" + s + " character");
  }
  return { encode: u, decodeUnsafe: d, decode: f };
}
var OR = DR;
const NR = OR,
  FR = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var LR = NR(FR);
const $R = ir(LR),
  P6 = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "deployer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "deployment",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "chainId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "metadataUri",
          type: "string",
        },
      ],
      name: "Added",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "deployer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "deployment",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "chainId",
          type: "uint256",
        },
      ],
      name: "Deleted",
      type: "event",
    },
    {
      inputs: [],
      name: "OPERATOR_ROLE",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "_msgData",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "_msgSender",
      outputs: [{ internalType: "address", name: "sender", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_deployer", type: "address" },
        { internalType: "address", name: "_deployment", type: "address" },
        { internalType: "uint256", name: "_chainId", type: "uint256" },
        { internalType: "string", name: "metadataUri", type: "string" },
      ],
      name: "add",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "contractType",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [],
      name: "contractVersion",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_deployer", type: "address" }],
      name: "count",
      outputs: [
        { internalType: "uint256", name: "deploymentCount", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_deployer", type: "address" }],
      name: "getAll",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "deploymentAddress",
              type: "address",
            },
            { internalType: "uint256", name: "chainId", type: "uint256" },
            { internalType: "string", name: "metadataURI", type: "string" },
          ],
          internalType: "struct ITWMultichainRegistry.Deployment[]",
          name: "allDeployments",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_chainId", type: "uint256" },
        { internalType: "address", name: "_deployment", type: "address" },
      ],
      name: "getMetadataUri",
      outputs: [
        { internalType: "string", name: "metadataUri", type: "string" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_deployer", type: "address" },
        { internalType: "address", name: "_deployment", type: "address" },
        { internalType: "uint256", name: "_chainId", type: "uint256" },
      ],
      name: "remove",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  WR = [
    {
      inputs: [
        {
          internalType: "address[]",
          name: "trustedForwarder",
          type: "address[]",
        },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      inputs: [{ internalType: "address", name: "forwarder", type: "address" }],
      name: "isTrustedForwarder",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  UR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "string",
          name: "prevURI",
          type: "string",
        },
        { indexed: !1, internalType: "string", name: "newURI", type: "string" },
      ],
      name: "AppURIUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "appURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "string", name: "_uri", type: "string" }],
      name: "setAppURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  jR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "string",
          name: "prevURI",
          type: "string",
        },
        { indexed: !1, internalType: "string", name: "newURI", type: "string" },
      ],
      name: "ContractURIUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "contractURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "string", name: "_uri", type: "string" }],
      name: "setContractURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  zR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "buyer",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "BuyerApprovedForListing",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "listingCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
      ],
      name: "CancelledListing",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
      ],
      name: "CurrencyApprovedForListing",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "listingCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          components: [
            { internalType: "uint256", name: "listingId", type: "uint256" },
            {
              internalType: "address",
              name: "listingCreator",
              type: "address",
            },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            { internalType: "uint128", name: "endTimestamp", type: "uint128" },
            { internalType: "bool", name: "reserved", type: "bool" },
            {
              internalType: "enum IDirectListings.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IDirectListings.Status",
              name: "status",
              type: "uint8",
            },
          ],
          indexed: !1,
          internalType: "struct IDirectListings.Listing",
          name: "listing",
          type: "tuple",
        },
      ],
      name: "NewListing",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "listingCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "buyer",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityBought",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "totalPricePaid",
          type: "uint256",
        },
      ],
      name: "NewSale",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "listingCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          components: [
            { internalType: "uint256", name: "listingId", type: "uint256" },
            {
              internalType: "address",
              name: "listingCreator",
              type: "address",
            },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            { internalType: "uint128", name: "endTimestamp", type: "uint128" },
            { internalType: "bool", name: "reserved", type: "bool" },
            {
              internalType: "enum IDirectListings.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IDirectListings.Status",
              name: "status",
              type: "uint8",
            },
          ],
          indexed: !1,
          internalType: "struct IDirectListings.Listing",
          name: "listing",
          type: "tuple",
        },
      ],
      name: "UpdatedListing",
      type: "event",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_listingId", type: "uint256" },
        { internalType: "address", name: "_buyer", type: "address" },
        { internalType: "bool", name: "_toApprove", type: "bool" },
      ],
      name: "approveBuyerForListing",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_listingId", type: "uint256" },
        { internalType: "address", name: "_currency", type: "address" },
        {
          internalType: "uint256",
          name: "_pricePerTokenInCurrency",
          type: "uint256",
        },
      ],
      name: "approveCurrencyForListing",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_listingId", type: "uint256" },
        { internalType: "address", name: "_buyFor", type: "address" },
        { internalType: "uint256", name: "_quantity", type: "uint256" },
        { internalType: "address", name: "_currency", type: "address" },
        {
          internalType: "uint256",
          name: "_expectedTotalPrice",
          type: "uint256",
        },
      ],
      name: "buyFromListing",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_listingId", type: "uint256" },
      ],
      name: "cancelListing",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            { internalType: "uint128", name: "endTimestamp", type: "uint128" },
            { internalType: "bool", name: "reserved", type: "bool" },
          ],
          internalType: "struct IDirectListings.ListingParameters",
          name: "_params",
          type: "tuple",
        },
      ],
      name: "createListing",
      outputs: [
        { internalType: "uint256", name: "listingId", type: "uint256" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_startId", type: "uint256" },
        { internalType: "uint256", name: "_endId", type: "uint256" },
      ],
      name: "getAllListings",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "listingId", type: "uint256" },
            {
              internalType: "address",
              name: "listingCreator",
              type: "address",
            },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            { internalType: "uint128", name: "endTimestamp", type: "uint128" },
            { internalType: "bool", name: "reserved", type: "bool" },
            {
              internalType: "enum IDirectListings.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IDirectListings.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IDirectListings.Listing[]",
          name: "listings",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_startId", type: "uint256" },
        { internalType: "uint256", name: "_endId", type: "uint256" },
      ],
      name: "getAllValidListings",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "listingId", type: "uint256" },
            {
              internalType: "address",
              name: "listingCreator",
              type: "address",
            },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            { internalType: "uint128", name: "endTimestamp", type: "uint128" },
            { internalType: "bool", name: "reserved", type: "bool" },
            {
              internalType: "enum IDirectListings.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IDirectListings.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IDirectListings.Listing[]",
          name: "listings",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_listingId", type: "uint256" },
      ],
      name: "getListing",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "listingId", type: "uint256" },
            {
              internalType: "address",
              name: "listingCreator",
              type: "address",
            },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            { internalType: "uint128", name: "endTimestamp", type: "uint128" },
            { internalType: "bool", name: "reserved", type: "bool" },
            {
              internalType: "enum IDirectListings.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IDirectListings.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IDirectListings.Listing",
          name: "listing",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalListings",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_listingId", type: "uint256" },
        {
          components: [
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            { internalType: "uint128", name: "endTimestamp", type: "uint128" },
            { internalType: "bool", name: "reserved", type: "bool" },
          ],
          internalType: "struct IDirectListings.ListingParameters",
          name: "_params",
          type: "tuple",
        },
      ],
      name: "updateListing",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  HR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "auctionId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "closer",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "auctionCreator",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "winningBidder",
          type: "address",
        },
      ],
      name: "AuctionClosed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "auctionCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "auctionId",
          type: "uint256",
        },
      ],
      name: "CancelledAuction",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "auctionCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "auctionId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          components: [
            { internalType: "uint256", name: "auctionId", type: "uint256" },
            {
              internalType: "address",
              name: "auctionCreator",
              type: "address",
            },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            { internalType: "uint64", name: "bidBufferBps", type: "uint64" },
            { internalType: "uint64", name: "startTimestamp", type: "uint64" },
            { internalType: "uint64", name: "endTimestamp", type: "uint64" },
            {
              internalType: "enum IEnglishAuctions.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IEnglishAuctions.Status",
              name: "status",
              type: "uint8",
            },
          ],
          indexed: !1,
          internalType: "struct IEnglishAuctions.Auction",
          name: "auction",
          type: "tuple",
        },
      ],
      name: "NewAuction",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "auctionId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "bidder",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "bidAmount",
          type: "uint256",
        },
        {
          components: [
            { internalType: "uint256", name: "auctionId", type: "uint256" },
            {
              internalType: "address",
              name: "auctionCreator",
              type: "address",
            },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            { internalType: "uint64", name: "bidBufferBps", type: "uint64" },
            { internalType: "uint64", name: "startTimestamp", type: "uint64" },
            { internalType: "uint64", name: "endTimestamp", type: "uint64" },
            {
              internalType: "enum IEnglishAuctions.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IEnglishAuctions.Status",
              name: "status",
              type: "uint8",
            },
          ],
          indexed: !1,
          internalType: "struct IEnglishAuctions.Auction",
          name: "auction",
          type: "tuple",
        },
      ],
      name: "NewBid",
      type: "event",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_auctionId", type: "uint256" },
        { internalType: "uint256", name: "_bidAmount", type: "uint256" },
      ],
      name: "bidInAuction",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_auctionId", type: "uint256" },
      ],
      name: "cancelAuction",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_auctionId", type: "uint256" },
      ],
      name: "collectAuctionPayout",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_auctionId", type: "uint256" },
      ],
      name: "collectAuctionTokens",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            { internalType: "uint64", name: "bidBufferBps", type: "uint64" },
            { internalType: "uint64", name: "startTimestamp", type: "uint64" },
            { internalType: "uint64", name: "endTimestamp", type: "uint64" },
          ],
          internalType: "struct IEnglishAuctions.AuctionParameters",
          name: "_params",
          type: "tuple",
        },
      ],
      name: "createAuction",
      outputs: [
        { internalType: "uint256", name: "auctionId", type: "uint256" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_startId", type: "uint256" },
        { internalType: "uint256", name: "_endId", type: "uint256" },
      ],
      name: "getAllAuctions",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "auctionId", type: "uint256" },
            {
              internalType: "address",
              name: "auctionCreator",
              type: "address",
            },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            { internalType: "uint64", name: "bidBufferBps", type: "uint64" },
            { internalType: "uint64", name: "startTimestamp", type: "uint64" },
            { internalType: "uint64", name: "endTimestamp", type: "uint64" },
            {
              internalType: "enum IEnglishAuctions.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IEnglishAuctions.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IEnglishAuctions.Auction[]",
          name: "auctions",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_startId", type: "uint256" },
        { internalType: "uint256", name: "_endId", type: "uint256" },
      ],
      name: "getAllValidAuctions",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "auctionId", type: "uint256" },
            {
              internalType: "address",
              name: "auctionCreator",
              type: "address",
            },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            { internalType: "uint64", name: "bidBufferBps", type: "uint64" },
            { internalType: "uint64", name: "startTimestamp", type: "uint64" },
            { internalType: "uint64", name: "endTimestamp", type: "uint64" },
            {
              internalType: "enum IEnglishAuctions.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IEnglishAuctions.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IEnglishAuctions.Auction[]",
          name: "auctions",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_auctionId", type: "uint256" },
      ],
      name: "getAuction",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "auctionId", type: "uint256" },
            {
              internalType: "address",
              name: "auctionCreator",
              type: "address",
            },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            { internalType: "uint64", name: "bidBufferBps", type: "uint64" },
            { internalType: "uint64", name: "startTimestamp", type: "uint64" },
            { internalType: "uint64", name: "endTimestamp", type: "uint64" },
            {
              internalType: "enum IEnglishAuctions.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IEnglishAuctions.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IEnglishAuctions.Auction",
          name: "auction",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_auctionId", type: "uint256" },
      ],
      name: "getWinningBid",
      outputs: [
        { internalType: "address", name: "bidder", type: "address" },
        { internalType: "address", name: "currency", type: "address" },
        { internalType: "uint256", name: "bidAmount", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_auctionId", type: "uint256" },
      ],
      name: "isAuctionExpired",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_auctionId", type: "uint256" },
        { internalType: "uint256", name: "_bidAmount", type: "uint256" },
      ],
      name: "isNewWinningBid",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  qR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "offeror",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "offerId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "seller",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityBought",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "totalPricePaid",
          type: "uint256",
        },
      ],
      name: "AcceptedOffer",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "offeror",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "offerId",
          type: "uint256",
        },
      ],
      name: "CancelledOffer",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "offeror",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "offerId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          components: [
            { internalType: "uint256", name: "offerId", type: "uint256" },
            { internalType: "address", name: "offeror", type: "address" },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "totalPrice", type: "uint256" },
            {
              internalType: "uint256",
              name: "expirationTimestamp",
              type: "uint256",
            },
            {
              internalType: "enum IOffers.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IOffers.Status",
              name: "status",
              type: "uint8",
            },
          ],
          indexed: !1,
          internalType: "struct IOffers.Offer",
          name: "offer",
          type: "tuple",
        },
      ],
      name: "NewOffer",
      type: "event",
    },
    {
      inputs: [{ internalType: "uint256", name: "_offerId", type: "uint256" }],
      name: "acceptOffer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "_offerId", type: "uint256" }],
      name: "cancelOffer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_startId", type: "uint256" },
        { internalType: "uint256", name: "_endId", type: "uint256" },
      ],
      name: "getAllOffers",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "offerId", type: "uint256" },
            { internalType: "address", name: "offeror", type: "address" },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "totalPrice", type: "uint256" },
            {
              internalType: "uint256",
              name: "expirationTimestamp",
              type: "uint256",
            },
            {
              internalType: "enum IOffers.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IOffers.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IOffers.Offer[]",
          name: "offers",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_startId", type: "uint256" },
        { internalType: "uint256", name: "_endId", type: "uint256" },
      ],
      name: "getAllValidOffers",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "offerId", type: "uint256" },
            { internalType: "address", name: "offeror", type: "address" },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "totalPrice", type: "uint256" },
            {
              internalType: "uint256",
              name: "expirationTimestamp",
              type: "uint256",
            },
            {
              internalType: "enum IOffers.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IOffers.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IOffers.Offer[]",
          name: "offers",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "_offerId", type: "uint256" }],
      name: "getOffer",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "offerId", type: "uint256" },
            { internalType: "address", name: "offeror", type: "address" },
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "totalPrice", type: "uint256" },
            {
              internalType: "uint256",
              name: "expirationTimestamp",
              type: "uint256",
            },
            {
              internalType: "enum IOffers.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IOffers.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IOffers.Offer",
          name: "offer",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "assetContract", type: "address" },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "uint256", name: "totalPrice", type: "uint256" },
            {
              internalType: "uint256",
              name: "expirationTimestamp",
              type: "uint256",
            },
          ],
          internalType: "struct IOffers.OfferParams",
          name: "_params",
          type: "tuple",
        },
      ],
      name: "makeOffer",
      outputs: [{ internalType: "uint256", name: "offerId", type: "uint256" }],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  VR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "packId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "totalPacksCreated",
          type: "uint256",
        },
      ],
      name: "PackCreated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "opener",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "packId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amountToOpen",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "requestId",
          type: "uint256",
        },
      ],
      name: "PackOpenRequested",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "packId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "opener",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "numOfPacksOpened",
          type: "uint256",
        },
        {
          components: [
            { internalType: "address", name: "assetContract", type: "address" },
            {
              internalType: "enum ITokenBundle.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "totalAmount", type: "uint256" },
          ],
          indexed: !1,
          internalType: "struct ITokenBundle.Token[]",
          name: "rewardUnitsDistributed",
          type: "tuple[]",
        },
      ],
      name: "PackOpened",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "packId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "requestId",
          type: "uint256",
        },
      ],
      name: "PackRandomnessFulfilled",
      type: "event",
    },
    {
      inputs: [{ internalType: "address", name: "_opener", type: "address" }],
      name: "canClaimRewards",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "claimRewards",
      outputs: [
        {
          components: [
            { internalType: "address", name: "assetContract", type: "address" },
            {
              internalType: "enum ITokenBundle.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "totalAmount", type: "uint256" },
          ],
          internalType: "struct ITokenBundle.Token[]",
          name: "rewardUnits",
          type: "tuple[]",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "assetContract", type: "address" },
            {
              internalType: "enum ITokenBundle.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "uint256", name: "totalAmount", type: "uint256" },
          ],
          internalType: "struct ITokenBundle.Token[]",
          name: "contents",
          type: "tuple[]",
        },
        {
          internalType: "uint256[]",
          name: "numOfRewardUnits",
          type: "uint256[]",
        },
        { internalType: "string", name: "packUri", type: "string" },
        {
          internalType: "uint128",
          name: "openStartTimestamp",
          type: "uint128",
        },
        {
          internalType: "uint128",
          name: "amountDistributedPerOpen",
          type: "uint128",
        },
        { internalType: "address", name: "recipient", type: "address" },
      ],
      name: "createPack",
      outputs: [
        { internalType: "uint256", name: "packId", type: "uint256" },
        { internalType: "uint256", name: "packTotalSupply", type: "uint256" },
      ],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "packId", type: "uint256" },
        { internalType: "uint256", name: "amountToOpen", type: "uint256" },
      ],
      name: "openPack",
      outputs: [
        { internalType: "uint256", name: "requestId", type: "uint256" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_packId", type: "uint256" },
        { internalType: "uint256", name: "_amountToOpen", type: "uint256" },
        { internalType: "uint32", name: "_callBackGasLimit", type: "uint32" },
      ],
      name: "openPackAndClaimRewards",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  GR = [
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "getRoleAdmin",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "hasRole",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  KR = [
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "getRoleAdmin",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "uint256", name: "index", type: "uint256" },
      ],
      name: "getRoleMember",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "getRoleMemberCount",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "hasRole",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  QR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "address",
          name: "platformFeeRecipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "flatFee",
          type: "uint256",
        },
      ],
      name: "FlatPlatformFeeUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "platformFeeRecipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "platformFeeBps",
          type: "uint256",
        },
      ],
      name: "PlatformFeeInfoUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "enum IPlatformFee.PlatformFeeType",
          name: "feeType",
          type: "uint8",
        },
      ],
      name: "PlatformFeeTypeUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "getPlatformFeeInfo",
      outputs: [
        { internalType: "address", name: "", type: "address" },
        { internalType: "uint16", name: "", type: "uint16" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_platformFeeRecipient",
          type: "address",
        },
        { internalType: "uint256", name: "_platformFeeBps", type: "uint256" },
      ],
      name: "setPlatformFeeInfo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  YR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
      ],
      name: "PrimarySaleRecipientUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "primarySaleRecipient",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_saleRecipient", type: "address" },
      ],
      name: "setPrimarySaleRecipient",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  JR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "newRoyaltyRecipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "newRoyaltyBps",
          type: "uint256",
        },
      ],
      name: "DefaultRoyalty",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "royaltyRecipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "royaltyBps",
          type: "uint256",
        },
      ],
      name: "RoyaltyForToken",
      type: "event",
    },
    {
      inputs: [],
      name: "getDefaultRoyaltyInfo",
      outputs: [
        { internalType: "address", name: "", type: "address" },
        { internalType: "uint16", name: "", type: "uint16" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getRoyaltyInfoForToken",
      outputs: [
        { internalType: "address", name: "", type: "address" },
        { internalType: "uint16", name: "", type: "uint16" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "salePrice", type: "uint256" },
      ],
      name: "royaltyInfo",
      outputs: [
        { internalType: "address", name: "receiver", type: "address" },
        { internalType: "uint256", name: "royaltyAmount", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_royaltyRecipient", type: "address" },
        { internalType: "uint256", name: "_royaltyBps", type: "uint256" },
      ],
      name: "setDefaultRoyaltyInfo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "address", name: "recipient", type: "address" },
        { internalType: "uint256", name: "bps", type: "uint256" },
      ],
      name: "setRoyaltyInfoForToken",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  XR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "prevOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnerUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_newOwner", type: "address" }],
      name: "setOwner",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  ZR = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "accountAdmin",
          type: "address",
        },
      ],
      name: "AccountCreated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      name: "SignerAdded",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      name: "SignerRemoved",
      type: "event",
    },
    {
      inputs: [],
      name: "accountImplementation",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "admin", type: "address" },
        { internalType: "bytes", name: "_data", type: "bytes" },
      ],
      name: "createAccount",
      outputs: [{ internalType: "address", name: "account", type: "address" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "signer", type: "address" }],
      name: "getAccountsOfSigner",
      outputs: [
        { internalType: "address[]", name: "accounts", type: "address[]" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "adminSigner", type: "address" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "getAddress",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getAllAccounts",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "signer", type: "address" }],
      name: "onSignerAdded",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "signer", type: "address" }],
      name: "onSignerRemoved",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  eM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "isAdmin", type: "bool" },
      ],
      name: "AdminUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "authorizingSigner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "targetSigner",
          type: "address",
        },
        {
          components: [
            { internalType: "address", name: "signer", type: "address" },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "permissionStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "permissionEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          indexed: !1,
          internalType: "struct IAccountPermissions.SignerPermissionRequest",
          name: "permissions",
          type: "tuple",
        },
      ],
      name: "SignerPermissionsUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "factory",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getAllActiveSigners",
      outputs: [
        {
          components: [
            { internalType: "address", name: "signer", type: "address" },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            { internalType: "uint128", name: "endTimestamp", type: "uint128" },
          ],
          internalType: "struct IAccountPermissions.SignerPermissions[]",
          name: "signers",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getAllAdmins",
      outputs: [
        { internalType: "address[]", name: "admins", type: "address[]" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getAllSigners",
      outputs: [
        {
          components: [
            { internalType: "address", name: "signer", type: "address" },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            { internalType: "uint128", name: "endTimestamp", type: "uint128" },
          ],
          internalType: "struct IAccountPermissions.SignerPermissions[]",
          name: "signers",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "signer", type: "address" }],
      name: "getPermissionsForSigner",
      outputs: [
        {
          components: [
            { internalType: "address", name: "signer", type: "address" },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            { internalType: "uint128", name: "endTimestamp", type: "uint128" },
          ],
          internalType: "struct IAccountPermissions.SignerPermissions",
          name: "permissions",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "signer", type: "address" }],
      name: "isActiveSigner",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "signer", type: "address" }],
      name: "isAdmin",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "multicall",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "account", type: "address" },
        { internalType: "bool", name: "isAdmin", type: "bool" },
      ],
      name: "setAdmin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "signer", type: "address" },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "permissionStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "permissionEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          internalType: "struct IAccountPermissions.SignerPermissionRequest",
          name: "req",
          type: "tuple",
        },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "setPermissionsForSigner",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "sender", type: "address" },
            { internalType: "uint256", name: "nonce", type: "uint256" },
            { internalType: "bytes", name: "initCode", type: "bytes" },
            { internalType: "bytes", name: "callData", type: "bytes" },
            { internalType: "uint256", name: "callGasLimit", type: "uint256" },
            {
              internalType: "uint256",
              name: "verificationGasLimit",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "preVerificationGas",
              type: "uint256",
            },
            { internalType: "uint256", name: "maxFeePerGas", type: "uint256" },
            {
              internalType: "uint256",
              name: "maxPriorityFeePerGas",
              type: "uint256",
            },
            { internalType: "bytes", name: "paymasterAndData", type: "bytes" },
            { internalType: "bytes", name: "signature", type: "bytes" },
          ],
          internalType: "struct UserOperation",
          name: "userOp",
          type: "tuple",
        },
        { internalType: "bytes32", name: "userOpHash", type: "bytes32" },
        {
          internalType: "uint256",
          name: "missingAccountFunds",
          type: "uint256",
        },
      ],
      name: "validateUserOp",
      outputs: [
        { internalType: "uint256", name: "validationData", type: "uint256" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "signer", type: "address" },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "permissionStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "permissionEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          internalType: "struct IAccountPermissions.SignerPermissionRequest",
          name: "req",
          type: "tuple",
        },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "verifySignerPermissionRequest",
      outputs: [
        { internalType: "bool", name: "success", type: "bool" },
        { internalType: "address", name: "signer", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  om = [
    {
      inputs: [
        { internalType: "address", name: "_trustedForwarder", type: "address" },
        {
          internalType: "contract IContractPublisher",
          name: "_prevPublisher",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "publisher",
          type: "address",
        },
        {
          components: [
            { internalType: "string", name: "contractId", type: "string" },
            {
              internalType: "uint256",
              name: "publishTimestamp",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "publishMetadataUri",
              type: "string",
            },
            { internalType: "bytes32", name: "bytecodeHash", type: "bytes32" },
            {
              internalType: "address",
              name: "implementation",
              type: "address",
            },
          ],
          indexed: !1,
          internalType: "struct IContractPublisher.CustomContractInstance",
          name: "publishedContract",
          type: "tuple",
        },
      ],
      name: "ContractPublished",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "publisher",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "string",
          name: "contractId",
          type: "string",
        },
      ],
      name: "ContractUnpublished",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, internalType: "bool", name: "isPaused", type: "bool" },
      ],
      name: "Paused",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "publisher",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "prevURI",
          type: "string",
        },
        { indexed: !1, internalType: "string", name: "newURI", type: "string" },
      ],
      name: "PublisherProfileUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_publisher", type: "address" },
      ],
      name: "getAllPublishedContracts",
      outputs: [
        {
          components: [
            { internalType: "string", name: "contractId", type: "string" },
            {
              internalType: "uint256",
              name: "publishTimestamp",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "publishMetadataUri",
              type: "string",
            },
            { internalType: "bytes32", name: "bytecodeHash", type: "bytes32" },
            {
              internalType: "address",
              name: "implementation",
              type: "address",
            },
          ],
          internalType: "struct IContractPublisher.CustomContractInstance[]",
          name: "published",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_publisher", type: "address" },
        { internalType: "string", name: "_contractId", type: "string" },
      ],
      name: "getPublishedContract",
      outputs: [
        {
          components: [
            { internalType: "string", name: "contractId", type: "string" },
            {
              internalType: "uint256",
              name: "publishTimestamp",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "publishMetadataUri",
              type: "string",
            },
            { internalType: "bytes32", name: "bytecodeHash", type: "bytes32" },
            {
              internalType: "address",
              name: "implementation",
              type: "address",
            },
          ],
          internalType: "struct IContractPublisher.CustomContractInstance",
          name: "published",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_publisher", type: "address" },
        { internalType: "string", name: "_contractId", type: "string" },
      ],
      name: "getPublishedContractVersions",
      outputs: [
        {
          components: [
            { internalType: "string", name: "contractId", type: "string" },
            {
              internalType: "uint256",
              name: "publishTimestamp",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "publishMetadataUri",
              type: "string",
            },
            { internalType: "bytes32", name: "bytecodeHash", type: "bytes32" },
            {
              internalType: "address",
              name: "implementation",
              type: "address",
            },
          ],
          internalType: "struct IContractPublisher.CustomContractInstance[]",
          name: "published",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "string", name: "compilerMetadataUri", type: "string" },
      ],
      name: "getPublishedUriFromCompilerUri",
      outputs: [
        {
          internalType: "string[]",
          name: "publishedMetadataUris",
          type: "string[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "publisher", type: "address" }],
      name: "getPublisherProfileUri",
      outputs: [{ internalType: "string", name: "uri", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "getRoleAdmin",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "uint256", name: "index", type: "uint256" },
      ],
      name: "getRoleMember",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "getRoleMemberCount",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "hasRole",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "isPaused",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "forwarder", type: "address" }],
      name: "isTrustedForwarder",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "multicall",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "prevPublisher",
      outputs: [
        {
          internalType: "contract IContractPublisher",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_publisher", type: "address" },
        { internalType: "string", name: "_contractId", type: "string" },
        { internalType: "string", name: "_publishMetadataUri", type: "string" },
        {
          internalType: "string",
          name: "_compilerMetadataUri",
          type: "string",
        },
        { internalType: "bytes32", name: "_bytecodeHash", type: "bytes32" },
        { internalType: "address", name: "_implementation", type: "address" },
      ],
      name: "publishContract",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bool", name: "_pause", type: "bool" }],
      name: "setPause",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "publisher", type: "address" },
        { internalType: "string", name: "uri", type: "string" },
      ],
      name: "setPublisherProfileUri",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_publisher", type: "address" },
        { internalType: "string", name: "_contractId", type: "string" },
      ],
      name: "unpublishContract",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ];
var I6 = { exports: {} };
(function (n) {
  var e = Object.prototype.hasOwnProperty,
    t = "~";
  function r() {}
  Object.create &&
    ((r.prototype = Object.create(null)), new r().__proto__ || (t = !1));
  function a(c, l, u) {
    (this.fn = c), (this.context = l), (this.once = u || !1);
  }
  function i(c, l, u, d, f) {
    if (typeof u != "function")
      throw new TypeError("The listener must be a function");
    var p = new a(u, d || c, f),
      m = t ? t + l : l;
    return (
      c._events[m]
        ? c._events[m].fn
          ? (c._events[m] = [c._events[m], p])
          : c._events[m].push(p)
        : ((c._events[m] = p), c._eventsCount++),
      c
    );
  }
  function s(c, l) {
    --c._eventsCount === 0 ? (c._events = new r()) : delete c._events[l];
  }
  function o() {
    (this._events = new r()), (this._eventsCount = 0);
  }
  (o.prototype.eventNames = function () {
    var l = [],
      u,
      d;
    if (this._eventsCount === 0) return l;
    for (d in (u = this._events)) e.call(u, d) && l.push(t ? d.slice(1) : d);
    return Object.getOwnPropertySymbols
      ? l.concat(Object.getOwnPropertySymbols(u))
      : l;
  }),
    (o.prototype.listeners = function (l) {
      var u = t ? t + l : l,
        d = this._events[u];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, p = d.length, m = new Array(p); f < p; f++)
        m[f] = d[f].fn;
      return m;
    }),
    (o.prototype.listenerCount = function (l) {
      var u = t ? t + l : l,
        d = this._events[u];
      return d ? (d.fn ? 1 : d.length) : 0;
    }),
    (o.prototype.emit = function (l, u, d, f, p, m) {
      var y = t ? t + l : l;
      if (!this._events[y]) return !1;
      var h = this._events[y],
        g = arguments.length,
        v,
        w;
      if (h.fn) {
        switch ((h.once && this.removeListener(l, h.fn, void 0, !0), g)) {
          case 1:
            return h.fn.call(h.context), !0;
          case 2:
            return h.fn.call(h.context, u), !0;
          case 3:
            return h.fn.call(h.context, u, d), !0;
          case 4:
            return h.fn.call(h.context, u, d, f), !0;
          case 5:
            return h.fn.call(h.context, u, d, f, p), !0;
          case 6:
            return h.fn.call(h.context, u, d, f, p, m), !0;
        }
        for (w = 1, v = new Array(g - 1); w < g; w++) v[w - 1] = arguments[w];
        h.fn.apply(h.context, v);
      } else {
        var T = h.length,
          A;
        for (w = 0; w < T; w++)
          switch (
            (h[w].once && this.removeListener(l, h[w].fn, void 0, !0), g)
          ) {
            case 1:
              h[w].fn.call(h[w].context);
              break;
            case 2:
              h[w].fn.call(h[w].context, u);
              break;
            case 3:
              h[w].fn.call(h[w].context, u, d);
              break;
            case 4:
              h[w].fn.call(h[w].context, u, d, f);
              break;
            default:
              if (!v)
                for (A = 1, v = new Array(g - 1); A < g; A++)
                  v[A - 1] = arguments[A];
              h[w].fn.apply(h[w].context, v);
          }
      }
      return !0;
    }),
    (o.prototype.on = function (l, u, d) {
      return i(this, l, u, d, !1);
    }),
    (o.prototype.once = function (l, u, d) {
      return i(this, l, u, d, !0);
    }),
    (o.prototype.removeListener = function (l, u, d, f) {
      var p = t ? t + l : l;
      if (!this._events[p]) return this;
      if (!u) return s(this, p), this;
      var m = this._events[p];
      if (m.fn)
        m.fn === u && (!f || m.once) && (!d || m.context === d) && s(this, p);
      else {
        for (var y = 0, h = [], g = m.length; y < g; y++)
          (m[y].fn !== u || (f && !m[y].once) || (d && m[y].context !== d)) &&
            h.push(m[y]);
        h.length ? (this._events[p] = h.length === 1 ? h[0] : h) : s(this, p);
      }
      return this;
    }),
    (o.prototype.removeAllListeners = function (l) {
      var u;
      return (
        l
          ? ((u = t ? t + l : l), this._events[u] && s(this, u))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      );
    }),
    (o.prototype.off = o.prototype.removeListener),
    (o.prototype.addListener = o.prototype.on),
    (o.prefixed = t),
    (o.EventEmitter = o),
    (n.exports = o);
})(I6);
var tM = I6.exports;
const Iu = ir(tM),
  R6 = [
    { inputs: [], stateMutability: "nonpayable", type: "constructor" },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "from", type: "address" },
            { internalType: "address", name: "to", type: "address" },
            { internalType: "uint256", name: "value", type: "uint256" },
            { internalType: "uint256", name: "gas", type: "uint256" },
            { internalType: "uint256", name: "nonce", type: "uint256" },
            { internalType: "bytes", name: "data", type: "bytes" },
          ],
          internalType: "struct Forwarder.ForwardRequest",
          name: "req",
          type: "tuple",
        },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "execute",
      outputs: [
        { internalType: "bool", name: "", type: "bool" },
        { internalType: "bytes", name: "", type: "bytes" },
      ],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "from", type: "address" }],
      name: "getNonce",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "from", type: "address" },
            { internalType: "address", name: "to", type: "address" },
            { internalType: "uint256", name: "value", type: "uint256" },
            { internalType: "uint256", name: "gas", type: "uint256" },
            { internalType: "uint256", name: "nonce", type: "uint256" },
            { internalType: "bytes", name: "data", type: "bytes" },
          ],
          internalType: "struct Forwarder.ForwardRequest",
          name: "req",
          type: "tuple",
        },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "verify",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  nM = [
    {
      inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "account", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "burnFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  M6 = [
    {
      anonymous: !1,
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "string", name: "metadata", type: "string" },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition.ClaimCondition[]",
          name: "claimConditions",
          type: "tuple[]",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionsUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "claimConditionIndex",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "receiver", type: "address" },
        { internalType: "uint256", name: "quantity", type: "uint256" },
        { internalType: "address", name: "currency", type: "address" },
        { internalType: "uint256", name: "pricePerToken", type: "uint256" },
        {
          components: [
            { internalType: "bytes32[]", name: "proof", type: "bytes32[]" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          internalType: "struct IDrop.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "string", name: "metadata", type: "string" },
          ],
          internalType: "struct IClaimCondition.ClaimCondition[]",
          name: "phases",
          type: "tuple[]",
        },
        { internalType: "bool", name: "resetClaimEligibility", type: "bool" },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  rM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          indexed: !1,
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "claimConditions",
          type: "tuple[]",
        },
      ],
      name: "ClaimConditionsUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "string",
          name: "prevURI",
          type: "string",
        },
        { indexed: !1, internalType: "string", name: "newURI", type: "string" },
      ],
      name: "ContractURIUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "maxTotalSupply",
          type: "uint256",
        },
      ],
      name: "MaxTotalSupplyUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "MaxWalletClaimCountUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "claimConditionIndex",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "wallet",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "WalletClaimCountUpdated",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "spender", type: "address" },
      ],
      name: "allowance",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "spender", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "approve",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "account", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "receiver", type: "address" },
        { internalType: "uint256", name: "quantity", type: "uint256" },
        { internalType: "address", name: "currency", type: "address" },
        { internalType: "uint256", name: "pricePerToken", type: "uint256" },
        { internalType: "bytes32[]", name: "proofs", type: "bytes32[]" },
        {
          internalType: "uint256",
          name: "proofMaxQuantityPerTransaction",
          type: "uint256",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "phases",
          type: "tuple[]",
        },
        { internalType: "bool", name: "resetClaimEligibility", type: "bool" },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transfer",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  B6 = [
    {
      anonymous: !1,
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "string", name: "metadata", type: "string" },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition.ClaimCondition",
          name: "condition",
          type: "tuple",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "receiver", type: "address" },
        { internalType: "uint256", name: "quantity", type: "uint256" },
        { internalType: "address", name: "currency", type: "address" },
        { internalType: "uint256", name: "pricePerToken", type: "uint256" },
        {
          components: [
            { internalType: "bytes32[]", name: "proof", type: "bytes32[]" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          internalType: "struct IDropSinglePhase.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "string", name: "metadata", type: "string" },
          ],
          internalType: "struct IClaimCondition.ClaimCondition",
          name: "phase",
          type: "tuple",
        },
        { internalType: "bool", name: "resetClaimEligibility", type: "bool" },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  D6 = [
    {
      anonymous: !1,
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition_V1.ClaimCondition",
          name: "condition",
          type: "tuple",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "receiver", type: "address" },
        { internalType: "uint256", name: "quantity", type: "uint256" },
        { internalType: "address", name: "currency", type: "address" },
        { internalType: "uint256", name: "pricePerToken", type: "uint256" },
        {
          components: [
            { internalType: "bytes32[]", name: "proof", type: "bytes32[]" },
            {
              internalType: "uint256",
              name: "maxQuantityInAllowlist",
              type: "uint256",
            },
          ],
          internalType: "struct IDropSinglePhase_V1.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          internalType: "struct IClaimCondition_V1.ClaimCondition",
          name: "phase",
          type: "tuple",
        },
        { internalType: "bool", name: "resetClaimEligibility", type: "bool" },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  aM = [
    {
      inputs: [],
      name: "DOMAIN_SEPARATOR",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "nonces",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "spender", type: "address" },
        { internalType: "uint256", name: "value", type: "uint256" },
        { internalType: "uint256", name: "deadline", type: "uint256" },
        { internalType: "uint8", name: "v", type: "uint8" },
        { internalType: "bytes32", name: "r", type: "bytes32" },
        { internalType: "bytes32", name: "s", type: "bytes32" },
      ],
      name: "permit",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  O6 = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityMinted",
          type: "uint256",
        },
      ],
      name: "TokensMinted",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "mintTo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  cm = [
    {
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "multicall",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  iM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          components: [
            { internalType: "address", name: "to", type: "address" },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          indexed: !1,
          internalType: "struct ISignatureMintERC20.MintRequest",
          name: "mintRequest",
          type: "tuple",
        },
      ],
      name: "TokensMintedWithSignature",
      type: "event",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "to", type: "address" },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          internalType: "struct ISignatureMintERC20.MintRequest",
          name: "req",
          type: "tuple",
        },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "mintWithSignature",
      outputs: [{ internalType: "address", name: "signer", type: "address" }],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "to", type: "address" },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          internalType: "struct ISignatureMintERC20.MintRequest",
          name: "req",
          type: "tuple",
        },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "verify",
      outputs: [
        { internalType: "bool", name: "success", type: "bool" },
        { internalType: "address", name: "signer", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  sM = [
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  oM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "_receiver", type: "address" },
        { internalType: "uint256", name: "_quantity", type: "uint256" },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_claimer", type: "address" },
        { internalType: "uint256", name: "_quantity", type: "uint256" },
      ],
      name: "verifyClaim",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
  ],
  N6 = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "index",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "revealedURI",
          type: "string",
        },
      ],
      name: "TokenURIRevealed",
      type: "event",
    },
    {
      inputs: [
        { internalType: "bytes", name: "data", type: "bytes" },
        { internalType: "bytes", name: "key", type: "bytes" },
      ],
      name: "encryptDecrypt",
      outputs: [{ internalType: "bytes", name: "result", type: "bytes" }],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "identifier", type: "uint256" },
        { internalType: "bytes", name: "key", type: "bytes" },
      ],
      name: "reveal",
      outputs: [
        { internalType: "string", name: "revealedURI", type: "string" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  cM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          indexed: !1,
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "claimConditions",
          type: "tuple[]",
        },
      ],
      name: "ClaimConditionsUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "maxTotalSupply",
          type: "uint256",
        },
      ],
      name: "MaxTotalSupplyUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "MaxWalletClaimCountUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "endTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "revealedURI",
          type: "string",
        },
      ],
      name: "NFTRevealed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "claimConditionIndex",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "endTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "baseURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "bytes",
          name: "encryptedBaseURI",
          type: "bytes",
        },
      ],
      name: "TokensLazyMinted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "wallet",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "WalletClaimCountUpdated",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "balance", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "receiver", type: "address" },
        { internalType: "uint256", name: "quantity", type: "uint256" },
        { internalType: "address", name: "currency", type: "address" },
        { internalType: "uint256", name: "pricePerToken", type: "uint256" },
        { internalType: "bytes32[]", name: "proofs", type: "bytes32[]" },
        {
          internalType: "uint256",
          name: "proofMaxQuantityPerTransaction",
          type: "uint256",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "operator", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "string", name: "baseURIForTokens", type: "string" },
        { internalType: "bytes", name: "encryptedBaseURI", type: "bytes" },
      ],
      name: "lazyMint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "owner", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "_approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "phases",
          type: "tuple[]",
        },
        { internalType: "bool", name: "resetClaimEligibility", type: "bool" },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  lM = [
    {
      inputs: [{ internalType: "uint256", name: "_index", type: "uint256" }],
      name: "tokenByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_owner", type: "address" },
        { internalType: "uint256", name: "_index", type: "uint256" },
      ],
      name: "tokenOfOwnerByIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  uM = [
    { inputs: [], name: "ApprovalCallerNotOwnerNorApproved", type: "error" },
    { inputs: [], name: "ApprovalQueryForNonexistentToken", type: "error" },
    { inputs: [], name: "BalanceQueryForZeroAddress", type: "error" },
    { inputs: [], name: "InvalidQueryRange", type: "error" },
    { inputs: [], name: "MintERC2309QuantityExceedsLimit", type: "error" },
    { inputs: [], name: "MintToZeroAddress", type: "error" },
    { inputs: [], name: "MintZeroQuantity", type: "error" },
    { inputs: [], name: "OwnerQueryForNonexistentToken", type: "error" },
    { inputs: [], name: "OwnershipNotInitializedForExtraData", type: "error" },
    { inputs: [], name: "TransferCallerNotOwnerNorApproved", type: "error" },
    { inputs: [], name: "TransferFromIncorrectOwner", type: "error" },
    {
      inputs: [],
      name: "TransferToNonERC721ReceiverImplementer",
      type: "error",
    },
    { inputs: [], name: "TransferToZeroAddress", type: "error" },
    { inputs: [], name: "URIQueryForNonexistentToken", type: "error" },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "fromTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "toTokenId",
          type: "uint256",
        },
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
      ],
      name: "ConsecutiveTransfer",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "balance", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "explicitOwnershipOf",
      outputs: [
        {
          components: [
            { internalType: "address", name: "addr", type: "address" },
            { internalType: "uint64", name: "startTimestamp", type: "uint64" },
            { internalType: "bool", name: "burned", type: "bool" },
            { internalType: "uint24", name: "extraData", type: "uint24" },
          ],
          internalType: "struct IERC721AUpgradeable.TokenOwnership",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "operator", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "owner", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "_approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "tokensOfOwner",
      outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "uint256", name: "start", type: "uint256" },
        { internalType: "uint256", name: "stop", type: "uint256" },
      ],
      name: "tokensOfOwnerIn",
      outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
  ],
  dM = [
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  af = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "endTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "baseURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "bytes",
          name: "encryptedBaseURI",
          type: "bytes",
        },
      ],
      name: "TokensLazyMinted",
      type: "event",
    },
    {
      inputs: [
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "string", name: "baseURIForTokens", type: "string" },
        { internalType: "bytes", name: "extraData", type: "bytes" },
      ],
      name: "lazyMint",
      outputs: [{ internalType: "uint256", name: "batchId", type: "uint256" }],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  F6 = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenIdMinted",
          type: "uint256",
        },
        { indexed: !1, internalType: "string", name: "uri", type: "string" },
      ],
      name: "TokensMinted",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "string", name: "uri", type: "string" },
      ],
      name: "mintTo",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  fM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenIdMinted",
          type: "uint256",
        },
        {
          components: [
            { internalType: "address", name: "to", type: "address" },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "royaltyBps", type: "uint256" },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            { internalType: "string", name: "uri", type: "string" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          indexed: !1,
          internalType: "struct ISignatureMintERC721.MintRequest",
          name: "mintRequest",
          type: "tuple",
        },
      ],
      name: "TokensMintedWithSignature",
      type: "event",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "to", type: "address" },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "royaltyBps", type: "uint256" },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            { internalType: "string", name: "uri", type: "string" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          internalType: "struct ISignatureMintERC721.MintRequest",
          name: "req",
          type: "tuple",
        },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "mintWithSignature",
      outputs: [{ internalType: "address", name: "signer", type: "address" }],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "to", type: "address" },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "royaltyBps", type: "uint256" },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            { internalType: "string", name: "uri", type: "string" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          internalType: "struct ISignatureMintERC721.MintRequest",
          name: "req",
          type: "tuple",
        },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "verify",
      outputs: [
        { internalType: "bool", name: "success", type: "bool" },
        { internalType: "address", name: "signer", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  pM = [
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "to", type: "address" },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "royaltyBps", type: "uint256" },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            { internalType: "string", name: "uri", type: "string" },
            { internalType: "uint256", name: "price", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          internalType: "struct ITokenERC721.MintRequest",
          name: "_req",
          type: "tuple",
        },
        { internalType: "bytes", name: "_signature", type: "bytes" },
      ],
      name: "mintWithSignature",
      outputs: [
        { internalType: "uint256", name: "tokenIdMinted", type: "uint256" },
      ],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "to", type: "address" },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "royaltyBps", type: "uint256" },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            { internalType: "string", name: "uri", type: "string" },
            { internalType: "uint256", name: "price", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          internalType: "struct ITokenERC721.MintRequest",
          name: "_req",
          type: "tuple",
        },
        { internalType: "bytes", name: "_signature", type: "bytes" },
      ],
      name: "verify",
      outputs: [
        { internalType: "bool", name: "", type: "bool" },
        { internalType: "address", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  hM = [
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "string", name: "tier", type: "string" },
        {
          indexed: !0,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "endTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "baseURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "bytes",
          name: "encryptedBaseURI",
          type: "bytes",
        },
      ],
      name: "TokensLazyMinted",
      type: "event",
    },
    {
      inputs: [],
      name: "getBaseURICount",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "_index", type: "uint256" }],
      name: "getBatchIdAtIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getMetadataForAllTiers",
      outputs: [
        {
          components: [
            { internalType: "string", name: "tier", type: "string" },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "startIdInclusive",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "endIdNonInclusive",
                  type: "uint256",
                },
              ],
              internalType: "struct LazyMintWithTier.TokenRange[]",
              name: "ranges",
              type: "tuple[]",
            },
            { internalType: "string[]", name: "baseURIs", type: "string[]" },
          ],
          internalType: "struct LazyMintWithTier.TierMetadata[]",
          name: "metadataForAllTiers",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_amount", type: "uint256" },
        { internalType: "string", name: "_baseURIForTokens", type: "string" },
        { internalType: "string", name: "_tier", type: "string" },
        { internalType: "bytes", name: "_data", type: "bytes" },
      ],
      name: "lazyMint",
      outputs: [{ internalType: "uint256", name: "batchId", type: "uint256" }],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  mM = [
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, internalType: "string", name: "name", type: "string" },
        {
          indexed: !1,
          internalType: "string",
          name: "description",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "imageURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "animationURI",
          type: "string",
        },
      ],
      name: "SharedMetadataUpdated",
      type: "event",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "string", name: "name", type: "string" },
            { internalType: "string", name: "description", type: "string" },
            { internalType: "string", name: "imageURI", type: "string" },
            { internalType: "string", name: "animationURI", type: "string" },
          ],
          internalType: "struct ISharedMetadata.SharedMetadataInfo",
          name: "_metadata",
          type: "tuple",
        },
      ],
      name: "setSharedMetadata",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "sharedMetadata",
      outputs: [
        { internalType: "string", name: "name", type: "string" },
        { internalType: "string", name: "description", type: "string" },
        { internalType: "string", name: "imageURI", type: "string" },
        { internalType: "string", name: "animationURI", type: "string" },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  yM = [
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "Access_MissingRoleOrAdmin",
      type: "error",
    },
    { inputs: [], name: "Access_OnlyAdmin", type: "error" },
    { inputs: [], name: "Access_WithdrawNotAllowed", type: "error" },
    {
      inputs: [
        { internalType: "address", name: "proposedAddress", type: "address" },
      ],
      name: "Admin_InvalidUpgradeAddress",
      type: "error",
    },
    { inputs: [], name: "Admin_UnableToFinalizeNotOpenEdition", type: "error" },
    { inputs: [], name: "ExternalMetadataRenderer_CallFailed", type: "error" },
    { inputs: [], name: "InvalidMintSchedule", type: "error" },
    {
      inputs: [],
      name: "MarketFilterDAOAddressNotSupportedForChain",
      type: "error",
    },
    { inputs: [], name: "MintFee_FundsSendFailure", type: "error" },
    { inputs: [], name: "Mint_SoldOut", type: "error" },
    {
      inputs: [{ internalType: "address", name: "operator", type: "address" }],
      name: "OperatorNotAllowed",
      type: "error",
    },
    { inputs: [], name: "Presale_Inactive", type: "error" },
    { inputs: [], name: "Presale_MerkleNotApproved", type: "error" },
    { inputs: [], name: "Presale_TooManyForAddress", type: "error" },
    { inputs: [], name: "Purchase_TooManyForAddress", type: "error" },
    {
      inputs: [
        { internalType: "uint256", name: "correctPrice", type: "uint256" },
      ],
      name: "Purchase_WrongPrice",
      type: "error",
    },
    {
      inputs: [],
      name: "RemoteOperatorFilterRegistryCallFailed",
      type: "error",
    },
    { inputs: [], name: "Sale_Inactive", type: "error" },
    {
      inputs: [
        { internalType: "uint16", name: "maxRoyaltyBPS", type: "uint16" },
      ],
      name: "Setup_RoyaltyPercentageTooHigh",
      type: "error",
    },
    { inputs: [], name: "Withdraw_FundsSendFailure", type: "error" },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "newAddress",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "changedBy",
          type: "address",
        },
      ],
      name: "FundsRecipientChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "withdrawnBy",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "withdrawnTo",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "feeRecipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "feeAmount",
          type: "uint256",
        },
      ],
      name: "FundsWithdrawn",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "tokenContract",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "comment",
          type: "string",
        },
      ],
      name: "MintComment",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "mintFeeAmount",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "mintFeeRecipient",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "success", type: "bool" },
      ],
      name: "MintFeePayout",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "numberOfMints",
          type: "uint256",
        },
      ],
      name: "OpenMintFinalized",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !0,
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "firstPurchasedTokenId",
          type: "uint256",
        },
      ],
      name: "Sale",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "changedBy",
          type: "address",
        },
      ],
      name: "SalesConfigChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "contract IMetadataRenderer",
          name: "renderer",
          type: "address",
        },
      ],
      name: "UpdatedMetadataRenderer",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "quantity", type: "uint256" },
      ],
      name: "adminMint",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address[]", name: "to", type: "address[]" }],
      name: "adminMintAirdrop",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "user", type: "address" }],
      name: "isAdmin",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "minter", type: "address" }],
      name: "mintedPerAddress",
      outputs: [
        {
          components: [
            { internalType: "uint256", name: "totalMints", type: "uint256" },
            { internalType: "uint256", name: "presaleMints", type: "uint256" },
            { internalType: "uint256", name: "publicMints", type: "uint256" },
          ],
          internalType: "struct IERC721Drop.AddressMintDetails",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "quantity", type: "uint256" }],
      name: "purchase",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "quantity", type: "uint256" },
        { internalType: "uint256", name: "maxQuantity", type: "uint256" },
        { internalType: "uint256", name: "pricePerToken", type: "uint256" },
        { internalType: "bytes32[]", name: "merkleProof", type: "bytes32[]" },
      ],
      name: "purchasePresale",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [],
      name: "saleDetails",
      outputs: [
        {
          components: [
            { internalType: "bool", name: "publicSaleActive", type: "bool" },
            { internalType: "bool", name: "presaleActive", type: "bool" },
            {
              internalType: "uint256",
              name: "publicSalePrice",
              type: "uint256",
            },
            { internalType: "uint64", name: "publicSaleStart", type: "uint64" },
            { internalType: "uint64", name: "publicSaleEnd", type: "uint64" },
            { internalType: "uint64", name: "presaleStart", type: "uint64" },
            { internalType: "uint64", name: "presaleEnd", type: "uint64" },
            {
              internalType: "bytes32",
              name: "presaleMerkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "maxSalePurchasePerAddress",
              type: "uint256",
            },
            { internalType: "uint256", name: "totalMinted", type: "uint256" },
            { internalType: "uint256", name: "maxSupply", type: "uint256" },
          ],
          internalType: "struct IERC721Drop.SaleDetails",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IMetadataRenderer",
          name: "newRenderer",
          type: "address",
        },
        { internalType: "bytes", name: "setupRenderer", type: "bytes" },
      ],
      name: "setMetadataRenderer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint104", name: "publicSalePrice", type: "uint104" },
        {
          internalType: "uint32",
          name: "maxSalePurchasePerAddress",
          type: "uint32",
        },
        { internalType: "uint64", name: "publicSaleStart", type: "uint64" },
        { internalType: "uint64", name: "publicSaleEnd", type: "uint64" },
        { internalType: "uint64", name: "presaleStart", type: "uint64" },
        { internalType: "uint64", name: "presaleEnd", type: "uint64" },
        { internalType: "bytes32", name: "presaleMerkleRoot", type: "bytes32" },
      ],
      name: "setSaleConfiguration",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  gM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenIdMinted",
          type: "uint256",
        },
        { indexed: !1, internalType: "string", name: "uri", type: "string" },
      ],
      name: "TokensMinted",
      type: "event",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "cancel",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "string", name: "uri", type: "string" },
      ],
      name: "mintTo",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "revoke",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  bM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "_fromTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "_toTokenId",
          type: "uint256",
        },
      ],
      name: "BatchMetadataUpdate",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "_tokenId",
          type: "uint256",
        },
      ],
      name: "MetadataUpdate",
      type: "event",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_tokenId", type: "uint256" },
        { internalType: "string", name: "_uri", type: "string" },
      ],
      name: "setTokenURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  xM = [
    {
      inputs: [
        { internalType: "address", name: "account", type: "address" },
        { internalType: "uint256", name: "id", type: "uint256" },
        { internalType: "uint256", name: "value", type: "uint256" },
      ],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "account", type: "address" },
        { internalType: "uint256[]", name: "ids", type: "uint256[]" },
        { internalType: "uint256[]", name: "values", type: "uint256[]" },
      ],
      name: "burnBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  vM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "_receiver", type: "address" },
        { internalType: "uint256", name: "_tokenId", type: "uint256" },
        { internalType: "uint256", name: "_quantity", type: "uint256" },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_claimer", type: "address" },
        { internalType: "uint256", name: "_tokenId", type: "uint256" },
        { internalType: "uint256", name: "_quantity", type: "uint256" },
      ],
      name: "verifyClaim",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
  ],
  wM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "string", name: "metadata", type: "string" },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition.ClaimCondition[]",
          name: "claimConditions",
          type: "tuple[]",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionsUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "claimConditionIndex",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "receiver", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "quantity", type: "uint256" },
        { internalType: "address", name: "currency", type: "address" },
        { internalType: "uint256", name: "pricePerToken", type: "uint256" },
        {
          components: [
            { internalType: "bytes32[]", name: "proof", type: "bytes32[]" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          internalType: "struct IDrop1155.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "string", name: "metadata", type: "string" },
          ],
          internalType: "struct IClaimCondition.ClaimCondition[]",
          name: "phases",
          type: "tuple[]",
        },
        { internalType: "bool", name: "resetClaimEligibility", type: "bool" },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  L6 = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          indexed: !1,
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "claimConditions",
          type: "tuple[]",
        },
      ],
      name: "ClaimConditionsUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "maxTotalSupply",
          type: "uint256",
        },
      ],
      name: "MaxTotalSupplyUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "MaxWalletClaimCountUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "saleRecipient",
          type: "address",
        },
      ],
      name: "SaleRecipientForTokenUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "claimConditionIndex",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "endTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "baseURI",
          type: "string",
        },
      ],
      name: "TokensLazyMinted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !1,
          internalType: "uint256[]",
          name: "ids",
          type: "uint256[]",
        },
        {
          indexed: !1,
          internalType: "uint256[]",
          name: "values",
          type: "uint256[]",
        },
      ],
      name: "TransferBatch",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        { indexed: !1, internalType: "uint256", name: "id", type: "uint256" },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "TransferSingle",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, internalType: "string", name: "value", type: "string" },
        { indexed: !0, internalType: "uint256", name: "id", type: "uint256" },
      ],
      name: "URI",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "wallet",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "WalletClaimCountUpdated",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "account", type: "address" },
        { internalType: "uint256", name: "id", type: "uint256" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address[]", name: "accounts", type: "address[]" },
        { internalType: "uint256[]", name: "ids", type: "uint256[]" },
      ],
      name: "balanceOfBatch",
      outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "receiver", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "quantity", type: "uint256" },
        { internalType: "address", name: "currency", type: "address" },
        { internalType: "uint256", name: "pricePerToken", type: "uint256" },
        { internalType: "bytes32[]", name: "proofs", type: "bytes32[]" },
        {
          internalType: "uint256",
          name: "proofMaxQuantityPerTransaction",
          type: "uint256",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "account", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "string", name: "baseURIForTokens", type: "string" },
      ],
      name: "lazyMint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256[]", name: "ids", type: "uint256[]" },
        { internalType: "uint256[]", name: "amounts", type: "uint256[]" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeBatchTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "id", type: "uint256" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "phases",
          type: "tuple[]",
        },
        { internalType: "bool", name: "resetClaimEligibility", type: "bool" },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  TM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "string", name: "metadata", type: "string" },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition.ClaimCondition",
          name: "condition",
          type: "tuple",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "receiver", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "quantity", type: "uint256" },
        { internalType: "address", name: "currency", type: "address" },
        { internalType: "uint256", name: "pricePerToken", type: "uint256" },
        {
          components: [
            { internalType: "bytes32[]", name: "proof", type: "bytes32[]" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          internalType: "struct IDropSinglePhase1155.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            { internalType: "string", name: "metadata", type: "string" },
          ],
          internalType: "struct IClaimCondition.ClaimCondition",
          name: "phase",
          type: "tuple",
        },
        { internalType: "bool", name: "resetClaimEligibility", type: "bool" },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  CM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition_V1.ClaimCondition",
          name: "condition",
          type: "tuple",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "receiver", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "uint256", name: "quantity", type: "uint256" },
        { internalType: "address", name: "currency", type: "address" },
        { internalType: "uint256", name: "pricePerToken", type: "uint256" },
        {
          components: [
            { internalType: "bytes32[]", name: "proof", type: "bytes32[]" },
            {
              internalType: "uint256",
              name: "maxQuantityInAllowlist",
              type: "uint256",
            },
          ],
          internalType: "struct IDropSinglePhase1155_V1.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            { internalType: "uint256", name: "supplyClaimed", type: "uint256" },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
          ],
          internalType: "struct IClaimCondition_V1.ClaimCondition",
          name: "phase",
          type: "tuple",
        },
        { internalType: "bool", name: "resetClaimEligibility", type: "bool" },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  AM = [
    {
      inputs: [],
      name: "nextTokenIdToMint",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  $6 = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenIdMinted",
          type: "uint256",
        },
        { indexed: !1, internalType: "string", name: "uri", type: "string" },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityMinted",
          type: "uint256",
        },
      ],
      name: "TokensMinted",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "string", name: "uri", type: "string" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "mintTo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  EM = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenIdMinted",
          type: "uint256",
        },
        {
          components: [
            { internalType: "address", name: "to", type: "address" },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "royaltyBps", type: "uint256" },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "string", name: "uri", type: "string" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          indexed: !1,
          internalType: "struct ISignatureMintERC1155.MintRequest",
          name: "mintRequest",
          type: "tuple",
        },
      ],
      name: "TokensMintedWithSignature",
      type: "event",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "to", type: "address" },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "royaltyBps", type: "uint256" },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "string", name: "uri", type: "string" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          internalType: "struct ISignatureMintERC1155.MintRequest",
          name: "req",
          type: "tuple",
        },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "mintWithSignature",
      outputs: [{ internalType: "address", name: "signer", type: "address" }],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            { internalType: "address", name: "to", type: "address" },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "royaltyBps", type: "uint256" },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            { internalType: "uint256", name: "tokenId", type: "uint256" },
            { internalType: "string", name: "uri", type: "string" },
            { internalType: "uint256", name: "quantity", type: "uint256" },
            { internalType: "uint256", name: "pricePerToken", type: "uint256" },
            { internalType: "address", name: "currency", type: "address" },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            { internalType: "bytes32", name: "uid", type: "bytes32" },
          ],
          internalType: "struct ISignatureMintERC1155.MintRequest",
          name: "req",
          type: "tuple",
        },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "verify",
      outputs: [
        { internalType: "bool", name: "success", type: "bool" },
        { internalType: "address", name: "signer", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Ng = 256,
  U0 = "0|[1-9]\\d*",
  kM = `(${U0})\\.(${U0})\\.(${U0})`,
  _M = new RegExp(kM);
function qp(n) {
  if (n.length > Ng) throw new Error(`version is longer than ${Ng} characters`);
  const e = n.trim().match(_M);
  if (!e || (e == null ? void 0 : e.length) !== 4)
    throw new Error(
      `${n} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`,
    );
  const t = Number(e[1]),
    r = Number(e[2]),
    a = Number(e[3]),
    i = [t, r, a].join(".");
  return { major: t, minor: r, patch: a, versionString: i };
}
function SM(n, e) {
  const t = qp(n),
    r = qp(e);
  if (r.major > t.major) return !0;
  const a = r.major === t.major;
  if (a && r.minor > t.minor) return !0;
  const i = r.minor === t.minor;
  return a && i && r.patch > t.patch;
}
const rn = (() =>
    M.union([
      M.string(),
      M.number(),
      M.bigint(),
      M.custom((n) => O.isBigNumber(n)),
    ]).transform((n) => O.from(n)))(),
  _t = rn.transform((n) => n.toString()),
  PM = (() =>
    M.union([M.bigint(), M.custom((n) => O.isBigNumber(n))]).transform((n) =>
      O.from(n).toString(),
    ))();
function lm(n) {
  return !!(n && n._isSigner);
}
function W6(n) {
  return !!(n && n._isProvider);
}
const U6 = 50,
  j6 = 250,
  IM = { timeLimitMs: U6, sizeLimit: j6 };
class RM extends Jx {
  constructor(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : IM;
    super(e, t),
      (this._timeLimitMs = r.timeLimitMs || j6),
      (this._sizeLimit = r.sizeLimit || U6),
      (this._pendingBatchAggregator = null),
      (this._pendingBatch = null);
  }
  sendCurrentBatch(e) {
    this._pendingBatchAggregator && clearTimeout(this._pendingBatchAggregator);
    const t = this._pendingBatch || [];
    (this._pendingBatch = null), (this._pendingBatchAggregator = null);
    const r = t.map((a) => a.request);
    return (
      this.emit("debug", {
        action: "requestBatch",
        request: hn(e),
        provider: this,
      }),
      ro(this.connection, JSON.stringify(r)).then(
        (a) => {
          this.emit("debug", {
            action: "response",
            request: r,
            response: a,
            provider: this,
          }),
            t.forEach((i, s) => {
              const o = a[s];
              if (o)
                if (o.error) {
                  const c = new Error(o.error.message);
                  (c.code = o.error.code), (c.data = o.error.data), i.reject(c);
                } else i.resolve(o.result);
              else i.reject(new Error("No response for request"));
            });
        },
        (a) => {
          this.emit("debug", {
            action: "response",
            error: a,
            request: r,
            provider: this,
          }),
            t.forEach((i) => {
              i.reject(a);
            });
        },
      )
    );
  }
  send(e, t) {
    const r = { method: e, params: t, id: this._nextId++, jsonrpc: "2.0" };
    this._pendingBatch === null && (this._pendingBatch = []);
    const a = { request: r, resolve: null, reject: null },
      i = new Promise((s, o) => {
        (a.resolve = s), (a.reject = o);
      });
    return (
      this._pendingBatch.push(a),
      this._pendingBatch.length === this._sizeLimit && this.sendCurrentBatch(r),
      this._pendingBatchAggregator ||
        (this._pendingBatchAggregator = setTimeout(() => {
          this.sendCurrentBatch(r);
        }, this._timeLimitMs)),
      i
    );
  }
}
const MM = (() =>
    M.object({
      rpc: M.array(M.string().url()),
      chainId: M.number(),
      nativeCurrency: M.object({
        name: M.string(),
        symbol: M.string(),
        decimals: M.number(),
      }),
      slug: M.string(),
    }))(),
  Vp = (() =>
    M.object({
      supportedChains: M.array(MM).default(oi),
      clientId: M.string().optional(),
      secretKey: M.string().optional(),
      readonlySettings: M.object({
        rpcUrl: M.string().url(),
        chainId: M.number().optional(),
      }).optional(),
      gasSettings: M.object({
        maxPriceInGwei: M.number()
          .min(1, "gas price cannot be less than 1")
          .default(300),
        speed: M.enum(["standard", "fast", "fastest"]).default("fastest"),
      }).default({ maxPriceInGwei: 300, speed: "fastest" }),
      gasless: M.union([
        M.object({
          openzeppelin: M.object({
            relayerUrl: M.string().url(),
            relayerForwarderAddress: M.string().optional(),
            useEOAForwarder: M.boolean().default(!1),
            domainName: M.string().default("GSNv2 Forwarder"),
            domainVersion: M.string().default("0.0.1"),
          }),
          experimentalChainlessSupport: M.boolean().default(!1),
        }),
        M.object({
          biconomy: M.object({
            apiId: M.string(),
            apiKey: M.string(),
            deadlineSeconds: M.number()
              .min(1, "deadlineSeconds cannot be les than 1")
              .default(3600),
          }),
        }),
      ]).optional(),
      gatewayUrls: M.array(M.string()).optional(),
    }).default({ gasSettings: { maxPriceInGwei: 300, speed: "fastest" } }))();
function BM(n) {
  return n.supportedChains.reduce((e, t) => ((e[t.chainId] = t), e), {});
}
function Ln(n, e) {
  if (typeof n == "string" && OM(n)) return Gp(n, e);
  const t = Vp.parse(e);
  um(n) && (t.supportedChains = [n, ...t.supportedChains]);
  const r = BM(t);
  let a = "",
    i;
  try {
    (i = DM(n, t)), (a = Vd(r[i], t.clientId)[0]);
  } catch {}
  if ((a || (a = `https://${i || n}.rpc.thirdweb.com/${t.clientId}`), !a))
    throw new Error(
      `No rpc url found for chain ${n}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`,
    );
  return Gp(a, e, i);
}
function DM(n, e) {
  if (um(n)) return n.chainId;
  if (typeof n == "number") return n;
  {
    const t = e.supportedChains.reduce(
      (r, a) => ((r[a.slug] = a.chainId), r),
      {},
    );
    if (n in t) return t[n];
  }
  throw new Error(
    `Cannot resolve chainId from: ${n} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`,
  );
}
function um(n) {
  return typeof n != "string" && typeof n != "number" && !lm(n) && !W6(n);
}
function OM(n) {
  const e = n.match(/^(ws|http)s?:/i);
  if (e)
    switch (e[1].toLowerCase()) {
      case "http":
      case "https":
      case "ws":
      case "wss":
        return !0;
    }
  return !1;
}
const Fg = new Map();
function Gp(n, e, t) {
  try {
    const r = {};
    NM(n) &&
      (e != null && e.clientId
        ? ((r["x-client-id"] = e == null ? void 0 : e.clientId),
          n.includes("bundleId") ||
            (n =
              n +
              (typeof globalThis < "u" && "APP_BUNDLE_ID" in globalThis
                ? `?bundleId=${globalThis.APP_BUNDLE_ID}`
                : "")))
        : e != null &&
          e.secretKey &&
          (r["x-secret-key"] = e == null ? void 0 : e.secretKey),
      typeof globalThis < "u" &&
        "TW_AUTH_TOKEN" in globalThis &&
        (r.authorization = `Bearer ${globalThis.TW_AUTH_TOKEN}`));
    const a = n.match(/^(ws|http)s?:/i);
    if (a)
      switch (a[1].toLowerCase()) {
        case "http":
        case "https":
          const i = `${n}-${t || -1}`,
            s = Fg.get(i);
          if (s) return s;
          const o = t
            ? new RM({ url: n, headers: r }, t)
            : new EE({ url: n, headers: r });
          return Fg.set(i, o), o;
        case "ws":
        case "wss":
          return new jd(n, t);
      }
  } catch {}
  return RE(n);
}
function NM(n) {
  return new URL(n).hostname.endsWith(".thirdweb.com");
}
function Vt(n, e) {
  let t, r;
  if (
    (lm(n)
      ? ((t = n), n.provider && (r = n.provider))
      : W6(n)
      ? (r = n)
      : (r = Ln(n, e)),
    e != null &&
      e.readonlySettings &&
      (r = Gp(e.readonlySettings.rpcUrl, e, e.readonlySettings.chainId)),
    !r)
  )
    throw t
      ? new Error(
          "No provider passed to the SDK! Please make sure that your signer is connected to a provider!",
        )
      : new Error(
          "No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!",
        );
  return [t, r];
}
let j0;
const z0 = new Map();
async function z6(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  j0 || (j0 = Vt("ethereum")[1]);
  let t;
  z0.has(n)
    ? (t = z0.get(n))
    : (t = j0
        .resolveName(n)
        .then((a) =>
          a
            ? {
                address: a,
                expirationTime: new Date(Date.now() + 1e3 * 60 * 5),
              }
            : {
                address: null,
                expirationTime: new Date(Date.now() + 1e3 * 30),
              },
        ));
  const r = await t;
  return (
    r.expirationTime < new Date() && (z0.delete(n), e === 0 && z6(n, e + 1)),
    r.address
  );
}
const FM = (() =>
    M.custom(
      (n) =>
        typeof n == "string" && (n.endsWith(".eth") || n.endsWith(".cb.id")),
    )
      .transform(async (n) => z6(n))
      .refine((n) => !!n && Lc(n), {
        message: "Provided value was not a valid ENS name",
      }))(),
  H6 = M.custom(
    (n) => typeof n == "string" && Lc(n),
    (n) => ({ message: `${n} is not a valid address` }),
  ),
  at = M.union([H6, FM], {
    invalid_type_error: "Provided value was not a valid address or ENS name",
  });
let oe = (function (n) {
    return (
      (n[(n.Mainnet = 1)] = "Mainnet"),
      (n[(n.Goerli = 5)] = "Goerli"),
      (n[(n.Polygon = 137)] = "Polygon"),
      (n[(n.Mumbai = 80001)] = "Mumbai"),
      (n[(n.Localhost = 1337)] = "Localhost"),
      (n[(n.Hardhat = 31337)] = "Hardhat"),
      (n[(n.Fantom = 250)] = "Fantom"),
      (n[(n.FantomTestnet = 4002)] = "FantomTestnet"),
      (n[(n.Avalanche = 43114)] = "Avalanche"),
      (n[(n.AvalancheFujiTestnet = 43113)] = "AvalancheFujiTestnet"),
      (n[(n.Optimism = 10)] = "Optimism"),
      (n[(n.OptimismGoerli = 420)] = "OptimismGoerli"),
      (n[(n.Arbitrum = 42161)] = "Arbitrum"),
      (n[(n.ArbitrumGoerli = 421613)] = "ArbitrumGoerli"),
      (n[(n.BinanceSmartChainMainnet = 56)] = "BinanceSmartChainMainnet"),
      (n[(n.BinanceSmartChainTestnet = 97)] = "BinanceSmartChainTestnet"),
      n
    );
  })({}),
  Kp = oi;
function LM(n) {
  n && n.length > 0 ? (Kp = n) : (Kp = oi);
}
function $M() {
  return Kp;
}
const an = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
  Ru = {
    [oe.Mainnet]: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [oe.Goerli]: {
      name: "Görli Ether",
      symbol: "GOR",
      decimals: 18,
      wrapped: {
        address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    11155111: {
      name: "Sepolia Ether",
      symbol: "SEP",
      decimals: 18,
      wrapped: {
        address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [oe.Polygon]: {
      name: "Matic",
      symbol: "MATIC",
      decimals: 18,
      wrapped: {
        address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
        name: "Wrapped Matic",
        symbol: "WMATIC",
      },
    },
    [oe.Mumbai]: {
      name: "Matic",
      symbol: "MATIC",
      decimals: 18,
      wrapped: {
        address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
        name: "Wrapped Matic",
        symbol: "WMATIC",
      },
    },
    [oe.Avalanche]: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18,
      wrapped: {
        address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
        name: "Wrapped AVAX",
        symbol: "WAVAX",
      },
    },
    [oe.AvalancheFujiTestnet]: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18,
      wrapped: {
        address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
        name: "Wrapped AVAX",
        symbol: "WAVAX",
      },
    },
    [oe.Fantom]: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18,
      wrapped: {
        address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
        name: "Wrapped Fantom",
        symbol: "WFTM",
      },
    },
    [oe.FantomTestnet]: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18,
      wrapped: {
        address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
        name: "Wrapped Fantom",
        symbol: "WFTM",
      },
    },
    [oe.Arbitrum]: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [oe.ArbitrumGoerli]: {
      name: "Arbitrum Goerli Ether",
      symbol: "AGOR",
      decimals: 18,
      wrapped: {
        address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [oe.Optimism]: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x4200000000000000000000000000000000000006",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [oe.OptimismGoerli]: {
      name: "Goerli Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x4200000000000000000000000000000000000006",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [oe.BinanceSmartChainMainnet]: {
      name: "Binance Chain Native Token",
      symbol: "BNB",
      decimals: 18,
      wrapped: {
        address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
        name: "Wrapped Binance Chain Token",
        symbol: "WBNB",
      },
    },
    [oe.BinanceSmartChainTestnet]: {
      name: "Binance Chain Native Token",
      symbol: "TBNB",
      decimals: 18,
      wrapped: {
        address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
        name: "Wrapped Binance Chain Testnet Token",
        symbol: "WBNB",
      },
    },
    [oe.Hardhat]: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [oe.Localhost]: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    84531: {
      name: "Base Goerli Testnet",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x4200000000000000000000000000000000000006",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    280: {
      name: "zkSync Era Testnet",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
  };
function q6(n) {
  const e = $M().find((t) => t.chainId === n);
  return e && e.nativeCurrency
    ? {
        name: e.nativeCurrency.name,
        symbol: e.nativeCurrency.symbol,
        decimals: 18,
        wrapped: {
          address: Ie,
          name: `Wrapped ${e.nativeCurrency.name}`,
          symbol: `W${e.nativeCurrency.symbol}`,
        },
      }
    : Ru[n] || {
        name: "Ether",
        symbol: "ETH",
        decimals: 18,
        wrapped: { address: Ie, name: "Wrapped Ether", symbol: "WETH" },
      };
}
const gq = {
    [oe.Mainnet]: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
    [oe.Goerli]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
    [oe.BinanceSmartChainMainnet]: "0x404460C6A5EdE2D891e8297795264fDe62ADBB75",
    [oe.Polygon]: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1",
    [oe.Mumbai]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
    [oe.Avalanche]: "0x5947BB275c521040051D82396192181b413227A3",
    [oe.AvalancheFujiTestnet]: "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",
    [oe.Fantom]: "0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",
    [oe.FantomTestnet]: "0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F",
  },
  sf = (() =>
    M.union([
      M.date().transform((n) => O.from(Math.floor(n.getTime() / 1e3))),
      M.number().transform((n) => O.from(n)),
    ]))(),
  dm = (() => sf.default(new Date(0)))(),
  Qc = (() =>
    sf.default(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10)))(),
  WM = (() =>
    M.object({ name: M.string(), symbol: M.string(), decimals: M.number() }))(),
  UM = (() => WM.extend({ value: rn, displayValue: M.string() }))(),
  ci = (() => M.object({ merkle: M.record(M.string()).default({}) }))(),
  Qp = (() =>
    M.object({
      address: at,
      maxClaimable: Ls.default(0),
      price: Ls.optional(),
      currencyAddress: at.default(Ie).optional(),
    }))(),
  fm = (() =>
    M.union([
      M.array(M.string()).transform(
        async (n) =>
          await Promise.all(n.map((e) => Qp.parseAsync({ address: e }))),
      ),
      M.array(Qp),
    ]))(),
  V6 = (() => Qp.extend({ proof: M.array(M.string()) }))(),
  G6 = (() => M.object({ merkleRoot: M.string(), claims: M.array(V6) }))(),
  jM = (() =>
    M.object({ name: M.string().optional() }).catchall(M.unknown()))(),
  pm = (() =>
    M.object({
      startTime: dm,
      currencyAddress: M.string().default(an),
      price: Cn.default(0),
      maxClaimableSupply: Ls,
      maxClaimablePerWallet: Ls,
      waitInSeconds: _t.default(0),
      merkleRootHash: pk.default(Ue([0], 32)),
      snapshot: M.optional(fm).nullable(),
      metadata: jM.optional(),
    }))(),
  zM = M.array(pm),
  K6 = (() =>
    pm.extend({
      availableSupply: Ls,
      currentMintSupply: Ls,
      currencyMetadata: UM.default({
        value: O.from("0"),
        displayValue: "0",
        symbol: "",
        decimals: 18,
        name: "",
      }),
      price: rn,
      waitInSeconds: rn,
      startTime: rn.transform((n) => new Date(n.toNumber() * 1e3)),
      snapshot: fm.optional().nullable(),
    }))();
function Q6(n) {
  if (n === void 0) {
    const e = Buffer.alloc(16);
    return IR({}, e), pe(Ne(e.toString("hex")));
  } else return pe(n);
}
const hm = (() =>
    M.object({
      to: at.refine((n) => n.toLowerCase() !== Ie, {
        message: "Cannot create payload to mint to zero address",
      }),
      price: Cn.default(0),
      currencyAddress: H6.default(an),
      mintStartTime: dm,
      mintEndTime: Qc,
      uid: M.string()
        .optional()
        .transform((n) => Q6(n)),
      primarySaleRecipient: at.default(Ie),
    }))(),
  Y6 = hm.extend({ quantity: Cn }),
  HM = Y6.extend({ mintStartTime: rn, mintEndTime: rn }),
  mm = (() =>
    hm.extend({
      metadata: Gd,
      royaltyRecipient: M.string().default(Ie),
      royaltyBps: io.default(0),
    }))(),
  J6 = (() =>
    mm.extend({
      metadata: Gd.default(""),
      uri: M.string(),
      royaltyBps: rn,
      mintStartTime: rn,
      mintEndTime: rn,
    }))(),
  qM = (() => mm.extend({ metadata: Gd.default(""), quantity: _t }))(),
  VM = qM.extend({ tokenId: _t }),
  GM = J6.extend({ tokenId: rn, quantity: rn }),
  KM = (() =>
    mm.extend({ metadata: Gd.default(""), quantity: rn.default(1) }))(),
  QM = (() => J6.extend({ quantity: rn.default(1) }))(),
  YM = [
    { name: "to", type: "address" },
    { name: "primarySaleRecipient", type: "address" },
    { name: "quantity", type: "uint256" },
    { name: "price", type: "uint256" },
    { name: "currency", type: "address" },
    { name: "validityStartTimestamp", type: "uint128" },
    { name: "validityEndTimestamp", type: "uint128" },
    { name: "uid", type: "bytes32" },
  ],
  JM = [
    { name: "to", type: "address" },
    { name: "royaltyRecipient", type: "address" },
    { name: "royaltyBps", type: "uint256" },
    { name: "primarySaleRecipient", type: "address" },
    { name: "uri", type: "string" },
    { name: "price", type: "uint256" },
    { name: "currency", type: "address" },
    { name: "validityStartTimestamp", type: "uint128" },
    { name: "validityEndTimestamp", type: "uint128" },
    { name: "uid", type: "bytes32" },
  ],
  XM = [
    { name: "to", type: "address" },
    { name: "royaltyRecipient", type: "address" },
    { name: "royaltyBps", type: "uint256" },
    { name: "primarySaleRecipient", type: "address" },
    { name: "tokenId", type: "uint256" },
    { name: "uri", type: "string" },
    { name: "quantity", type: "uint256" },
    { name: "pricePerToken", type: "uint256" },
    { name: "currency", type: "address" },
    { name: "validityStartTimestamp", type: "uint128" },
    { name: "validityEndTimestamp", type: "uint128" },
    { name: "uid", type: "bytes32" },
  ],
  ZM = [
    { name: "to", type: "address" },
    { name: "royaltyRecipient", type: "address" },
    { name: "royaltyBps", type: "uint256" },
    { name: "primarySaleRecipient", type: "address" },
    { name: "uri", type: "string" },
    { name: "quantity", type: "uint256" },
    { name: "pricePerToken", type: "uint256" },
    { name: "currency", type: "address" },
    { name: "validityStartTimestamp", type: "uint128" },
    { name: "validityEndTimestamp", type: "uint128" },
    { name: "uid", type: "bytes32" },
  ],
  eB = [
    { name: "validityStartTimestamp", type: "uint128" },
    { name: "validityEndTimestamp", type: "uint128" },
    { name: "uid", type: "bytes32" },
    { name: "data", type: "bytes" },
  ],
  En = (() =>
    M.object({
      name: M.string(),
      description: M.string().optional(),
      image: Di.optional(),
      external_link: M.string().optional(),
      app_uri: M.string().optional(),
      social_urls: M.record(M.string()).optional(),
    }))(),
  cr = (() =>
    En.extend({ image: M.string().optional() }).catchall(M.unknown()))(),
  Bt = (() =>
    M.object({
      seller_fee_basis_points: io.default(0),
      fee_recipient: at.default(Ie),
    }))(),
  li = M.object({ primary_sale_recipient: at }),
  nr = (() =>
    M.object({
      platform_fee_basis_points: io.default(0),
      platform_fee_recipient: at.default(Ie),
    }))(),
  Wn = (() => M.object({ trusted_forwarders: M.array(at).default([]) }))(),
  It = (() => M.object({ symbol: M.string().default("") }))(),
  tB = (() => En.catchall(M.union([PM, M.unknown()])))(),
  X6 = (() => tB.merge(Bt.merge(ci).merge(It).partial()).catchall(M.any()))(),
  nB = (() => cr.merge(Bt.merge(ci).merge(It).partial()).catchall(M.any()))(),
  rB = (() => X6.merge(nr.merge(li).merge(Wn).partial()))(),
  Es = { deploy: rB, output: nB, input: X6 },
  Lg = (() =>
    M.object({ type: M.string(), name: M.string().default("") }).catchall(
      M.any(),
    ))(),
  $g = (() =>
    Lg.extend({
      stateMutability: M.string().optional(),
      components: M.array(Lg).optional(),
    }).catchall(M.any()))(),
  aB = (() =>
    M.object({
      type: M.string(),
      name: M.string().default(""),
      inputs: M.array($g).default([]),
      outputs: M.array($g).default([]),
    }).catchall(M.any()))(),
  mt = M.array(aB),
  of = (() =>
    M.object({
      name: M.string(),
      metadataUri: M.string(),
      bytecodeUri: M.string(),
      analytics: M.any().optional(),
    }).catchall(M.any()))(),
  Yp = (() => M.record(M.string(), M.string()))(),
  iB = (() =>
    M.object({
      factoryFunction: M.string(),
      params: M.array(M.object({ name: M.string(), type: M.string() })).default(
        [],
      ),
      customFactoryAddresses: Yp,
    }))(),
  sB = (() =>
    M.object({
      implementationAddresses: Yp,
      implementationInitializerFunction: M.string().default("initialize"),
      customFactoryInput: iB.optional(),
      factoryAddresses: Yp.optional(),
    }))(),
  oB = (() =>
    M.union([
      M.literal("standard"),
      M.literal("autoFactory"),
      M.literal("customFactory"),
    ]))(),
  cB = (() =>
    M.object({
      allNetworks: M.boolean().optional(),
      networksEnabled: M.array(M.number()).default([]),
    }))(),
  Z6 = (() =>
    M.object({
      version: M.string().refine(
        (n) => {
          try {
            return qp(n), !0;
          } catch {
            return !1;
          }
        },
        (n) => ({
          message: `'${n}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`,
        }),
      ),
      displayName: M.string().optional(),
      description: M.string().optional(),
      readme: M.string().optional(),
      license: M.string().optional(),
      changelog: M.string().optional(),
      tags: M.array(M.string()).optional(),
      audit: Di.nullable().optional(),
      logo: Di.nullable().optional(),
      isDeployableViaFactory: M.boolean().optional(),
      isDeployableViaProxy: M.boolean().optional(),
      factoryDeploymentData: sB.optional(),
      deployType: oB.optional(),
      networksForDeployment: cB.optional(),
      constructorParams: M.record(
        M.string(),
        M.object({
          displayName: M.string().optional(),
          description: M.string().optional(),
          defaultValue: M.string().optional(),
          hidden: M.boolean().optional(),
        }).catchall(M.any()),
      ).optional(),
      compositeAbi: mt.optional(),
    }).catchall(M.any()))(),
  lB = (() =>
    Z6.extend({
      audit: M.string().nullable().optional(),
      logo: M.string().nullable().optional(),
    }))(),
  uB = (() => of.merge(Z6).extend({ publisher: at.optional() }))(),
  dB = (() => of.merge(lB).extend({ publisher: at.optional() }))(),
  fB = (() =>
    M.object({
      name: M.string().optional(),
      bio: M.string().optional(),
      avatar: Di.nullable().optional(),
      website: M.string().optional(),
      twitter: M.string().optional(),
      telegram: M.string().optional(),
      facebook: M.string().optional(),
      github: M.string().optional(),
      medium: M.string().optional(),
      linkedin: M.string().optional(),
      reddit: M.string().optional(),
      discord: M.string().optional(),
    }))(),
  pB = (() => fB.extend({ avatar: M.string().nullable().optional() }))(),
  hB = (() =>
    M.object({ id: M.string(), timestamp: _t, metadataUri: M.string() }))(),
  ev = (() =>
    M.object({
      title: M.string().optional(),
      author: M.string().optional(),
      details: M.string().optional(),
      notice: M.string().optional(),
    }))(),
  mB = (() =>
    M.object({
      name: M.string(),
      abi: mt,
      metadata: M.record(M.string(), M.any()),
      info: ev,
      licenses: M.array(M.string().optional())
        .default([])
        .transform((n) => n.filter((e) => e !== void 0)),
    }))(),
  yB = (() => of.merge(mB).extend({ bytecode: M.string() }))(),
  gB = (() =>
    M.object({
      gasLimit: _t.optional(),
      gasPrice: _t.optional(),
      maxFeePerGas: _t.optional(),
      maxPriorityFeePerGas: _t.optional(),
      nonce: _t.optional(),
      value: _t.optional(),
      blockTag: M.union([M.string(), M.number()]).optional(),
      from: at.optional(),
      type: M.number().optional(),
    }).strict())();
class cf {
  constructor(e) {
    this.contractWrapper = e;
  }
  encode(e, t) {
    return this.contractWrapper.readContract.interface.encodeFunctionData(e, t);
  }
  decode(e, t) {
    return this.contractWrapper.readContract.interface.decodeFunctionData(e, t);
  }
}
class tv extends Error {
  constructor(e) {
    super(e ? `Object with id ${e} NOT FOUND` : "NOT_FOUND");
  }
}
class bB extends Error {
  constructor(e, t) {
    super(`MISSING ROLE: ${e} does not have the '${t}' role`);
  }
}
class xB extends Error {
  constructor(e) {
    super(`DUPLICATE_LEAFS${e ? ` : ${e}` : ""}`);
  }
}
class bq extends Error {
  constructor(e) {
    super(`Auction already started with existing bid${e ? `, id: ${e}` : ""}`);
  }
}
class xq extends Error {
  constructor(e, t) {
    super(
      `Could not find listing.${e ? ` marketplace address: ${e}` : ""}${
        t ? ` listing id: ${t}` : ""
      }`,
    );
  }
}
class vq extends Error {
  constructor(e, t, r, a) {
    super(
      `Incorrect listing type. Are you sure you're using the right method?.${
        e ? ` marketplace address: ${e}` : ""
      }${t ? ` listing id: ${t}` : ""}${a ? ` expected type: ${a}` : ""}${
        r ? ` actual type: ${r}` : ""
      }`,
    );
  }
}
class H0 extends Error {
  constructor(e, t) {
    super(
      `Auction has not ended yet${e ? `, id: ${e}` : ""}${
        t ? `, end time: ${t.toString()}` : ""
      }`,
    );
  }
}
class $s extends Error {
  constructor(e) {
    super(
      `This functionality is not available because the contract does not implement the '${e.docLinks.contracts}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/extensions `,
    );
  }
}
var Bc, Dc, Oc;
class ym extends Error {
  constructor(t, r) {
    var i;
    let a = `


╔═══════════════════╗
║ TRANSACTION ERROR ║
╚═══════════════════╝

`;
    if (
      ((a += `Reason: ${t.reason}`),
      (a += `


╔═════════════════════════╗
║ TRANSACTION INFORMATION ║
╚═════════════════════════╝
`),
      (a += Aa("from", t.from)),
      t.to &&
        (a += Aa("to", t.contractName ? `${t.to} (${t.contractName})` : t.to)),
      (a += Aa("chain", `${t.network.name} (${t.network.chainId})`)),
      t.rpcUrl)
    )
      try {
        const s = new URL(t.rpcUrl);
        a += Aa("rpc", s.hostname);
      } catch {}
    if (
      (t.hash && (a += Aa("tx hash", t.hash)),
      t.value &&
        t.value.gt(0) &&
        (a += Aa(
          "value",
          `${zd(t.value)} ${
            ((i = Ru[t.network.chainId]) == null ? void 0 : i.symbol) || ""
          }`,
        )),
      (a += Aa("data", `${t.data}`)),
      t.method && (a += Aa("method", t.method)),
      t.sources)
    ) {
      const s = t.sources.find((o) => o.source.includes(t.reason));
      if (s) {
        const o = s.source
            .split(
              `
`,
            )
            .map((u, d) => `${d + 1}  ${u}`),
          c = o.findIndex((u) => u.includes(t.reason));
        o[c] += "   <-- REVERT";
        const l = o.slice(c - 8, c + 4);
        (a += `


╔══════════════════════╗
║ SOLIDITY STACK TRACE ║
╚══════════════════════╝

`),
          (a += `File: ${s.filename.replace("node_modules/", "")}

`),
          (a += l.join(`
`));
      }
    }
    (a += `


╔═════════════════════╗
║ DEBUGGING RESOURCES ║
╚═════════════════════╝

`),
      (a +=
        "Need helping debugging? Join our Discord: https://discord.gg/thirdweb"),
      (a += `

`);
    super(a);
    al(this, Bc, void 0);
    al(this, Dc, void 0);
    al(this, Oc, void 0);
    il(this, Bc, t.reason), il(this, Dc, t), il(this, Oc, r);
  }
  get reason() {
    return rl(this, Bc);
  }
  get raw() {
    return rl(this, Oc);
  }
  get info() {
    return rl(this, Dc);
  }
}
(Bc = new WeakMap()), (Dc = new WeakMap()), (Oc = new WeakMap());
function gm(n) {
  if (n.reason && !n.reason.includes("cannot estimate gas")) return n.reason;
  if (n.error) return n.error;
  let e = n;
  return (
    typeof n == "object"
      ? (e = JSON.stringify(n))
      : typeof n != "string" && (e = n.toString()),
    Wg(/.*?"message":"([^"\\]*).*?/, e) ||
      Wg(/.*?"reason":"([^"\\]*).*?/, e) ||
      n.message ||
      ""
  );
}
function Aa(n, e) {
  if (e === "") return e;
  const t = Array(10 - n.length)
    .fill(" ")
    .join("");
  return (
    e.includes(`
`)
      ? (e =
          `

  ` +
          e.split(`
`).join(`
  `))
      : (e = `${t}${e}`),
    `
${n}:${e}`
  );
}
function Wg(n, e) {
  const t = e.match(n) || [];
  let r = "";
  return (t == null ? void 0 : t.length) > 0 && (r += t[1]), r;
}
function Mu(n, e) {
  return n
    ? (n && n.toString().includes(e)) ||
        (n && n.message && n.message.toString().includes(e)) ||
        (n && n.error && n.error.toString().includes(e))
    : !1;
}
const Ug = {
    name: "ERC20ClaimConditionsV1",
    namespace: "token.drop.claim",
    docLinks: { sdk: "sdk.erc20dclaimable", contracts: "erc20claimconditions" },
    abis: [mn, D6],
    features: {},
  },
  dc = {
    name: "ERC20ClaimConditionsV2",
    namespace: "token.drop.claim",
    docLinks: { sdk: "sdk.erc20dclaimable", contracts: "erc20claimconditions" },
    abis: [mn, B6],
    features: {},
  },
  jg = {
    name: "ERC20ClaimPhasesV2",
    namespace: "token.drop.claim",
    docLinks: { sdk: "sdk.erc20dclaimable", contracts: "erc20claimphases" },
    abis: [mn, M6],
    features: {},
  },
  zg = {
    name: "ERC20ClaimPhasesV1",
    namespace: "token.drop.claim",
    docLinks: { sdk: "sdk.erc20dclaimable", contracts: "erc20claimphases" },
    abis: [rM],
    features: {},
  },
  fc = {
    name: "ERC20Burnable",
    namespace: "token.burn",
    docLinks: { sdk: "sdk.erc20burnable", contracts: "erc20burnable" },
    abis: [mn, nM],
    features: {},
  },
  Bu = {
    name: "ERC20SignatureMintable",
    namespace: "token.signature",
    docLinks: {
      sdk: "sdk.erc20signaturemintable",
      contracts: "erc20signaturemint",
    },
    abis: [mn, iM],
    features: {},
  },
  Du = {
    name: "ERC20BatchMintable",
    namespace: "token.mint.batch",
    docLinks: {
      sdk: "sdk.erc20batchmintable",
      contracts: "erc20batchmintable",
    },
    abis: [mn, O6, cm],
    features: {},
  },
  pc = {
    name: "ERC20Mintable",
    namespace: "token.mint",
    docLinks: { sdk: "sdk.erc20mintable", contracts: "erc20mintable" },
    abis: [mn, O6],
    features: { [Du.name]: Du },
  },
  Hg = {
    name: "ERC20Permit",
    namespace: "token.permit",
    docLinks: { sdk: "sdk.erc20permit", contracts: "erc20permit" },
    abis: [mn, aM],
    features: {},
  },
  Ou = {
    name: "ERC20",
    namespace: "token",
    docLinks: { sdk: "sdk.erc20", contracts: "erc20" },
    abis: [mn],
    features: {
      [fc.name]: fc,
      [pc.name]: pc,
      [Ug.name]: Ug,
      [dc.name]: dc,
      [zg.name]: zg,
      [jg.name]: jg,
      [Bu.name]: Bu,
      [Hg.name]: Hg,
    },
  },
  Nu = {
    name: "ERC721Burnable",
    namespace: "nft.burn",
    docLinks: { sdk: "sdk.erc721burnable", contracts: "erc721burnable" },
    abis: [Pt, sM],
    features: {},
  },
  Fu = {
    name: "ERC721Revealable",
    namespace: "nft.drop.revealer",
    docLinks: { sdk: "sdk.delayedreveal", contracts: "erc721revealable" },
    abis: [Pt, af, N6],
    features: {},
  },
  Lu = {
    name: "ERC721TieredDrop",
    namespace: "nft.tieredDrop",
    docLinks: { sdk: "sdk.erc721tiereddrop", contracts: "" },
    abis: [Pt, hM],
    features: {},
  },
  qg = {
    name: "ERC721ClaimConditionsV1",
    namespace: "nft.drop.claim",
    docLinks: {
      sdk: "sdk.erc721claimable",
      contracts: "erc721claimconditions",
    },
    abis: [Pt, D6],
    features: {},
  },
  $u = {
    name: "ERC721ClaimConditionsV2",
    namespace: "nft.drop.claim",
    docLinks: {
      sdk: "sdk.erc721claimable",
      contracts: "erc721claimconditions",
    },
    abis: [Pt, B6],
    features: {},
  },
  Vg = {
    name: "ERC721ClaimPhasesV1",
    namespace: "nft.drop.claim",
    docLinks: { sdk: "sdk.erc721claimable", contracts: "erc721claimphases" },
    abis: [cM],
    features: {},
  },
  Gg = {
    name: "ERC721ClaimPhasesV2",
    namespace: "nft.drop.claim",
    docLinks: { sdk: "sdk.erc721claimable", contracts: "erc721claimphases" },
    abis: [Pt, M6],
    features: {},
  },
  hc = {
    name: "ERC721ClaimCustom",
    namespace: "nft.drop.claim",
    docLinks: { sdk: "sdk.erc721claimable", contracts: "erc721claimcustom" },
    abis: [Pt, oM],
    features: {},
  },
  Jp = {
    name: "ERC721ClaimZora",
    namespace: "nft.drop.claim",
    docLinks: { sdk: "sdk.erc721claimable", contracts: "erc721claimzora" },
    abis: [Pt, yM],
    features: {},
  },
  Wu = {
    name: "ERC721LazyMintable",
    namespace: "nft.drop",
    docLinks: { sdk: "sdk.erc721lazymintable", contracts: "lazymint" },
    abis: [Pt, af],
    features: { [Fu.name]: Fu },
  },
  Uu = {
    name: "ERC721BatchMintable",
    namespace: "nft.mint.batch",
    docLinks: {
      sdk: "sdk.erc721batchmintable",
      contracts: "erc721batchmintable",
    },
    abis: [Pt, F6, cm],
    features: {},
  },
  ju = {
    name: "ERC721Mintable",
    namespace: "nft.mint",
    docLinks: { sdk: "sdk.erc721mintable", contracts: "erc721mintable" },
    abis: [Pt, F6],
    features: { [Uu.name]: Uu },
  },
  zu = {
    name: "ERC721SignatureMintV2",
    namespace: "nft.signature",
    docLinks: {
      sdk: "sdk.erc721signaturemint",
      contracts: "erc721signaturemint",
    },
    abis: [Pt, fM],
    features: {},
  },
  Kg = {
    name: "ERC721SignatureMintV1",
    namespace: "nft.signature",
    docLinks: {
      sdk: "sdk.erc721signaturemint",
      contracts: "erc721signaturemint",
    },
    abis: [pM],
    features: {},
  },
  Xp = {
    name: "ERC721Enumerable",
    namespace: "nft.query.owned",
    docLinks: { sdk: "sdk.erc721enumerable", contracts: "erc721enumerable" },
    abis: [Pt, lM],
    features: {},
  },
  Zp = {
    name: "ERC721AQueryable",
    namespace: "nft.query.owned",
    docLinks: { sdk: "", contracts: "" },
    abis: [uM],
    features: {},
  },
  ks = {
    name: "ERC721Supply",
    namespace: "nft.query",
    docLinks: { sdk: "sdk.erc721supply", contracts: "erc721supply" },
    abis: [Pt, dM],
    features: { [Xp.name]: Xp, [Zp.name]: Zp },
  },
  Hu = {
    name: "ERC721SharedMetadata",
    namespace: "nft.sharedmetadata",
    docLinks: { sdk: "sdk.sharedmetadata", contracts: "SharedMetadata" },
    abis: [Pt, mM],
    features: {},
  },
  Ni = {
    name: "ERC721LoyaltyCard",
    namespace: "nft.loyaltyCard",
    docLinks: { sdk: "", contracts: "" },
    abis: [gM],
    features: {},
  },
  Ws = {
    name: "ERC721UpdatableMetadata",
    namespace: "nft.metadata",
    docLinks: { sdk: "", contracts: "" },
    abis: [bM],
    features: {},
  },
  qu = {
    name: "ERC721",
    namespace: "nft",
    docLinks: { sdk: "sdk.erc721", contracts: "erc721" },
    abis: [Pt],
    features: {
      [Nu.name]: Nu,
      [ks.name]: ks,
      [ju.name]: ju,
      [Wu.name]: Wu,
      [Kg.name]: Kg,
      [zu.name]: zu,
      [Lu.name]: Lu,
      [hc.name]: hc,
      [Jp.name]: Jp,
      [qg.name]: qg,
      [$u.name]: $u,
      [Vg.name]: Vg,
      [Gg.name]: Gg,
      [Hu.name]: Hu,
      [Ni.name]: Ni,
      [Ws.name]: Ws,
    },
  },
  wi = {
    name: "ERC1155Burnable",
    namespace: "edition.burn",
    docLinks: { sdk: "sdk.erc1155burnable", contracts: "erc1155burnable" },
    abis: [yn, xM],
    features: {},
  },
  Qg = {
    name: "ERC1155ClaimConditionsV1",
    namespace: "edition.drop.claim",
    docLinks: {
      sdk: "sdk.erc1155claimable",
      contracts: "erc1155dropsinglephase",
    },
    abis: [yn, CM],
    features: {},
  },
  Vu = {
    name: "ERC1155ClaimConditionsV2",
    namespace: "edition.drop.claim",
    docLinks: {
      sdk: "sdk.erc1155claimable",
      contracts: "erc1155claimconditions",
    },
    abis: [yn, TM],
    features: {},
  },
  Yg = {
    name: "ERC1155ClaimPhasesV2",
    namespace: "edition.drop.claim",
    docLinks: { sdk: "sdk.erc1155claimable", contracts: "erc1155claimphases" },
    abis: [yn, wM],
    features: {},
  },
  Jg = {
    name: "ERC1155ClaimPhasesV1",
    namespace: "edition.drop.claim",
    docLinks: { sdk: "sdk.erc1155claimable", contracts: "erc1155claimphases" },
    abis: [L6],
    features: {},
  },
  mc = {
    name: "ERC1155ClaimCustom",
    namespace: "edition.drop.claim",
    docLinks: { sdk: "sdk.erc1155claimable", contracts: "erc1155claimcustom" },
    abis: [yn, vM],
    features: {},
  },
  Us = {
    name: "ERC1155Revealable",
    namespace: "edition.drop.revealer",
    docLinks: { sdk: "sdk.drop.delayedreveal", contracts: "erc1155revealable" },
    abis: [yn, af, N6],
    features: {},
  },
  Gu = {
    name: "ERC1155LazyMintableV2",
    namespace: "edition.drop",
    docLinks: { sdk: "sdk.erc1155droppable", contracts: "lazymint" },
    abis: [yn, af],
    features: { [Us.name]: Us },
  },
  Xg = {
    name: "ERC1155LazyMintableV1",
    namespace: "edition.drop",
    docLinks: { sdk: "sdk.erc1155droppable", contracts: "lazymint" },
    abis: [L6],
    features: { [Jg.name]: Jg },
  },
  Ku = {
    name: "ERC1155SignatureMintable",
    namespace: "edition.signature",
    docLinks: {
      sdk: "sdk.erc1155signaturemintable",
      contracts: "erc1155signaturemint",
    },
    abis: [yn, EM],
    features: {},
  },
  Qu = {
    name: "ERC1155BatchMintable",
    namespace: "edition.mint.batch",
    docLinks: {
      sdk: "sdk.erc1155batchmintable",
      contracts: "erc1155batchmintable",
    },
    abis: [yn, $6, cm],
    features: {},
  },
  Ti = {
    name: "ERC1155Mintable",
    namespace: "edition.mint",
    docLinks: { sdk: "sdk.erc1155mintable", contracts: "erc1155mintable" },
    abis: [yn, $6],
    features: { [Qu.name]: Qu },
  },
  Ci = {
    name: "ERC1155Enumerable",
    namespace: "edition.query",
    docLinks: { sdk: "sdk.erc1155", contracts: "erc1155enumerable" },
    abis: [yn, AM],
    features: {},
  },
  Yu = {
    name: "ERC1155",
    namespace: "edition",
    docLinks: { sdk: "sdk.erc1155enumerable", contracts: "erc1155" },
    abis: [yn],
    features: {
      [wi.name]: wi,
      [Ci.name]: Ci,
      [Ti.name]: Ti,
      [Xg.name]: Xg,
      [Gu.name]: Gu,
      [Us.name]: Us,
      [Ku.name]: Ku,
      [mc.name]: mc,
      [Qg.name]: Qg,
      [Vu.name]: Vu,
      [Yg.name]: Yg,
    },
  },
  bm = [
    {
      inputs: [],
      name: "getAllPlugins",
      outputs: [
        {
          components: [
            {
              internalType: "bytes4",
              name: "functionSelector",
              type: "bytes4",
            },
            {
              internalType: "string",
              name: "functionSignature",
              type: "string",
            },
            { internalType: "address", name: "pluginAddress", type: "address" },
          ],
          internalType: "struct IPluginMap.Plugin[]",
          name: "registered",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  nv = [
    {
      inputs: [],
      name: "getAllExtensions",
      outputs: [
        {
          components: [
            {
              components: [
                { internalType: "string", name: "name", type: "string" },
                { internalType: "string", name: "metadataURI", type: "string" },
                {
                  internalType: "address",
                  name: "implementation",
                  type: "address",
                },
              ],
              internalType: "struct IExtension.ExtensionMetadata",
              name: "metadata",
              type: "tuple",
            },
            {
              components: [
                {
                  internalType: "bytes4",
                  name: "functionSelector",
                  type: "bytes4",
                },
                {
                  internalType: "string",
                  name: "functionSignature",
                  type: "string",
                },
              ],
              internalType: "struct IExtension.ExtensionFunction[]",
              name: "functions",
              type: "tuple[]",
            },
          ],
          internalType: "struct IExtension.Extension[]",
          name: "allExtensions",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Ju = {
    name: "Royalty",
    namespace: "royalty",
    docLinks: { sdk: "sdk.contractroyalty", contracts: "royalty" },
    abis: [JR],
    features: {},
  },
  Xu = {
    name: "PrimarySale",
    namespace: "sales",
    docLinks: { sdk: "sdk.contractprimarysale", contracts: "primarysale" },
    abis: [YR],
    features: {},
  },
  Zu = {
    name: "PlatformFee",
    namespace: "platformFees",
    docLinks: { sdk: "sdk.platformfee", contracts: "platformfee" },
    abis: [QR],
    features: {},
  },
  Zg = {
    name: "PermissionsEnumerable",
    namespace: "roles",
    docLinks: { sdk: "sdk.contractroles", contracts: "permissionsenumerable" },
    abis: [KR],
    features: {},
  },
  ed = {
    name: "Permissions",
    namespace: "roles",
    docLinks: { sdk: "sdk.contractroles", contracts: "permissions" },
    abis: [GR],
    features: { [Zg.name]: Zg },
  },
  td = {
    name: "ContractMetadata",
    namespace: "metadata",
    docLinks: { sdk: "sdk.contractmetadata", contracts: "contractmetadata" },
    abis: [jR],
    features: {},
  },
  nd = {
    name: "AppURI",
    namespace: "appURI",
    docLinks: { sdk: "sdk.appURI", contracts: "" },
    abis: [UR],
    features: {},
  },
  rd = {
    name: "Ownable",
    namespace: "owner",
    docLinks: { sdk: "sdk.owner", contracts: "ownable" },
    abis: [XR],
    features: {},
  },
  eb = {
    name: "Gasless",
    namespace: "gasless",
    docLinks: { sdk: "sdk.gaslesstransaction", contracts: "" },
    abis: [WR],
    features: {},
  },
  tb = {
    name: "PackVRF",
    namespace: "pack.vrf",
    docLinks: { sdk: "sdk.packvrf", contracts: "" },
    abis: [VR],
    features: {},
  },
  nb = {
    name: "PluginRouter",
    namespace: "plugin.router",
    docLinks: { sdk: "sdk.pluginrouter", contracts: "" },
    abis: [bm],
    features: {},
  },
  rb = {
    name: "ExtensionRouter",
    namespace: "extension.router",
    docLinks: { sdk: "", contracts: "" },
    abis: [nv],
    features: {},
  },
  ad = {
    name: "DirectListings",
    namespace: "direct.listings",
    docLinks: { sdk: "", contracts: "" },
    abis: [zR],
    features: {},
  },
  id = {
    name: "EnglishAuctions",
    namespace: "english.auctions",
    docLinks: { sdk: "", contracts: "" },
    abis: [HR],
    features: {},
  },
  sd = {
    name: "Offers",
    namespace: "offers",
    docLinks: { sdk: "", contracts: "" },
    abis: [qR],
    features: {},
  },
  yc = {
    name: "AccountFactory",
    namespace: "accountFactory",
    docLinks: { sdk: "sdk.accountFactory", contracts: "" },
    abis: [ZR],
    features: {},
  },
  gc = {
    name: "Account",
    namespace: "account",
    docLinks: { sdk: "sdk.account", contracts: "" },
    abis: [eM],
    features: {},
  },
  vB = {
    [Ou.name]: Ou,
    [qu.name]: qu,
    [Yu.name]: Yu,
    [Ju.name]: Ju,
    [Zu.name]: Zu,
    [Xu.name]: Xu,
    [ed.name]: ed,
    [td.name]: td,
    [nd.name]: nd,
    [rd.name]: rd,
    [eb.name]: eb,
    [tb.name]: tb,
    [nb.name]: nb,
    [rb.name]: rb,
    [ad.name]: ad,
    [id.name]: id,
    [sd.name]: sd,
    [yc.name]: yc,
    [gc.name]: gc,
    [Ni.name]: Ni,
    [Ws.name]: Ws,
  };
function eh(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    r = n.type,
    a = !1;
  return (
    r.endsWith("[]") && ((a = !0), (r = r.slice(0, -2))),
    r.startsWith("bytes") && (r = "BytesLike"),
    (r.startsWith("uint") || r.startsWith("int")) &&
      (r = e ? "BigNumber" : "BigNumberish"),
    r.startsWith("bool") && (r = "boolean"),
    r === "address" && (r = "string"),
    r === "tuple" &&
      n.components &&
      (r = `{ ${n.components.map((i) => eh(i, !1, !0)).join(", ")} }`),
    a && (r += "[]"),
    t && (r = `${n.name}: ${r}`),
    r
  );
}
function rv(n, e, t) {
  var r, a, i, s, o, c, l, u, d, f;
  return (
    ((o =
      (s =
        (a =
          (r = e == null ? void 0 : e.output) == null ? void 0 : r.userdoc) ==
        null
          ? void 0
          : a[t]) == null
        ? void 0
        : s[
            Object.keys(
              ((i = e == null ? void 0 : e.output) == null
                ? void 0
                : i.userdoc[t]) || {},
            ).find((p) => p.includes(n || "unknown")) || ""
          ]) == null
      ? void 0
      : o.notice) ||
    ((f =
      (d =
        (l = (c = e == null ? void 0 : e.output) == null ? void 0 : c.devdoc) ==
        null
          ? void 0
          : l[t]) == null
        ? void 0
        : d[
            Object.keys(
              ((u = e == null ? void 0 : e.output) == null
                ? void 0
                : u.devdoc[t]) || {},
            ).find((p) => p.includes(n || "unknown")) || ""
          ]) == null
      ? void 0
      : f.details)
  );
}
function bc(n, e) {
  var a, i, s, o;
  const t = (n || []).filter((c) => c.type === "function"),
    r = [];
  for (const c of t) {
    const l = rv(c.name, e, "methods"),
      u =
        ((i =
          (a = c.inputs) == null
            ? void 0
            : a.map((y) => `${y.name || "key"}: ${eh(y)}`)) == null
          ? void 0
          : i.join(", ")) || "",
      d = u ? `, [${u}]` : "",
      f =
        (o = (s = c.outputs) == null ? void 0 : s.map((y) => eh(y, !0))) == null
          ? void 0
          : o.join(", "),
      p = f ? `: Promise<${f}>` : ": Promise<TransactionResult>",
      m = `contract.call("${c.name}"${d})${p}`;
    r.push({
      inputs: c.inputs || [],
      outputs: c.outputs || [],
      name: c.name || "unknown",
      signature: m,
      stateMutability: c.stateMutability || "",
      comment: l,
    });
  }
  return r;
}
function wB(n, e) {
  const t = bc(n),
    r = e.flatMap((i) => bc(i));
  return (
    t.filter(
      (i) =>
        r.find(
          (o) =>
            o.name === i.name &&
            o.inputs.length === i.inputs.length &&
            o.inputs.every((c, l) => {
              var u;
              return c.type === "tuple" || c.type === "tuple[]"
                ? c.type === i.inputs[l].type &&
                    ((u = c.components) == null
                      ? void 0
                      : u.every((d, f) => {
                          var p, m;
                          return (
                            d.type ===
                            ((m =
                              (p = i.inputs[l].components) == null
                                ? void 0
                                : p[f]) == null
                              ? void 0
                              : m.type)
                          );
                        }))
                : c.type === i.inputs[l].type;
            }),
        ) !== void 0,
    ).length === r.length
  );
}
function xm(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : vB;
  const t = {};
  for (const r in e) {
    const a = e[r],
      i = TB(n, a),
      s = xm(n, a.features);
    t[r] = { ...a, features: s, enabled: i };
  }
  return t;
}
function TB(n, e) {
  return wB(n, e.abis);
}
function js(n, e) {
  const t = xm(n);
  return av(t, e);
}
function av(n, e) {
  const t = Object.keys(n);
  if (!t.includes(e)) {
    let a = !1;
    for (const i of t) {
      const s = n[i];
      if (((a = av(s.features, e)), a)) break;
    }
    return a;
  }
  return n[e].enabled;
}
function fe(n, e) {
  return js(mt.parse(n.abi), e);
}
function vt(n, e) {
  return n in e.readContract.functions;
}
let th;
try {
  th = new TextDecoder();
} catch {}
let ye,
  _i,
  ee = 0;
const CB = 105,
  AB = 57342,
  EB = 57343,
  ab = 57337,
  ib = 6,
  is = {};
let Be = {},
  ft,
  od,
  cd = 0,
  xc = 0,
  St,
  mr,
  ut = [],
  nh = [],
  vn,
  dn,
  Wo,
  sb = { useRecords: !1, mapsAsObjects: !0 },
  rh = !1;
class ld {
  constructor(e) {
    if (
      e &&
      ((e.keyMap || e._keyMap) &&
        !e.useRecords &&
        ((e.useRecords = !1), (e.mapsAsObjects = !0)),
      e.useRecords === !1 &&
        e.mapsAsObjects === void 0 &&
        (e.mapsAsObjects = !0),
      e.getStructures && (e.getShared = e.getStructures),
      e.getShared && !e.structures && ((e.structures = []).uninitialized = !0),
      e.keyMap)
    ) {
      this.mapKey = new Map();
      for (let [t, r] of Object.entries(e.keyMap)) this.mapKey.set(r, t);
    }
    Object.assign(this, e);
  }
  decodeKey(e) {
    return (this.keyMap && this.mapKey.get(e)) || e;
  }
  decode(e, t) {
    if (ye)
      return cv(
        () => (
          lv(), this ? this.decode(e, t) : ld.prototype.decode.call(sb, e, t)
        ),
      );
    (_i = t > -1 ? t : e.length),
      (ee = 0),
      (xc = 0),
      (od = null),
      (St = null),
      (ye = e);
    try {
      dn =
        e.dataView ||
        (e.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength));
    } catch (r) {
      throw (
        ((ye = null),
        e instanceof Uint8Array
          ? r
          : new Error(
              "Source must be a Uint8Array or Buffer but was a " +
                (e && typeof e == "object" ? e.constructor.name : typeof e),
            ))
      );
    }
    if (this instanceof ld) {
      if (
        ((Be = this),
        (vn =
          this.sharedValues &&
          (this.pack
            ? new Array(this.maxPrivatePackedValues || 16).concat(
                this.sharedValues,
              )
            : this.sharedValues)),
        this.structures)
      )
        return (ft = this.structures), ob();
      (!ft || ft.length > 0) && (ft = []);
    } else (Be = sb), (!ft || ft.length > 0) && (ft = []), (vn = null);
    return ob();
  }
}
function ob() {
  try {
    let n = $e();
    if (St) {
      if (ee >= St.postBundlePosition) {
        let e = new Error("Unexpected bundle position");
        throw ((e.incomplete = !0), e);
      }
      (ee = St.postBundlePosition), (St = null);
    }
    if (ee == _i) (ft = null), (ye = null), mr && (mr = null);
    else if (ee > _i) {
      let e = new Error("Unexpected end of CBOR data");
      throw ((e.incomplete = !0), e);
    } else if (!rh) throw new Error("Data read, but end of buffer not reached");
    return n;
  } catch (n) {
    throw (
      (lv(),
      (n instanceof RangeError ||
        n.message.startsWith("Unexpected end of buffer")) &&
        (n.incomplete = !0),
      n)
    );
  }
}
function $e() {
  let n = ye[ee++],
    e = n >> 5;
  if (((n = n & 31), n > 23))
    switch (n) {
      case 24:
        n = ye[ee++];
        break;
      case 25:
        if (e == 7) return PB();
        (n = dn.getUint16(ee)), (ee += 2);
        break;
      case 26:
        if (e == 7) {
          let t = dn.getFloat32(ee);
          if (Be.useFloat32 > 2) {
            let r = uv[((ye[ee] & 127) << 1) | (ye[ee + 1] >> 7)];
            return (ee += 4), ((r * t + (t > 0 ? 0.5 : -0.5)) >> 0) / r;
          }
          return (ee += 4), t;
        }
        (n = dn.getUint32(ee)), (ee += 4);
        break;
      case 27:
        if (e == 7) {
          let t = dn.getFloat64(ee);
          return (ee += 8), t;
        }
        if (e > 1) {
          if (dn.getUint32(ee) > 0)
            throw new Error(
              "JavaScript does not support arrays, maps, or strings with length over 4294967295",
            );
          n = dn.getUint32(ee + 4);
        } else
          Be.int64AsNumber
            ? ((n = dn.getUint32(ee) * 4294967296), (n += dn.getUint32(ee + 4)))
            : (n = dn.getBigUint64(ee));
        ee += 8;
        break;
      case 31:
        switch (e) {
          case 2:
          case 3:
            throw new Error(
              "Indefinite length not supported for byte or text strings",
            );
          case 4:
            let t = [],
              r,
              a = 0;
            for (; (r = $e()) != is; ) t[a++] = r;
            return e == 4 ? t : e == 3 ? t.join("") : Buffer.concat(t);
          case 5:
            let i;
            if (Be.mapsAsObjects) {
              let s = {};
              if (Be.keyMap)
                for (; (i = $e()) != is; ) s[Dr(Be.decodeKey(i))] = $e();
              else for (; (i = $e()) != is; ) s[Dr(i)] = $e();
              return s;
            } else {
              Wo && ((Be.mapsAsObjects = !0), (Wo = !1));
              let s = new Map();
              if (Be.keyMap)
                for (; (i = $e()) != is; ) s.set(Be.decodeKey(i), $e());
              else for (; (i = $e()) != is; ) s.set(i, $e());
              return s;
            }
          case 7:
            return is;
          default:
            throw new Error("Invalid major type for indefinite length " + e);
        }
      default:
        throw new Error("Unknown token " + n);
    }
  switch (e) {
    case 0:
      return n;
    case 1:
      return ~n;
    case 2:
      return SB(n);
    case 3:
      if (xc >= ee) return od.slice(ee - cd, (ee += n) - cd);
      if (xc == 0 && _i < 140 && n < 32) {
        let a = n < 16 ? iv(n) : _B(n);
        if (a != null) return a;
      }
      return kB(n);
    case 4:
      let t = new Array(n);
      for (let a = 0; a < n; a++) t[a] = $e();
      return t;
    case 5:
      if (Be.mapsAsObjects) {
        let a = {};
        if (Be.keyMap)
          for (let i = 0; i < n; i++) a[Dr(Be.decodeKey($e()))] = $e();
        else for (let i = 0; i < n; i++) a[Dr($e())] = $e();
        return a;
      } else {
        Wo && ((Be.mapsAsObjects = !0), (Wo = !1));
        let a = new Map();
        if (Be.keyMap)
          for (let i = 0; i < n; i++) a.set(Be.decodeKey($e()), $e());
        else for (let i = 0; i < n; i++) a.set($e(), $e());
        return a;
      }
    case 6:
      if (n >= ab) {
        let a = ft[n & 8191];
        if (a) return a.read || (a.read = ah(a)), a.read();
        if (n < 65536) {
          if (n == EB) return sh($e());
          if (n == AB) {
            let i = Uo(),
              s = $e();
            for (let o = 2; o < i; o++) sh([s++, $e()]);
            return $e();
          } else if (n == ab) return OB();
          if (Be.getShared && (vm(), (a = ft[n & 8191]), a))
            return a.read || (a.read = ah(a)), a.read();
        }
      }
      let r = ut[n];
      if (r) return r.handlesRead ? r($e) : r($e());
      {
        let a = $e();
        for (let i = 0; i < nh.length; i++) {
          let s = nh[i](n, a);
          if (s !== void 0) return s;
        }
        return new lf(a, n);
      }
    case 7:
      switch (n) {
        case 20:
          return !1;
        case 21:
          return !0;
        case 22:
          return null;
        case 23:
          return;
        case 31:
        default:
          let a = (vn || bi())[n];
          if (a !== void 0) return a;
          throw new Error("Unknown token " + n);
      }
    default:
      if (isNaN(n)) {
        let a = new Error("Unexpected end of CBOR data");
        throw ((a.incomplete = !0), a);
      }
      throw new Error("Unknown CBOR token " + n);
  }
}
const cb = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function ah(n) {
  function e() {
    let t = ye[ee++];
    if (((t = t & 31), t > 23))
      switch (t) {
        case 24:
          t = ye[ee++];
          break;
        case 25:
          (t = dn.getUint16(ee)), (ee += 2);
          break;
        case 26:
          (t = dn.getUint32(ee)), (ee += 4);
          break;
        default:
          throw new Error("Expected array header, but got " + ye[ee - 1]);
      }
    let r = this.compiledReader;
    for (; r; ) {
      if (r.propertyCount === t) return r($e);
      r = r.next;
    }
    if (this.slowReads++ >= 3) {
      let i = this.length == t ? this : this.slice(0, t);
      return (
        (r = Be.keyMap
          ? new Function(
              "r",
              "return {" +
                i
                  .map((s) => Be.decodeKey(s))
                  .map((s) =>
                    cb.test(s)
                      ? Dr(s) + ":r()"
                      : "[" + JSON.stringify(s) + "]:r()",
                  )
                  .join(",") +
                "}",
            )
          : new Function(
              "r",
              "return {" +
                i
                  .map((s) =>
                    cb.test(s)
                      ? Dr(s) + ":r()"
                      : "[" + JSON.stringify(s) + "]:r()",
                  )
                  .join(",") +
                "}",
            )),
        this.compiledReader && (r.next = this.compiledReader),
        (r.propertyCount = t),
        (this.compiledReader = r),
        r($e)
      );
    }
    let a = {};
    if (Be.keyMap)
      for (let i = 0; i < t; i++) a[Dr(Be.decodeKey(this[i]))] = $e();
    else for (let i = 0; i < t; i++) a[Dr(this[i])] = $e();
    return a;
  }
  return (n.slowReads = 0), e;
}
function Dr(n) {
  return n === "__proto__" ? "__proto_" : n;
}
let kB = ih;
function ih(n) {
  let e;
  if (n < 16 && (e = iv(n))) return e;
  if (n > 64 && th) return th.decode(ye.subarray(ee, (ee += n)));
  const t = ee + n,
    r = [];
  for (e = ""; ee < t; ) {
    const a = ye[ee++];
    if (!(a & 128)) r.push(a);
    else if ((a & 224) === 192) {
      const i = ye[ee++] & 63;
      r.push(((a & 31) << 6) | i);
    } else if ((a & 240) === 224) {
      const i = ye[ee++] & 63,
        s = ye[ee++] & 63;
      r.push(((a & 31) << 12) | (i << 6) | s);
    } else if ((a & 248) === 240) {
      const i = ye[ee++] & 63,
        s = ye[ee++] & 63,
        o = ye[ee++] & 63;
      let c = ((a & 7) << 18) | (i << 12) | (s << 6) | o;
      c > 65535 &&
        ((c -= 65536),
        r.push(((c >>> 10) & 1023) | 55296),
        (c = 56320 | (c & 1023))),
        r.push(c);
    } else r.push(a);
    r.length >= 4096 && ((e += Rt.apply(String, r)), (r.length = 0));
  }
  return r.length > 0 && (e += Rt.apply(String, r)), e;
}
let Rt = String.fromCharCode;
function _B(n) {
  let e = ee,
    t = new Array(n);
  for (let r = 0; r < n; r++) {
    const a = ye[ee++];
    if ((a & 128) > 0) {
      ee = e;
      return;
    }
    t[r] = a;
  }
  return Rt.apply(String, t);
}
function iv(n) {
  if (n < 4)
    if (n < 2) {
      if (n === 0) return "";
      {
        let e = ye[ee++];
        if ((e & 128) > 1) {
          ee -= 1;
          return;
        }
        return Rt(e);
      }
    } else {
      let e = ye[ee++],
        t = ye[ee++];
      if ((e & 128) > 0 || (t & 128) > 0) {
        ee -= 2;
        return;
      }
      if (n < 3) return Rt(e, t);
      let r = ye[ee++];
      if ((r & 128) > 0) {
        ee -= 3;
        return;
      }
      return Rt(e, t, r);
    }
  else {
    let e = ye[ee++],
      t = ye[ee++],
      r = ye[ee++],
      a = ye[ee++];
    if ((e & 128) > 0 || (t & 128) > 0 || (r & 128) > 0 || (a & 128) > 0) {
      ee -= 4;
      return;
    }
    if (n < 6) {
      if (n === 4) return Rt(e, t, r, a);
      {
        let i = ye[ee++];
        if ((i & 128) > 0) {
          ee -= 5;
          return;
        }
        return Rt(e, t, r, a, i);
      }
    } else if (n < 8) {
      let i = ye[ee++],
        s = ye[ee++];
      if ((i & 128) > 0 || (s & 128) > 0) {
        ee -= 6;
        return;
      }
      if (n < 7) return Rt(e, t, r, a, i, s);
      let o = ye[ee++];
      if ((o & 128) > 0) {
        ee -= 7;
        return;
      }
      return Rt(e, t, r, a, i, s, o);
    } else {
      let i = ye[ee++],
        s = ye[ee++],
        o = ye[ee++],
        c = ye[ee++];
      if ((i & 128) > 0 || (s & 128) > 0 || (o & 128) > 0 || (c & 128) > 0) {
        ee -= 8;
        return;
      }
      if (n < 10) {
        if (n === 8) return Rt(e, t, r, a, i, s, o, c);
        {
          let l = ye[ee++];
          if ((l & 128) > 0) {
            ee -= 9;
            return;
          }
          return Rt(e, t, r, a, i, s, o, c, l);
        }
      } else if (n < 12) {
        let l = ye[ee++],
          u = ye[ee++];
        if ((l & 128) > 0 || (u & 128) > 0) {
          ee -= 10;
          return;
        }
        if (n < 11) return Rt(e, t, r, a, i, s, o, c, l, u);
        let d = ye[ee++];
        if ((d & 128) > 0) {
          ee -= 11;
          return;
        }
        return Rt(e, t, r, a, i, s, o, c, l, u, d);
      } else {
        let l = ye[ee++],
          u = ye[ee++],
          d = ye[ee++],
          f = ye[ee++];
        if ((l & 128) > 0 || (u & 128) > 0 || (d & 128) > 0 || (f & 128) > 0) {
          ee -= 12;
          return;
        }
        if (n < 14) {
          if (n === 12) return Rt(e, t, r, a, i, s, o, c, l, u, d, f);
          {
            let p = ye[ee++];
            if ((p & 128) > 0) {
              ee -= 13;
              return;
            }
            return Rt(e, t, r, a, i, s, o, c, l, u, d, f, p);
          }
        } else {
          let p = ye[ee++],
            m = ye[ee++];
          if ((p & 128) > 0 || (m & 128) > 0) {
            ee -= 14;
            return;
          }
          if (n < 15) return Rt(e, t, r, a, i, s, o, c, l, u, d, f, p, m);
          let y = ye[ee++];
          if ((y & 128) > 0) {
            ee -= 15;
            return;
          }
          return Rt(e, t, r, a, i, s, o, c, l, u, d, f, p, m, y);
        }
      }
    }
  }
}
function SB(n) {
  return Be.copyBuffers
    ? Uint8Array.prototype.slice.call(ye, ee, (ee += n))
    : ye.subarray(ee, (ee += n));
}
let sv = new Float32Array(1),
  Al = new Uint8Array(sv.buffer, 0, 4);
function PB() {
  let n = ye[ee++],
    e = ye[ee++],
    t = (n & 127) >> 2;
  if (t === 31) return e || n & 3 ? NaN : n & 128 ? -1 / 0 : 1 / 0;
  if (t === 0) {
    let r = (((n & 3) << 8) | e) / 16777216;
    return n & 128 ? -r : r;
  }
  return (
    (Al[3] = (n & 128) | ((t >> 1) + 56)),
    (Al[2] = ((n & 7) << 5) | (e >> 3)),
    (Al[1] = e << 5),
    (Al[0] = 0),
    sv[0]
  );
}
class lf {
  constructor(e, t) {
    (this.value = e), (this.tag = t);
  }
}
ut[0] = (n) => new Date(n);
ut[1] = (n) => new Date(Math.round(n * 1e3));
ut[2] = (n) => {
  let e = BigInt(0);
  for (let t = 0, r = n.byteLength; t < r; t++)
    e = (BigInt(n[t]) + e) << BigInt(8);
  return e;
};
ut[3] = (n) => BigInt(-1) - ut[2](n);
ut[4] = (n) => +(n[1] + "e" + n[0]);
ut[5] = (n) => n[1] * Math.exp(n[0] * Math.log(2));
const sh = (n) => {
  let e = n[0] - 57344,
    t = n[1],
    r = ft[e];
  r &&
    r.isShared &&
    ((ft.restoreStructures || (ft.restoreStructures = []))[e] = r),
    (ft[e] = t),
    (t.read = ah(t));
  let a = {};
  if (Be.keyMap)
    for (let i = 2, s = n.length; i < s; i++) {
      let o = Be.decodeKey(t[i - 2]);
      a[Dr(o)] = n[i];
    }
  else
    for (let i = 2, s = n.length; i < s; i++) {
      let o = t[i - 2];
      a[Dr(o)] = n[i];
    }
  return a;
};
ut[CB] = sh;
ut[14] = (n) =>
  St ? St[0].slice(St.position0, (St.position0 += n)) : new lf(n, 14);
ut[15] = (n) =>
  St ? St[1].slice(St.position1, (St.position1 += n)) : new lf(n, 15);
let IB = { Error, RegExp };
ut[27] = (n) => (IB[n[0]] || Error)(n[1], n[2]);
const ov = (n) => {
  if (ye[ee++] != 132)
    throw new Error(
      "Packed values structure must be followed by a 4 element array",
    );
  let e = n();
  return (
    (vn = vn ? e.concat(vn.slice(e.length)) : e),
    (vn.prefixes = n()),
    (vn.suffixes = n()),
    n()
  );
};
ov.handlesRead = !0;
ut[51] = ov;
ut[ib] = (n) => {
  if (!vn)
    if (Be.getShared) vm();
    else return new lf(n, ib);
  if (typeof n == "number") return vn[16 + (n >= 0 ? 2 * n : -2 * n - 1)];
  throw new Error("No support for non-integer packed references yet");
};
ut[25] = (n) => stringRefs[n];
ut[256] = (n) => {
  stringRefs = [];
  try {
    return n();
  } finally {
    stringRefs = null;
  }
};
ut[256].handlesRead = !0;
ut[28] = (n) => {
  mr || ((mr = new Map()), (mr.id = 0));
  let e = mr.id++,
    t = ye[ee],
    r;
  t >> 5 == 4 ? (r = []) : (r = {});
  let a = { target: r };
  mr.set(e, a);
  let i = n();
  return a.used ? Object.assign(r, i) : ((a.target = i), i);
};
ut[28].handlesRead = !0;
ut[29] = (n) => {
  let e = mr.get(n);
  return (e.used = !0), e.target;
};
ut[258] = (n) => new Set(n);
(ut[259] = (n) => (
  Be.mapsAsObjects && ((Be.mapsAsObjects = !1), (Wo = !0)), n()
)).handlesRead = !0;
function ss(n, e) {
  return typeof n == "string"
    ? n + e
    : n instanceof Array
    ? n.concat(e)
    : Object.assign({}, n, e);
}
function bi() {
  if (!vn)
    if (Be.getShared) vm();
    else throw new Error("No packed values available");
  return vn;
}
const RB = 1399353956;
nh.push((n, e) => {
  if (n >= 225 && n <= 255) return ss(bi().prefixes[n - 224], e);
  if (n >= 28704 && n <= 32767) return ss(bi().prefixes[n - 28672], e);
  if (n >= 1879052288 && n <= 2147483647)
    return ss(bi().prefixes[n - 1879048192], e);
  if (n >= 216 && n <= 223) return ss(e, bi().suffixes[n - 216]);
  if (n >= 27647 && n <= 28671) return ss(e, bi().suffixes[n - 27639]);
  if (n >= 1811940352 && n <= 1879048191)
    return ss(e, bi().suffixes[n - 1811939328]);
  if (n == RB) return { packedValues: vn, structures: ft.slice(0), version: e };
  if (n == 55799) return e;
});
const MB = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1,
  lb = [Uint8Array],
  BB = [64];
for (let n = 0; n < lb.length; n++) DB(lb[n], BB[n]);
function DB(n, e) {
  let t = "get" + n.name.slice(0, -5);
  typeof n != "function" && (n = null);
  let r = n.BYTES_PER_ELEMENT;
  for (let a = 0; a < 2; a++) {
    if (!a && r == 1) continue;
    let i = r == 2 ? 1 : r == 4 ? 2 : 3;
    ut[a ? e : e - 4] =
      r == 1 || a == MB
        ? (s) => {
            if (!n) throw new Error("Could not find typed array for code " + e);
            return new n(Uint8Array.prototype.slice.call(s, 0).buffer);
          }
        : (s) => {
            if (!n) throw new Error("Could not find typed array for code " + e);
            let o = new DataView(s.buffer, s.byteOffset, s.byteLength),
              c = s.length >> i,
              l = new n(c),
              u = o[t];
            for (let d = 0; d < c; d++) l[d] = u.call(o, d << i, a);
            return l;
          };
  }
}
function OB() {
  let n = Uo(),
    e = ee + $e();
  for (let r = 2; r < n; r++) {
    let a = Uo();
    ee += a;
  }
  let t = ee;
  return (
    (ee = e),
    (St = [ih(Uo()), ih(Uo())]),
    (St.position0 = 0),
    (St.position1 = 0),
    (St.postBundlePosition = ee),
    (ee = t),
    $e()
  );
}
function Uo() {
  let n = ye[ee++] & 31;
  if (n > 23)
    switch (n) {
      case 24:
        n = ye[ee++];
        break;
      case 25:
        (n = dn.getUint16(ee)), (ee += 2);
        break;
      case 26:
        (n = dn.getUint32(ee)), (ee += 4);
        break;
    }
  return n;
}
function vm() {
  if (Be.getShared) {
    let n = cv(() => ((ye = null), Be.getShared())) || {},
      e = n.structures || [];
    (Be.sharedVersion = n.version),
      (vn = Be.sharedValues = n.packedValues),
      ft === !0
        ? (Be.structures = ft = e)
        : ft.splice.apply(ft, [0, e.length].concat(e));
  }
}
function cv(n) {
  let e = _i,
    t = ee,
    r = cd,
    a = xc,
    i = od,
    s = mr,
    o = St,
    c = new Uint8Array(ye.slice(0, _i)),
    l = ft,
    u = Be,
    d = rh,
    f = n();
  return (
    (_i = e),
    (ee = t),
    (cd = r),
    (xc = a),
    (od = i),
    (mr = s),
    (St = o),
    (ye = c),
    (rh = d),
    (ft = l),
    (Be = u),
    (dn = new DataView(ye.buffer, ye.byteOffset, ye.byteLength)),
    f
  );
}
function lv() {
  (ye = null), (mr = null), (ft = null);
}
const uv = new Array(147);
for (let n = 0; n < 256; n++) uv[n] = +("1e" + Math.floor(45.15 - n * 0.30103));
const NB = new ld({ useRecords: !1 }),
  FB = NB.decode;
function LB(n) {
  if (((n = n.toString(16)), n.startsWith("0x") || (n = `0x${n}`), !$B(n)))
    throw new Error(`Given value "${n}" is not a valid hex string.`);
  n = n.replace(/^0x/i, "");
  const e = [];
  for (let t = 0; t < n.length; t += 2) e.push(parseInt(n.slice(t, t + 2), 16));
  return e;
}
function $B(n) {
  return (
    (typeof n == "string" || typeof n == "number") &&
    /^(-)?0x[0-9a-f]*$/i.test(n.toString())
  );
}
function WB(n) {
  const e = LB(n),
    t = e[e.length - 2] * 256 + e[e.length - 1],
    r = Uint8Array.from(e.slice(e.length - 2 - t, -2)),
    a = FB(r);
  if ("ipfs" in a && a.ipfs)
    try {
      return `ipfs://${$R.encode(a.ipfs)}`;
    } catch (i) {
      console.warn("feature-detection ipfs cbor failed", i);
    }
}
function UB(n) {
  if (n.startsWith("0x363d3d373d3d3d363d73")) return `0x${n.slice(22, 62)}`;
  if (n.startsWith("0x36603057343d5230")) return `0x${n.slice(122, 162)}`;
  if (n.startsWith("0x3d3d3d3d363d3d37363d73")) return `0x${n.slice(24, 64)}`;
  if (n.startsWith("0x366000600037611000600036600073"))
    return `0x${n.slice(32, 72)}`;
}
async function vc(n, e) {
  let t;
  try {
    t = await e.getCode(n);
  } catch (r) {
    throw new Error(`Failed to get bytecode for address ${n}: ${r}`);
  }
  if (t === "0x") {
    const r = await e.getNetwork();
    throw new Error(
      `Contract at ${n} does not exist on chain '${r.name}' (chainId: ${r.chainId})`,
    );
  }
  try {
    const r = UB(t);
    if (r) return await vc(r, e);
  } catch {}
  try {
    const a = `0x${(
      await e.getStorageAt(
        n,
        O.from(
          "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
        ),
      )
    ).slice(-40)}`;
    if (Lc(a) && a !== Ie) return await vc(a, e);
  } catch {}
  return await WB(t);
}
async function ud(n, e) {
  const t = await e.downloadJSON(n);
  if (!t || !t.output)
    throw new Error(`Could not resolve metadata for contract at ${n}`);
  const r = mt.parse(t.output.abi),
    a = t.settings.compilationTarget,
    i = Object.keys(a),
    s = a[i[0]],
    o = ev.parse({
      title: t.output.devdoc.title,
      author: t.output.devdoc.author,
      details: t.output.devdoc.detail,
      notice: t.output.userdoc.notice,
    }),
    c = [
      ...new Set(
        Object.entries(t.sources).map((l) => {
          let [, u] = l;
          return u.license;
        }),
      ),
    ];
  return { name: s, abi: r, metadata: t, info: o, licenses: c };
}
function wc(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return typeof process < "u" &&
    {
      TERM_PROGRAM: "vscode",
      NODE: "/opt/homebrew/Cellar/node/20.4.0/bin/node",
      INIT_CWD: "/Users/nemanjamijailovic/Desktop/react/nefentus",
      TERM: "xterm-256color",
      SHELL: "/bin/zsh",
      npm_config_metrics_registry: "https://registry.npmjs.org/",
      TMPDIR: "/var/folders/sf/_jxj1sq93p92nygnjzjz7wz40000gn/T/",
      npm_config_global_prefix: "/opt/homebrew",
      TERM_PROGRAM_VERSION: "1.83.1",
      ZDOTDIR: "/Users/nemanjamijailovic",
      ORIGINAL_XDG_CURRENT_DESKTOP: "undefined",
      MallocNanoZone: "0",
      COLOR: "1",
      npm_config_noproxy: "",
      npm_config_local_prefix:
        "/Users/nemanjamijailovic/Desktop/react/nefentus",
      USER: "nemanjamijailovic",
      COMMAND_MODE: "unix2003",
      npm_config_globalconfig: "/opt/homebrew/etc/npmrc",
      SSH_AUTH_SOCK: "/private/tmp/com.apple.launchd.v3QbEzlluP/Listeners",
      __CF_USER_TEXT_ENCODING: "0x1F5:0x0:0x0",
      npm_execpath: "/opt/homebrew/lib/node_modules/npm/bin/npm-cli.js",
      PATH: "/Users/nemanjamijailovic/Desktop/react/nefentus/node_modules/.bin:/Users/nemanjamijailovic/Desktop/react/node_modules/.bin:/Users/nemanjamijailovic/Desktop/node_modules/.bin:/Users/nemanjamijailovic/node_modules/.bin:/Users/node_modules/.bin:/node_modules/.bin:/opt/homebrew/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/opt/homebrew/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin",
      npm_package_json:
        "/Users/nemanjamijailovic/Desktop/react/nefentus/package.json",
      _: "/Users/nemanjamijailovic/Desktop/react/nefentus/node_modules/.bin/vite",
      LaunchInstanceID: "40140A37-FB8D-43E2-921C-067ECA7C31B9",
      npm_config_userconfig: "/Users/nemanjamijailovic/.npmrc",
      npm_config_init_module: "/Users/nemanjamijailovic/.npm-init.js",
      USER_ZDOTDIR: "/Users/nemanjamijailovic",
      __CFBundleIdentifier: "com.microsoft.VSCode",
      npm_command: "run-script",
      PWD: "/Users/nemanjamijailovic/Desktop/react/nefentus",
      npm_lifecycle_event: "build",
      EDITOR: "vi",
      npm_package_name: "nefentus",
      LANG: "en_US.UTF-8",
      npm_config_npm_version: "9.7.2",
      VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node",
      XPC_FLAGS: "0x0",
      npm_config_node_gyp:
        "/opt/homebrew/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js",
      npm_package_version: "0.1.0",
      XPC_SERVICE_NAME: "0",
      VSCODE_INJECTION: "1",
      SHLVL: "2",
      HOME: "/Users/nemanjamijailovic",
      VSCODE_GIT_ASKPASS_MAIN:
        "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js",
      npm_config_cache: "/Users/nemanjamijailovic/.npm",
      LOGNAME: "nemanjamijailovic",
      npm_lifecycle_script: "vite build",
      VSCODE_GIT_IPC_HANDLE:
        "/var/folders/sf/_jxj1sq93p92nygnjzjz7wz40000gn/T/vscode-git-ae8730b21b.sock",
      npm_config_user_agent:
        "npm/9.7.2 node/v20.4.0 darwin arm64 workspaces/false",
      VSCODE_GIT_ASKPASS_NODE:
        "/Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper (Plugin).app/Contents/MacOS/Code Helper (Plugin)",
      GIT_ASKPASS:
        "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh",
      SECURITYSESSIONID: "186b4",
      npm_node_execpath: "/opt/homebrew/Cellar/node/20.4.0/bin/node",
      npm_config_prefix: "/opt/homebrew",
      COLORTERM: "truecolor",
      NODE_ENV: "production",
      VITE_REACT_APP_BASE_ENDPOINT_API: "https://api.nefentus.com/api",
      VITE_REACT_APP_GA_ID: "G-HRH664KZ9E",
      VITE_REACT_APP_RECAPTCHA_SITE_KEY:
        "6Leb6H8oAAAAAM0q25gltEqlMOUUymzoDobq4NLc",
      VITE_REACT_APP_SECRET_WORD: "AppNefentusSuperPuperSecretWord",
    }[n]
    ? {
        TERM_PROGRAM: "vscode",
        NODE: "/opt/homebrew/Cellar/node/20.4.0/bin/node",
        INIT_CWD: "/Users/nemanjamijailovic/Desktop/react/nefentus",
        TERM: "xterm-256color",
        SHELL: "/bin/zsh",
        npm_config_metrics_registry: "https://registry.npmjs.org/",
        TMPDIR: "/var/folders/sf/_jxj1sq93p92nygnjzjz7wz40000gn/T/",
        npm_config_global_prefix: "/opt/homebrew",
        TERM_PROGRAM_VERSION: "1.83.1",
        ZDOTDIR: "/Users/nemanjamijailovic",
        ORIGINAL_XDG_CURRENT_DESKTOP: "undefined",
        MallocNanoZone: "0",
        COLOR: "1",
        npm_config_noproxy: "",
        npm_config_local_prefix:
          "/Users/nemanjamijailovic/Desktop/react/nefentus",
        USER: "nemanjamijailovic",
        COMMAND_MODE: "unix2003",
        npm_config_globalconfig: "/opt/homebrew/etc/npmrc",
        SSH_AUTH_SOCK: "/private/tmp/com.apple.launchd.v3QbEzlluP/Listeners",
        __CF_USER_TEXT_ENCODING: "0x1F5:0x0:0x0",
        npm_execpath: "/opt/homebrew/lib/node_modules/npm/bin/npm-cli.js",
        PATH: "/Users/nemanjamijailovic/Desktop/react/nefentus/node_modules/.bin:/Users/nemanjamijailovic/Desktop/react/node_modules/.bin:/Users/nemanjamijailovic/Desktop/node_modules/.bin:/Users/nemanjamijailovic/node_modules/.bin:/Users/node_modules/.bin:/node_modules/.bin:/opt/homebrew/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/opt/homebrew/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin",
        npm_package_json:
          "/Users/nemanjamijailovic/Desktop/react/nefentus/package.json",
        _: "/Users/nemanjamijailovic/Desktop/react/nefentus/node_modules/.bin/vite",
        LaunchInstanceID: "40140A37-FB8D-43E2-921C-067ECA7C31B9",
        npm_config_userconfig: "/Users/nemanjamijailovic/.npmrc",
        npm_config_init_module: "/Users/nemanjamijailovic/.npm-init.js",
        USER_ZDOTDIR: "/Users/nemanjamijailovic",
        __CFBundleIdentifier: "com.microsoft.VSCode",
        npm_command: "run-script",
        PWD: "/Users/nemanjamijailovic/Desktop/react/nefentus",
        npm_lifecycle_event: "build",
        EDITOR: "vi",
        npm_package_name: "nefentus",
        LANG: "en_US.UTF-8",
        npm_config_npm_version: "9.7.2",
        VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node",
        XPC_FLAGS: "0x0",
        npm_config_node_gyp:
          "/opt/homebrew/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js",
        npm_package_version: "0.1.0",
        XPC_SERVICE_NAME: "0",
        VSCODE_INJECTION: "1",
        SHLVL: "2",
        HOME: "/Users/nemanjamijailovic",
        VSCODE_GIT_ASKPASS_MAIN:
          "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js",
        npm_config_cache: "/Users/nemanjamijailovic/.npm",
        LOGNAME: "nemanjamijailovic",
        npm_lifecycle_script: "vite build",
        VSCODE_GIT_IPC_HANDLE:
          "/var/folders/sf/_jxj1sq93p92nygnjzjz7wz40000gn/T/vscode-git-ae8730b21b.sock",
        npm_config_user_agent:
          "npm/9.7.2 node/v20.4.0 darwin arm64 workspaces/false",
        VSCODE_GIT_ASKPASS_NODE:
          "/Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper (Plugin).app/Contents/MacOS/Code Helper (Plugin)",
        GIT_ASKPASS:
          "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh",
        SECURITYSESSIONID: "186b4",
        npm_node_execpath: "/opt/homebrew/Cellar/node/20.4.0/bin/node",
        npm_config_prefix: "/opt/homebrew",
        COLORTERM: "truecolor",
        NODE_ENV: "production",
        VITE_REACT_APP_BASE_ENDPOINT_API: "https://api.nefentus.com/api",
        VITE_REACT_APP_GA_ID: "G-HRH664KZ9E",
        VITE_REACT_APP_RECAPTCHA_SITE_KEY:
          "6Leb6H8oAAAAAM0q25gltEqlMOUUymzoDobq4NLc",
        VITE_REACT_APP_SECRET_WORD: "AppNefentusSuperPuperSecretWord",
      }[n]
    : e;
}
const jB = "0xcdAD8FA86e18538aC207872E8ff3536501431B73";
function oh() {
  return wc("multiChainRegistryAddress", jB);
}
const dv = {};
let q0;
function fv(n, e) {
  return `${n}-${e}`;
}
function zB(n, e, t) {
  dv[fv(n, e)] = t;
}
function HB(n, e) {
  return dv[fv(n, e)];
}
async function wr(n, e, t) {
  const r = (await e.getNetwork()).chainId,
    a = HB(n, r);
  if (a) return a;
  let i;
  try {
    const s = await vc(n, e);
    if (!s) throw new Error(`Could not resolve metadata for contract at ${n}`);
    i = await ud(s, t);
  } catch (s) {
    console.debug(
      "Failed to get Contract Metadata from IPFS, defaulting to onchain registry",
      s == null ? void 0 : s.message,
    );
    try {
      q0 || (q0 = new Pe(oh(), P6, Ln("polygon", {})));
      const o = await q0.getMetadataUri(r, n);
      if (!o)
        throw new Error(`Could not resolve metadata for contract at ${n}`);
      i = await ud(o, t);
    } catch {
      throw new Error(`Could not resolve metadata for contract at ${n}`);
    }
  }
  if (!i)
    throw new Error(
      `No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${r}/${n}`,
    );
  return zB(n, r, i), i;
}
async function Un(n, e, t) {
  try {
    const r = await wr(n, e, t);
    if (r && r.abi) return r.abi;
  } catch {}
}
function yt(n) {
  async function e() {
    return (await n(...arguments)).execute();
  }
  return (e.prepare = n), e;
}
function Y(n) {
  async function e() {
    return (await n(...arguments)).execute();
  }
  return (e.prepare = n), e;
}
async function uf(n, e) {
  return await Promise.all(
    Object.entries(n.metadata.sources).map(async (t) => {
      let [r, a] = t;
      const i = a.urls,
        s = i ? i.find((o) => o.includes("ipfs")) : void 0;
      if (s) {
        const o = s.split("ipfs/")[1],
          c = new Promise((u, d) => setTimeout(() => d("timeout"), 3e3)),
          l = await Promise.race([(await e.download(`ipfs://${o}`)).text(), c]);
        return { filename: r, source: l };
      } else
        return {
          filename: r,
          source: a.content || "Could not find source for this contract",
        };
    }),
  );
}
function qB(n) {
  const e = js(mt.parse(n), "PluginRouter");
  return js(mt.parse(n), "ExtensionRouter") || e;
}
const VB = () => !0,
  pv = () => !VB();
function GB(n, e) {
  if (n.length === 0 || n.length === 1 || !e) return n;
  for (let t = 0; t < n.length; t++)
    for (let r = t + 1; r < n.length; r++) e(n[t], n[r]) && n.splice(r, 1);
  return n;
}
const KB = [
    "eip-155",
    "eip155",
    "protected",
    "invalid chain id for signer",
    "chain id none",
    "chain_id mismatch",
    "recovered sender mismatch",
    "transaction hash mismatch",
    "chainid no support",
    "chainid (0)",
    "chainid(0)",
  ],
  QB = [
    ["account", "not found"],
    ["wrong", "chainid"],
  ],
  xs = {
    5001: { name: "Mantle Testnet", gasPrice: 1 },
    71402: { name: "Godwoken Mainnet", gasPrice: 4e4 * 10 ** 9 },
    1351057110: { name: "Chaos (SKALE Testnet)", gasPrice: 1e5 },
    361: { name: "Theta Mainnet", gasPrice: 4e3 * 10 ** 9 },
    365: { name: "Theta Testnet", gasPrice: 4e3 * 10 ** 9 },
    7700: { name: "Canto", gasPrice: 1e3 * 10 ** 9 },
    7701: { name: "Canto Testnet", gasPrice: 1e3 * 10 ** 9 },
  };
function ub(n) {
  const e = KB.findIndex((r) => n.includes(r)),
    t = QB.findIndex((r) => {
      let a = !0;
      return (
        r.forEach((i) => {
          a && (a = n.includes(i));
        }),
        a
      );
    });
  return e !== -1 || t !== -1;
}
const YB =
    "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3",
  JB = {
    v: 27,
    r: "0x2222222222222222222222222222222222222222222222222222222222222222",
    s: "0x2222222222222222222222222222222222222222222222222222222222222222",
  },
  dd = "0x4e59b44847b379578588920cA78FbF26c0B4956C",
  XB = 5e6,
  ZB =
    "0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033",
  eD = [
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "predictedAddress",
              type: "address",
            },
            { internalType: "address", name: "to", type: "address" },
            { internalType: "bytes", name: "data", type: "bytes" },
          ],
          internalType: "struct IDeployer.Transaction[]",
          name: "transactions",
          type: "tuple[]",
        },
      ],
      stateMutability: "payable",
      type: "constructor",
    },
  ];
async function ua(n, e) {
  const t = await e.getCode(n);
  return t !== "0x" && t !== "0x0";
}
async function hv(n) {
  try {
    await n.sendTransaction(
      "0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222",
    );
  } catch (e) {
    const t = e.toString().toLowerCase(),
      r = JSON.stringify(e).toLowerCase();
    return !!(ub(t) || ub(r));
  }
  return !1;
}
function tD(n, e) {
  const t = ae(Ge(uu(n))),
    r = Uc(t, e),
    a = uu(n, e);
  return { signer: r, transaction: a };
}
function fd(n, e) {
  const t = au(JB),
    r = tD(
      {
        gasPrice: e || 100 * 10 ** 9,
        gasLimit: 1e5,
        nonce: 0,
        data: YB,
        chainId: n,
      },
      t,
    ),
    a = Nc({ from: r.signer, nonce: 0 });
  return { ...r, deployment: a };
}
async function Qi(n) {
  if (await ua(dd, n)) return dd;
  const t = await hv(n),
    r = (await n.getNetwork()).chainId,
    a = t ? r : 0;
  return (xs[r] ? fd(a, xs[r].gasPrice) : fd(a)).deployment;
}
const db =
    "0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029",
  nD = "0x664244560eBa21Bf82d7150C791bE1AbcD5B4cd7";
function wm() {
  return wc("contractPublisherAddress", nD);
}
const V0 = {},
  fb = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
async function Yc(n) {
  if (V0[n]) return V0[n];
  const t = await new Pe(wm(), om, Ln("polygon", {})).getPublishedContract(
    fb,
    n,
  );
  if (!t)
    throw new Error(
      `No published contract found for ${n} at version by '${fb}'`,
    );
  const r = t.publishMetadataUri;
  return (V0[n] = r), r;
}
async function Tm(n, e) {
  const t = await (await e.download(n)).text();
  return dB.parse(JSON.parse(t));
}
async function mv(n, e) {
  return of.parse(JSON.parse(await (await e.download(n)).text()));
}
async function Tc(n, e) {
  const t = await mv(n, e),
    r = await (await e.download(t.bytecodeUri)).text(),
    a = await ud(t.metadataUri, e);
  return yB.parse({ ...t, ...a, bytecode: r });
}
const G0 = {};
async function Za(n, e) {
  if (G0[n]) return G0[n];
  const t = await Tc(n, e);
  let r;
  try {
    r = await Tm(n, e);
  } catch {}
  const a = { compilerMetadata: t, extendedMetadata: r };
  return (G0[n] = a), a;
}
function yv(n) {
  const t = `tw.${wn(n)}`;
  return wn(t);
}
function pb(n, e, t) {
  const r = t ? wn(t) : yv(n);
  return Ns(["bytes32", "bytes", "bytes"], [r, n, e]);
}
function hb(n, e, t, r) {
  const a = r ? wn(r) : yv(n),
    i = Ns(["bytes", "bytes"], [n, e]),
    s = Ns(
      ["bytes1", "address", "bytes32", "bytes32"],
      ["0xff", t, a, er(["bytes"], [i])],
    );
  return `0x${er(["bytes"], [s]).slice(26)}`;
}
function df(n) {
  const e = mt.parse(n || []);
  for (const t of e) if (t.type === "constructor") return t.inputs || [];
  return [];
}
const kr = { deploymentPresets: {} };
function rD(n) {
  return aD[n] || Ie;
}
const aD = {
  [oe.Mainnet]: "0x0385603ab55642cb4dd5de3ae9e306809991804f",
  [oe.Goerli]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [oe.BinanceSmartChainMainnet]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [oe.Polygon]: "0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2",
  [oe.Mumbai]: "0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07",
  [oe.Avalanche]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [oe.Optimism]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [oe.Arbitrum]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
};
async function xr(n, e, t, r, a) {
  const i = a && a.contractName;
  let s = a && a.metadata;
  if (
    (ce(i || s, "Require contract name or metadata"),
    i && kr.deploymentPresets[i])
  )
    return kr.deploymentPresets[i];
  if (i === "WETH9") {
    const d = hb(db, [], r),
      f = await ua(d, e);
    let p = "";
    return (
      f || (p = pb(db, [])),
      { name: i, type: n, transaction: { predictedAddress: d, to: r, data: p } }
    );
  }
  if (!s) {
    ce(i, "Require contract name");
    const d = await Yc(i);
    s = (await Za(d, t)).compilerMetadata;
  }
  const o = await gv(s, e, t, r, a == null ? void 0 : a.constructorParams),
    c = hb(s.bytecode, o, r),
    l = await ua(c, e);
  let u = "";
  return (
    l || (u = pb(s.bytecode, o)),
    {
      name: i,
      type: n,
      transaction: { predictedAddress: c, to: r, data: u },
      encodedArgs: o,
    }
  );
}
async function gv(n, e, t, r, a) {
  const i = df(n.abi),
    s = i.map((l) => (l.type === "tuple[]" ? kt.from(l) : l.type)),
    o = await Promise.all(
      i.map(async (l) => {
        if (a && a[l.name])
          return (
            a[l.name].type &&
              ce(
                a[l.name].type === l.type,
                `Provided type ${
                  a[l.name].type
                } doesn't match the actual type ${l.type} from Abi`,
              ),
            a[l.name].value
          );
        if (l.name && l.name.includes("nativeTokenWrapper")) {
          const u = (await e.getNetwork()).chainId;
          let d = q6(u).wrapped.address;
          if (d === Ie) {
            const f = await xr("infra", e, t, r, { contractName: "WETH9" });
            kr.deploymentPresets.WETH9 || (kr.deploymentPresets.WETH9 = f),
              (d = f.transaction.predictedAddress);
          }
          return d;
        } else if (l.name && l.name.includes("trustedForwarder")) {
          if (n.name === "Pack") {
            const d = await xr("infra", e, t, r, {
              contractName: "ForwarderEOAOnly",
            });
            return (
              kr.deploymentPresets.ForwarderEOAOnly ||
                (kr.deploymentPresets.ForwarderEOAOnly = d),
              d.transaction.predictedAddress
            );
          }
          const u = await xr("infra", e, t, r, { contractName: "Forwarder" });
          return (
            kr.deploymentPresets.Forwarder ||
              (kr.deploymentPresets.Forwarder = u),
            u.transaction.predictedAddress
          );
        } else if (l.name && l.name.includes("royaltyEngineAddress")) {
          const u = (await e.getNetwork()).chainId;
          return rD(u);
        } else throw new Error("Can't resolve constructor arguments");
      }),
    );
  return Ga.encode(s, o);
}
async function bv(n, e, t) {
  return (
    t || (t = await Qi(n)),
    (await xr("infra", n, e, t, { contractName: "ForwarderEOAOnly" }))
      .transaction.predictedAddress
  );
}
async function Cm(n, e, t) {
  return (
    t || (t = await Qi(n)),
    (await xr("infra", n, e, t, { contractName: "Forwarder" })).transaction
      .predictedAddress
  );
}
const xv = [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "value", type: "uint256" },
    { name: "gas", type: "uint256" },
    { name: "nonce", type: "uint256" },
    { name: "data", type: "bytes" },
  ],
  vv = [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "value", type: "uint256" },
    { name: "gas", type: "uint256" },
    { name: "nonce", type: "uint256" },
    { name: "data", type: "bytes" },
    { name: "chainid", type: "uint256" },
  ],
  wv = [
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "uint256", name: "batchId", type: "uint256" },
      ],
      name: "getNonce",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  os = {},
  mb = {};
async function pd(n, e, t) {
  const r = t.join("|"),
    a = mb[r],
    i = Date.now() - a >= 2e3;
  if (!(r in os) || i) {
    const o = await n.functions[e](...t);
    Array.isArray(o) && o.length > 0
      ? (os[r] = O.from(o[0]))
      : (os[r] = O.from(o)),
      (mb[r] = Date.now());
  }
  const s = os[r];
  return (os[r] = O.from(os[r]).add(1)), s;
}
async function Cc(n, e, t, r) {
  var l, u;
  let a = n;
  n.originalSigner && (a = n.originalSigner);
  const i = a == null ? void 0 : a.provider;
  if (!i) throw new Error("missing provider");
  const s = Wt.getPayload(e, t, r);
  let o = "";
  const c = (await a.getAddress()).toLowerCase();
  if ((l = i == null ? void 0 : i.provider) != null && l.isWalletConnect)
    o = await i.send("eth_signTypedData", [
      (await a.getAddress()).toLowerCase(),
      JSON.stringify(s),
    ]);
  else
    try {
      o = await a._signTypedData(e, t, r);
    } catch (d) {
      if (
        (u = d == null ? void 0 : d.message) != null &&
        u.includes("eth_signTypedData_v4")
      )
        o = await i.send("eth_signTypedData", [c, JSON.stringify(s)]);
      else
        try {
          await i.send("eth_signTypedData_v4", [c, JSON.stringify(s)]);
        } catch (f) {
          throw f;
        }
    }
  return { payload: s, signature: au(ai(o)) };
}
const iD = [
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  sD = [
    {
      constant: !0,
      inputs: [],
      name: "DOMAIN_SEPARATOR",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getDomainSeperator",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  oD = [
    {
      inputs: [{ internalType: "address", name: "owner", type: "address" }],
      name: "nonces",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "user", type: "address" }],
      name: "getNonce",
      outputs: [{ internalType: "uint256", name: "nonce", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
  ];
async function cD(n, e) {
  const t = new Pe(e, oD, n);
  try {
    return await t.nonces(await n.getAddress());
  } catch {
    return await t.getNonce(await n.getAddress());
  }
}
async function lD(n, e) {
  const t = new Pe(e, sD, n);
  try {
    return await t.DOMAIN_SEPARATOR();
  } catch {
    try {
      return await t.getDomainSeperator();
    } catch (a) {
      console.error("Error getting domain separator", a);
    }
  }
}
async function uD(n, e) {
  return new Pe(e, iD, n).name();
}
async function dD(n, e) {
  const t = await lD(n, e.verifyingContract),
    r = {
      name: e.name,
      version: e.version,
      verifyingContract: e.verifyingContract,
      salt: Ue(O.from(e.chainId).toHexString(), 32),
    };
  return Wt.hashDomain(r) === t ? r : e;
}
async function Tv(n, e, t, r, a, i, s) {
  const o = await dD(n, {
    name: await uD(n, e),
    version: "1",
    chainId: await n.getChainId(),
    verifyingContract: e,
  });
  (s = s || (await cD(n, e)).toString()), (i = i || On);
  const c = { owner: t, spender: r, value: a, nonce: s, deadline: i },
    l = {
      Permit: [
        { name: "owner", type: "address" },
        { name: "spender", type: "address" },
        { name: "value", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "deadline", type: "uint256" },
      ],
    },
    { signature: u } = await Cc(n, o, l, c);
  return { message: c, signature: u };
}
const Ye = "0x0000000000000000000000000000000000000000",
  bn = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
  hi = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0",
  mi = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81",
  Fi = {
    [oe.Mainnet]: {
      openzeppelinForwarder: mi,
      openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
      biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
      twFactory: hi,
      twRegistry: bn,
      twBYOCRegistry: Ye,
    },
    [oe.Goerli]: {
      openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
      openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
      biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
      twFactory: hi,
      twRegistry: bn,
      twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4",
    },
    [oe.Polygon]: {
      openzeppelinForwarder: mi,
      openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
      biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
      twFactory: hi,
      twRegistry: bn,
      twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7",
    },
    [oe.Mumbai]: {
      openzeppelinForwarder: mi,
      openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
      biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
      twFactory: hi,
      twRegistry: bn,
      twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C",
    },
    [oe.Avalanche]: {
      openzeppelinForwarder: mi,
      openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
      biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
      twFactory: hi,
      twRegistry: bn,
      twBYOCRegistry: Ye,
    },
    [oe.AvalancheFujiTestnet]: {
      openzeppelinForwarder: mi,
      openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
      biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
      twFactory: hi,
      twRegistry: bn,
      twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23",
    },
    [oe.Fantom]: {
      openzeppelinForwarder: mi,
      openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
      biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
      twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
      twRegistry: bn,
      twBYOCRegistry: Ye,
    },
    [oe.FantomTestnet]: {
      openzeppelinForwarder: mi,
      openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
      biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
      twFactory: hi,
      twRegistry: bn,
      twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23",
    },
    [oe.Arbitrum]: {
      openzeppelinForwarder: "0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add",
      openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
      biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: bn,
      twBYOCRegistry: Ye,
    },
    [oe.ArbitrumGoerli]: {
      openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
      openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
      biconomyForwarder: Ye,
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: bn,
      twBYOCRegistry: Ye,
    },
    [oe.Optimism]: {
      openzeppelinForwarder: "0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7",
      openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
      biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: bn,
      twBYOCRegistry: Ye,
    },
    [oe.OptimismGoerli]: {
      openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
      openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
      biconomyForwarder: Ye,
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: bn,
      twBYOCRegistry: Ye,
    },
    [oe.BinanceSmartChainMainnet]: {
      openzeppelinForwarder: "0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171",
      openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
      biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
      twBYOCRegistry: Ye,
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: bn,
    },
    [oe.BinanceSmartChainTestnet]: {
      openzeppelinForwarder: "0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955",
      openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
      biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
      twBYOCRegistry: Ye,
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: bn,
    },
    [oe.Hardhat]: {
      openzeppelinForwarder: Ye,
      openzeppelinForwarderEOA: Ye,
      biconomyForwarder: Ye,
      twFactory: Ye,
      twRegistry: Ye,
      twBYOCRegistry: Ye,
    },
    [oe.Localhost]: {
      openzeppelinForwarder: Ye,
      openzeppelinForwarderEOA: Ye,
      biconomyForwarder: Ye,
      twFactory: Ye,
      twRegistry: Ye,
      twBYOCRegistry: Ye,
    },
  };
function hd(n, e) {
  var t;
  return n === oe.Hardhat || n === oe.Localhost
    ? e === "twFactory"
      ? wc("factoryAddress")
      : e === "twRegistry"
      ? wc("registryAddress")
      : Ye
    : (t = Fi[n]) == null
    ? void 0
    : t[e];
}
class Cv {
  constructor(e) {
    (this.args = e.args),
      (this.overrides = e.overrides || {}),
      (this.provider = e.provider),
      (this.signer = e.signer),
      (this.storage = e.storage),
      this.signer.provider ||
        (this.signer = this.signer.connect(this.provider));
  }
  get getSigner() {
    return this.signer;
  }
  get getProvider() {
    return this.provider;
  }
  get getStorage() {
    return this.storage;
  }
  getArgs() {
    return this.args;
  }
  getOverrides() {
    return this.overrides;
  }
  getValue() {
    return this.overrides.value || 0;
  }
  setArgs(e) {
    return (this.args = e), this;
  }
  setOverrides(e) {
    return (this.overrides = e), this;
  }
  updateOverrides(e) {
    return (this.overrides = { ...this.overrides, ...e }), this;
  }
  setValue(e) {
    return this.updateOverrides({ value: e }), this;
  }
  setGasLimit(e) {
    return this.updateOverrides({ gasLimit: e }), this;
  }
  setGasPrice(e) {
    return this.updateOverrides({ gasPrice: e }), this;
  }
  setNonce(e) {
    return this.updateOverrides({ nonce: e }), this;
  }
  setMaxFeePerGas(e) {
    return this.updateOverrides({ maxFeePerGas: e }), this;
  }
  setMaxPriorityFeePerGas(e) {
    return this.updateOverrides({ maxPriorityFeePerGas: e }), this;
  }
  setType(e) {
    return this.updateOverrides({ type: e }), this;
  }
  setAccessList(e) {
    return this.updateOverrides({ accessList: e }), this;
  }
  setCustomData(e) {
    return this.updateOverrides({ customData: e }), this;
  }
  setCcipReadEnabled(e) {
    return this.updateOverrides({ ccipReadEnabled: e }), this;
  }
  setGasLimitMultiple(e) {
    O.isBigNumber(this.overrides.gasLimit)
      ? (this.overrides.gasLimit = O.from(
          Math.floor(O.from(this.overrides.gasLimit).toNumber() * e),
        ))
      : (this.gasMultiple = e);
  }
  async estimateGasCost() {
    const e = await this.estimateGasLimit(),
      t = await this.getGasPrice(),
      r = e.mul(t);
    return { ether: zd(r), wei: r };
  }
  async getGasPrice() {
    const e = await this.provider.getGasPrice(),
      t = Ht("300", "gwei"),
      r = e.div(100).mul(10),
      a = e.add(r);
    return a.gt(t) ? t : a;
  }
  async getSignerAddress() {
    return this.signer.getAddress();
  }
  async getGasOverrides() {
    return {};
  }
  getPreferredPriorityFee(e) {
    const t = e.div(100).mul(10),
      r = e.add(t),
      a = Ht("300", "gwei"),
      i = Ht("2.5", "gwei");
    return r.gt(a) ? a : r.lt(i) ? i : r;
  }
}
class ne extends Cv {
  static fromContractWrapper(e) {
    const t = e.contractWrapper.getSigner();
    if (!t)
      throw new Error(
        "Cannot create a transaction without a signer. Please ensure that you have a connected signer.",
      );
    const r = {
      ...e,
      contract: e.contractWrapper.writeContract,
      provider: e.contractWrapper.getProvider(),
      signer: t,
      gasless: e.contractWrapper.options.gasless,
      storage: e.contractWrapper.storage,
    };
    return new ne(r);
  }
  static async fromContractInfo(e) {
    const t = e.storage;
    let r = e.contractAbi;
    if (!r)
      try {
        r = (await wr(e.contractAddress, e.provider, t)).abi;
      } catch {
        throw new Error(
          `Could resolve contract metadata for address ${e.contractAddress}. Please pass the contract ABI manually with the 'contractAbi' option.`,
        );
      }
    const a = new Pe(e.contractAddress, r, e.provider),
      i = { ...e, storage: t, contract: a };
    return new ne(i);
  }
  constructor(e) {
    super({
      args: e.args,
      overrides: e.overrides,
      provider: e.provider,
      signer: e.signer,
      storage: e.storage,
    }),
      (this.method = e.method),
      (this.gaslessOptions = e.gasless),
      (this.parse = e.parse),
      (this.contract = e.contract.connect(this.signer)),
      (this.storage = e.storage);
  }
  getTarget() {
    return this.contract.address;
  }
  getMethod() {
    return this.method;
  }
  getGaslessOptions() {
    return this.gaslessOptions;
  }
  setGaslessOptions(e) {
    return (this.gaslessOptions = e), this;
  }
  setParse(e) {
    return (this.parse = e), this;
  }
  encode() {
    return this.contract.interface.encodeFunctionData(this.method, this.args);
  }
  async sign() {
    const t = { ...(await this.getGasOverrides()), ...this.overrides };
    t.gasLimit || (t.gasLimit = await this.estimateGasLimit());
    const r = await this.contract.populateTransaction[this.method](
        ...this.args,
        t,
      ),
      a = await this.contract.signer.populateTransaction(r);
    return await this.contract.signer.signTransaction(a);
  }
  async simulate() {
    if (!this.contract.callStatic[this.method]) throw this.functionError();
    try {
      return await this.contract.callStatic[this.method](
        ...this.args,
        ...(this.overrides.value ? [{ value: this.overrides.value }] : []),
      );
    } catch (e) {
      throw await this.transactionError(e);
    }
  }
  async estimateGasLimit() {
    if (!this.contract.estimateGas[this.method]) throw this.functionError();
    try {
      const e = await this.contract.estimateGas[this.method](
        ...this.args,
        this.overrides,
      );
      return this.gasMultiple
        ? O.from(Math.floor(O.from(e).toNumber() * this.gasMultiple))
        : e;
    } catch (e) {
      throw (await this.simulate(), await this.transactionError(e));
    }
  }
  async send() {
    if (!this.contract.functions[this.method]) throw this.functionError();
    if (
      this.gaslessOptions &&
      ("openzeppelin" in this.gaslessOptions ||
        "biconomy" in this.gaslessOptions)
    )
      return this.sendGasless();
    const t = { ...(await this.getGasOverrides()), ...this.overrides };
    if (!t.gasLimit) {
      t.gasLimit = await this.estimateGasLimit();
      try {
        const r = JSON.parse(this.contract.interface.format("json"));
        qB(r) && (t.gasLimit = t.gasLimit.mul(110).div(100));
      } catch (r) {
        console.warn("Error raising gas limit", r);
      }
    }
    try {
      return await this.contract.functions[this.method](...this.args, t);
    } catch (r) {
      throw await this.transactionError(r);
    }
  }
  async execute() {
    const e = await this.send();
    let t;
    try {
      t = await e.wait();
    } catch (r) {
      throw (await this.simulate(), await this.transactionError(r));
    }
    return this.parse ? this.parse(t) : { receipt: t };
  }
  async sendGasless() {
    const e = await this.prepareGasless(),
      t = await pD(
        e,
        this.signer,
        this.provider,
        this.storage,
        this.gaslessOptions,
      );
    let r,
      a = 1;
    for (; !r; )
      if (
        ((r = await this.provider.getTransaction(t)),
        r ||
          (await new Promise((i) => setTimeout(i, Math.min(a * 1e3, 1e4))),
          a++),
        a > 20)
      )
        throw new Error(`Unable to retrieve transaction with hash ${t}`);
    return r;
  }
  async prepareGasless() {
    var c;
    ce(
      this.gaslessOptions &&
        ("openzeppelin" in this.gaslessOptions ||
          "biconomy" in this.gaslessOptions),
      "No gasless options set on this transaction!",
    );
    const e = [...this.args];
    if (
      this.method === "multicall" &&
      Array.isArray(this.args[0]) &&
      e[0].length > 0
    ) {
      const l = await this.getSignerAddress();
      e[0] = e[0].map((u) => Ns(["bytes", "address"], [u, l]));
    }
    ce(this.signer, "Cannot execute gasless transaction without valid signer");
    const t = (await this.provider.getNetwork()).chainId,
      r = await (this.overrides.from || this.getSignerAddress()),
      a = this.contract.address,
      i = ((c = this.overrides) == null ? void 0 : c.value) || 0;
    if (O.from(i).gt(0))
      throw new Error(
        "Cannot send native token value with gasless transaction",
      );
    const s = this.contract.interface.encodeFunctionData(this.method, e);
    let o = O.from(0);
    try {
      o = (await this.contract.estimateGas[this.method](...e)).mul(2);
    } catch {}
    return (
      o.lt(1e5) && (o = O.from(5e5)),
      this.overrides.gasLimit &&
        O.from(this.overrides.gasLimit).gt(o) &&
        (o = O.from(this.overrides.gasLimit)),
      {
        from: r,
        to: a,
        data: s,
        chainId: t,
        gasLimit: o,
        functionName: this.method,
        functionArgs: e,
        callOverrides: this.overrides,
      }
    );
  }
  functionError() {
    return new Error(
      `Contract "${this.contract.address}" does not have function "${this.method}"`,
    );
  }
  async transactionError(e) {
    var g, v, w;
    const t = this.provider,
      r = await t.getNetwork(),
      a = await (this.overrides.from || this.getSignerAddress()),
      i = this.contract.address,
      s = this.encode(),
      o = O.from(this.overrides.value || 0),
      c = (g = t.connection) == null ? void 0 : g.url,
      l = this.contract.interface.getFunction(this.method),
      u = this.args.map((T) =>
        JSON.stringify(T).length <= 80
          ? JSON.stringify(T)
          : JSON.stringify(T, void 0, 2),
      ),
      d =
        u.join(", ").length <= 80
          ? u.join(", ")
          : `
` +
            u.map(
              (T) =>
                "  " +
                T.split(`
`).join(`
  `),
            ).join(`,
`) +
            `
`,
      f = `${l.name}(${d})`,
      p =
        e.transactionHash ||
        ((v = e.transaction) == null ? void 0 : v.hash) ||
        ((w = e.receipt) == null ? void 0 : w.transactionHash),
      m = gm(e);
    let y, h;
    try {
      const T = await wr(this.contract.address, this.provider, this.storage);
      T.name && (h = T.name),
        T.metadata.sources && (y = await uf(T, this.storage));
    } catch {}
    return new ym(
      {
        reason: m,
        from: a,
        to: i,
        method: f,
        data: s,
        network: r,
        rpcUrl: c,
        value: o,
        hash: p,
        contractName: h,
        sources: y,
      },
      e,
    );
  }
}
class fD extends Cv {
  constructor(e) {
    super(e), (this.factory = e.factory), (this.events = e.events);
  }
  encode() {
    return pe(
      nt([
        this.factory.bytecode,
        this.factory.interface.encodeDeploy(this.args),
      ]),
    );
  }
  getTarget() {
    return Ie;
  }
  getMethod() {
    return "deploy";
  }
  async sign() {
    const e = await this.populateTransaction();
    return this.signer.signTransaction(e);
  }
  async simulate() {
    const e = await this.populateTransaction();
    return this.signer.call(e);
  }
  async estimateGasLimit() {
    try {
      const t = { ...(await this.getGasOverrides()), ...this.overrides },
        r = this.factory.getDeployTransaction(...this.args, t);
      return this.signer.estimateGas(r);
    } catch (e) {
      throw await this.deployError(e);
    }
  }
  async send() {
    try {
      const e = await this.populateTransaction();
      return await this.signer.sendTransaction(e);
    } catch (e) {
      throw await this.deployError(e);
    }
  }
  async execute() {
    const e = await this.send();
    try {
      await e.wait();
    } catch (r) {
      throw (await this.simulate(), await this.deployError(r));
    }
    const t = Nc({ from: e.from, nonce: e.nonce });
    return (
      this.events &&
        this.events.emit("contractDeployed", {
          status: "completed",
          contractAddress: t,
          transactionHash: e.hash,
        }),
      t
    );
  }
  async populateTransaction() {
    const t = { ...(await this.getGasOverrides()), ...this.overrides };
    return (
      t.gasLimit || (t.gasLimit = await this.estimateGasLimit()),
      this.factory.getDeployTransaction(...this.args, t)
    );
  }
  async deployError(e) {
    var p, m, y;
    const t = this.provider,
      r = await t.getNetwork(),
      a = await (this.overrides.from || this.getSignerAddress()),
      i = this.encode(),
      s = O.from(this.overrides.value || 0),
      o = (p = t.connection) == null ? void 0 : p.url,
      c = this.args.map((h) =>
        JSON.stringify(h).length <= 80
          ? JSON.stringify(h)
          : JSON.stringify(h, void 0, 2),
      ),
      u = `deployContract(${
        c.join(", ").length <= 80
          ? c.join(", ")
          : `
` +
            c.map(
              (h) =>
                "  " +
                h.split(`
`).join(`
  `),
            ).join(`,
`) +
            `
`
      })`,
      d =
        e.transactionHash ||
        ((m = e.transaction) == null ? void 0 : m.hash) ||
        ((y = e.receipt) == null ? void 0 : y.transactionHash),
      f = gm(e);
    return new ym(
      {
        reason: f,
        from: a,
        method: u,
        data: i,
        network: r,
        rpcUrl: o,
        value: s,
        hash: d,
      },
      e,
    );
  }
}
async function pD(n, e, t, r, a) {
  return a && "biconomy" in a ? hD(n, e, t, a) : mD(n, e, t, r, a);
}
async function hD(n, e, t, r) {
  const a = await gD(n, e, t, r),
    i = await la("https://api.biconomy.io/api/v2/meta-tx/native", a);
  if (i.ok) {
    const s = await i.json();
    if (!s.txHash) throw new Error(`relay transaction failed: ${s.log}`);
    return s.txHash;
  }
  throw new Error(
    `relay transaction failed with status: ${i.status} (${i.statusText})`,
  );
}
async function mD(n, e, t, r, a) {
  ce(
    a && "openzeppelin" in a,
    "calling openzeppelin gasless transaction without openzeppelin config in the SDK options",
  );
  const i = await yD(n, e, t, r, a),
    s = await la(a.openzeppelin.relayerUrl, i);
  if (s.ok) {
    const o = await s.json();
    if (!o.result) throw new Error(`Relay transaction failed: ${o.message}`);
    return JSON.parse(o.result).txHash;
  }
  throw new Error(
    `relay transaction failed with status: ${s.status} (${s.statusText})`,
  );
}
async function yD(n, e, t, r, a) {
  ce(
    a && "openzeppelin" in a,
    "calling openzeppelin gasless transaction without openzeppelin config in the SDK options",
  ),
    ce(e, "provider is not set"),
    ce(t, "provider is not set");
  const i =
      a.openzeppelin.relayerForwarderAddress ||
      (a.openzeppelin.useEOAForwarder
        ? Fi[n.chainId].openzeppelinForwarderEOA || (await bv(t, r))
        : Fi[n.chainId].openzeppelinForwarder || (await Cm(t, r))),
    s = new Pe(i, R6, t),
    o = await pd(s, "getNonce", [n.from]);
  let c, l, u;
  a.experimentalChainlessSupport
    ? ((c = {
        name: "GSNv2 Forwarder",
        version: "0.0.1",
        verifyingContract: i,
      }),
      (l = { ForwardRequest: vv }),
      (u = {
        from: n.from,
        to: n.to,
        value: O.from(0).toString(),
        gas: O.from(n.gasLimit).toString(),
        nonce: O.from(o).toString(),
        data: n.data,
        chainid: O.from(n.chainId).toString(),
      }))
    : ((c = {
        name: a.openzeppelin.domainName,
        version: a.openzeppelin.domainVersion,
        chainId: n.chainId,
        verifyingContract: i,
      }),
      (l = { ForwardRequest: xv }),
      (u = {
        from: n.from,
        to: n.to,
        value: O.from(0).toString(),
        gas: O.from(n.gasLimit).toString(),
        nonce: O.from(o).toString(),
        data: n.data,
      }));
  let d;
  if (n.functionName === "approve" && n.functionArgs.length === 2) {
    const p = n.functionArgs[0],
      m = n.functionArgs[1],
      { message: y, signature: h } = await Tv(e, n.to, n.from, p, m),
      { r: g, s: v, v: w } = ai(h);
    (u = {
      to: n.to,
      owner: y.owner,
      spender: y.spender,
      value: O.from(y.value).toString(),
      nonce: O.from(y.nonce).toString(),
      deadline: O.from(y.deadline).toString(),
      r: g,
      s: v,
      v: w,
    }),
      (d = h);
  } else {
    const { signature: p } = await Cc(e, c, l, u);
    d = p;
  }
  let f = "forward";
  return (
    u != null && u.owner && (f = "permit"),
    {
      method: "POST",
      body: JSON.stringify({
        request: u,
        signature: d,
        forwarderAddress: i,
        type: f,
      }),
    }
  );
}
async function gD(n, e, t, r) {
  var u;
  ce(r && "biconomy" in r, "calling biconomySendFunction without biconomy"),
    ce(e && t, "signer and provider must be set");
  const a = new Pe(hd(n.chainId, "biconomyForwarder"), wv, t),
    i = 0,
    s = await pd(a, "getNonce", [n.from, i]),
    o = {
      from: n.from,
      to: n.to,
      token: Ie,
      txGas: n.gasLimit.toNumber(),
      tokenGasPrice: "0",
      batchId: i,
      batchNonce: s.toNumber(),
      deadline: Math.floor(
        Date.now() / 1e3 +
          ((r &&
            "biconomy" in r &&
            ((u = r.biconomy) == null ? void 0 : u.deadlineSeconds)) ||
            3600),
      ),
      data: n.data,
    },
    c = ae(
      er(
        [
          "address",
          "address",
          "address",
          "uint256",
          "uint256",
          "uint256",
          "uint256",
          "uint256",
          "bytes32",
        ],
        [
          o.from,
          o.to,
          o.token,
          o.txGas,
          o.tokenGasPrice,
          o.batchId,
          o.batchNonce,
          o.deadline,
          Ge(o.data),
        ],
      ),
    ),
    l = await e.signMessage(c);
  return {
    method: "POST",
    body: JSON.stringify({
      from: n.from,
      apiId: r.biconomy.apiId,
      params: [o, l],
      to: n.to,
      gasLimit: n.gasLimit.toHexString(),
    }),
    headers: {
      "x-api-key": r.biconomy.apiKey,
      "Content-Type": "application/json;charset=utf-8",
    },
  };
}
class _s {
  constructor(e, t, r) {
    $(this, "featureName", td.name);
    $(
      this,
      "set",
      Y(async (e) => {
        const t = await this._parseAndUploadMetadata(e),
          r = this.contractWrapper;
        if (this.supportsContractMetadata(r))
          return ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "setContractURI",
            args: [t],
            parse: (a) => ({ receipt: a, data: this.get }),
          });
        throw new $s(td);
      }),
    );
    $(
      this,
      "update",
      Y(async (e) => await this.set.prepare({ ...(await this.get()), ...e })),
    );
    (this.contractWrapper = e), (this.schema = t), (this.storage = r);
  }
  parseOutputMetadata(e) {
    return this.schema.output.parseAsync(e);
  }
  parseInputMetadata(e) {
    return this.schema.input.parseAsync(e);
  }
  async get() {
    let e;
    if (this.supportsContractMetadata(this.contractWrapper)) {
      const t = await this.contractWrapper.readContract.contractURI();
      t && t.includes("://") && (e = await this.storage.downloadJSON(t));
    }
    if (!e)
      try {
        let t;
        try {
          vt("name", this.contractWrapper) &&
            (t = await this.contractWrapper.readContract.name());
        } catch {}
        let r;
        try {
          vt("symbol", this.contractWrapper) &&
            (r = await this.contractWrapper.readContract.symbol());
        } catch {}
        let a;
        try {
          a = await wr(
            this.contractWrapper.readContract.address,
            this.contractWrapper.getProvider(),
            this.storage,
          );
        } catch {}
        e = {
          name: t || (a == null ? void 0 : a.name),
          symbol: r,
          description: a == null ? void 0 : a.info.title,
        };
      } catch {
        throw new Error("Could not fetch contract metadata");
      }
    return this.parseOutputMetadata(e);
  }
  async _parseAndUploadMetadata(e) {
    const t = await this.parseInputMetadata(e);
    return this.storage.upload(t);
  }
  supportsContractMetadata(e) {
    return fe(e, "ContractMetadata");
  }
}
async function te(n) {
  return at.parseAsync(n);
}
const Av = {
    admin: "",
    transfer: "TRANSFER_ROLE",
    minter: "MINTER_ROLE",
    pauser: "PAUSER_ROLE",
    lister: "LISTER_ROLE",
    asset: "ASSET_ROLE",
    unwrap: "UNWRAP_ROLE",
    factory: "FACTORY_ROLE",
    signer: "SIGNER_ROLE",
  },
  Ev = Object.keys(Av);
function Do(n) {
  return n === "admin" ? Ue([0], 32) : wn(Av[n]);
}
class bD {
  constructor(e, t) {
    $(this, "featureName", ed.name);
    $(
      this,
      "setAll",
      Y(async (e) => {
        var s, o;
        const t = Object.keys(e);
        ce(t.length, "you must provide at least one role to set"),
          ce(
            t.every((c) => this.roles.includes(c)),
            "this contract does not support the given role",
          );
        const r = await this.getAll(),
          a = [],
          i = t.sort((c) => (c === "admin" ? 1 : -1));
        for (let c = 0; c < i.length; c++) {
          const l = i[c],
            u = await Promise.all(
              ((s = e[l]) == null ? void 0 : s.map(async (m) => await te(m))) ||
                [],
            ),
            d = await Promise.all(
              ((o = r[l]) == null ? void 0 : o.map(async (m) => await te(m))) ||
                [],
            ),
            f = u.filter((m) => !d.includes(m)),
            p = d.filter((m) => !u.includes(m));
          if (
            (f.length &&
              f.forEach((m) => {
                a.push(
                  this.contractWrapper.readContract.interface.encodeFunctionData(
                    "grantRole",
                    [Do(l), m],
                  ),
                );
              }),
            p.length)
          )
            for (let m = 0; m < p.length; m++) {
              const y = p[m],
                h = await this.getRevokeRoleFunctionName(y);
              a.push(
                this.contractWrapper.readContract.interface.encodeFunctionData(
                  h,
                  [Do(l), y],
                ),
              );
            }
        }
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [a],
        });
      }),
    );
    $(
      this,
      "grant",
      Y(async (e, t) => {
        ce(
          this.roles.includes(e),
          `this contract does not support the "${e}" role`,
        );
        const r = await te(t);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "grantRole",
          args: [Do(e), r],
        });
      }),
    );
    $(
      this,
      "revoke",
      Y(async (e, t) => {
        ce(
          this.roles.includes(e),
          `this contract does not support the "${e}" role`,
        );
        const r = await te(t),
          a = await this.getRevokeRoleFunctionName(r);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: a,
          args: [Do(e), r],
        });
      }),
    );
    (this.contractWrapper = e), (this.roles = t);
  }
  async getAll() {
    ce(this.roles.length, "this contract has no support for roles");
    const e = {};
    for (const t of this.roles) e[t] = await this.get(t);
    return e;
  }
  async get(e) {
    ce(
      this.roles.includes(e),
      `this contract does not support the "${e}" role`,
    );
    const t = this.contractWrapper;
    if (vt("getRoleMemberCount", t) && vt("getRoleMember", t)) {
      const r = Do(e),
        a = (await t.readContract.getRoleMemberCount(r)).toNumber();
      return await Promise.all(
        Array.from(Array(a).keys()).map((i) =>
          t.readContract.getRoleMember(r, i),
        ),
      );
    }
    throw new Error(
      "Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.",
    );
  }
  async verify(e, t) {
    await Promise.all(
      e.map(async (r) => {
        const a = await this.get(r),
          i = await te(t);
        if (!a.map((s) => s.toLowerCase()).includes(i.toLowerCase()))
          throw new bB(i, r);
      }),
    );
  }
  async getRevokeRoleFunctionName(e) {
    const t = await te(e);
    return (await this.contractWrapper.getSignerAddress()).toLowerCase() ===
      t.toLowerCase()
      ? "renounceRole"
      : "revokeRole";
  }
}
class xD {
  constructor(e, t) {
    $(this, "featureName", Ju.name);
    $(
      this,
      "setDefaultRoyaltyInfo",
      Y(async (e) => {
        const t = await this.metadata.get(),
          r = await this.metadata.parseInputMetadata({ ...t, ...e }),
          a = await this.metadata._parseAndUploadMetadata(r);
        if (vt("setContractURI", this.contractWrapper)) {
          const i = [
            this.contractWrapper.readContract.interface.encodeFunctionData(
              "setDefaultRoyaltyInfo",
              [r.fee_recipient, r.seller_fee_basis_points],
            ),
            this.contractWrapper.readContract.interface.encodeFunctionData(
              "setContractURI",
              [a],
            ),
          ];
          return ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [i],
            parse: (s) => ({
              receipt: s,
              data: () => this.getDefaultRoyaltyInfo(),
            }),
          });
        } else
          throw new Error(
            "Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.",
          );
      }),
    );
    $(
      this,
      "setTokenRoyaltyInfo",
      Y(async (e, t) => {
        const r = Bt.parse(t);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setRoyaltyInfoForToken",
          args: [e, r.fee_recipient, r.seller_fee_basis_points],
          parse: (a) => ({
            receipt: a,
            data: () => this.getDefaultRoyaltyInfo(),
          }),
        });
      }),
    );
    (this.contractWrapper = e), (this.metadata = t);
  }
  async getDefaultRoyaltyInfo() {
    const [e, t] =
      await this.contractWrapper.readContract.getDefaultRoyaltyInfo();
    return Bt.parseAsync({ fee_recipient: e, seller_fee_basis_points: t });
  }
  async getTokenRoyaltyInfo(e) {
    const [t, r] =
      await this.contractWrapper.readContract.getRoyaltyInfoForToken(e);
    return Bt.parseAsync({ fee_recipient: t, seller_fee_basis_points: r });
  }
}
class vD {
  constructor(e) {
    $(this, "featureName", Xu.name);
    $(
      this,
      "setRecipient",
      Y(async (e) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setPrimarySaleRecipient",
          args: [e],
        }),
      ),
    );
    this.contractWrapper = e;
  }
  async getRecipient() {
    return await this.contractWrapper.readContract.primarySaleRecipient();
  }
}
const ff = ae("0x80ac58cd"),
  pf = ae("0xd9b67a26"),
  hf = { name: "Failed to load NFT metadata" };
async function Am(n, e, t) {
  if (e.startsWith("data:application/json;base64") && typeof Buffer < "u") {
    const i = e.split(",")[1],
      s = JSON.parse(Buffer.from(i, "base64").toString("utf-8"));
    return Ip.parse({ ...s, id: O.from(n).toString(), uri: e });
  }
  const r = e.replace("{id}", Ue(O.from(n).toHexString(), 32).slice(2));
  let a;
  try {
    a = await t.downloadJSON(r);
  } catch {
    const s = e.replace("{id}", O.from(n).toString());
    try {
      a = await t.downloadJSON(s);
    } catch {
      console.warn(
        `failed to get token metadata: ${JSON.stringify({
          tokenId: n.toString(),
          tokenUri: e,
        })} -- falling back to default metadata`,
      ),
        (a = hf);
    }
  }
  return Ip.parse({ ...a, id: O.from(n).toString(), uri: e });
}
async function mf(n, e, t, r) {
  let a;
  const i = new Pe(n, rf, e),
    s = await i.supportsInterface(ff),
    o = await i.supportsInterface(pf);
  if (s) a = await new Pe(n, RR, e).tokenURI(t);
  else if (o) a = await new Pe(n, MR, e).uri(t);
  else throw Error("Contract must implement ERC 1155 or ERC 721.");
  return a
    ? Am(t, a, r)
    : Ip.parse({ ...hf, id: O.from(t).toString(), uri: "" });
}
async function Em(n, e) {
  return typeof n == "string" ? n : await e.upload(Xa.parse(n));
}
async function Yi(n, e, t, r) {
  if (wD(n)) return n;
  if (TD(n))
    return await e.uploadBatch(
      n.map((i) => Xa.parse(i)),
      {
        rewriteFileNames: { fileStartNumber: t || 0 },
        onProgress: r == null ? void 0 : r.onProgress,
      },
    );
  throw new Error(
    "NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)",
  );
}
function Ss(n) {
  const e = n[0].substring(0, n[0].lastIndexOf("/"));
  for (let t = 0; t < n.length; t++) {
    const r = n[t].substring(0, n[t].lastIndexOf("/"));
    if (e !== r)
      throw new Error(
        `Can only create batches with the same base URI for every entry in the batch. Expected '${e}' but got '${r}'`,
      );
  }
  return e.replace(/\/$/, "") + "/";
}
function wD(n) {
  return n.find((e) => typeof e != "string") === void 0;
}
function TD(n) {
  return n.find((e) => typeof e != "object") === void 0;
}
class kv {
  constructor(e, t, r, a) {
    $(
      this,
      "createDelayedRevealBatch",
      Y(async (e, t, r, a) => {
        if (!r) throw new Error("Password is required");
        const i = await this.storage.uploadBatch([Xa.parse(e)], {
            rewriteFileNames: { fileStartNumber: 0 },
          }),
          s = Ss(i),
          o = await this.nextTokenIdToMintFn(),
          c = await this.storage.uploadBatch(
            t.map((y) => Xa.parse(y)),
            {
              onProgress: a == null ? void 0 : a.onProgress,
              rewriteFileNames: { fileStartNumber: o.toNumber() },
            },
          ),
          l = Ss(c),
          u = await this.contractWrapper.readContract.getBaseURICount(),
          d = await this.hashDelayRevealPassword(u, r),
          f = await this.contractWrapper.readContract.encryptDecrypt(Ne(l), d);
        let p;
        if (await this.isLegacyContract()) p = f;
        else {
          const y = await this.contractWrapper.getChainID(),
            h = er(["bytes", "bytes", "uint256"], [Ne(l), d, y]);
          p = Ga.encode(["bytes", "bytes32"], [f, h]);
        }
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [c.length, s.endsWith("/") ? s : `${s}/`, p],
          parse: (y) => {
            const h = this.contractWrapper.parseLogs(
                "TokensLazyMinted",
                y == null ? void 0 : y.logs,
              ),
              g = h[0].args.startTokenId,
              v = h[0].args.endTokenId,
              w = [];
            for (let T = g; T.lte(v); T = T.add(1))
              w.push({ id: T, receipt: y });
            return w;
          },
        });
      }),
    );
    $(
      this,
      "reveal",
      Y(async (e, t) => {
        if (!t) throw new Error("Password is required");
        const r = await this.hashDelayRevealPassword(e, t);
        try {
          const a = await this.contractWrapper.callStatic().reveal(e, r);
          if (!a.includes("://") || !a.endsWith("/"))
            throw new Error("invalid password");
        } catch {
          throw new Error("invalid password");
        }
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "reveal",
          args: [e, r],
        });
      }),
    );
    (this.featureName = r),
      (this.nextTokenIdToMintFn = a),
      (this.contractWrapper = e),
      (this.storage = t);
  }
  async getBatchesToReveal() {
    const e = await this.contractWrapper.readContract.getBaseURICount();
    if (e.isZero()) return [];
    const t = Array.from(Array(e.toNumber()).keys()),
      r = await Promise.all(
        t.map((l) => {
          if (vt("getBatchIdAtIndex", this.contractWrapper))
            return this.contractWrapper.readContract.getBatchIdAtIndex(l);
          if (vt("baseURIIndices", this.contractWrapper))
            return this.contractWrapper.readContract.baseURIIndices(l);
          throw new Error(
            "Contract does not have getBatchIdAtIndex or baseURIIndices.",
          );
        }),
      ),
      a = r.slice(0, r.length - 1),
      i = await Promise.all(
        Array.from([0, ...a]).map((l) => this.getNftMetadata(l.toString())),
      ),
      s = await this.isLegacyContract(),
      c = (
        await Promise.all(
          Array.from([...r]).map((l) =>
            s
              ? this.getLegacyEncryptedData(l)
              : this.contractWrapper.readContract.encryptedData(l),
          ),
        )
      ).map((l) =>
        sa(l) > 0 ? (s ? l : Ga.decode(["bytes", "bytes32"], l)[0]) : l,
      );
    return i
      .map((l, u) => ({
        batchId: O.from(u),
        batchUri: l.uri,
        placeholderMetadata: l,
      }))
      .filter((l, u) => sa(c[u]) > 0);
  }
  async hashDelayRevealPassword(e, t) {
    const r = await this.contractWrapper.getChainID(),
      a = this.contractWrapper.readContract.address;
    return er(["string", "uint256", "uint256", "address"], [t, r, e, a]);
  }
  async getNftMetadata(e) {
    return mf(
      this.contractWrapper.readContract.address,
      this.contractWrapper.getProvider(),
      e,
      this.storage,
    );
  }
  async isLegacyContract() {
    if (vt("contractVersion", this.contractWrapper))
      try {
        return (await this.contractWrapper.readContract.contractVersion()) <= 2;
      } catch {
        return !1;
      }
    return !1;
  }
  async getLegacyEncryptedData(e) {
    const r = await new Pe(
      this.contractWrapper.readContract.address,
      BR,
      this.contractWrapper.getProvider(),
    ).functions.encryptedBaseURI(e);
    return r.length > 0 ? r[0] : "0x";
  }
}
function rr(n) {
  return n.toLowerCase() === an || n.toLowerCase() === Ie;
}
function Na(n, e) {
  return n === "unlimited" ? On : Ht(n, e);
}
async function Jc(n, e) {
  if (rr(e)) {
    const t = await n.getNetwork(),
      r = q6(t.chainId);
    return { name: r.name, symbol: r.symbol, decimals: r.decimals };
  } else {
    const t = new Pe(e, $I, n),
      [r, a, i] = await Promise.all([t.name(), t.symbol(), t.decimals()]);
    return { name: r, symbol: a, decimals: i };
  }
}
async function _v(n) {
  const t = Array.from({ length: Math.ceil(n.length / 25e3) }, (a, i) =>
      n.slice(i * 25e3, i * 25e3 + 25e3),
    ),
    r = [];
  for (const a of t) r.push(...(await fm.parseAsync(a)));
  return r;
}
const CD = 2;
let Li = (function (n) {
  return (n[(n.V1 = 1)] = "V1"), (n[(n.V2 = 2)] = "V2"), n;
})({});
class Yn {
  constructor(e, t, r, a, i) {
    (this.storage = e),
      (this.shardNybbles = a),
      (this.baseUri = t),
      (this.originalEntriesUri = r),
      (this.tokenDecimals = i),
      (this.shards = {}),
      (this.trees = {});
  }
  static async fromUri(e, t) {
    try {
      const r = await t.downloadJSON(e);
      if (r.isShardedMerkleTree) return Yn.fromShardedMerkleTreeInfo(r, t);
    } catch {
      return;
    }
  }
  static async fromShardedMerkleTreeInfo(e, t) {
    return new Yn(
      t,
      e.baseUri,
      e.originalEntriesUri,
      e.shardNybbles,
      e.tokenDecimals,
    );
  }
  static hashEntry(e, t, r, a) {
    switch (a) {
      case Li.V1:
        return er(["address", "uint256"], [e.address, Na(e.maxClaimable, t)]);
      case Li.V2:
        return er(
          ["address", "uint256", "uint256", "address"],
          [
            e.address,
            Na(e.maxClaimable, t),
            Na(e.price || "unlimited", r),
            e.currencyAddress || Ie,
          ],
        );
    }
  }
  static async fetchAndCacheDecimals(e, t, r) {
    if (!r) return 18;
    let a = e[r];
    return a === void 0 && ((a = (await Jc(t, r)).decimals), (e[r] = a)), a;
  }
  static async buildAndUpload(e, t, r, a, i) {
    let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : CD;
    const o = await _v(e),
      c = {};
    for (const w of o) {
      const T = w.address.slice(2, 2 + s).toLowerCase();
      c[T] === void 0 && (c[T] = []), c[T].push(w);
    }
    const l = {},
      u = await Promise.all(
        Object.entries(c).map(async (w) => {
          let [T, A] = w;
          return [
            T,
            new Kl.MerkleTree(
              await Promise.all(
                A.map(async (E) => {
                  const _ = await Yn.fetchAndCacheDecimals(
                    l,
                    r,
                    E.currencyAddress,
                  );
                  return Yn.hashEntry(E, t, _, i);
                }),
              ),
              Ge,
              { sort: !0 },
            ).getHexRoot(),
          ];
        }),
      ),
      d = Object.fromEntries(u),
      f = new Kl.MerkleTree(Object.values(d), Ge, { sort: !0 }),
      p = [];
    for (const [w, T] of Object.entries(c)) {
      const A = {
        proofs: f.getProof(d[w]).map((E) => "0x" + E.data.toString("hex")),
        entries: T,
      };
      p.push({ data: JSON.stringify(A), name: `${w}.json` });
    }
    const m = await a.uploadBatch(p),
      y = m[0].slice(0, m[0].lastIndexOf("/")),
      h = await a.upload(o),
      g = {
        merkleRoot: f.getHexRoot(),
        baseUri: y,
        originalEntriesUri: h,
        shardNybbles: s,
        tokenDecimals: t,
        isShardedMerkleTree: !0,
      },
      v = await a.upload(g);
    return { shardedMerkleInfo: g, uri: v };
  }
  async getProof(e, t, r) {
    const a = e.slice(2, 2 + this.shardNybbles).toLowerCase();
    let i = this.shards[a];
    const s = {};
    if (i === void 0)
      try {
        i = this.shards[a] = await this.storage.downloadJSON(
          `${this.baseUri}/${a}.json`,
        );
        const d = await Promise.all(
          i.entries.map(async (f) => {
            const p = await Yn.fetchAndCacheDecimals(s, t, f.currencyAddress);
            return Yn.hashEntry(f, this.tokenDecimals, p, r);
          }),
        );
        this.trees[a] = new Kl.MerkleTree(d, Ge, { sort: !0 });
      } catch {
        return null;
      }
    const o = i.entries.find(
      (d) => d.address.toLowerCase() === e.toLowerCase(),
    );
    if (!o) return null;
    const c = await Yn.fetchAndCacheDecimals(s, t, o.currencyAddress),
      l = Yn.hashEntry(o, this.tokenDecimals, c, r),
      u = this.trees[a].getProof(l).map((d) => "0x" + d.data.toString("hex"));
    return V6.parseAsync({ ...o, proof: u.concat(i.proofs) });
  }
  async getAllEntries() {
    try {
      return await this.storage.downloadJSON(this.originalEntriesUri);
    } catch (e) {
      return console.warn("Could not fetch original snapshot entries", e), [];
    }
  }
}
let zt = (function (n) {
    return (
      (n[(n.UNSET = 0)] = "UNSET"),
      (n[(n.Created = 1)] = "Created"),
      (n[(n.Completed = 2)] = "Completed"),
      (n[(n.Cancelled = 3)] = "Cancelled"),
      (n[(n.Active = 4)] = "Active"),
      (n[(n.Expired = 5)] = "Expired"),
      n
    );
  })({}),
  et = (function (n) {
    return (
      (n.NotEnoughSupply = "There is not enough supply to claim."),
      (n.AddressNotAllowed = "This address is not on the allowlist."),
      (n.WaitBeforeNextClaimTransaction =
        "Not enough time since last claim transaction. Please wait."),
      (n.AlreadyClaimed = "You have already claimed the token."),
      (n.NotEnoughTokens =
        "There are not enough tokens in the wallet to pay for the claim."),
      (n.NoActiveClaimPhase =
        "There is no active claim phase at the moment. Please check back in later."),
      (n.NoClaimConditionSet = "There is no claim condition set."),
      (n.NoWallet = "No wallet connected."),
      (n.Unknown = "No claim conditions found."),
      n
    );
  })({}),
  Bn = (function (n) {
    return (n.Transaction = "transaction"), (n.Signature = "signature"), n;
  })({});
class fo extends Iu {
  constructor(e, t) {
    super();
    try {
      this.options = Vp.parse(t);
    } catch (i) {
      console.error(
        "invalid sdk options object passed, falling back to default options",
        i,
      ),
        (this.options = Vp.parse({}));
    }
    const [r, a] = Vt(e, this.options);
    (this.signer = r), (this.provider = a);
  }
  updateSignerOrProvider(e) {
    const [t, r] = Vt(e, this.options);
    (this.signer = t), (this.provider = r);
  }
  isReadOnly() {
    return !lm(this.signer);
  }
  getSigner() {
    return this.signer;
  }
  getProvider() {
    return this.provider;
  }
  getSignerOrProvider() {
    return this.getSigner() || this.getProvider();
  }
}
class Dt extends fo {
  constructor(t, r, a, i, s) {
    super(t, i);
    $(this, "isValidContract", !1);
    $(this, "customOverrides", () => ({}));
    (this.abi = a),
      (this.writeContract = new Pe(r, a, this.getSignerOrProvider())),
      (this.readContract = this.writeContract.connect(this.getProvider())),
      (this.storage = s);
  }
  updateSignerOrProvider(t) {
    super.updateSignerOrProvider(t),
      (this.writeContract = this.writeContract.connect(
        this.getSignerOrProvider(),
      )),
      (this.readContract = this.writeContract.connect(this.getProvider()));
  }
  async getChainID() {
    const t = this.getProvider(),
      { chainId: r } = await t.getNetwork();
    return r;
  }
  async getSignerAddress() {
    const t = this.getSigner();
    if (!t)
      throw new Error(
        "This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.",
      );
    return await t.getAddress();
  }
  callStatic() {
    return this.writeContract.callStatic;
  }
  async getCallOverrides() {
    return {};
  }
  getPreferredPriorityFee(t) {
    const r = this.options.gasSettings.speed,
      a = this.options.gasSettings.maxPriceInGwei;
    let i;
    switch (r) {
      case "standard":
        i = O.from(0);
        break;
      case "fast":
        i = t.div(100).mul(5);
        break;
      case "fastest":
        i = t.div(100).mul(10);
        break;
    }
    let s = t.add(i);
    const o = Ht(a.toString(), "gwei"),
      c = Ht("2.5", "gwei");
    return s.gt(o) && (s = o), s.lt(c) && (s = c), s;
  }
  async getPreferredGasPrice() {
    const t = await this.getProvider().getGasPrice(),
      r = this.options.gasSettings.speed,
      a = this.options.gasSettings.maxPriceInGwei;
    let i = t,
      s;
    switch (r) {
      case "standard":
        s = O.from(1);
        break;
      case "fast":
        s = t.div(100).mul(5);
        break;
      case "fastest":
        s = t.div(100).mul(10);
        break;
    }
    i = i.add(s);
    const o = Ht(a.toString(), "gwei");
    return i.gt(o) && (i = o), i;
  }
  emitTransactionEvent(t, r) {
    this.emit(Bn.Transaction, { status: t, transactionHash: r });
  }
  async multiCall(t) {
    return this.sendTransaction("multicall", [t]);
  }
  async estimateGas(t, r) {
    return this.writeContract.estimateGas[t](...r);
  }
  withTransactionOverride(t) {
    this.customOverrides = t;
  }
  async call(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
      a = arguments.length > 2 ? arguments[2] : void 0;
    const i = a ? await gB.parseAsync(a) : void 0,
      s = bc(mt.parse(this.abi)).filter((u) => u.name === t);
    if (!s.length)
      throw new Error(
        `Function "${t}" not found in contract. Check your dashboard for the list of functions available`,
      );
    const o = s.find((u) => u.name === t && u.inputs.length === r.length);
    if (!o)
      throw new Error(`Function "${t}" requires ${s[0].inputs.length} arguments, but ${r.length} were provided.
Expected function signature: ${s[0].signature}`);
    const c = `${t}(${o.inputs.map((u) => u.type).join()})`,
      l = c in this.readContract.functions ? c : t;
    return o.stateMutability === "view" || o.stateMutability === "pure"
      ? i
        ? this.readContract[l](...r, i)
        : this.readContract[l](...r)
      : { receipt: await this.sendTransaction(l, r, i) };
  }
  async sendTransaction(t, r, a) {
    var i;
    if (
      (a || (a = await this.getCallOverrides()),
      (a = { ...a, ...this.customOverrides() }),
      (this.customOverrides = () => ({})),
      (i = this.options) != null &&
        i.gasless &&
        ("openzeppelin" in this.options.gasless ||
          "biconomy" in this.options.gasless))
    ) {
      if (t === "multicall" && Array.isArray(r[0]) && r[0].length > 0) {
        const l = await this.getSignerAddress();
        r[0] = r[0].map((u) => Ns(["bytes", "address"], [u, l]));
      }
      const s = this.getProvider(),
        o = await this.sendGaslessTransaction(t, r, a);
      this.emitTransactionEvent("submitted", o);
      const c = await s.waitForTransaction(o);
      return this.emitTransactionEvent("completed", o), c;
    } else {
      if (!this.isValidContract) {
        const c = await this.getProvider().getCode(this.readContract.address);
        if (((this.isValidContract = c !== "0x"), !this.isValidContract))
          throw new Error(
            "The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct",
          );
      }
      const s = await this.sendTransactionByFunction(t, r, a);
      this.emitTransactionEvent("submitted", s.hash);
      let o;
      try {
        o = await s.wait();
      } catch (c) {
        try {
          await this.writeContract.callStatic[t](
            ...r,
            ...(a.value ? [{ value: a.value }] : []),
          );
        } catch (l) {
          throw await this.formatError(l, t, r, a);
        }
        throw await this.formatError(c, t, r, a);
      }
      return this.emitTransactionEvent("completed", s.hash), o;
    }
  }
  async sendTransactionByFunction(t, r, a) {
    const i = this.writeContract.functions[t];
    if (!i) throw new Error(`invalid function: "${t.toString()}"`);
    if (!a.gasLimit)
      try {
        a.gasLimit = await this.writeContract.estimateGas[t](...r, a);
      } catch {
        try {
          await this.writeContract.callStatic[t](
            ...r,
            ...(a.value ? [{ value: a.value }] : []),
          );
        } catch (o) {
          throw await this.formatError(o, t, r, a);
        }
      }
    try {
      return await i(...r, a);
    } catch (s) {
      const o = await (a.from || this.getSignerAddress()),
        c = await (a.value ? a.value : 0),
        l = await this.getProvider().getBalance(o);
      throw l.eq(0) || (c && l.lt(c))
        ? await this.formatError(
            new Error(
              "You have insufficient funds in your account to execute this transaction.",
            ),
            t,
            r,
            a,
          )
        : await this.formatError(s, t, r, a);
    }
  }
  async formatError(t, r, a, i) {
    var A, E, _;
    const s = this.getProvider(),
      o = await s.getNetwork(),
      c = await (i.from || this.getSignerAddress()),
      l = this.readContract.address,
      u = this.readContract.interface.encodeFunctionData(r, a),
      d = O.from(i.value || 0),
      f = (A = s.connection) == null ? void 0 : A.url,
      p = this.readContract.interface.getFunction(r),
      m = a.map((S) =>
        JSON.stringify(S).length <= 80
          ? JSON.stringify(S)
          : JSON.stringify(S, void 0, 2),
      ),
      y =
        m.join(", ").length <= 80
          ? m.join(", ")
          : `
` +
            m.map(
              (S) =>
                "  " +
                S.split(`
`).join(`
  `),
            ).join(`,
`) +
            `
`,
      h = `${p.name}(${y})`,
      g =
        t.transactionHash ||
        ((E = t.transaction) == null ? void 0 : E.hash) ||
        ((_ = t.receipt) == null ? void 0 : _.transactionHash),
      v = gm(t);
    let w, T;
    try {
      const S = await wr(
        this.readContract.address,
        this.getProvider(),
        this.storage,
      );
      S.name && (T = S.name),
        S.metadata.sources && (w = await uf(S, this.storage));
    } catch {}
    return new ym(
      {
        reason: v,
        from: c,
        to: l,
        method: h,
        data: u,
        network: o,
        rpcUrl: f,
        value: d,
        hash: g,
        contractName: T,
        sources: w,
      },
      t,
    );
  }
  async sendGaslessTransaction(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
      a = arguments.length > 2 ? arguments[2] : void 0;
    const i = this.getSigner();
    ce(i, "Cannot execute gasless transaction without valid signer");
    const s = await this.getChainID(),
      o = await this.getSignerAddress(),
      c = this.writeContract.address,
      l = (a == null ? void 0 : a.value) || 0;
    if (O.from(l).gt(0))
      throw new Error(
        "Cannot send native token value with gasless transaction",
      );
    const u = this.writeContract.interface.encodeFunctionData(t, r);
    let d = O.from(0);
    try {
      d = (await this.readContract.estimateGas[t](...r)).mul(2);
    } catch {}
    d.lt(1e5) && (d = O.from(5e5)),
      a.gasLimit && O.from(a.gasLimit).gt(d) && (d = O.from(a.gasLimit));
    const f = {
      from: o,
      to: c,
      data: u,
      chainId: s,
      gasLimit: d,
      functionName: t.toString(),
      functionArgs: r,
      callOverrides: a,
    };
    return await this.defaultGaslessSendFunction(f);
  }
  async signTypedData(t, r, a, i) {
    this.emit(Bn.Signature, { status: "submitted", message: i, signature: "" });
    const { signature: s } = await Cc(t, r, a, i);
    return (
      this.emit(Bn.Signature, {
        status: "completed",
        message: i,
        signature: s,
      }),
      s
    );
  }
  parseLogs(t, r) {
    if (!r || r.length === 0) return [];
    const a = this.writeContract.interface.getEventTopic(t);
    return r
      .filter((s) => s.topics.indexOf(a) >= 0)
      .map((s) => this.writeContract.interface.parseLog(s));
  }
  async defaultGaslessSendFunction(t) {
    return this.options.gasless && "biconomy" in this.options.gasless
      ? this.biconomySendFunction(t)
      : this.defenderSendFunction(t);
  }
  async biconomySendFunction(t) {
    var f, p;
    ce(
      this.options.gasless && "biconomy" in this.options.gasless,
      "calling biconomySendFunction without biconomy",
    );
    const r = this.getSigner(),
      a = this.getProvider();
    ce(r && a, "signer and provider must be set");
    const i = new Pe(hd(t.chainId, "biconomyForwarder"), wv, a),
      s = 0,
      o = await pd(i, "getNonce", [t.from, s]),
      c = {
        from: t.from,
        to: t.to,
        token: Ie,
        txGas: t.gasLimit.toNumber(),
        tokenGasPrice: "0",
        batchId: s,
        batchNonce: o.toNumber(),
        deadline: Math.floor(
          Date.now() / 1e3 +
            ((((f = this.options) == null ? void 0 : f.gasless) &&
              "biconomy" in this.options.gasless &&
              ((p = this.options.gasless.biconomy) == null
                ? void 0
                : p.deadlineSeconds)) ||
              3600),
        ),
        data: t.data,
      },
      l = ae(
        er(
          [
            "address",
            "address",
            "address",
            "uint256",
            "uint256",
            "uint256",
            "uint256",
            "uint256",
            "bytes32",
          ],
          [
            c.from,
            c.to,
            c.token,
            c.txGas,
            c.tokenGasPrice,
            c.batchId,
            c.batchNonce,
            c.deadline,
            Ge(c.data),
          ],
        ),
      );
    this.emit(Bn.Signature, { status: "submitted", message: l, signature: "" });
    const u = await r.signMessage(l);
    this.emit(Bn.Signature, { status: "completed", message: l, signature: u });
    const d = await la("https://api.biconomy.io/api/v2/meta-tx/native", {
      method: "POST",
      body: JSON.stringify({
        from: t.from,
        apiId: this.options.gasless.biconomy.apiId,
        params: [c, u],
        to: t.to,
        gasLimit: t.gasLimit.toHexString(),
      }),
      headers: {
        "x-api-key": this.options.gasless.biconomy.apiKey,
        "Content-Type": "application/json;charset=utf-8",
      },
    });
    if (d.ok) {
      const m = await d.json();
      if (!m.txHash) throw new Error(`relay transaction failed: ${m.log}`);
      return m.txHash;
    }
    throw new Error(
      `relay transaction failed with status: ${d.status} (${d.statusText})`,
    );
  }
  async defenderSendFunction(t) {
    ce(
      this.options.gasless && "openzeppelin" in this.options.gasless,
      "calling openzeppelin gasless transaction without openzeppelin config in the SDK options",
    );
    const r = this.getSigner(),
      a = this.getProvider();
    ce(r, "provider is not set"), ce(a, "provider is not set");
    const i =
        this.options.gasless.openzeppelin.relayerForwarderAddress ||
        (this.options.gasless.openzeppelin.useEOAForwarder
          ? Fi[t.chainId].openzeppelinForwarderEOA ||
            (await bv(this.getProvider(), this.storage))
          : Fi[t.chainId].openzeppelinForwarder ||
            (await Cm(this.getProvider(), this.storage))),
      s = new Pe(i, R6, a),
      o = await pd(s, "getNonce", [t.from]);
    let c, l, u;
    this.options.gasless.experimentalChainlessSupport
      ? ((c = {
          name: "GSNv2 Forwarder",
          version: "0.0.1",
          verifyingContract: i,
        }),
        (l = { ForwardRequest: vv }),
        (u = {
          from: t.from,
          to: t.to,
          value: O.from(0).toString(),
          gas: O.from(t.gasLimit).toString(),
          nonce: O.from(o).toString(),
          data: t.data,
          chainid: O.from(t.chainId).toString(),
        }))
      : ((c = {
          name: this.options.gasless.openzeppelin.domainName,
          version: this.options.gasless.openzeppelin.domainVersion,
          chainId: t.chainId,
          verifyingContract: i,
        }),
        (l = { ForwardRequest: xv }),
        (u = {
          from: t.from,
          to: t.to,
          value: O.from(0).toString(),
          gas: O.from(t.gasLimit).toString(),
          nonce: O.from(o).toString(),
          data: t.data,
        }));
    let d;
    if (
      (this.emit(Bn.Signature, {
        status: "submitted",
        message: u,
        signature: "",
      }),
      t.functionName === "approve" && t.functionArgs.length === 2)
    ) {
      const y = t.functionArgs[0],
        h = t.functionArgs[1],
        { message: g, signature: v } = await Tv(
          r,
          this.writeContract.address,
          t.from,
          y,
          h,
        ),
        { r: w, s: T, v: A } = ai(v);
      (u = {
        to: this.readContract.address,
        owner: g.owner,
        spender: g.spender,
        value: O.from(g.value).toString(),
        nonce: O.from(g.nonce).toString(),
        deadline: O.from(g.deadline).toString(),
        r: w,
        s: T,
        v: A,
      }),
        (d = v);
    } else {
      const { signature: y } = await Cc(r, c, l, u);
      d = y;
    }
    let f = "forward";
    u != null && u.owner && (f = "permit");
    const p = JSON.stringify({
      request: u,
      signature: d,
      forwarderAddress: i,
      type: f,
    });
    this.emit(Bn.Signature, { status: "completed", message: u, signature: d });
    const m = await la(this.options.gasless.openzeppelin.relayerUrl, {
      method: "POST",
      body: p,
    });
    if (m.ok) {
      const y = await m.json();
      if (!y.result) throw new Error(`Relay transaction failed: ${y.message}`);
      return JSON.parse(y.result).txHash;
    }
    throw new Error(
      `relay transaction failed with status: ${m.status} (${m.statusText})`,
    );
  }
}
async function km(n, e, t, r, a, i) {
  if (!t) return null;
  const s = t[e];
  if (s) {
    const o = await a.downloadJSON(s);
    if (o.isShardedMerkleTree && o.merkleRoot === e)
      return await (await Yn.fromShardedMerkleTreeInfo(o, a)).getProof(n, r, i);
    const c = await G6.parseAsync(o);
    if (e === c.merkleRoot)
      return (
        c.claims.find((l) => l.address.toLowerCase() === n.toLowerCase()) ||
        null
      );
  }
  return null;
}
function md(n) {
  return {
    startTimestamp: n.startTimestamp,
    maxClaimableSupply: n.maxClaimableSupply,
    supplyClaimed: n.supplyClaimed,
    merkleRoot: n.merkleRoot,
    pricePerToken: n.pricePerToken,
    currency: n.currency,
    quantityLimitPerTransaction: n.maxClaimablePerWallet,
    waitTimeInSecondsBetweenClaims: n.waitTimeInSecondsBetweenClaims || 0,
  };
}
function yd(n) {
  return {
    startTimestamp: n.startTimestamp,
    maxClaimableSupply: n.maxClaimableSupply,
    supplyClaimed: n.supplyClaimed,
    merkleRoot: n.merkleRoot,
    pricePerToken: n.pricePerToken,
    currency: n.currency,
    quantityLimitPerWallet: n.maxClaimablePerWallet,
    metadata: n.metadata || "",
  };
}
function gd(n) {
  return {
    startTimestamp: n.startTimestamp,
    maxClaimableSupply: n.maxClaimableSupply,
    supplyClaimed: n.supplyClaimed,
    merkleRoot: n.merkleRoot.toString(),
    pricePerToken: n.pricePerToken,
    currency: n.currency,
    maxClaimablePerWallet: n.quantityLimitPerTransaction,
    waitTimeInSecondsBetweenClaims: n.waitTimeInSecondsBetweenClaims,
  };
}
function bd(n) {
  return {
    startTimestamp: n.startTimestamp,
    maxClaimableSupply: n.maxClaimableSupply,
    supplyClaimed: n.supplyClaimed,
    merkleRoot: n.merkleRoot.toString(),
    pricePerToken: n.pricePerToken,
    currency: n.currency,
    maxClaimablePerWallet: n.quantityLimitPerWallet,
    waitTimeInSecondsBetweenClaims: 0,
    metadata: n.metadata,
  };
}
async function Sv(n, e, t, r, a) {
  const i = n.getSigner(),
    s = n.getProvider(),
    o = new Dt(i || s, e, mn, n.options, n.storage),
    c = await n.getSignerAddress(),
    l = n.readContract.address,
    u = await o.readContract.allowance(c, l),
    d = O.from(t).mul(O.from(r)).div(Ht("1", a));
  u.lt(d) && (await o.sendTransaction("approve", [l, u.add(d)]));
}
async function qt(n, e, t) {
  const r = await Jc(n, t);
  return Ht(Cn.parse(e), r.decimals);
}
async function Pv(n, e, t, r, a, i, s, o, c) {
  let l = Na(t.maxClaimablePerWallet, a),
    u = [Ue([0], 32)],
    d = t.price,
    f = t.currencyAddress;
  try {
    if (!t.merkleRootHash.toString().startsWith(Ie)) {
      const h = await km(
        n,
        t.merkleRootHash.toString(),
        await r(),
        i.getProvider(),
        s,
        c,
      );
      if (h)
        (u = h.proof),
          (l = h.maxClaimable === "unlimited" ? On : Ht(h.maxClaimable, a)),
          (d =
            h.price === void 0 || h.price === "unlimited"
              ? On
              : await qt(i.getProvider(), h.price, h.currencyAddress || Ie)),
          (f = h.currencyAddress || Ie);
      else if (c === Li.V1) throw new Error("No claim found for this address");
    }
  } catch (h) {
    if ((h == null ? void 0 : h.message) === "No claim found for this address")
      throw h;
    console.warn(
      "failed to check claim condition merkle root hash, continuing anyways",
      h,
    );
  }
  const p = (await i.getCallOverrides()) || {},
    m = d.toString() !== On.toString() ? d : t.price,
    y = f !== Ie ? f : t.currencyAddress;
  return (
    m.gt(0) &&
      (rr(y)
        ? (p.value = O.from(m).mul(e).div(Ht("1", a)))
        : o && (await Sv(i, y, m, e, a))),
    {
      overrides: p,
      proofs: u,
      maxClaimable: l,
      price: m,
      currencyAddress: y,
      priceInProof: d,
      currencyAddressInProof: f,
    }
  );
}
async function AD(n, e, t, r, a) {
  const i = await _v(n),
    s = i.map((l) => l.address);
  if (new Set(s).size < s.length) throw new xB();
  const c = await Yn.buildAndUpload(i, e, t, r, a);
  return { merkleRoot: c.shardedMerkleInfo.merkleRoot, snapshotUri: c.uri };
}
function ED(n, e) {
  const t = O.from(n),
    r = O.from(e);
  return t.eq(r) ? 0 : t.gt(r) ? 1 : -1;
}
async function kD(n, e, t, r, a) {
  const i = [];
  return {
    inputsWithSnapshots: await Promise.all(
      n.map(async (o) => {
        if (o.snapshot && o.snapshot.length > 0) {
          const c = await AD(o.snapshot, e, t, r, a);
          i.push(c), (o.merkleRootHash = c.merkleRoot);
        } else o.merkleRootHash = Ue([0], 32);
        return o;
      }),
    ),
    snapshotInfos: i,
  };
}
async function _D(n, e, t, r) {
  const a = n.currencyAddress === Ie ? an : n.currencyAddress,
    i = Na(n.maxClaimableSupply, e),
    s = Na(n.maxClaimablePerWallet, e);
  let o;
  return (
    n.metadata &&
      (typeof n.metadata == "string"
        ? (o = n.metadata)
        : (o = await r.upload(n.metadata))),
    {
      startTimestamp: n.startTime,
      maxClaimableSupply: i,
      supplyClaimed: 0,
      maxClaimablePerWallet: s,
      pricePerToken: await qt(t, n.price, a),
      currency: a,
      merkleRoot: n.merkleRootHash.toString(),
      waitTimeInSecondsBetweenClaims: n.waitInSeconds || 0,
      metadata: o,
    }
  );
}
async function Iv(n, e, t, r, a) {
  const { inputsWithSnapshots: i, snapshotInfos: s } = await kD(n, e, t, r, a),
    o = await zM.parseAsync(i),
    c = (await Promise.all(o.map((l) => _D(l, e, t, r)))).sort((l, u) =>
      ED(l.startTimestamp, u.startTimestamp),
    );
  return { snapshotInfos: s, sortedConditions: c };
}
async function Xn(n, e, t) {
  const r = await Jc(n, e);
  return { ...r, value: O.from(t), displayValue: Ja(t, r.decimals) };
}
async function SD(n, e, t) {
  if (!e) return null;
  const r = e[n];
  if (r) {
    const a = await t.downloadJSON(r);
    if (a.isShardedMerkleTree && a.merkleRoot === n) {
      const i = await Yn.fromUri(r, t);
      return (i == null ? void 0 : i.getAllEntries()) || null;
    } else {
      const i = await G6.parseAsync(a);
      if (n === i.merkleRoot)
        return i.claims.map((s) => ({
          address: s.address,
          maxClaimable: s.maxClaimable,
          price: s.price,
          currencyAddress: s.currencyAddress,
        }));
    }
  }
  return null;
}
function El(n, e) {
  return n.toString() === On.toString() ? "unlimited" : Ja(n, e);
}
async function xd(n, e, t, r, a, i) {
  var f;
  const s = await Xn(t, n.currency, n.pricePerToken),
    o = El(n.maxClaimableSupply, e),
    c = El(n.maxClaimablePerWallet, e),
    l = El(O.from(n.maxClaimableSupply).sub(n.supplyClaimed), e),
    u = El(n.supplyClaimed, e);
  let d;
  return (
    n.metadata && (d = await a.downloadJSON(n.metadata)),
    K6.parseAsync({
      startTime: n.startTimestamp,
      maxClaimableSupply: o,
      maxClaimablePerWallet: c,
      currentMintSupply: u,
      availableSupply: l,
      waitInSeconds:
        (f = n.waitTimeInSecondsBetweenClaims) == null ? void 0 : f.toString(),
      price: O.from(n.pricePerToken),
      currency: n.currency,
      currencyAddress: n.currency,
      currencyMetadata: s,
      merkleRootHash: n.merkleRoot,
      snapshot: i ? await SD(n.merkleRoot, r, a) : void 0,
      metadata: d,
    })
  );
}
async function Rv(n, e, t) {
  if (n >= t.length)
    throw Error(
      `Index out of bounds - got index: ${n} with ${t.length} conditions`,
    );
  const r = t[n].currencyMetadata.decimals,
    a = t[n].price,
    i = Ja(a, r),
    s = await pm.parseAsync({ ...t[n], price: i, ...e }),
    o = await K6.parseAsync({ ...s, price: a });
  return t.map((c, l) => {
    let u;
    l === n ? (u = o) : (u = c);
    const d = Ja(u.price, r);
    return { ...u, price: d };
  });
}
class Mv {
  constructor(e, t, r) {
    $(
      this,
      "set",
      Y(
        (() => {
          var e = this;
          return async function (t) {
            let r =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : !1,
              a = t;
            if (
              e.isLegacySinglePhaseDrop(e.contractWrapper) ||
              e.isNewSinglePhaseDrop(e.contractWrapper)
            ) {
              if (((r = !0), t.length === 0))
                a = [
                  {
                    startTime: new Date(0),
                    currencyAddress: Ie,
                    price: 0,
                    maxClaimableSupply: 0,
                    maxClaimablePerWallet: 0,
                    waitInSeconds: 0,
                    merkleRootHash: Ue([0], 32),
                    snapshot: [],
                  },
                ];
              else if (t.length > 1)
                throw new Error(
                  "Single phase drop contract cannot have multiple claim conditions, only one is allowed",
                );
            }
            (e.isNewSinglePhaseDrop(e.contractWrapper) ||
              e.isNewMultiphaseDrop(e.contractWrapper)) &&
              a.forEach((d) => {
                var f;
                if (
                  d.snapshot &&
                  d.snapshot.length > 0 &&
                  (d.maxClaimablePerWallet === void 0 ||
                    d.maxClaimablePerWallet === "unlimited")
                )
                  throw new Error(`maxClaimablePerWallet must be set to a specific value when an allowlist is set.
Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.
contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])`);
                if (
                  d.snapshot &&
                  d.snapshot.length > 0 &&
                  ((f = d.maxClaimablePerWallet) == null
                    ? void 0
                    : f.toString()) === "0" &&
                  d.snapshot
                    .map((p) => {
                      var m;
                      return typeof p == "string"
                        ? 0
                        : Number(
                            ((m = p.maxClaimable) == null
                              ? void 0
                              : m.toString()) || 0,
                          );
                    })
                    .reduce((p, m) => p + m, 0) === 0
                )
                  throw new Error(
                    "maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.",
                  );
              });
            const { snapshotInfos: i, sortedConditions: s } = await Iv(
                a,
                await e.getTokenDecimals(),
                e.contractWrapper.getProvider(),
                e.storage,
                e.getSnapshotFormatVersion(),
              ),
              o = {};
            i.forEach((d) => {
              o[d.merkleRoot] = d.snapshotUri;
            });
            const c = await e.metadata.get(),
              l = [];
            if (!_6(c.merkle, o)) {
              const d = await e.metadata.parseInputMetadata({
                  ...c,
                  merkle: o,
                }),
                f = await e.metadata._parseAndUploadMetadata(d);
              if (vt("setContractURI", e.contractWrapper))
                l.push(
                  e.contractWrapper.readContract.interface.encodeFunctionData(
                    "setContractURI",
                    [f],
                  ),
                );
              else
                throw new Error(
                  "Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.",
                );
            }
            const u = e.contractWrapper;
            if (e.isLegacySinglePhaseDrop(u))
              l.push(
                u.readContract.interface.encodeFunctionData(
                  "setClaimConditions",
                  [md(s[0]), r],
                ),
              );
            else if (e.isLegacyMultiPhaseDrop(u))
              l.push(
                u.readContract.interface.encodeFunctionData(
                  "setClaimConditions",
                  [s.map(md), r],
                ),
              );
            else if (e.isNewSinglePhaseDrop(u))
              l.push(
                u.readContract.interface.encodeFunctionData(
                  "setClaimConditions",
                  [yd(s[0]), r],
                ),
              );
            else if (e.isNewMultiphaseDrop(u))
              l.push(
                u.readContract.interface.encodeFunctionData(
                  "setClaimConditions",
                  [s.map(yd), r],
                ),
              );
            else throw new Error("Contract does not support claim conditions");
            return ne.fromContractWrapper({
              contractWrapper: e.contractWrapper,
              method: "multicall",
              args: [l],
            });
          };
        })(),
      ),
    );
    $(
      this,
      "update",
      Y(async (e, t) => {
        const r = await this.getAll(),
          a = await Rv(e, t, r);
        return await this.set.prepare(a);
      }),
    );
    (this.storage = r), (this.contractWrapper = e), (this.metadata = t);
  }
  async getActive(e) {
    const t = await this.get(),
      r = await this.metadata.get();
    return await xd(
      t,
      await this.getTokenDecimals(),
      this.contractWrapper.getProvider(),
      r.merkle || {},
      this.storage,
      (e == null ? void 0 : e.withAllowList) || !1,
    );
  }
  async get(e) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const t = await this.contractWrapper.readContract.claimCondition();
      return gd(t);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const t =
          e !== void 0
            ? e
            : await this.contractWrapper.readContract.getActiveClaimConditionId(),
        r = await this.contractWrapper.readContract.getClaimConditionById(t);
      return gd(r);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const t = await this.contractWrapper.readContract.claimCondition();
      return bd(t);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const t =
          e !== void 0
            ? e
            : await this.contractWrapper.readContract.getActiveClaimConditionId(),
        r = await this.contractWrapper.readContract.getClaimConditionById(t);
      return bd(r);
    } else throw new Error("Contract does not support claim conditions");
  }
  async getAll(e) {
    if (
      this.isLegacyMultiPhaseDrop(this.contractWrapper) ||
      this.isNewMultiphaseDrop(this.contractWrapper)
    ) {
      const [t, r] = await this.contractWrapper.readContract.claimCondition(),
        a = t.toNumber(),
        i = r.toNumber(),
        s = [];
      for (let l = a; l < a + i; l++) s.push(await this.get(l));
      const o = await this.metadata.get(),
        c = await this.getTokenDecimals();
      return Promise.all(
        s.map((l) =>
          xd(
            l,
            c,
            this.contractWrapper.getProvider(),
            o.merkle,
            this.storage,
            (e == null ? void 0 : e.withAllowList) || !1,
          ),
        ),
      );
    } else return [await this.getActive(e)];
  }
  async canClaim(e, t) {
    return (
      t && (t = await te(t)),
      (await this.getClaimIneligibilityReasons(e, t)).length === 0
    );
  }
  async getClaimIneligibilityReasons(e, t) {
    const r = [];
    let a, i;
    const s = await this.getTokenDecimals(),
      o = Ht(Cn.parse(e), s);
    if (t === void 0)
      try {
        t = await this.contractWrapper.getSignerAddress();
      } catch (f) {
        console.warn("failed to get signer address", f);
      }
    if (!t) return [et.NoWallet];
    const c = await te(t);
    try {
      i = await this.getActive();
    } catch (f) {
      return Mu(f, "!CONDITION") || Mu(f, "no active mint condition")
        ? (r.push(et.NoClaimConditionSet), r)
        : (console.warn("failed to get active claim condition", f),
          r.push(et.Unknown),
          r);
    }
    i.availableSupply !== "unlimited" &&
      Ht(i.availableSupply, s).lt(o) &&
      r.push(et.NotEnoughSupply);
    const u = Zn(i.merkleRootHash).length > 0;
    let d = null;
    if (u) {
      if (
        ((d = await this.getClaimerProofs(c)),
        !d &&
          (this.isLegacySinglePhaseDrop(this.contractWrapper) ||
            this.isLegacyMultiPhaseDrop(this.contractWrapper)))
      )
        return r.push(et.AddressNotAllowed), r;
      if (d)
        try {
          const f = await this.prepareClaim(e, !1, s, c);
          let p;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            if (
              ((a =
                await this.contractWrapper.readContract.getActiveClaimConditionId()),
              ([p] =
                await this.contractWrapper.readContract.verifyClaimMerkleProof(
                  a,
                  c,
                  e,
                  f.proofs,
                  f.maxClaimable,
                )),
              !p)
            )
              return r.push(et.AddressNotAllowed), r;
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            if (
              (([p] =
                await this.contractWrapper.readContract.verifyClaimMerkleProof(
                  c,
                  e,
                  { proof: f.proofs, maxQuantityInAllowlist: f.maxClaimable },
                )),
              !p)
            )
              return r.push(et.AddressNotAllowed), r;
          } else
            this.isNewSinglePhaseDrop(this.contractWrapper)
              ? await this.contractWrapper.readContract.verifyClaim(
                  c,
                  e,
                  f.currencyAddress,
                  f.price,
                  {
                    proof: f.proofs,
                    quantityLimitPerWallet: f.maxClaimable,
                    currency: f.currencyAddressInProof,
                    pricePerToken: f.priceInProof,
                  },
                )
              : this.isNewMultiphaseDrop(this.contractWrapper) &&
                ((a =
                  await this.contractWrapper.readContract.getActiveClaimConditionId()),
                await this.contractWrapper.readContract.verifyClaim(
                  a,
                  c,
                  e,
                  f.currencyAddress,
                  f.price,
                  {
                    proof: f.proofs,
                    quantityLimitPerWallet: f.maxClaimable,
                    currency: f.currencyAddressInProof,
                    pricePerToken: f.priceInProof,
                  },
                ));
        } catch (f) {
          return (
            console.warn(
              "Merkle proof verification failed:",
              "reason" in f ? f.reason : f,
            ),
            r.push(et.AddressNotAllowed),
            r
          );
        }
    }
    if (
      this.isNewSinglePhaseDrop(this.contractWrapper) ||
      this.isNewMultiphaseDrop(this.contractWrapper)
    ) {
      const f = await this.getClaimerProofs(c);
      let p = O.from(0),
        m = Na(i.maxClaimablePerWallet, s);
      if (
        (this.isNewSinglePhaseDrop(this.contractWrapper) &&
          (p =
            await this.contractWrapper.readContract.getSupplyClaimedByWallet(
              c,
            )),
        this.isNewMultiphaseDrop(this.contractWrapper))
      ) {
        const y =
          await this.contractWrapper.readContract.getActiveClaimConditionId();
        p = await this.contractWrapper.readContract.getSupplyClaimedByWallet(
          y,
          c,
        );
      }
      if (
        (f && (m = Na(f.maxClaimable, s)),
        (!u || (u && !d)) && (m.lte(p) || m.eq(0)))
      )
        return r.push(et.AddressNotAllowed), r;
    }
    if (
      this.isLegacySinglePhaseDrop(this.contractWrapper) ||
      this.isLegacyMultiPhaseDrop(this.contractWrapper)
    ) {
      let [f, p] = [O.from(0), O.from(0)];
      this.isLegacyMultiPhaseDrop(this.contractWrapper)
        ? ((a =
            await this.contractWrapper.readContract.getActiveClaimConditionId()),
          ([f, p] = await this.contractWrapper.readContract.getClaimTimestamp(
            a,
            c,
          )))
        : this.isLegacySinglePhaseDrop(this.contractWrapper) &&
          ([f, p] =
            await this.contractWrapper.readContract.getClaimTimestamp(c));
      const m = O.from(Date.now()).div(1e3);
      f.gt(0) &&
        m.lt(p) &&
        (p.eq(On)
          ? r.push(et.AlreadyClaimed)
          : r.push(et.WaitBeforeNextClaimTransaction));
    }
    if (i.price.gt(0) && pv()) {
      const f = i.price.mul(O.from(e)),
        p = this.contractWrapper.getProvider();
      rr(i.currencyAddress)
        ? (await p.getBalance(c)).lt(f) && r.push(et.NotEnoughTokens)
        : (
            await new Dt(
              p,
              i.currencyAddress,
              mn,
              {},
              this.storage,
            ).readContract.balanceOf(c)
          ).lt(f) && r.push(et.NotEnoughTokens);
    }
    return r;
  }
  async getClaimerProofs(e, t) {
    const a = (await this.get(t)).merkleRoot;
    if (Zn(a).length > 0) {
      const s = await this.metadata.get(),
        o = await te(e);
      return await km(
        o,
        a.toString(),
        s.merkle,
        this.contractWrapper.getProvider(),
        this.storage,
        this.getSnapshotFormatVersion(),
      );
    } else return null;
  }
  async getTokenDecimals() {
    return fe(this.contractWrapper, "ERC20")
      ? this.contractWrapper.readContract.decimals()
      : Promise.resolve(0);
  }
  async prepareClaim(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
      a = arguments.length > 3 ? arguments[3] : void 0;
    const i = a || (await this.contractWrapper.getSignerAddress());
    return Pv(
      i,
      e,
      await this.getActive(),
      async () => (await this.metadata.get()).merkle,
      r,
      this.contractWrapper,
      this.storage,
      t,
      this.getSnapshotFormatVersion(),
    );
  }
  async getClaimArguments(e, t, r) {
    const a = await te(e);
    return this.isLegacyMultiPhaseDrop(this.contractWrapper)
      ? [a, t, r.currencyAddress, r.price, r.proofs, r.maxClaimable]
      : this.isLegacySinglePhaseDrop(this.contractWrapper)
      ? [
          a,
          t,
          r.currencyAddress,
          r.price,
          { proof: r.proofs, maxQuantityInAllowlist: r.maxClaimable },
          Ne(""),
        ]
      : [
          a,
          t,
          r.currencyAddress,
          r.price,
          {
            proof: r.proofs,
            quantityLimitPerWallet: r.maxClaimable,
            pricePerToken: r.priceInProof,
            currency: r.currencyAddressInProof,
          },
          Ne(""),
        ];
  }
  async getClaimTransaction(e, t, r) {
    if (r != null && r.pricePerToken)
      throw new Error(
        "Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`",
      );
    const a = await this.prepareClaim(
      t,
      (r == null ? void 0 : r.checkERC20Allowance) === void 0
        ? !0
        : r.checkERC20Allowance,
      await this.getTokenDecimals(),
    );
    return ne.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: await this.getClaimArguments(e, t, a),
      overrides: a.overrides,
    });
  }
  isNewSinglePhaseDrop(e) {
    return fe(e, "ERC721ClaimConditionsV2") || fe(e, "ERC20ClaimConditionsV2");
  }
  isNewMultiphaseDrop(e) {
    return fe(e, "ERC721ClaimPhasesV2") || fe(e, "ERC20ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(e) {
    return fe(e, "ERC721ClaimConditionsV1") || fe(e, "ERC20ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(e) {
    return fe(e, "ERC721ClaimPhasesV1") || fe(e, "ERC20ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) ||
      this.isLegacySinglePhaseDrop(this.contractWrapper)
      ? Li.V1
      : Li.V2;
  }
}
class PD {
  constructor(e, t, r) {
    $(
      this,
      "set",
      Y(
        (() => {
          var e = this;
          return async function (t, r) {
            let a =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : !1;
            return e.setBatch.prepare([{ tokenId: t, claimConditions: r }], a);
          };
        })(),
      ),
    );
    $(
      this,
      "setBatch",
      Y(
        (() => {
          var e = this;
          return async function (t) {
            let r =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : !1;
            const a = {},
              i = await Promise.all(
                t.map(async (c) => {
                  let { tokenId: l, claimConditions: u } = c,
                    d = u;
                  if (e.isLegacySinglePhaseDrop(e.contractWrapper)) {
                    if (((r = !0), u.length === 0))
                      d = [
                        {
                          startTime: new Date(0),
                          currencyAddress: Ie,
                          price: 0,
                          maxClaimableSupply: 0,
                          maxClaimablePerWallet: 0,
                          waitInSeconds: 0,
                          merkleRootHash: Ue([0], 32),
                          snapshot: [],
                        },
                      ];
                    else if (u.length > 1)
                      throw new Error(
                        "Single phase drop contract cannot have multiple claim conditions, only one is allowed",
                      );
                  }
                  (e.isNewSinglePhaseDrop(e.contractWrapper) ||
                    e.isNewMultiphaseDrop(e.contractWrapper)) &&
                    d.forEach((m) => {
                      var y;
                      if (
                        m.snapshot &&
                        m.snapshot.length > 0 &&
                        (m.maxClaimablePerWallet === void 0 ||
                          m.maxClaimablePerWallet === "unlimited")
                      )
                        throw new Error(`maxClaimablePerWallet must be set to a specific value when an allowlist is set.
Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.

ex:
contract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])`);
                      if (
                        m.snapshot &&
                        m.snapshot.length > 0 &&
                        ((y = m.maxClaimablePerWallet) == null
                          ? void 0
                          : y.toString()) === "0" &&
                        m.snapshot
                          .map((h) => {
                            var g;
                            return typeof h == "string"
                              ? 0
                              : Number(
                                  ((g = h.maxClaimable) == null
                                    ? void 0
                                    : g.toString()) || 0,
                                );
                          })
                          .reduce((h, g) => h + g, 0) === 0
                      )
                        throw new Error(
                          "maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.",
                        );
                    });
                  const { snapshotInfos: f, sortedConditions: p } = await Iv(
                    d,
                    0,
                    e.contractWrapper.getProvider(),
                    e.storage,
                    e.getSnapshotFormatVersion(),
                  );
                  return (
                    f.forEach((m) => {
                      a[m.merkleRoot] = m.snapshotUri;
                    }),
                    { tokenId: l, sortedConditions: p }
                  );
                }),
              ),
              s = await e.metadata.get(),
              o = [];
            for (const c of Object.keys(s.merkle || {})) a[c] = s.merkle[c];
            if (!_6(s.merkle, a)) {
              const c = await e.metadata.parseInputMetadata({
                  ...s,
                  merkle: a,
                }),
                l = await e.metadata._parseAndUploadMetadata(c);
              if (vt("setContractURI", e.contractWrapper))
                o.push(
                  e.contractWrapper.readContract.interface.encodeFunctionData(
                    "setContractURI",
                    [l],
                  ),
                );
              else
                throw new Error(
                  "Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.",
                );
            }
            return (
              i.forEach((c) => {
                let { tokenId: l, sortedConditions: u } = c;
                if (e.isLegacySinglePhaseDrop(e.contractWrapper))
                  o.push(
                    e.contractWrapper.readContract.interface.encodeFunctionData(
                      "setClaimConditions",
                      [l, md(u[0]), r],
                    ),
                  );
                else if (e.isLegacyMultiPhaseDrop(e.contractWrapper))
                  o.push(
                    e.contractWrapper.readContract.interface.encodeFunctionData(
                      "setClaimConditions",
                      [l, u.map(md), r],
                    ),
                  );
                else if (e.isNewSinglePhaseDrop(e.contractWrapper))
                  o.push(
                    e.contractWrapper.readContract.interface.encodeFunctionData(
                      "setClaimConditions",
                      [l, yd(u[0]), r],
                    ),
                  );
                else if (e.isNewMultiphaseDrop(e.contractWrapper))
                  o.push(
                    e.contractWrapper.readContract.interface.encodeFunctionData(
                      "setClaimConditions",
                      [l, u.map(yd), r],
                    ),
                  );
                else
                  throw new Error("Contract does not support claim conditions");
              }),
              ne.fromContractWrapper({
                contractWrapper: e.contractWrapper,
                method: "multicall",
                args: [o],
              })
            );
          };
        })(),
      ),
    );
    $(
      this,
      "update",
      Y(async (e, t, r) => {
        const a = await this.getAll(e),
          i = await Rv(t, r, a);
        return await this.set.prepare(e, i);
      }),
    );
    (this.storage = r), (this.contractWrapper = e), (this.metadata = t);
  }
  async getActive(e, t) {
    const r = await this.get(e),
      a = await this.metadata.get();
    return await xd(
      r,
      0,
      this.contractWrapper.getProvider(),
      a.merkle,
      this.storage,
      (t == null ? void 0 : t.withAllowList) || !1,
    );
  }
  async get(e, t) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const r = await this.contractWrapper.readContract.claimCondition(e);
      return gd(r);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const r =
          t !== void 0
            ? t
            : await this.contractWrapper.readContract.getActiveClaimConditionId(
                e,
              ),
        a = await this.contractWrapper.readContract.getClaimConditionById(e, r);
      return gd(a);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const r = await this.contractWrapper.readContract.claimCondition(e);
      return bd(r);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const r =
          t !== void 0
            ? t
            : await this.contractWrapper.readContract.getActiveClaimConditionId(
                e,
              ),
        a = await this.contractWrapper.readContract.getClaimConditionById(e, r);
      return bd(a);
    } else throw new Error("Contract does not support claim conditions");
  }
  async getAll(e, t) {
    if (
      this.isLegacyMultiPhaseDrop(this.contractWrapper) ||
      this.isNewMultiphaseDrop(this.contractWrapper)
    ) {
      const r = await this.contractWrapper.readContract.claimCondition(e),
        a = r.currentStartId.toNumber(),
        i = r.count.toNumber(),
        s = [];
      for (let c = a; c < a + i; c++) s.push(await this.get(e, c));
      const o = await this.metadata.get();
      return Promise.all(
        s.map((c) =>
          xd(
            c,
            0,
            this.contractWrapper.getProvider(),
            o.merkle,
            this.storage,
            (t == null ? void 0 : t.withAllowList) || !1,
          ),
        ),
      );
    } else return [await this.getActive(e, t)];
  }
  async canClaim(e, t, r) {
    return (
      r && (r = await te(r)),
      (await this.getClaimIneligibilityReasons(e, t, r)).length === 0
    );
  }
  async getClaimIneligibilityReasons(e, t, r) {
    const a = [];
    let i, s;
    if (r === void 0)
      try {
        r = await this.contractWrapper.getSignerAddress();
      } catch (m) {
        console.warn("failed to get signer address", m);
      }
    if (!r) return [et.NoWallet];
    const o = await te(r);
    try {
      s = await this.getActive(e);
    } catch (m) {
      return Mu(m, "!CONDITION") || Mu(m, "no active mint condition")
        ? (a.push(et.NoClaimConditionSet), a)
        : (a.push(et.Unknown), a);
    }
    s.availableSupply !== "unlimited" &&
      O.from(s.availableSupply).lt(t) &&
      a.push(et.NotEnoughSupply);
    const l = Zn(s.merkleRootHash).length > 0;
    let u = null;
    if (l) {
      if (
        ((u = await this.getClaimerProofs(e, o)),
        !u &&
          (this.isLegacySinglePhaseDrop(this.contractWrapper) ||
            this.isLegacyMultiPhaseDrop(this.contractWrapper)))
      )
        return a.push(et.AddressNotAllowed), a;
      if (u)
        try {
          const m = await this.prepareClaim(e, t, !1, o);
          let y;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            if (
              ((i =
                await this.contractWrapper.readContract.getActiveClaimConditionId(
                  e,
                )),
              ([y] =
                await this.contractWrapper.readContract.verifyClaimMerkleProof(
                  i,
                  o,
                  e,
                  t,
                  m.proofs,
                  m.maxClaimable,
                )),
              !y)
            )
              return a.push(et.AddressNotAllowed), a;
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            if (
              (([y] =
                await this.contractWrapper.readContract.verifyClaimMerkleProof(
                  e,
                  o,
                  t,
                  { proof: m.proofs, maxQuantityInAllowlist: m.maxClaimable },
                )),
              !y)
            )
              return a.push(et.AddressNotAllowed), a;
          } else
            this.isNewSinglePhaseDrop(this.contractWrapper)
              ? await this.contractWrapper.readContract.verifyClaim(
                  e,
                  o,
                  t,
                  m.currencyAddress,
                  m.price,
                  {
                    proof: m.proofs,
                    quantityLimitPerWallet: m.maxClaimable,
                    currency: m.currencyAddressInProof,
                    pricePerToken: m.priceInProof,
                  },
                )
              : this.isNewMultiphaseDrop(this.contractWrapper) &&
                ((i =
                  await this.contractWrapper.readContract.getActiveClaimConditionId(
                    e,
                  )),
                await this.contractWrapper.readContract.verifyClaim(
                  i,
                  o,
                  e,
                  t,
                  m.currencyAddress,
                  m.price,
                  {
                    proof: m.proofs,
                    quantityLimitPerWallet: m.maxClaimable,
                    currency: m.currencyAddressInProof,
                    pricePerToken: m.priceInProof,
                  },
                ));
        } catch (m) {
          return (
            console.warn(
              "Merkle proof verification failed:",
              "reason" in m ? m.reason : m,
            ),
            a.push(et.AddressNotAllowed),
            a
          );
        }
    }
    if (
      (this.isNewSinglePhaseDrop(this.contractWrapper) ||
        this.isNewMultiphaseDrop(this.contractWrapper)) &&
      (!l || (l && !u)) &&
      s.maxClaimablePerWallet === "0"
    )
      return a.push(et.AddressNotAllowed), a;
    let [d, f] = [O.from(0), O.from(0)];
    this.isLegacyMultiPhaseDrop(this.contractWrapper)
      ? ((i =
          await this.contractWrapper.readContract.getActiveClaimConditionId(e)),
        ([d, f] = await this.contractWrapper.readContract.getClaimTimestamp(
          e,
          i,
          o,
        )))
      : this.isLegacySinglePhaseDrop(this.contractWrapper) &&
        ([d, f] = await this.contractWrapper.readContract.getClaimTimestamp(
          e,
          o,
        ));
    const p = O.from(Date.now()).div(1e3);
    if (
      (d.gt(0) &&
        p.lt(f) &&
        (f.eq(On)
          ? a.push(et.AlreadyClaimed)
          : a.push(et.WaitBeforeNextClaimTransaction)),
      s.price.gt(0) && pv())
    ) {
      const m = s.price.mul(t),
        y = this.contractWrapper.getProvider();
      rr(s.currencyAddress)
        ? (await y.getBalance(o)).lt(m) && a.push(et.NotEnoughTokens)
        : (
            await new Dt(
              y,
              s.currencyAddress,
              mn,
              {},
              this.storage,
            ).readContract.balanceOf(o)
          ).lt(m) && a.push(et.NotEnoughTokens);
    }
    return a;
  }
  async getClaimerProofs(e, t, r) {
    const i = (await this.get(e, r)).merkleRoot;
    if (Zn(i).length > 0) {
      const o = await this.metadata.get(),
        c = await te(t);
      return await km(
        c,
        i.toString(),
        o.merkle,
        this.contractWrapper.getProvider(),
        this.storage,
        this.getSnapshotFormatVersion(),
      );
    } else return null;
  }
  async prepareClaim(e, t, r, a) {
    const i = await te(a || (await this.contractWrapper.getSignerAddress()));
    return Pv(
      i,
      t,
      await this.getActive(e),
      async () => (await this.metadata.get()).merkle,
      0,
      this.contractWrapper,
      this.storage,
      r,
      this.getSnapshotFormatVersion(),
    );
  }
  async getClaimArguments(e, t, r, a) {
    const i = await te(t);
    return this.isLegacyMultiPhaseDrop(this.contractWrapper)
      ? [i, e, r, a.currencyAddress, a.price, a.proofs, a.maxClaimable]
      : this.isLegacySinglePhaseDrop(this.contractWrapper)
      ? [
          i,
          e,
          r,
          a.currencyAddress,
          a.price,
          { proof: a.proofs, maxQuantityInAllowlist: a.maxClaimable },
          Ne(""),
        ]
      : [
          i,
          e,
          r,
          a.currencyAddress,
          a.price,
          {
            proof: a.proofs,
            quantityLimitPerWallet: a.maxClaimable,
            pricePerToken: a.priceInProof,
            currency: a.currencyAddressInProof,
          },
          Ne(""),
        ];
  }
  async getClaimTransaction(e, t, r, a) {
    if (a != null && a.pricePerToken)
      throw new Error(
        "Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`",
      );
    const i = await this.prepareClaim(
      t,
      r,
      (a == null ? void 0 : a.checkERC20Allowance) || !0,
    );
    return ne.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: await this.getClaimArguments(t, e, r, i),
      overrides: i.overrides,
    });
  }
  isNewSinglePhaseDrop(e) {
    return fe(e, "ERC1155ClaimConditionsV2");
  }
  isNewMultiphaseDrop(e) {
    return fe(e, "ERC1155ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(e) {
    return fe(e, "ERC1155ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(e) {
    return fe(e, "ERC1155ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) ||
      this.isLegacySinglePhaseDrop(this.contractWrapper)
      ? Li.V1
      : Li.V2;
  }
}
class ID {
  constructor(e, t) {
    $(this, "featureName", Du.name);
    $(
      this,
      "to",
      Y(async (e) => {
        const t = [];
        for (const r of e)
          t.push(
            this.contractWrapper.readContract.interface.encodeFunctionData(
              "mintTo",
              [
                await te(r.toAddress),
                await this.erc20.normalizeAmount(r.amount),
              ],
            ),
          );
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [t],
        });
      }),
    );
    (this.erc20 = e), (this.contractWrapper = t);
  }
}
class RD {
  constructor(e, t) {
    $(this, "featureName", fc.name);
    $(
      this,
      "tokens",
      Y(async (e) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "burn",
          args: [await this.erc20.normalizeAmount(e)],
        }),
      ),
    );
    $(
      this,
      "from",
      Y(async (e, t) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "burnFrom",
          args: [await te(e), await this.erc20.normalizeAmount(t)],
        }),
      ),
    );
    (this.erc20 = e), (this.contractWrapper = t);
  }
}
class MD {
  constructor(e, t, r) {
    $(this, "featureName", dc.name);
    $(
      this,
      "to",
      Y(async (e, t, r) => {
        const a = await this.erc20.normalizeAmount(t);
        return await this.conditions.getClaimTransaction(e, a, r);
      }),
    );
    (this.erc20 = e), (this.contractWrapper = t), (this.storage = r);
    const a = new _s(this.contractWrapper, Es, this.storage);
    this.conditions = new Mv(this.contractWrapper, a, this.storage);
  }
}
class BD {
  constructor(e, t, r) {
    (this.erc20 = e),
      (this.contractWrapper = t),
      (this.storage = r),
      (this.claim = new MD(this.erc20, this.contractWrapper, this.storage));
  }
}
class DD {
  constructor(e, t) {
    $(this, "featureName", pc.name);
    $(
      this,
      "to",
      Y(async (e, t) => await this.getMintTransaction(e, t)),
    );
    (this.erc20 = e),
      (this.contractWrapper = t),
      (this.batch = this.detectErc20BatchMintable());
  }
  async getMintTransaction(e, t) {
    return ne.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "mintTo",
      args: [await te(e), await this.erc20.normalizeAmount(t)],
    });
  }
  detectErc20BatchMintable() {
    if (fe(this.contractWrapper, "ERC20BatchMintable"))
      return new ID(this.erc20, this.contractWrapper);
  }
}
async function ei(n, e, t, r) {
  if (rr(t)) r.value = e;
  else {
    const a = n.getSigner(),
      i = n.getProvider(),
      s = new Dt(a || i, t, mn, n.options, n.storage),
      o = await n.getSignerAddress(),
      c = n.readContract.address;
    return (
      (await s.readContract.allowance(o, c)).lt(e) &&
        (await s.sendTransaction("approve", [c, e])),
      r
    );
  }
}
class OD {
  constructor(e, t) {
    $(this, "featureName", Bu.name);
    $(
      this,
      "mint",
      Y(async (e) => {
        const t = e.payload,
          r = e.signature,
          a = await this.mapPayloadToContractStruct(t),
          i = await this.contractWrapper.getCallOverrides();
        return (
          await ei(this.contractWrapper, O.from(a.price), t.currencyAddress, i),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "mintWithSignature",
            args: [a, r],
            overrides: i,
          })
        );
      }),
    );
    $(
      this,
      "mintBatch",
      Y(async (e) => {
        const r = (
          await Promise.all(
            e.map(async (a) => {
              const i = await this.mapPayloadToContractStruct(a.payload),
                s = a.signature,
                o = a.payload.price;
              if (O.from(o).gt(0))
                throw new Error(
                  "Can only batch free mints. For mints with a price, use regular mint()",
                );
              return { message: i, signature: s };
            }),
          )
        ).map((a) =>
          this.contractWrapper.readContract.interface.encodeFunctionData(
            "mintWithSignature",
            [a.message, a.signature],
          ),
        );
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [r],
        });
      }),
    );
    (this.contractWrapper = e), (this.roles = t);
  }
  async verify(e) {
    const t = e.payload,
      r = e.signature,
      a = await this.mapPayloadToContractStruct(t);
    return (await this.contractWrapper.readContract.verify(a, r))[0];
  }
  async generate(e) {
    return (await this.generateBatch([e]))[0];
  }
  async generateBatch(e) {
    var s;
    await ((s = this.roles) == null
      ? void 0
      : s.verify(["minter"], await this.contractWrapper.getSignerAddress()));
    const t = await Promise.all(e.map((o) => Y6.parseAsync(o))),
      r = await this.contractWrapper.getChainID(),
      a = this.contractWrapper.getSigner();
    ce(a, "No signer available");
    const i = await this.contractWrapper.readContract.name();
    return await Promise.all(
      t.map(async (o) => {
        const c = await HM.parseAsync(o),
          l = await this.contractWrapper.signTypedData(
            a,
            {
              name: i,
              version: "1",
              chainId: r,
              verifyingContract: this.contractWrapper.readContract.address,
            },
            { MintRequest: YM },
            await this.mapPayloadToContractStruct(c),
          );
        return { payload: c, signature: l.toString() };
      }),
    );
  }
  async mapPayloadToContractStruct(e) {
    const t = await qt(
        this.contractWrapper.getProvider(),
        e.price,
        e.currencyAddress,
      ),
      r = Ht(e.quantity, await this.contractWrapper.readContract.decimals());
    return {
      to: e.to,
      primarySaleRecipient: e.primarySaleRecipient,
      quantity: r,
      price: t,
      currency: e.currencyAddress,
      validityEndTimestamp: e.mintEndTime,
      validityStartTimestamp: e.mintStartTime,
      uid: e.uid,
    };
  }
}
function xe(n, e) {
  if (!n) throw new $s(e);
  return n;
}
async function ND(n, e) {
  const t = await n.readContract.decimals();
  return Ht(Cn.parse(e), t);
}
class FD {
  constructor(e, t, r) {
    $(this, "featureName", Ou.name);
    $(
      this,
      "transfer",
      Y(async (e, t) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "transfer",
          args: [await te(e), await this.normalizeAmount(t)],
        }),
      ),
    );
    $(
      this,
      "transferFrom",
      Y(async (e, t, r) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "transferFrom",
          args: [await te(e), await te(t), await this.normalizeAmount(r)],
        }),
      ),
    );
    $(
      this,
      "setAllowance",
      Y(async (e, t) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approve",
          args: [await te(e), await this.normalizeAmount(t)],
        }),
      ),
    );
    $(
      this,
      "transferBatch",
      Y(async (e) => {
        const t = await Promise.all(
          e.map(async (r) => {
            const a = await this.normalizeAmount(r.amount);
            return this.contractWrapper.readContract.interface.encodeFunctionData(
              "transfer",
              [await te(r.toAddress), a],
            );
          }),
        );
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [t],
        });
      }),
    );
    $(
      this,
      "mint",
      Y(async (e) =>
        this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), e),
      ),
    );
    $(
      this,
      "mintTo",
      Y(async (e, t) => xe(this.mintable, pc).to.prepare(e, t)),
    );
    $(
      this,
      "mintBatchTo",
      Y(async (e) => {
        var t;
        return xe(
          (t = this.mintable) == null ? void 0 : t.batch,
          Du,
        ).to.prepare(e);
      }),
    );
    $(
      this,
      "burn",
      Y(async (e) => xe(this.burnable, fc).tokens.prepare(e)),
    );
    $(
      this,
      "burnFrom",
      Y(async (e, t) => xe(this.burnable, fc).from.prepare(e, t)),
    );
    $(
      this,
      "claim",
      Y(async (e, t) =>
        this.claimTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e,
          t,
        ),
      ),
    );
    $(
      this,
      "claimTo",
      Y(async (e, t, r) => {
        var a;
        return xe(
          (a = this.droppable) == null ? void 0 : a.claim,
          dc,
        ).to.prepare(e, t, r);
      }),
    );
    (this.contractWrapper = e),
      (this.storage = t),
      (this.mintable = this.detectErc20Mintable()),
      (this.burnable = this.detectErc20Burnable()),
      (this.droppable = this.detectErc20Droppable()),
      (this.signatureMintable = this.detectErc20SignatureMintable()),
      (this._chainId = r);
  }
  get chainId() {
    return this._chainId;
  }
  onNetworkUpdated(e) {
    this.contractWrapper.updateSignerOrProvider(e);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get() {
    return await Jc(this.contractWrapper.getProvider(), this.getAddress());
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async balanceOf(e) {
    return this.getValue(
      await this.contractWrapper.readContract.balanceOf(await te(e)),
    );
  }
  async totalSupply() {
    return await this.getValue(
      await this.contractWrapper.readContract.totalSupply(),
    );
  }
  async allowance(e) {
    return await this.allowanceOf(
      await this.contractWrapper.getSignerAddress(),
      await te(e),
    );
  }
  async allowanceOf(e, t) {
    return await this.getValue(
      await this.contractWrapper.readContract.allowance(
        await te(e),
        await te(t),
      ),
    );
  }
  async getMintTransaction(e, t) {
    return xe(this.mintable, pc).getMintTransaction(e, t);
  }
  get claimConditions() {
    var e;
    return xe((e = this.droppable) == null ? void 0 : e.claim, dc).conditions;
  }
  get signature() {
    return xe(this.signatureMintable, Bu);
  }
  async normalizeAmount(e) {
    return ND(this.contractWrapper, e);
  }
  async getValue(e) {
    return await Xn(
      this.contractWrapper.getProvider(),
      this.getAddress(),
      O.from(e),
    );
  }
  detectErc20Mintable() {
    if (fe(this.contractWrapper, "ERC20"))
      return new DD(this, this.contractWrapper);
  }
  detectErc20Burnable() {
    if (fe(this.contractWrapper, "ERC20Burnable"))
      return new RD(this, this.contractWrapper);
  }
  detectErc20Droppable() {
    if (
      fe(this.contractWrapper, "ERC20ClaimConditionsV1") ||
      fe(this.contractWrapper, "ERC20ClaimConditionsV2") ||
      fe(this.contractWrapper, "ERC20ClaimPhasesV1") ||
      fe(this.contractWrapper, "ERC20ClaimPhasesV2")
    )
      return new BD(this, this.contractWrapper, this.storage);
  }
  detectErc20SignatureMintable() {
    if (fe(this.contractWrapper, "ERC20SignatureMintable"))
      return new OD(this.contractWrapper);
  }
}
class LD {
  constructor(e, t, r) {
    $(this, "featureName", Uu.name);
    $(
      this,
      "to",
      Y(async (e, t) => {
        const r = await Yi(t, this.storage),
          a = await te(e),
          i = await Promise.all(
            r.map(async (s) =>
              this.contractWrapper.readContract.interface.encodeFunctionData(
                "mintTo",
                [a, s],
              ),
            ),
          );
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [i],
          parse: (s) => {
            const o = this.contractWrapper.parseLogs("TokensMinted", s.logs);
            if (o.length === 0 || o.length < t.length)
              throw new Error("TokenMinted event not found, minting failed");
            return o.map((c) => {
              const l = c.args.tokenIdMinted;
              return { id: l, receipt: s, data: () => this.erc721.get(l) };
            });
          },
        });
      }),
    );
    (this.erc721 = e), (this.contractWrapper = t), (this.storage = r);
  }
}
class $D {
  constructor(e, t, r) {
    $(this, "featureName", $u.name);
    $(
      this,
      "to",
      Y(async (e, t, r) => {
        const a = await this.conditions.getClaimTransaction(e, t, r);
        return (
          a.setParse((i) => {
            const o = this.contractWrapper.parseLogs(
                "TokensClaimed",
                i == null ? void 0 : i.logs,
              )[0].args.startTokenId,
              c = o.add(t),
              l = [];
            for (let u = o; u.lt(c); u = u.add(1))
              l.push({ id: u, receipt: i, data: () => this.erc721.get(u) });
            return l;
          }),
          a
        );
      }),
    );
    (this.erc721 = e), (this.contractWrapper = t), (this.storage = r);
    const a = new _s(this.contractWrapper, Es, this.storage);
    this.conditions = new Mv(this.contractWrapper, a, this.storage);
  }
}
async function Bv(n, e, t, r, a) {
  let i = {};
  const s = r || an,
    c = (await qt(n.getProvider(), e, s)).mul(t);
  return (
    c.gt(0) &&
      (s === an
        ? (i = { value: c })
        : s !== an && a && (await Sv(n, s, c, t, 0))),
    i
  );
}
class WD {
  constructor(e, t) {
    $(this, "featureName", hc.name);
    $(
      this,
      "to",
      Y(async (e, t, r) => {
        const a = await this.getClaimTransaction(e, t, r);
        return (
          a.setParse((i) => {
            const o = this.contractWrapper.parseLogs(
                "TokensClaimed",
                i == null ? void 0 : i.logs,
              )[0].args.startTokenId,
              c = o.add(t),
              l = [];
            for (let u = o; u.lt(c); u = u.add(1))
              l.push({ id: u, receipt: i, data: () => this.erc721.get(u) });
            return l;
          }),
          a
        );
      }),
    );
    (this.erc721 = e), (this.contractWrapper = t);
  }
  async getClaimTransaction(e, t, r) {
    let a = {};
    return (
      r &&
        r.pricePerToken &&
        (a = await Bv(
          this.contractWrapper,
          r.pricePerToken,
          t,
          r.currencyAddress,
          r.checkERC20Allowance,
        )),
      ne.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "claim",
        args: [e, t],
        overrides: a,
      })
    );
  }
}
class UD {
  constructor(e, t, r) {
    $(this, "featureName", Wu.name);
    $(
      this,
      "lazyMint",
      Y(async (e, t) => {
        const r = await this.erc721.nextTokenIdToMint(),
          a = await Yi(e, this.storage, r.toNumber(), t),
          i = Ss(a);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [a.length, i.endsWith("/") ? i : `${i}/`, Ne("")],
          parse: (s) => {
            const o = this.contractWrapper.parseLogs(
                "TokensLazyMinted",
                s == null ? void 0 : s.logs,
              ),
              c = o[0].args.startTokenId,
              l = o[0].args.endTokenId,
              u = [];
            for (let d = c; d.lte(l); d = d.add(1))
              u.push({
                id: d,
                receipt: s,
                data: () => this.erc721.getTokenMetadata(d),
              });
            return u;
          },
        });
      }),
    );
    (this.erc721 = e),
      (this.contractWrapper = t),
      (this.storage = r),
      (this.revealer = this.detectErc721Revealable());
  }
  detectErc721Revealable() {
    if (fe(this.contractWrapper, "ERC721Revealable"))
      return new kv(this.contractWrapper, this.storage, Fu.name, () =>
        this.erc721.nextTokenIdToMint(),
      );
  }
}
class jD {
  constructor(e, t, r) {
    $(this, "featureName", ju.name);
    $(
      this,
      "to",
      Y(async (e, t) => {
        const r = await Em(t, this.storage);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "mintTo",
          args: [await te(e), r],
          parse: (a) => {
            const i = this.contractWrapper.parseLogs(
              "Transfer",
              a == null ? void 0 : a.logs,
            );
            if (i.length === 0)
              throw new Error("TransferEvent event not found");
            const s = i[0].args.tokenId;
            return { id: s, receipt: a, data: () => this.erc721.get(s) };
          },
        });
      }),
    );
    (this.erc721 = e),
      (this.contractWrapper = t),
      (this.storage = r),
      (this.batch = this.detectErc721BatchMintable());
  }
  async getMintTransaction(e, t) {
    return this.to.prepare(await te(e), t);
  }
  detectErc721BatchMintable() {
    if (fe(this.contractWrapper, "ERC721BatchMintable"))
      return new LD(this.erc721, this.contractWrapper, this.storage);
  }
}
class zD {
  constructor(e, t) {
    $(this, "featureName", Xp.name);
    (this.erc721 = e), (this.contractWrapper = t);
  }
  async all(e) {
    const t = await this.tokenIds(e);
    return await Promise.all(t.map((r) => this.erc721.get(r.toString())));
  }
  async tokenIds(e) {
    const t = await te(e || (await this.contractWrapper.getSignerAddress())),
      r = await this.contractWrapper.readContract.balanceOf(t),
      a = Array.from(Array(r.toNumber()).keys());
    return await Promise.all(
      a.map((i) => this.contractWrapper.readContract.tokenOfOwnerByIndex(t, i)),
    );
  }
}
class HD {
  constructor(e, t) {
    $(this, "featureName", Zp.name);
    (this.erc721 = e), (this.contractWrapper = t);
  }
  async all(e) {
    const t = await this.tokenIds(e);
    return await Promise.all(t.map((r) => this.erc721.get(r.toString())));
  }
  async tokenIds(e) {
    const t = await te(e || (await this.contractWrapper.getSignerAddress()));
    return await this.contractWrapper.readContract.tokensOfOwner(t);
  }
}
class qD {
  constructor(e, t) {
    $(this, "featureName", ks.name);
    (this.erc721 = e),
      (this.contractWrapper = t),
      (this.owned = this.detectErc721Owned());
  }
  async all(e) {
    let t = O.from(0);
    vt("startTokenId", this.contractWrapper) &&
      (t = await this.contractWrapper.readContract.startTokenId());
    const r = O.from((e == null ? void 0 : e.start) || 0)
        .add(t)
        .toNumber(),
      a = O.from((e == null ? void 0 : e.count) || Ko).toNumber(),
      i = await this.erc721.nextTokenIdToMint(),
      s = Math.min(i.add(t).toNumber(), r + a);
    return await Promise.all(
      [...Array(s - r).keys()].map((o) => this.erc721.get((r + o).toString())),
    );
  }
  async allOwners() {
    let e,
      t = O.from(0);
    vt("startTokenId", this.contractWrapper) &&
      (t = await this.contractWrapper.readContract.startTokenId());
    try {
      e = await this.erc721.totalClaimedSupply();
    } catch {
      e = await this.totalCount();
    }
    return (
      (e = e.add(t)),
      (
        await Promise.all(
          [...new Array(e.toNumber()).keys()].map(async (r) => ({
            tokenId: r,
            owner: await this.erc721.ownerOf(r).catch(() => Ie),
          })),
        )
      ).filter((r) => r.owner !== Ie)
    );
  }
  async totalCount() {
    return await this.erc721.nextTokenIdToMint();
  }
  async totalCirculatingSupply() {
    return await this.contractWrapper.readContract.totalSupply();
  }
  detectErc721Owned() {
    if (fe(this.contractWrapper, "ERC721Enumerable"))
      return new zD(this.erc721, this.contractWrapper);
    if (fe(this.contractWrapper, "ERC721AQueryable"))
      return new HD(this.erc721, this.contractWrapper);
  }
}
const VD = (() =>
  hm.extend({
    tierPriority: M.array(M.string()),
    royaltyRecipient: at.default(Ie),
    royaltyBps: io.default(0),
    quantity: rn.default(1),
  }))();
class GD {
  constructor(e, t, r) {
    $(this, "featureName", Lu.name);
    $(
      this,
      "createBatchWithTier",
      Y(async (e, t, r) => {
        const a = await this.erc721.nextTokenIdToMint(),
          i = await Yi(e, this.storage, a.toNumber(), r),
          s = Ss(i);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [i.length, s.endsWith("/") ? s : `${s}/`, t, Ne("")],
          parse: (o) => {
            const c = this.contractWrapper.parseLogs(
                "TokensLazyMinted",
                o == null ? void 0 : o.logs,
              ),
              l = c[0].args[1],
              u = c[0].args[2],
              d = [];
            for (let f = l; f.lte(u); f = f.add(1))
              d.push({
                id: f,
                receipt: o,
                data: () => this.erc721.getTokenMetadata(f),
              });
            return d;
          },
        });
      }),
    );
    $(
      this,
      "createDelayedRevealBatchWithTier",
      Y(async (e, t, r, a, i) => {
        if (!r) throw new Error("Password is required");
        const s = await this.storage.uploadBatch([Xa.parse(e)], {
            rewriteFileNames: { fileStartNumber: 0 },
          }),
          o = Ss(s),
          c = await this.erc721.nextTokenIdToMint(),
          l = await this.storage.uploadBatch(
            t.map((g) => Xa.parse(g)),
            {
              onProgress: i == null ? void 0 : i.onProgress,
              rewriteFileNames: { fileStartNumber: c.toNumber() },
            },
          ),
          u = Ss(l),
          d = await this.contractWrapper.readContract.getBaseURICount(),
          f = await this.contractWrapper.getChainID(),
          p = er(
            ["string", "uint256", "uint256", "address"],
            [r, f, d, this.contractWrapper.readContract.address],
          ),
          m = await this.contractWrapper.readContract.encryptDecrypt(Ne(u), p),
          y = er(["bytes", "bytes", "uint256"], [Ne(u), p, f]),
          h = Ga.encode(["bytes", "bytes32"], [m, y]);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [l.length, o.endsWith("/") ? o : `${o}/`, a, h],
          parse: (g) => {
            const v = this.contractWrapper.parseLogs(
                "TokensLazyMinted",
                g == null ? void 0 : g.logs,
              ),
              w = v[0].args[1],
              T = v[0].args[2],
              A = [];
            for (let E = w; E.lte(T); E = E.add(1))
              A.push({
                id: E,
                receipt: g,
                data: () => this.erc721.getTokenMetadata(E),
              });
            return A;
          },
        });
      }),
    );
    $(
      this,
      "reveal",
      Y(async (e, t) => {
        if (!t) throw new Error("Password is required");
        const r = await this.contractWrapper.getChainID(),
          a = er(
            ["string", "uint256", "uint256", "address"],
            [t, r, e, this.contractWrapper.readContract.address],
          );
        try {
          const i = await this.contractWrapper.callStatic().reveal(e, a);
          if (!i.includes("://") || !i.endsWith("/"))
            throw new Error("invalid password");
        } catch {
          throw new Error("invalid password");
        }
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "reveal",
          args: [e, a],
        });
      }),
    );
    (this.erc721 = e), (this.contractWrapper = t), (this.storage = r);
  }
  async getMetadataInTier(e) {
    const r = (
      await this.contractWrapper.readContract.getMetadataForAllTiers()
    ).find((i) => i.tier === e);
    if (!r) throw new Error("Tier not found in contract.");
    return await Promise.all(
      r.ranges
        .map((i, s) => {
          const o = [],
            c = r.baseURIs[s];
          for (
            let l = i.startIdInclusive.toNumber();
            l < i.endIdNonInclusive.toNumber();
            l++
          ) {
            const u = `${c}/${l}`,
              d = this.storage.downloadJSON(u);
            o.push(d);
          }
          return o;
        })
        .flat(),
    );
  }
  async getTokensInTier(e) {
    const t = await this.contractWrapper.readContract.getTokensInTierLen();
    if (t.eq(0)) return [];
    const r = await this.contractWrapper.readContract.getTokensInTier(e, 0, t);
    return await Promise.all(
      r
        .map((i) => {
          const s = [];
          for (
            let o = i.startIdInclusive.toNumber();
            o < i.endIdNonInclusive.toNumber();
            o++
          )
            s.push(this.erc721.get(o));
          return s;
        })
        .flat(),
    );
  }
  async generate(e) {
    const [t] = await this.generateBatch([e]);
    return t;
  }
  async generateBatch(e) {
    const t = await Promise.all(e.map((i) => VD.parseAsync(i))),
      r = await this.contractWrapper.getChainID(),
      a = this.contractWrapper.getSigner();
    return (
      ce(a, "No signer available"),
      await Promise.all(
        t.map(async (i) => {
          const s = await this.contractWrapper.signTypedData(
            a,
            {
              name: "SignatureAction",
              version: "1",
              chainId: r,
              verifyingContract: this.contractWrapper.readContract.address,
            },
            { GenericRequest: eB },
            await this.mapPayloadToContractStruct(i),
          );
          return { payload: i, signature: s.toString() };
        }),
      )
    );
  }
  async verify(e) {
    const t = await this.mapPayloadToContractStruct(e.payload);
    return (await this.contractWrapper.readContract.verify(t, e.signature))[0];
  }
  async claimWithSignature(e) {
    const t = await this.mapPayloadToContractStruct(e.payload),
      r = await qt(
        this.contractWrapper.getProvider(),
        e.payload.price,
        e.payload.currencyAddress,
      ),
      a = await this.contractWrapper.getCallOverrides();
    await ei(this.contractWrapper, r, e.payload.currencyAddress, a);
    const i = await this.contractWrapper.sendTransaction(
        "claimWithSignature",
        [t, e.signature],
        a,
      ),
      s = this.contractWrapper.parseLogs(
        "TokensClaimed",
        i == null ? void 0 : i.logs,
      ),
      o = s[0].args.startTokenId,
      c = o.add(s[0].args.quantityClaimed),
      l = [];
    for (let u = o; u.lt(c); u = u.add(1))
      l.push({ id: u, receipt: i, data: () => this.erc721.get(u) });
    return l;
  }
  async mapPayloadToContractStruct(e) {
    const t = await qt(
        this.contractWrapper.getProvider(),
        e.price,
        e.currencyAddress,
      ),
      r = Ga.encode(
        [
          "string[]",
          "address",
          "address",
          "uint256",
          "address",
          "uint256",
          "uint256",
          "address",
        ],
        [
          e.tierPriority,
          e.to,
          e.royaltyRecipient,
          e.royaltyBps,
          e.primarySaleRecipient,
          e.quantity,
          t,
          e.currencyAddress,
        ],
      );
    return {
      uid: e.uid,
      validityStartTimestamp: e.mintStartTime,
      validityEndTimestamp: e.mintEndTime,
      data: r,
    };
  }
}
class KD {
  constructor(e) {
    $(this, "featureName", Nu.name);
    $(
      this,
      "token",
      Y(async (e) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "burn",
          args: [e],
        }),
      ),
    );
    this.contractWrapper = e;
  }
}
class QD {
  constructor(e, t) {
    $(this, "featureName", zu.name);
    $(
      this,
      "mint",
      Y(async (e) => {
        const t = e.payload,
          r = e.signature,
          a = await this.contractWrapper.getCallOverrides(),
          i = (s) => {
            const o = this.contractWrapper.parseLogs(
              "TokensMintedWithSignature",
              s.logs,
            );
            if (o.length === 0)
              throw new Error("No MintWithSignature event found");
            return { id: o[0].args.tokenIdMinted, receipt: s };
          };
        if (await this.isLegacyNFTContract()) {
          const s = await this.mapLegacyPayloadToContractStruct(t),
            o = s.price;
          return (
            await ei(this.contractWrapper, o, t.currencyAddress, a),
            ne.fromContractWrapper({
              contractWrapper: this.contractWrapper,
              method: "mintWithSignature",
              args: [s, r],
              overrides: a,
              parse: i,
            })
          );
        } else {
          const s = await this.mapPayloadToContractStruct(t),
            o = s.pricePerToken.mul(s.quantity);
          return (
            await ei(this.contractWrapper, o, t.currencyAddress, a),
            ne.fromContractWrapper({
              contractWrapper: this.contractWrapper,
              method: "mintWithSignature",
              args: [s, r],
              overrides: a,
              parse: i,
            })
          );
        }
      }),
    );
    $(
      this,
      "mintBatch",
      Y(async (e) => {
        const t = await this.isLegacyNFTContract(),
          a = (
            await Promise.all(
              e.map(async (i) => {
                let s;
                t
                  ? (s = await this.mapLegacyPayloadToContractStruct(i.payload))
                  : (s = await this.mapPayloadToContractStruct(i.payload));
                const o = i.signature,
                  c = i.payload.price;
                if (O.from(c).gt(0))
                  throw new Error(
                    "Can only batch free mints. For mints with a price, use regular mint()",
                  );
                return { message: s, signature: o };
              }),
            )
          ).map((i) =>
            t
              ? this.contractWrapper.readContract.interface.encodeFunctionData(
                  "mintWithSignature",
                  [i.message, i.signature],
                )
              : this.contractWrapper.readContract.interface.encodeFunctionData(
                  "mintWithSignature",
                  [i.message, i.signature],
                ),
          );
        if (vt("multicall", this.contractWrapper))
          return ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [a],
            parse: (i) => {
              const s = this.contractWrapper.parseLogs(
                "TokensMintedWithSignature",
                i.logs,
              );
              if (s.length === 0)
                throw new Error("No MintWithSignature event found");
              return s.map((o) => ({ id: o.args.tokenIdMinted, receipt: i }));
            },
          });
        throw new Error("Multicall not available on this contract!");
      }),
    );
    (this.contractWrapper = e), (this.storage = t);
  }
  async verify(e) {
    const t = await this.isLegacyNFTContract(),
      r = e.payload,
      a = e.signature;
    let i, s;
    if (t) {
      const o = this.contractWrapper.readContract;
      (i = await this.mapLegacyPayloadToContractStruct(r)),
        (s = await o.verify(i, a));
    } else {
      const o = this.contractWrapper.readContract;
      (i = await this.mapPayloadToContractStruct(r)),
        (s = await o.verify(i, a));
    }
    return s[0];
  }
  async generate(e) {
    return (await this.generateBatch([e]))[0];
  }
  async generateBatch(e) {
    const t = await this.isLegacyNFTContract(),
      r = await Promise.all(e.map((c) => KM.parseAsync(c))),
      a = r.map((c) => c.metadata),
      i = await Yi(a, this.storage),
      s = await this.contractWrapper.getChainID(),
      o = this.contractWrapper.getSigner();
    return (
      ce(o, "No signer available"),
      await Promise.all(
        r.map(async (c, l) => {
          const u = i[l],
            d = await QM.parseAsync({ ...c, uri: u });
          let f;
          return (
            t
              ? (f = await this.contractWrapper.signTypedData(
                  o,
                  {
                    name: "TokenERC721",
                    version: "1",
                    chainId: s,
                    verifyingContract:
                      this.contractWrapper.readContract.address,
                  },
                  { MintRequest: JM },
                  await this.mapLegacyPayloadToContractStruct(d),
                ))
              : (f = await this.contractWrapper.signTypedData(
                  o,
                  {
                    name: "SignatureMintERC721",
                    version: "1",
                    chainId: s,
                    verifyingContract:
                      await this.contractWrapper.readContract.address,
                  },
                  { MintRequest: ZM },
                  await this.mapPayloadToContractStruct(d),
                )),
            { payload: d, signature: f.toString() }
          );
        }),
      )
    );
  }
  async mapPayloadToContractStruct(e) {
    const t = await qt(
      this.contractWrapper.getProvider(),
      e.price,
      e.currencyAddress,
    );
    return {
      to: e.to,
      royaltyRecipient: e.royaltyRecipient,
      royaltyBps: e.royaltyBps,
      primarySaleRecipient: e.primarySaleRecipient,
      uri: e.uri,
      quantity: e.quantity,
      pricePerToken: t,
      currency: e.currencyAddress,
      validityStartTimestamp: e.mintStartTime,
      validityEndTimestamp: e.mintEndTime,
      uid: e.uid,
    };
  }
  async mapLegacyPayloadToContractStruct(e) {
    const t = await qt(
      this.contractWrapper.getProvider(),
      e.price,
      e.currencyAddress,
    );
    return {
      to: e.to,
      price: t,
      uri: e.uri,
      currency: e.currencyAddress,
      validityEndTimestamp: e.mintEndTime,
      validityStartTimestamp: e.mintStartTime,
      uid: e.uid,
      royaltyRecipient: e.royaltyRecipient,
      royaltyBps: e.royaltyBps,
      primarySaleRecipient: e.primarySaleRecipient,
    };
  }
  async isLegacyNFTContract() {
    return fe(this.contractWrapper, "ERC721SignatureMintV1");
  }
}
class YD {
  constructor(e, t) {
    $(this, "featureName", Hu.name);
    $(
      this,
      "set",
      Y(async (e) => {
        const t = _5.parse(e),
          r = [];
        Oi(t.image)
          ? r.push(this.storage.upload(t.image))
          : typeof t.image == "string"
          ? r.push(Promise.resolve(t.image))
          : r.push(Promise.resolve(void 0)),
          Oi(t.animation_url)
            ? r.push(this.storage.upload(t.animation_url))
            : typeof t.animation_url == "string"
            ? r.push(Promise.resolve(t.animation_url))
            : r.push(Promise.resolve(void 0));
        const [a, i] = await Promise.all(r);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setSharedMetadata",
          args: [
            {
              name: `${t.name || ""}`,
              description: t.description || "",
              imageURI: a || "",
              animationURI: i || "",
            },
          ],
        });
      }),
    );
    (this.contractWrapper = e), (this.storage = t);
  }
  async get() {
    const e = await this.contractWrapper.readContract.sharedMetadata();
    if (!e.every((t) => t === ""))
      return {
        name: e.name,
        description: e.description,
        image: e.imageURI,
        animation_url: e.animationURI,
      };
  }
}
function Dv(n) {
  return zh(Cn.parse(n));
}
class JD {
  constructor(e, t) {
    $(this, "featureName", Jp.name);
    $(
      this,
      "to",
      Y(async (e, t, r) => {
        var u;
        const a = await ((u = this.contractWrapper.getSigner()) == null
          ? void 0
          : u.getAddress());
        if (e !== a)
          throw new Error(
            "Zora Drop: Destination address must match connected wallet address",
          );
        if (r != null && r.pricePerToken)
          throw new Error(
            "Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated",
          );
        const s = (await this.getSaleDetails()).publicSalePrice,
          o = Dv("0.000777"),
          c = O.from(s).add(o).mul(t),
          l = ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "purchase",
            args: [t],
            overrides: { value: c },
          });
        return (
          l.setParse((d) => {
            const p = this.contractWrapper.parseLogs(
                "Sale",
                d == null ? void 0 : d.logs,
              )[0].args.firstPurchasedTokenId,
              m = p.add(t),
              y = [];
            for (let h = p; h.lt(m); h = h.add(1))
              y.push({ id: h, receipt: d, data: () => this.erc721.get(h) });
            return y;
          }),
          l
        );
      }),
    );
    (this.erc721 = e), (this.contractWrapper = t);
  }
  async getSaleDetails() {
    return this.contractWrapper.readContract.saleDetails();
  }
}
class XD {
  constructor(e) {
    $(this, "featureName", Ni.name);
    $(
      this,
      "cancel",
      Y(async (e) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "cancel",
          args: [e],
        }),
      ),
    );
    $(
      this,
      "revoke",
      Y(async (e) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "revoke",
          args: [e],
        }),
      ),
    );
    this.contractWrapper = e;
  }
}
class ZD {
  constructor(e, t) {
    $(this, "featureName", Ws.name);
    $(
      this,
      "update",
      Y(async (e, t) => {
        const r = await Em(t, this.storage);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setTokenURI",
          args: [e, r],
        });
      }),
    );
    (this.contractWrapper = e), (this.storage = t);
  }
}
class eO {
  constructor(e, t, r) {
    $(this, "featureName", qu.name);
    $(
      this,
      "transfer",
      Y(async (e, t) => {
        const r = await this.contractWrapper.getSignerAddress();
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "transferFrom(address,address,uint256)",
          args: [r, await te(e), t],
        });
      }),
    );
    $(
      this,
      "transferFrom",
      Y(async (e, t, r) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "transferFrom(address,address,uint256)",
          args: [await te(e), await te(t), r],
        }),
      ),
    );
    $(
      this,
      "setApprovalForAll",
      Y(async (e, t) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setApprovalForAll",
          args: [await te(e), t],
        }),
      ),
    );
    $(
      this,
      "setApprovalForToken",
      Y(async (e, t) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approve",
          args: [await te(e), t],
        }),
      ),
    );
    $(
      this,
      "mint",
      Y(async (e) =>
        this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), e),
      ),
    );
    $(
      this,
      "mintTo",
      Y(async (e, t) => xe(this.mintable, ju).to.prepare(e, t)),
    );
    $(
      this,
      "mintBatch",
      Y(async (e) =>
        this.mintBatchTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e,
        ),
      ),
    );
    $(
      this,
      "mintBatchTo",
      Y(async (e, t) => {
        var r;
        return xe(
          (r = this.mintable) == null ? void 0 : r.batch,
          Uu,
        ).to.prepare(e, t);
      }),
    );
    $(
      this,
      "burn",
      Y(async (e) => xe(this.burnable, Nu).token.prepare(e)),
    );
    $(
      this,
      "cancel",
      Y(async (e) => xe(this.loyaltyCard, Ni).cancel.prepare(e)),
    );
    $(
      this,
      "revoke",
      Y(async (e) => xe(this.loyaltyCard, Ni).revoke.prepare(e)),
    );
    $(
      this,
      "lazyMint",
      Y(async (e, t) => xe(this.lazyMintable, Wu).lazyMint.prepare(e, t)),
    );
    $(
      this,
      "update",
      Y(async (e, t) => xe(this.updatableMetadata, Ws).update.prepare(e, t)),
    );
    $(
      this,
      "claim",
      Y(async (e, t) =>
        this.claimTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e,
          t,
        ),
      ),
    );
    $(
      this,
      "claimTo",
      Y(async (e, t, r) => {
        const a = this.claimWithConditions,
          i = this.claimCustom,
          s = this.claimZora;
        if (a) return a.to.prepare(e, t, r);
        if (i) return i.to.prepare(e, t, r);
        if (s) return s.to.prepare(e, t, r);
        throw new $s(hc);
      }),
    );
    (this.contractWrapper = e),
      (this.storage = t),
      (this.query = this.detectErc721Enumerable()),
      (this.mintable = this.detectErc721Mintable()),
      (this.burnable = this.detectErc721Burnable()),
      (this.lazyMintable = this.detectErc721LazyMintable()),
      (this.tieredDropable = this.detectErc721TieredDrop()),
      (this.signatureMintable = this.detectErc721SignatureMintable()),
      (this.claimWithConditions = this.detectErc721ClaimableWithConditions()),
      (this.claimCustom = this.detectErc721Claimable()),
      (this.claimZora = this.detectErc721ClaimableZora()),
      (this.erc721SharedMetadata = this.detectErc721SharedMetadata()),
      (this.loyaltyCard = this.detectErc721LoyaltyCard()),
      (this.updatableMetadata = this.detectErc721UpdatableMetadata()),
      (this._chainId = r);
  }
  get chainId() {
    return this._chainId;
  }
  onNetworkUpdated(e) {
    this.contractWrapper.updateSignerOrProvider(e);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(e) {
    const [t, r] = await Promise.all([
      this.ownerOf(e).catch(() => Ie),
      this.getTokenMetadata(e).catch(() => ({
        id: e.toString(),
        uri: "",
        ...hf,
      })),
    ]);
    return { owner: t, metadata: r, type: "ERC721", supply: "1" };
  }
  async ownerOf(e) {
    return await this.contractWrapper.readContract.ownerOf(e);
  }
  async balanceOf(e) {
    return await this.contractWrapper.readContract.balanceOf(await te(e));
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async isApproved(e, t) {
    return await this.contractWrapper.readContract.isApprovedForAll(
      await te(e),
      await te(t),
    );
  }
  async getAll(e) {
    return xe(this.query, ks).all(e);
  }
  async getAllOwners() {
    return xe(this.query, ks).allOwners();
  }
  async totalCount() {
    return this.nextTokenIdToMint();
  }
  async totalCirculatingSupply() {
    return xe(this.query, ks).totalCirculatingSupply();
  }
  async getOwned(e) {
    var t;
    if ((e && (e = await te(e)), (t = this.query) != null && t.owned))
      return this.query.owned.all(e);
    {
      const r = e || (await this.contractWrapper.getSignerAddress()),
        a = await this.getAllOwners();
      return Promise.all(
        (a || [])
          .filter((i) => {
            var s;
            return (
              (r == null ? void 0 : r.toLowerCase()) ===
              ((s = i.owner) == null ? void 0 : s.toLowerCase())
            );
          })
          .map(async (i) => await this.get(i.tokenId)),
      );
    }
  }
  async getOwnedTokenIds(e) {
    var t;
    if ((e && (e = await te(e)), (t = this.query) != null && t.owned))
      return this.query.owned.tokenIds(e);
    {
      const r = e || (await this.contractWrapper.getSignerAddress());
      return ((await this.getAllOwners()) || [])
        .filter((i) => {
          var s;
          return (
            (r == null ? void 0 : r.toLowerCase()) ===
            ((s = i.owner) == null ? void 0 : s.toLowerCase())
          );
        })
        .map((i) => O.from(i.tokenId));
    }
  }
  async getMintTransaction(e, t) {
    return this.mintTo.prepare(e, t);
  }
  async getClaimTransaction(e, t, r) {
    const a = this.claimWithConditions,
      i = this.claimCustom;
    if (a) return a.conditions.getClaimTransaction(e, t, r);
    if (i) return i.getClaimTransaction(e, t, r);
    throw new $s(hc);
  }
  async totalClaimedSupply() {
    const e = this.contractWrapper;
    if (vt("totalMinted", e)) return e.readContract.totalMinted();
    if (vt("nextTokenIdToClaim", e)) return e.readContract.nextTokenIdToClaim();
    throw new Error(
      "No function found on contract to get total claimed supply",
    );
  }
  async totalUnclaimedSupply() {
    return (await this.nextTokenIdToMint()).sub(
      await this.totalClaimedSupply(),
    );
  }
  get claimConditions() {
    return xe(this.claimWithConditions, $u).conditions;
  }
  get tieredDrop() {
    return xe(this.tieredDropable, Lu);
  }
  get signature() {
    return xe(this.signatureMintable, zu);
  }
  get revealer() {
    var e;
    return xe((e = this.lazyMintable) == null ? void 0 : e.revealer, Fu);
  }
  get sharedMetadata() {
    return xe(this.erc721SharedMetadata, Hu);
  }
  async getTokenMetadata(e) {
    const t = await this.contractWrapper.readContract.tokenURI(e);
    if (!t) throw new tv();
    return Am(e, t, this.storage);
  }
  async nextTokenIdToMint() {
    if (vt("nextTokenIdToMint", this.contractWrapper)) {
      let e = await this.contractWrapper.readContract.nextTokenIdToMint();
      return (
        vt("startTokenId", this.contractWrapper) &&
          (e = e.sub(await this.contractWrapper.readContract.startTokenId())),
        e
      );
    } else {
      if (vt("totalSupply", this.contractWrapper))
        return await this.contractWrapper.readContract.totalSupply();
      throw new Error(
        "Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint",
      );
    }
  }
  detectErc721Enumerable() {
    if (
      fe(this.contractWrapper, "ERC721Supply") ||
      vt("nextTokenIdToMint", this.contractWrapper)
    )
      return new qD(this, this.contractWrapper);
  }
  detectErc721Mintable() {
    if (fe(this.contractWrapper, "ERC721Mintable"))
      return new jD(this, this.contractWrapper, this.storage);
  }
  detectErc721Burnable() {
    if (fe(this.contractWrapper, "ERC721Burnable"))
      return new KD(this.contractWrapper);
  }
  detectErc721LazyMintable() {
    if (fe(this.contractWrapper, "ERC721LazyMintable"))
      return new UD(this, this.contractWrapper, this.storage);
  }
  detectErc721TieredDrop() {
    if (fe(this.contractWrapper, "ERC721TieredDrop"))
      return new GD(this, this.contractWrapper, this.storage);
  }
  detectErc721SignatureMintable() {
    if (
      fe(this.contractWrapper, "ERC721SignatureMintV1") ||
      fe(this.contractWrapper, "ERC721SignatureMintV2")
    )
      return new QD(this.contractWrapper, this.storage);
  }
  detectErc721ClaimableWithConditions() {
    if (
      fe(this.contractWrapper, "ERC721ClaimConditionsV1") ||
      fe(this.contractWrapper, "ERC721ClaimConditionsV2") ||
      fe(this.contractWrapper, "ERC721ClaimPhasesV1") ||
      fe(this.contractWrapper, "ERC721ClaimPhasesV2")
    )
      return new $D(this, this.contractWrapper, this.storage);
  }
  detectErc721Claimable() {
    if (fe(this.contractWrapper, "ERC721ClaimCustom"))
      return new WD(this, this.contractWrapper);
  }
  detectErc721ClaimableZora() {
    if (fe(this.contractWrapper, "ERC721ClaimZora"))
      return new JD(this, this.contractWrapper);
  }
  detectErc721SharedMetadata() {
    if (fe(this.contractWrapper, "ERC721SharedMetadata"))
      return new YD(this.contractWrapper, this.storage);
  }
  detectErc721LoyaltyCard() {
    if (fe(this.contractWrapper, "ERC721LoyaltyCard"))
      return new XD(this.contractWrapper);
  }
  detectErc721UpdatableMetadata() {
    if (fe(this.contractWrapper, "ERC721UpdatableMetadata"))
      return new ZD(this.contractWrapper, this.storage);
  }
}
class tO {
  constructor(e, t, r) {
    $(this, "featureName", Qu.name);
    $(
      this,
      "to",
      Y(async (e, t) => {
        const r = t.map((c) => c.metadata),
          a = t.map((c) => c.supply),
          i = await Yi(r, this.storage),
          s = await te(e),
          o = await Promise.all(
            i.map(async (c, l) =>
              this.contractWrapper.readContract.interface.encodeFunctionData(
                "mintTo",
                [s, On, c, a[l]],
              ),
            ),
          );
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [o],
          parse: (c) => {
            const l = this.contractWrapper.parseLogs("TokensMinted", c.logs);
            if (l.length === 0 || l.length < r.length)
              throw new Error("TokenMinted event not found, minting failed");
            return l.map((u) => {
              const d = u.args.tokenIdMinted;
              return { id: d, receipt: c, data: () => this.erc1155.get(d) };
            });
          },
        });
      }),
    );
    (this.erc1155 = e), (this.contractWrapper = t), (this.storage = r);
  }
}
class nO {
  constructor(e) {
    $(this, "featureName", wi.name);
    $(
      this,
      "tokens",
      Y(async (e, t) => {
        const r = await this.contractWrapper.getSignerAddress();
        return this.from.prepare(r, e, t);
      }),
    );
    $(
      this,
      "from",
      Y(async (e, t, r) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "burn",
          args: [await te(e), t, r],
        }),
      ),
    );
    $(
      this,
      "batch",
      Y(async (e, t) => {
        const r = await this.contractWrapper.getSignerAddress();
        return this.batchFrom.prepare(r, e, t);
      }),
    );
    $(
      this,
      "batchFrom",
      Y(async (e, t, r) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "burnBatch",
          args: [await te(e), t, r],
        }),
      ),
    );
    this.contractWrapper = e;
  }
}
class rO {
  constructor(e, t) {
    $(this, "featureName", Ci.name);
    (this.erc1155 = e), (this.contractWrapper = t);
  }
  async all(e) {
    const t = O.from((e == null ? void 0 : e.start) || 0).toNumber(),
      r = O.from((e == null ? void 0 : e.count) || Ko).toNumber(),
      a = Math.min((await this.totalCount()).toNumber(), t + r);
    return await Promise.all(
      [...Array(a - t).keys()].map((i) => this.erc1155.get((t + i).toString())),
    );
  }
  async totalCount() {
    return await this.contractWrapper.readContract.nextTokenIdToMint();
  }
  async totalCirculatingSupply(e) {
    return await this.contractWrapper.readContract.totalSupply(e);
  }
  async owned(e) {
    const t = await te(e || (await this.contractWrapper.getSignerAddress())),
      r = await this.contractWrapper.readContract.nextTokenIdToMint(),
      i = (
        await this.contractWrapper.readContract.balanceOfBatch(
          Array(r.toNumber()).fill(t),
          Array.from(Array(r.toNumber()).keys()),
        )
      )
        .map((s, o) => ({ tokenId: o, balance: s }))
        .filter((s) => s.balance.gt(0));
    return await Promise.all(
      i.map(async (s) => ({
        ...(await this.erc1155.get(s.tokenId.toString())),
        owner: t,
        quantityOwned: s.balance.toString(),
      })),
    );
  }
}
async function _m(n, e) {
  try {
    const t = new Pe(n, S6, e),
      [r, a] = await Promise.all([
        zi(await t.contractType()).replace(/\x00/g, ""),
        await t.contractVersion(),
      ]);
    return { type: r, version: a };
  } catch {
    return;
  }
}
class aO {
  constructor(e, t, r) {
    $(this, "featureName", Gu.name);
    $(
      this,
      "lazyMint",
      Y(async (e, t) => {
        const r = await this.erc1155.nextTokenIdToMint(),
          a = await Yi(e, this.storage, r.toNumber(), t),
          i = a[0].substring(0, a[0].lastIndexOf("/"));
        for (let c = 0; c < a.length; c++) {
          const l = a[c].substring(0, a[c].lastIndexOf("/"));
          if (i !== l)
            throw new Error(
              `Can only create batches with the same base URI for every entry in the batch. Expected '${i}' but got '${l}'`,
            );
        }
        const s = (c) => {
            const l = this.contractWrapper.parseLogs(
                "TokensLazyMinted",
                c == null ? void 0 : c.logs,
              ),
              u = l[0].args.startTokenId,
              d = l[0].args.endTokenId,
              f = [];
            for (let p = u; p.lte(d); p = p.add(1))
              f.push({
                id: p,
                receipt: c,
                data: () => this.erc1155.getTokenMetadata(p),
              });
            return f;
          },
          o = await _m(
            this.contractWrapper.readContract.address,
            this.contractWrapper.getProvider(),
          );
        return this.isLegacyEditionDropContract(this.contractWrapper, o)
          ? ne.fromContractWrapper({
              contractWrapper: this.contractWrapper,
              method: "lazyMint",
              args: [a.length, `${i.endsWith("/") ? i : `${i}/`}`],
              parse: s,
            })
          : ne.fromContractWrapper({
              contractWrapper: this.contractWrapper,
              method: "lazyMint",
              args: [a.length, `${i.endsWith("/") ? i : `${i}/`}`, Ne("")],
              parse: s,
            });
      }),
    );
    (this.erc1155 = e),
      (this.contractWrapper = t),
      (this.storage = r),
      (this.revealer = this.detectErc1155Revealable());
  }
  detectErc1155Revealable() {
    if (fe(this.contractWrapper, "ERC1155Revealable"))
      return new kv(this.contractWrapper, this.storage, Us.name, () =>
        this.erc1155.nextTokenIdToMint(),
      );
  }
  isLegacyEditionDropContract(e, t) {
    return (t && t.type === "DropERC1155" && t.version < 3) || !1;
  }
}
class iO {
  constructor(e, t, r) {
    $(this, "featureName", Ti.name);
    $(
      this,
      "to",
      Y(async (e, t) => {
        const r = await this.getMintTransaction(e, t);
        return (
          r.setParse((a) => {
            const i = this.contractWrapper.parseLogs(
              "TransferSingle",
              a == null ? void 0 : a.logs,
            );
            if (i.length === 0)
              throw new Error("TransferSingleEvent event not found");
            const s = i[0].args.id;
            return {
              id: s,
              receipt: a,
              data: () => this.erc1155.get(s.toString()),
            };
          }),
          r
        );
      }),
    );
    $(
      this,
      "additionalSupplyTo",
      Y(async (e, t, r) => {
        const a = await this.erc1155.getTokenMetadata(t);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "mintTo",
          args: [await te(e), t, a.uri, r],
          parse: (i) => ({
            id: O.from(t),
            receipt: i,
            data: () => this.erc1155.get(t),
          }),
        });
      }),
    );
    (this.erc1155 = e),
      (this.contractWrapper = t),
      (this.storage = r),
      (this.batch = this.detectErc1155BatchMintable());
  }
  async getMintTransaction(e, t) {
    const r = await Em(t.metadata, this.storage);
    return ne.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "mintTo",
      args: [await te(e), On, r, t.supply],
    });
  }
  detectErc1155BatchMintable() {
    if (fe(this.contractWrapper, "ERC1155BatchMintable"))
      return new tO(this.erc1155, this.contractWrapper, this.storage);
  }
}
const yb = (() => M.object({ address: at, quantity: Cn.default(1) }))(),
  sO = (() =>
    M.union([
      M.array(M.string()).transform(
        async (n) =>
          await Promise.all(n.map((e) => yb.parseAsync({ address: e }))),
      ),
      M.array(yb),
    ]))();
class oO {
  constructor(e, t, r) {
    $(this, "featureName", Ku.name);
    $(
      this,
      "mint",
      Y(async (e) => {
        const t = e.payload,
          r = e.signature,
          a = await this.mapPayloadToContractStruct(t),
          i = await this.contractWrapper.getCallOverrides();
        return (
          await ei(
            this.contractWrapper,
            a.pricePerToken.mul(a.quantity),
            t.currencyAddress,
            i,
          ),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "mintWithSignature",
            args: [a, r],
            overrides: i,
            parse: (s) => {
              const o = this.contractWrapper.parseLogs(
                "TokensMintedWithSignature",
                s.logs,
              );
              if (o.length === 0)
                throw new Error("No MintWithSignature event found");
              return { id: o[0].args.tokenIdMinted, receipt: s };
            },
          })
        );
      }),
    );
    $(
      this,
      "mintBatch",
      Y(async (e) => {
        const r = (
          await Promise.all(
            e.map(async (a) => {
              const i = await this.mapPayloadToContractStruct(a.payload),
                s = a.signature,
                o = a.payload.price;
              if (O.from(o).gt(0))
                throw new Error(
                  "Can only batch free mints. For mints with a price, use regular mint()",
                );
              return { message: i, signature: s };
            }),
          )
        ).map((a) =>
          this.contractWrapper.readContract.interface.encodeFunctionData(
            "mintWithSignature",
            [a.message, a.signature],
          ),
        );
        if (vt("multicall", this.contractWrapper))
          return ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [r],
            parse: (a) => {
              const i = this.contractWrapper.parseLogs(
                "TokensMintedWithSignature",
                a.logs,
              );
              if (i.length === 0)
                throw new Error("No MintWithSignature event found");
              return i.map((s) => ({ id: s.args.tokenIdMinted, receipt: a }));
            },
          });
        throw new Error("Multicall not supported on this contract!");
      }),
    );
    (this.contractWrapper = e), (this.storage = t), (this.roles = r);
  }
  async verify(e) {
    const t = e.payload,
      r = e.signature,
      a = await this.mapPayloadToContractStruct(t);
    return (await this.contractWrapper.readContract.verify(a, r))[0];
  }
  async generate(e) {
    const t = { ...e, tokenId: On };
    return this.generateFromTokenId(t);
  }
  async generateFromTokenId(e) {
    return (await this.generateBatchFromTokenIds([e]))[0];
  }
  async generateBatch(e) {
    const t = e.map((r) => ({ ...r, tokenId: On }));
    return this.generateBatchFromTokenIds(t);
  }
  async generateBatchFromTokenIds(e) {
    var l;
    await ((l = this.roles) == null
      ? void 0
      : l.verify(["minter"], await this.contractWrapper.getSignerAddress()));
    const t = await Promise.all(e.map((u) => VM.parseAsync(u))),
      r = t.map((u) => u.metadata),
      a = await Yi(r, this.storage),
      i = await this.contractWrapper.getChainID(),
      s = this.contractWrapper.getSigner();
    ce(s, "No signer available");
    const o = await _m(
        this.contractWrapper.readContract.address,
        this.contractWrapper.getProvider(),
      ),
      c = (o == null ? void 0 : o.type) === "TokenERC1155";
    return await Promise.all(
      t.map(async (u, d) => {
        const f = a[d],
          p = await GM.parseAsync({ ...u, uri: f }),
          m = await this.contractWrapper.signTypedData(
            s,
            {
              name: c ? "TokenERC1155" : "SignatureMintERC1155",
              version: "1",
              chainId: i,
              verifyingContract: this.contractWrapper.readContract.address,
            },
            { MintRequest: XM },
            await this.mapPayloadToContractStruct(p),
          );
        return { payload: p, signature: m.toString() };
      }),
    );
  }
  async mapPayloadToContractStruct(e) {
    const t = await qt(
      this.contractWrapper.getProvider(),
      e.price,
      e.currencyAddress,
    );
    return {
      to: e.to,
      tokenId: e.tokenId,
      uri: e.uri,
      quantity: e.quantity,
      pricePerToken: t,
      currency: e.currencyAddress,
      validityStartTimestamp: e.mintStartTime,
      validityEndTimestamp: e.mintEndTime,
      uid: e.uid,
      royaltyRecipient: e.royaltyRecipient,
      royaltyBps: e.royaltyBps,
      primarySaleRecipient: e.primarySaleRecipient,
    };
  }
}
class cO {
  constructor(e) {
    $(this, "featureName", mc.name);
    $(
      this,
      "to",
      Y(async (e, t, r, a) => await this.getClaimTransaction(e, t, r, a)),
    );
    this.contractWrapper = e;
  }
  async getClaimTransaction(e, t, r, a) {
    let i = {};
    return (
      a &&
        a.pricePerToken &&
        (i = await Bv(
          this.contractWrapper,
          a.pricePerToken,
          r,
          a.currencyAddress,
          a.checkERC20Allowance,
        )),
      ne.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "claim",
        args: [await te(e), t, r],
        overrides: i,
      })
    );
  }
}
class lO {
  constructor(e, t) {
    $(this, "featureName", Vu.name);
    $(
      this,
      "to",
      Y(
        async (e, t, r, a) =>
          await this.conditions.getClaimTransaction(e, t, r, a),
      ),
    );
    (this.contractWrapper = e), (this.storage = t);
    const r = new _s(this.contractWrapper, Es, this.storage);
    this.conditions = new PD(e, r, this.storage);
  }
}
class uO {
  constructor(e, t, r) {
    $(this, "featureName", Yu.name);
    $(
      this,
      "transfer",
      Y(
        (() => {
          var e = this;
          return async function (t, r, a) {
            let i =
              arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : [0];
            const s = await e.contractWrapper.getSignerAddress();
            return ne.fromContractWrapper({
              contractWrapper: e.contractWrapper,
              method: "safeTransferFrom",
              args: [s, await te(t), r, a, i],
            });
          };
        })(),
      ),
    );
    $(
      this,
      "transferFrom",
      Y(
        (() => {
          var e = this;
          return async function (t, r, a, i) {
            let s =
              arguments.length > 4 && arguments[4] !== void 0
                ? arguments[4]
                : [0];
            return ne.fromContractWrapper({
              contractWrapper: e.contractWrapper,
              method: "safeTransferFrom",
              args: [await te(t), await te(r), a, i, s],
            });
          };
        })(),
      ),
    );
    $(
      this,
      "setApprovalForAll",
      Y(async (e, t) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setApprovalForAll",
          args: [e, t],
        }),
      ),
    );
    $(
      this,
      "airdrop",
      Y(
        (() => {
          var e = this;
          return async function (t, r) {
            let a =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : [0];
            const i = await e.contractWrapper.getSignerAddress(),
              s = await e.balanceOf(i, t),
              o = await sO.parseAsync(r),
              c = o.reduce(
                (u, d) =>
                  O.from(u).add(O.from((d == null ? void 0 : d.quantity) || 1)),
                O.from(0),
              );
            if (s.lt(O.from(c)))
              throw new Error(
                `The caller owns ${s.toString()} NFTs, but wants to airdrop ${c.toString()} NFTs.`,
              );
            const l = o.map((u) => {
              let { address: d, quantity: f } = u;
              return e.contractWrapper.readContract.interface.encodeFunctionData(
                "safeTransferFrom",
                [i, d, t, f, a],
              );
            });
            return ne.fromContractWrapper({
              contractWrapper: e.contractWrapper,
              method: "multicall",
              args: [l],
            });
          };
        })(),
      ),
    );
    $(
      this,
      "mint",
      Y(async (e) =>
        this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), e),
      ),
    );
    $(
      this,
      "mintTo",
      Y(async (e, t) => xe(this.mintable, Ti).to.prepare(e, t)),
    );
    $(
      this,
      "mintAdditionalSupply",
      Y(async (e, t) =>
        xe(this.mintable, Ti).additionalSupplyTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e,
          t,
        ),
      ),
    );
    $(
      this,
      "mintAdditionalSupplyTo",
      Y(async (e, t, r) =>
        xe(this.mintable, Ti).additionalSupplyTo.prepare(e, t, r),
      ),
    );
    $(
      this,
      "mintBatch",
      Y(async (e) =>
        this.mintBatchTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e,
        ),
      ),
    );
    $(
      this,
      "mintBatchTo",
      Y(async (e, t) => {
        var r;
        return xe(
          (r = this.mintable) == null ? void 0 : r.batch,
          Qu,
        ).to.prepare(e, t);
      }),
    );
    $(
      this,
      "burn",
      Y(async (e, t) => xe(this.burnable, wi).tokens.prepare(e, t)),
    );
    $(
      this,
      "burnFrom",
      Y(async (e, t, r) => xe(this.burnable, wi).from.prepare(e, t, r)),
    );
    $(
      this,
      "burnBatch",
      Y(async (e, t) => xe(this.burnable, wi).batch.prepare(e, t)),
    );
    $(
      this,
      "burnBatchFrom",
      Y(async (e, t, r) => xe(this.burnable, wi).batchFrom.prepare(e, t, r)),
    );
    $(
      this,
      "lazyMint",
      Y(async (e, t) => xe(this.lazyMintable, Gu).lazyMint.prepare(e, t)),
    );
    $(
      this,
      "claim",
      Y(async (e, t, r) =>
        this.claimTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e,
          t,
          r,
        ),
      ),
    );
    $(
      this,
      "claimTo",
      Y(async (e, t, r, a) => {
        const i = this.claimWithConditions,
          s = this.claimCustom;
        if (i) return i.to.prepare(e, t, r, a);
        if (s) return s.to.prepare(e, t, r, a);
        throw new $s(mc);
      }),
    );
    (this.contractWrapper = e),
      (this.storage = t),
      (this.query = this.detectErc1155Enumerable()),
      (this.mintable = this.detectErc1155Mintable()),
      (this.burnable = this.detectErc1155Burnable()),
      (this.lazyMintable = this.detectErc1155LazyMintable()),
      (this.signatureMintable = this.detectErc1155SignatureMintable()),
      (this.claimCustom = this.detectErc1155Claimable()),
      (this.claimWithConditions = this.detectErc1155ClaimableWithConditions()),
      (this._chainId = r);
  }
  get chainId() {
    return this._chainId;
  }
  onNetworkUpdated(e) {
    this.contractWrapper.updateSignerOrProvider(e);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(e) {
    const [t, r] = await Promise.all([
      this.contractWrapper.readContract.totalSupply(e).catch(() => O.from(0)),
      this.getTokenMetadata(e).catch(() => ({
        id: e.toString(),
        uri: "",
        ...hf,
      })),
    ]);
    return { owner: Ie, metadata: r, type: "ERC1155", supply: t.toString() };
  }
  async totalSupply(e) {
    return await this.contractWrapper.readContract.totalSupply(e);
  }
  async balanceOf(e, t) {
    return await this.contractWrapper.readContract.balanceOf(await te(e), t);
  }
  async balance(e) {
    return await this.balanceOf(
      await this.contractWrapper.getSignerAddress(),
      e,
    );
  }
  async isApproved(e, t) {
    return await this.contractWrapper.readContract.isApprovedForAll(
      await te(e),
      await te(t),
    );
  }
  async nextTokenIdToMint() {
    if (vt("nextTokenIdToMint", this.contractWrapper))
      return await this.contractWrapper.readContract.nextTokenIdToMint();
    throw new Error(
      "Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint",
    );
  }
  async getAll(e) {
    return xe(this.query, Ci).all(e);
  }
  async totalCount() {
    return xe(this.query, Ci).totalCount();
  }
  async totalCirculatingSupply(e) {
    return xe(this.query, Ci).totalCirculatingSupply(e);
  }
  async getOwned(e) {
    return e && (e = await te(e)), xe(this.query, Ci).owned(e);
  }
  async getMintTransaction(e, t) {
    return xe(this.mintable, Ti).getMintTransaction(e, t);
  }
  async getClaimTransaction(e, t, r, a) {
    const i = this.claimWithConditions,
      s = this.claimCustom;
    if (i) return i.conditions.getClaimTransaction(e, t, r, a);
    if (s) return s.getClaimTransaction(e, t, r, a);
    throw new $s(mc);
  }
  get claimConditions() {
    return xe(this.claimWithConditions, Vu).conditions;
  }
  get signature() {
    return xe(this.signatureMintable, Ku);
  }
  get revealer() {
    var e;
    return xe((e = this.lazyMintable) == null ? void 0 : e.revealer, Us);
  }
  async getTokenMetadata(e) {
    const t = await this.contractWrapper.readContract.uri(e);
    if (!t) throw new tv();
    return Am(e, t, this.storage);
  }
  detectErc1155Enumerable() {
    if (fe(this.contractWrapper, "ERC1155Enumerable"))
      return new rO(this, this.contractWrapper);
  }
  detectErc1155Mintable() {
    if (fe(this.contractWrapper, "ERC1155Mintable"))
      return new iO(this, this.contractWrapper, this.storage);
  }
  detectErc1155Burnable() {
    if (fe(this.contractWrapper, "ERC1155Burnable"))
      return new nO(this.contractWrapper);
  }
  detectErc1155LazyMintable() {
    if (
      fe(this.contractWrapper, "ERC1155LazyMintableV1") ||
      fe(this.contractWrapper, "ERC1155LazyMintableV2")
    )
      return new aO(this, this.contractWrapper, this.storage);
  }
  detectErc1155SignatureMintable() {
    if (fe(this.contractWrapper, "ERC1155SignatureMintable"))
      return new oO(this.contractWrapper, this.storage);
  }
  detectErc1155Claimable() {
    if (fe(this.contractWrapper, "ERC1155ClaimCustom"))
      return new cO(this.contractWrapper);
  }
  detectErc1155ClaimableWithConditions() {
    if (
      fe(this.contractWrapper, "ERC1155ClaimConditionsV1") ||
      fe(this.contractWrapper, "ERC1155ClaimConditionsV2") ||
      fe(this.contractWrapper, "ERC1155ClaimPhasesV1") ||
      fe(this.contractWrapper, "ERC1155ClaimPhasesV2")
    )
      return new lO(this.contractWrapper, this.storage);
  }
}
function ch(n) {
  return rr(n) ? an : n;
}
async function dO(n, e, t, r, a) {
  try {
    const i = new Pe(t, rf, n),
      s = await i.supportsInterface(ff),
      o = await i.supportsInterface(pf);
    if (s) {
      const c = new Pe(t, Pt, n);
      if (await c.isApprovedForAll(a, e)) return !0;
      let u;
      try {
        u = await c.getApproved(r);
      } catch {}
      return (u == null ? void 0 : u.toLowerCase()) === e.toLowerCase();
    } else
      return o
        ? await new Pe(t, yn, n).isApprovedForAll(a, e)
        : (console.error("Contract does not implement ERC 1155 or ERC 721."),
          !1);
  } catch (i) {
    return console.error("Failed to check if token is approved", i), !1;
  }
}
async function vd(n, e, t, r, a) {
  const i = new Dt(n.getSignerOrProvider(), t, rf, n.options, n.storage),
    s = await i.readContract.supportsInterface(ff),
    o = await i.readContract.supportsInterface(pf);
  if (s) {
    const c = new Dt(n.getSignerOrProvider(), t, Pt, n.options, n.storage);
    (await c.readContract.isApprovedForAll(a, e)) ||
      (await c.readContract.getApproved(r)).toLowerCase() === e.toLowerCase() ||
      (await c.sendTransaction("setApprovalForAll", [e, !0]));
  } else if (o) {
    const c = new Dt(n.getSignerOrProvider(), t, yn, n.options, n.storage);
    (await c.readContract.isApprovedForAll(a, e)) ||
      (await c.sendTransaction("setApprovalForAll", [e, !0]));
  } else throw Error("Contract must implement ERC 1155 or ERC 721.");
}
function wq(n) {
  switch (
    (ce(
      n.assetContractAddress !== void 0 && n.assetContractAddress !== null,
      "Asset contract address is required",
    ),
    ce(
      n.buyoutPricePerToken !== void 0 && n.buyoutPricePerToken !== null,
      "Buyout price is required",
    ),
    ce(
      n.listingDurationInSeconds !== void 0 &&
        n.listingDurationInSeconds !== null,
      "Listing duration is required",
    ),
    ce(
      n.startTimestamp !== void 0 && n.startTimestamp !== null,
      "Start time is required",
    ),
    ce(n.tokenId !== void 0 && n.tokenId !== null, "Token ID is required"),
    ce(n.quantity !== void 0 && n.quantity !== null, "Quantity is required"),
    n.type)
  ) {
    case "NewAuctionListing":
      ce(
        n.reservePricePerToken !== void 0 && n.reservePricePerToken !== null,
        "Reserve price is required",
      );
  }
}
async function Tq(n, e, t) {
  return {
    quantity: t.quantityDesired,
    pricePerToken: t.pricePerToken,
    currencyContractAddress: t.currency,
    buyerAddress: t.offeror,
    quantityDesired: t.quantityWanted,
    currencyValue: await Xn(
      n,
      t.currency,
      t.quantityWanted.mul(t.pricePerToken),
    ),
    listingId: e,
  };
}
function Cq(n, e, t) {
  return (
    (t = O.from(t)),
    (n = O.from(n)),
    (e = O.from(e)),
    n.eq(O.from(0)) ? !1 : e.sub(n).mul(E5).div(n).gte(t)
  );
}
async function zs(n, e, t) {
  const r = [];
  for (; e - n > Ko; ) r.push(t(n, n + Ko - 1)), (n += Ko);
  return r.push(t(n, e - 1)), await Promise.all(r);
}
const gb = (() =>
  M.object({
    assetContractAddress: at,
    tokenId: _t,
    quantity: _t.default(1),
    currencyContractAddress: at.default(an),
    pricePerToken: Cn,
    startTimestamp: sf.default(new Date()),
    endTimestamp: Qc,
    isReservedListing: M.boolean().default(!1),
  }))();
class Xc {
  constructor(e) {
    this.contractWrapper = e;
  }
  addTransactionListener(e) {
    this.contractWrapper.addListener(Bn.Transaction, e);
  }
  removeTransactionListener(e) {
    this.contractWrapper.off(Bn.Transaction, e);
  }
  addEventListener(e, t) {
    const r = this.contractWrapper.readContract.interface.getEvent(e),
      i = {
        address: this.contractWrapper.readContract.address,
        topics: [this.contractWrapper.readContract.interface.getEventTopic(r)],
      },
      s = (o) => {
        const c = this.contractWrapper.readContract.interface.parseLog(o);
        t(this.toContractEvent(c.eventFragment, c.args, o));
      };
    return (
      this.contractWrapper.getProvider().on(i, s),
      () => {
        this.contractWrapper.getProvider().off(i, s);
      }
    );
  }
  listenToAllEvents(e) {
    const r = { address: this.contractWrapper.readContract.address },
      a = (i) => {
        try {
          const s = this.contractWrapper.readContract.interface.parseLog(i);
          e(this.toContractEvent(s.eventFragment, s.args, i));
        } catch (s) {
          console.error("Could not parse event:", i, s);
        }
      };
    return (
      this.contractWrapper.getProvider().on(r, a),
      () => {
        this.contractWrapper.getProvider().off(r, a);
      }
    );
  }
  removeEventListener(e, t) {
    const r = this.contractWrapper.readContract.interface.getEvent(e);
    this.contractWrapper.readContract.off(r.name, t);
  }
  removeAllListeners() {
    this.contractWrapper.readContract.removeAllListeners();
    const t = { address: this.contractWrapper.readContract.address };
    this.contractWrapper.getProvider().removeAllListeners(t);
  }
  async getAllEvents() {
    let e =
      arguments.length > 0 && arguments[0] !== void 0
        ? arguments[0]
        : { fromBlock: 0, toBlock: "latest", order: "desc" };
    const r = (
      await this.contractWrapper.readContract.queryFilter(
        {},
        e.fromBlock,
        e.toBlock,
      )
    ).sort((a, i) =>
      e.order === "desc"
        ? i.blockNumber - a.blockNumber
        : a.blockNumber - i.blockNumber,
    );
    return this.parseEvents(r);
  }
  async getEvents(e) {
    let t =
      arguments.length > 1 && arguments[1] !== void 0
        ? arguments[1]
        : { fromBlock: 0, toBlock: "latest", order: "desc" };
    const r = this.contractWrapper.readContract.interface.getEvent(e),
      a = this.contractWrapper.readContract.interface.getEvent(e),
      i = t.filters ? a.inputs.map((l) => t.filters[l.name]) : [],
      s = this.contractWrapper.readContract.filters[r.name](...i),
      c = (
        await this.contractWrapper.readContract.queryFilter(
          s,
          t.fromBlock,
          t.toBlock,
        )
      ).sort((l, u) =>
        t.order === "desc"
          ? u.blockNumber - l.blockNumber
          : l.blockNumber - u.blockNumber,
      );
    return this.parseEvents(c);
  }
  parseEvents(e) {
    return e.map((t) => {
      const r = Object.fromEntries(
        Object.entries(t).filter(
          (a) => typeof a[1] != "function" && a[0] !== "args",
        ),
      );
      if (t.args) {
        const a = Object.entries(t.args),
          i = a.slice(a.length / 2, a.length),
          s = {};
        for (const [o, c] of i) s[o] = c;
        return { eventName: t.event || "", data: s, transaction: r };
      }
      return { eventName: t.event || "", data: {}, transaction: r };
    });
  }
  toContractEvent(e, t, r) {
    const a = Object.fromEntries(
        Object.entries(r).filter(
          (s) => typeof s[1] != "function" && s[0] !== "args",
        ),
      ),
      i = {};
    return (
      e.inputs.forEach((s, o) => {
        if (Array.isArray(t[o])) {
          const c = s.components;
          if (c) {
            const l = t[o];
            if (s.type === "tuple[]") {
              const u = [];
              for (let d = 0; d < l.length; d++) {
                const f = l[d],
                  p = {};
                for (let m = 0; m < c.length; m++) {
                  const y = c[m].name;
                  p[y] = f[m];
                }
                u.push(p);
              }
              i[s.name] = u;
            } else {
              const u = {};
              for (let d = 0; d < c.length; d++) {
                const f = c[d].name;
                u[f] = l[d];
              }
              i[s.name] = u;
            }
          }
        } else i[s.name] = t[o];
      }),
      { eventName: e.name, data: i, transaction: a }
    );
  }
}
class yf {
  constructor(e) {
    this.contractWrapper = e;
  }
  overrideNextTransaction(e) {
    this.contractWrapper.withTransactionOverride(e);
  }
}
class gf {
  constructor(e) {
    this.contractWrapper = e;
  }
  async gasCostOf(e, t) {
    const r = await this.contractWrapper.getPreferredGasPrice(),
      a = await this.contractWrapper.estimateGas(e, t);
    return zd(a.mul(r));
  }
  async gasLimitOf(e, t) {
    return this.contractWrapper.estimateGas(e, t);
  }
  async currentGasPriceInGwei() {
    const e = await this.contractWrapper.getProvider().getGasPrice();
    return Ja(e, "gwei");
  }
}
class fO {
  constructor(e, t) {
    $(this, "featureName", ad.name);
    $(
      this,
      "createListing",
      Y(async (e) => {
        const t = await gb.parseAsync(e);
        await vd(
          this.contractWrapper,
          this.getAddress(),
          t.assetContractAddress,
          t.tokenId,
          await this.contractWrapper.getSignerAddress(),
        );
        const r = await qt(
            this.contractWrapper.getProvider(),
            t.pricePerToken,
            t.currencyContractAddress,
          ),
          i = (await this.contractWrapper.getProvider().getBlock("latest"))
            .timestamp;
        return (
          t.startTimestamp.lt(i) && (t.startTimestamp = O.from(i)),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "createListing",
            args: [
              {
                assetContract: t.assetContractAddress,
                tokenId: t.tokenId,
                quantity: t.quantity,
                currency: ch(t.currencyContractAddress),
                pricePerToken: r,
                startTimestamp: t.startTimestamp,
                endTimestamp: t.endTimestamp,
                reserved: t.isReservedListing,
              },
            ],
            parse: (s) => ({
              id: this.contractWrapper.parseLogs(
                "NewListing",
                s == null ? void 0 : s.logs,
              )[0].args.listingId,
              receipt: s,
            }),
          })
        );
      }),
    );
    $(
      this,
      "createListingsBatch",
      Y(async (e) => {
        const t = await Promise.all(
          e.map(async (r) => (await this.createListing.prepare(r)).encode()),
        );
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [t],
          parse: (r) =>
            this.contractWrapper
              .parseLogs("NewListing", r == null ? void 0 : r.logs)
              .map((i) => ({ id: i.args.listingId, receipt: r })),
        });
      }),
    );
    $(
      this,
      "updateListing",
      Y(async (e, t) => {
        const r = await gb.parseAsync(t);
        await vd(
          this.contractWrapper,
          this.getAddress(),
          r.assetContractAddress,
          r.tokenId,
          await this.contractWrapper.getSignerAddress(),
        );
        const a = await qt(
          this.contractWrapper.getProvider(),
          r.pricePerToken,
          r.currencyContractAddress,
        );
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "updateListing",
          args: [
            e,
            {
              assetContract: r.assetContractAddress,
              tokenId: r.tokenId,
              quantity: r.quantity,
              currency: ch(r.currencyContractAddress),
              pricePerToken: a,
              startTimestamp: r.startTimestamp,
              endTimestamp: r.endTimestamp,
              reserved: r.isReservedListing,
            },
          ],
          parse: (i) => ({
            id: this.contractWrapper.parseLogs(
              "UpdatedListing",
              i == null ? void 0 : i.logs,
            )[0].args.listingId,
            receipt: i,
          }),
        });
      }),
    );
    $(
      this,
      "cancelListing",
      Y(async (e) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "cancelListing",
          args: [e],
        }),
      ),
    );
    $(
      this,
      "buyFromListing",
      Y(async (e, t, r) => {
        r && (r = await te(r));
        const a = await this.validateListing(O.from(e)),
          { valid: i, error: s } = await this.isStillValidListing(a, t);
        if (!i) throw new Error(`Listing ${e} is no longer valid. ${s}`);
        const o = r || (await this.contractWrapper.getSignerAddress()),
          c = O.from(t),
          l = O.from(a.pricePerToken).mul(c),
          u = (await this.contractWrapper.getCallOverrides()) || {};
        return (
          await ei(this.contractWrapper, l, a.currencyContractAddress, u),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "buyFromListing",
            args: [e, o, c, a.currencyContractAddress, l],
            overrides: u,
          })
        );
      }),
    );
    $(
      this,
      "approveBuyerForReservedListing",
      Y(async (e, t) => {
        if (await this.isBuyerApprovedForListing(e, t))
          throw new Error(`Buyer ${t} already approved for listing ${e}.`);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approveBuyerForListing",
          args: [e, t, !0],
        });
      }),
    );
    $(
      this,
      "revokeBuyerApprovalForReservedListing",
      Y(async (e, t) => {
        if (await this.isBuyerApprovedForListing(e, t))
          return ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "approveBuyerForListing",
            args: [e, t, !1],
          });
        throw new Error(`Buyer ${t} not approved for listing ${e}.`);
      }),
    );
    $(
      this,
      "approveCurrencyForListing",
      Y(async (e, t, r) => {
        const a = await this.validateListing(O.from(e)),
          i = await te(t);
        i === a.currencyContractAddress &&
          ce(
            r === a.pricePerToken,
            "Approving listing currency with a different price.",
          );
        const s =
          await this.contractWrapper.readContract.currencyPriceForListing(e, i);
        return (
          ce(r === s, "Currency already approved with this price."),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "approveCurrencyForListing",
            args: [e, i, r],
          })
        );
      }),
    );
    $(
      this,
      "revokeCurrencyApprovalForListing",
      Y(async (e, t) => {
        const r = await this.validateListing(O.from(e)),
          a = await te(t);
        if (a === r.currencyContractAddress)
          throw new Error("Can't revoke approval for main listing currency.");
        const i =
          await this.contractWrapper.readContract.currencyPriceForListing(e, a);
        return (
          ce(!i.isZero(), "Currency not approved."),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "approveCurrencyForListing",
            args: [e, a, O.from(0)],
          })
        );
      }),
    );
    (this.contractWrapper = e),
      (this.storage = t),
      (this.events = new Xc(this.contractWrapper)),
      (this.encoder = new cf(this.contractWrapper)),
      (this.interceptor = new yf(this.contractWrapper)),
      (this.estimator = new gf(this.contractWrapper));
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getTotalCount() {
    return await this.contractWrapper.readContract.totalListings();
  }
  async getAll(e) {
    const t = await this.getTotalCount(),
      r = O.from((e == null ? void 0 : e.start) || 0).toNumber(),
      a = t.toNumber();
    if (a === 0) throw new Error("No listings exist on the contract.");
    let i = [];
    i = (
      await zs(r, a, this.contractWrapper.readContract.getAllListings)
    ).flat();
    const o = await this.applyFilter(i, e);
    return await Promise.all(o.map((c) => this.mapListing(c)));
  }
  async getAllValid(e) {
    const t = await this.getTotalCount(),
      r = O.from((e == null ? void 0 : e.start) || 0).toNumber(),
      a = t.toNumber();
    if (a === 0) throw new Error("No listings exist on the contract.");
    let i = [];
    i = (
      await zs(r, a, this.contractWrapper.readContract.getAllValidListings)
    ).flat();
    const o = await this.applyFilter(i, e);
    return await Promise.all(o.map((c) => this.mapListing(c)));
  }
  async getListing(e) {
    const t = await this.contractWrapper.readContract.getListing(e);
    return await this.mapListing(t);
  }
  async isBuyerApprovedForListing(e, t) {
    if (!(await this.validateListing(O.from(e))).isReservedListing)
      throw new Error(`Listing ${e} is not a reserved listing.`);
    return await this.contractWrapper.readContract.isBuyerApprovedForListing(
      e,
      await te(t),
    );
  }
  async isCurrencyApprovedForListing(e, t) {
    return (
      await this.validateListing(O.from(e)),
      await this.contractWrapper.readContract.isCurrencyApprovedForListing(
        e,
        await te(t),
      )
    );
  }
  async currencyPriceForListing(e, t) {
    const r = await this.validateListing(O.from(e)),
      a = await te(t);
    if (a === r.currencyContractAddress) return r.pricePerToken;
    if (!(await this.isCurrencyApprovedForListing(e, a)))
      throw new Error(`Currency ${a} is not approved for Listing ${e}.`);
    return await this.contractWrapper.readContract.currencyPriceForListing(
      e,
      a,
    );
  }
  async validateListing(e) {
    try {
      return await this.getListing(e);
    } catch (t) {
      throw (console.error(`Error getting the listing with id ${e}`), t);
    }
  }
  async mapListing(e) {
    let t = zt.UNSET;
    const a = (await this.contractWrapper.getProvider().getBlock("latest"))
      .timestamp;
    switch (e.status) {
      case 1:
        t = O.from(e.startTimestamp).gt(a)
          ? zt.Created
          : O.from(e.endTimestamp).lt(a)
          ? zt.Expired
          : zt.Active;
        break;
      case 2:
        t = zt.Completed;
        break;
      case 3:
        t = zt.Cancelled;
        break;
    }
    return {
      assetContractAddress: e.assetContract,
      currencyContractAddress: e.currency,
      pricePerToken: e.pricePerToken.toString(),
      currencyValuePerToken: await Xn(
        this.contractWrapper.getProvider(),
        e.currency,
        e.pricePerToken,
      ),
      id: e.listingId.toString(),
      tokenId: e.tokenId.toString(),
      quantity: e.quantity.toString(),
      startTimeInSeconds: O.from(e.startTimestamp).toNumber(),
      asset: await mf(
        e.assetContract,
        this.contractWrapper.getProvider(),
        e.tokenId,
        this.storage,
      ),
      endTimeInSeconds: O.from(e.endTimestamp).toNumber(),
      creatorAddress: e.listingCreator,
      isReservedListing: e.reserved,
      status: t,
    };
  }
  async isStillValidListing(e, t) {
    if (
      !(await dO(
        this.contractWrapper.getProvider(),
        this.getAddress(),
        e.assetContractAddress,
        e.tokenId,
        e.creatorAddress,
      ))
    )
      return {
        valid: !1,
        error: `Token '${e.tokenId}' from contract '${e.assetContractAddress}' is not approved for transfer`,
      };
    const a = this.contractWrapper.getProvider(),
      i = new Pe(e.assetContractAddress, rf, a),
      s = await i.supportsInterface(ff),
      o = await i.supportsInterface(pf);
    if (s) {
      const c = new Pe(e.assetContractAddress, Pt, a);
      let l;
      try {
        l = await c.ownerOf(e.tokenId);
      } catch {}
      const u =
        (l == null ? void 0 : l.toLowerCase()) ===
        e.creatorAddress.toLowerCase();
      return {
        valid: u,
        error: u
          ? void 0
          : `Seller is not the owner of Token '${e.tokenId}' from contract '${e.assetContractAddress} anymore'`,
      };
    } else if (o) {
      const u = (
        await new Pe(e.assetContractAddress, yn, a).balanceOf(
          e.creatorAddress,
          e.tokenId,
        )
      ).gte(t || e.quantity);
      return {
        valid: u,
        error: u
          ? void 0
          : `Seller does not have enough balance of Token '${e.tokenId}' from contract '${e.assetContractAddress} to fulfill the listing`,
      };
    } else
      return {
        valid: !1,
        error: "Contract does not implement ERC 1155 or ERC 721.",
      };
  }
  async applyFilter(e, t) {
    let r = [...e];
    if (t) {
      if (t.seller) {
        const a = await te(t.seller);
        r = r.filter(
          (i) =>
            i.listingCreator.toString().toLowerCase() ===
            (a == null ? void 0 : a.toString().toLowerCase()),
        );
      }
      if (t.tokenContract) {
        const a = await te(t.tokenContract);
        r = r.filter(
          (i) =>
            i.assetContract.toString().toLowerCase() ===
            (a == null ? void 0 : a.toString().toLowerCase()),
        );
      }
      t.tokenId !== void 0 &&
        (r = r.filter((a) => {
          var i;
          return (
            a.tokenId.toString() ===
            ((i = t == null ? void 0 : t.tokenId) == null
              ? void 0
              : i.toString())
          );
        }));
    }
    return t != null && t.count && t.count < r.length ? r.slice(0, t.count) : r;
  }
}
const pO = (() =>
  M.object({
    assetContractAddress: at,
    tokenId: _t,
    quantity: _t.default(1),
    currencyContractAddress: at.default(an),
    minimumBidAmount: Cn,
    buyoutBidAmount: Cn,
    timeBufferInSeconds: _t.default(900),
    bidBufferBps: _t.default(500),
    startTimestamp: sf.default(new Date()),
    endTimestamp: Qc,
  }))();
class hO {
  constructor(e, t) {
    $(this, "featureName", id.name);
    $(
      this,
      "createAuction",
      Y(async (e) => {
        const t = pO.parse(e);
        await vd(
          this.contractWrapper,
          this.getAddress(),
          t.assetContractAddress,
          t.tokenId,
          await this.contractWrapper.getSignerAddress(),
        );
        const r = await qt(
            this.contractWrapper.getProvider(),
            t.buyoutBidAmount,
            t.currencyContractAddress,
          ),
          a = await qt(
            this.contractWrapper.getProvider(),
            t.minimumBidAmount,
            t.currencyContractAddress,
          ),
          s = (await this.contractWrapper.getProvider().getBlock("latest"))
            .timestamp;
        return (
          t.startTimestamp.lt(s) && (t.startTimestamp = O.from(s)),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "createAuction",
            args: [
              {
                assetContract: t.assetContractAddress,
                tokenId: t.tokenId,
                quantity: t.quantity,
                currency: ch(t.currencyContractAddress),
                minimumBidAmount: a,
                buyoutBidAmount: r,
                timeBufferInSeconds: t.timeBufferInSeconds,
                bidBufferBps: t.bidBufferBps,
                startTimestamp: t.startTimestamp,
                endTimestamp: t.endTimestamp,
              },
            ],
            parse: (o) => ({
              id: this.contractWrapper.parseLogs("NewAuction", o.logs)[0].args
                .auctionId,
              receipt: o,
            }),
          })
        );
      }),
    );
    $(
      this,
      "createAuctionsBatch",
      Y(async (e) => {
        const t = await Promise.all(
          e.map(async (r) => (await this.createAuction.prepare(r)).encode()),
        );
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [t],
          parse: (r) =>
            this.contractWrapper
              .parseLogs("NewAuction", r == null ? void 0 : r.logs)
              .map((i) => ({ id: i.args.auctionId, receipt: r })),
        });
      }),
    );
    $(
      this,
      "buyoutAuction",
      Y(async (e) => {
        const t = await this.validateAuction(O.from(e)),
          r = await Jc(
            this.contractWrapper.getProvider(),
            t.currencyContractAddress,
          );
        return this.makeBid.prepare(e, Ja(t.buyoutBidAmount, r.decimals));
      }),
    );
    $(
      this,
      "makeBid",
      Y(async (e, t) => {
        const r = await this.validateAuction(O.from(e)),
          a = await qt(
            this.contractWrapper.getProvider(),
            t,
            r.currencyContractAddress,
          );
        if (a.eq(O.from(0))) throw new Error("Cannot make a bid with 0 value");
        if (O.from(r.buyoutBidAmount).gt(0) && a.gt(r.buyoutBidAmount))
          throw new Error(
            "Bid amount must be less than or equal to buyoutBidAmount",
          );
        if (await this.getWinningBid(e)) {
          const o = await this.isWinningBid(e, a);
          ce(
            o,
            "Bid price is too low based on the current winning bid and the bid buffer",
          );
        } else {
          const o = a,
            c = O.from(r.minimumBidAmount);
          ce(o.gte(c), "Bid price is too low based on minimum bid amount");
        }
        const s = (await this.contractWrapper.getCallOverrides()) || {};
        return (
          await ei(this.contractWrapper, a, r.currencyContractAddress, s),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "bidInAuction",
            args: [e, a],
            overrides: s,
          })
        );
      }),
    );
    $(
      this,
      "cancelAuction",
      Y(async (e) => {
        if (await this.getWinningBid(e)) throw new Error("Bids already made.");
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "cancelAuction",
          args: [e],
        });
      }),
    );
    $(
      this,
      "closeAuctionForBidder",
      Y(async (e, t) => {
        t || (t = await this.contractWrapper.getSignerAddress());
        const r = await this.validateAuction(O.from(e));
        try {
          return ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "collectAuctionTokens",
            args: [O.from(e)],
          });
        } catch (a) {
          throw a.message.includes("Marketplace: auction still active.")
            ? new H0(e.toString(), r.endTimeInSeconds.toString())
            : a;
        }
      }),
    );
    $(
      this,
      "closeAuctionForSeller",
      Y(async (e) => {
        const t = await this.validateAuction(O.from(e));
        try {
          return ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "collectAuctionPayout",
            args: [O.from(e)],
          });
        } catch (r) {
          throw r.message.includes("Marketplace: auction still active.")
            ? new H0(e.toString(), t.endTimeInSeconds.toString())
            : r;
        }
      }),
    );
    $(
      this,
      "executeSale",
      Y(async (e) => {
        const t = await this.validateAuction(O.from(e));
        try {
          const r = await this.getWinningBid(e);
          ce(r, "No winning bid found");
          const a = this.encoder.encode("collectAuctionPayout", [e]),
            i = this.encoder.encode("collectAuctionTokens", [e]);
          return ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [[a, i]],
          });
        } catch (r) {
          throw r.message.includes("Marketplace: auction still active.")
            ? new H0(e.toString(), t.endTimeInSeconds.toString())
            : r;
        }
      }),
    );
    (this.contractWrapper = e),
      (this.storage = t),
      (this.events = new Xc(this.contractWrapper)),
      (this.encoder = new cf(this.contractWrapper)),
      (this.interceptor = new yf(this.contractWrapper)),
      (this.estimator = new gf(this.contractWrapper));
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getTotalCount() {
    return await this.contractWrapper.readContract.totalAuctions();
  }
  async getAll(e) {
    const t = await this.getTotalCount(),
      r = O.from((e == null ? void 0 : e.start) || 0).toNumber(),
      a = t.toNumber();
    if (a === 0) throw new Error("No auctions exist on the contract.");
    let i = [];
    i = (
      await zs(r, a, this.contractWrapper.readContract.getAllAuctions)
    ).flat();
    const o = await this.applyFilter(i, e);
    return await Promise.all(o.map((c) => this.mapAuction(c)));
  }
  async getAllValid(e) {
    const t = await this.getTotalCount(),
      r = O.from((e == null ? void 0 : e.start) || 0).toNumber(),
      a = t.toNumber();
    if (a === 0) throw new Error("No auctions exist on the contract.");
    let i = [];
    i = (
      await zs(r, a, this.contractWrapper.readContract.getAllValidAuctions)
    ).flat();
    const o = await this.applyFilter(i, e);
    return await Promise.all(o.map((c) => this.mapAuction(c)));
  }
  async getAuction(e) {
    const t = await this.contractWrapper.readContract.getAuction(e);
    return await this.mapAuction(t);
  }
  async getWinningBid(e) {
    await this.validateAuction(O.from(e));
    const t = await this.contractWrapper.readContract.getWinningBid(e);
    if (t._bidder !== Ie)
      return await this.mapBid(
        e.toString(),
        t._bidder,
        t._currency,
        t._bidAmount.toString(),
      );
  }
  async isWinningBid(e, t) {
    return await this.contractWrapper.readContract.isNewWinningBid(e, t);
  }
  async getWinner(e) {
    const t = await this.validateAuction(O.from(e)),
      r = await this.contractWrapper.readContract.getWinningBid(e),
      a = O.from(Math.floor(Date.now() / 1e3)),
      i = O.from(t.endTimeInSeconds);
    if (a.gt(i) && r._bidder !== Ie) return r._bidder;
    const o = (
      await this.contractWrapper.readContract.queryFilter(
        this.contractWrapper.readContract.filters.AuctionClosed(),
      )
    ).find((c) => c.args.auctionId.eq(O.from(e)));
    if (!o)
      throw new Error(`Could not find auction with ID ${e} in closed auctions`);
    return o.args.winningBidder;
  }
  async getBidBufferBps(e) {
    return (await this.getAuction(e)).bidBufferBps;
  }
  async getMinimumNextBid(e) {
    const [t, r, a] = await Promise.all([
        this.getBidBufferBps(e),
        this.getWinningBid(e),
        await this.validateAuction(O.from(e)),
      ]),
      i = r ? O.from(r.bidAmount) : O.from(a.minimumBidAmount),
      s = i.add(i.mul(t).div(1e4));
    return Xn(this.contractWrapper.getProvider(), a.currencyContractAddress, s);
  }
  async validateAuction(e) {
    try {
      return await this.getAuction(e);
    } catch (t) {
      throw (console.error(`Error getting the auction with id ${e}`), t);
    }
  }
  async mapAuction(e) {
    let t = zt.UNSET;
    const a = (await this.contractWrapper.getProvider().getBlock("latest"))
      .timestamp;
    switch (e.status) {
      case 1:
        t = O.from(e.startTimestamp).gt(a)
          ? zt.Created
          : O.from(e.endTimestamp).lt(a)
          ? zt.Expired
          : zt.Active;
        break;
      case 2:
        t = zt.Completed;
        break;
      case 3:
        t = zt.Cancelled;
        break;
    }
    return {
      id: e.auctionId.toString(),
      creatorAddress: e.auctionCreator,
      assetContractAddress: e.assetContract,
      tokenId: e.tokenId.toString(),
      quantity: e.quantity.toString(),
      currencyContractAddress: e.currency,
      minimumBidAmount: e.minimumBidAmount.toString(),
      minimumBidCurrencyValue: await Xn(
        this.contractWrapper.getProvider(),
        e.currency,
        e.minimumBidAmount,
      ),
      buyoutBidAmount: e.buyoutBidAmount.toString(),
      buyoutCurrencyValue: await Xn(
        this.contractWrapper.getProvider(),
        e.currency,
        e.buyoutBidAmount,
      ),
      timeBufferInSeconds: O.from(e.timeBufferInSeconds).toNumber(),
      bidBufferBps: O.from(e.bidBufferBps).toNumber(),
      startTimeInSeconds: O.from(e.startTimestamp).toNumber(),
      endTimeInSeconds: O.from(e.endTimestamp).toNumber(),
      asset: await mf(
        e.assetContract,
        this.contractWrapper.getProvider(),
        e.tokenId,
        this.storage,
      ),
      status: t,
    };
  }
  async mapBid(e, t, r, a) {
    const i = await te(t),
      s = await te(r);
    return {
      auctionId: e,
      bidderAddress: i,
      currencyContractAddress: s,
      bidAmount: a,
      bidAmountCurrencyValue: await Xn(
        this.contractWrapper.getProvider(),
        s,
        a,
      ),
    };
  }
  async applyFilter(e, t) {
    let r = [...e];
    if (t) {
      if (t.seller) {
        const a = await te(t.seller);
        r = r.filter(
          (i) =>
            i.auctionCreator.toString().toLowerCase() ===
            (a == null ? void 0 : a.toString().toLowerCase()),
        );
      }
      if (t.tokenContract) {
        const a = await te(t.tokenContract);
        r = r.filter(
          (i) =>
            i.assetContract.toString().toLowerCase() ===
            (a == null ? void 0 : a.toString().toLowerCase()),
        );
      }
      t.tokenId !== void 0 &&
        (r = r.filter((a) => {
          var i;
          return (
            a.tokenId.toString() ===
            ((i = t == null ? void 0 : t.tokenId) == null
              ? void 0
              : i.toString())
          );
        }));
    }
    return t != null && t.count && t.count < r.length ? r.slice(0, t.count) : r;
  }
}
const mO = (() =>
  M.object({
    assetContractAddress: at,
    tokenId: _t,
    quantity: _t.default(1),
    currencyContractAddress: at.default(an),
    totalPrice: Cn,
    endTimestamp: Qc,
  }))();
class yO {
  constructor(e, t) {
    $(this, "featureName", sd.name);
    $(
      this,
      "makeOffer",
      Y(async (e) => {
        const t = await mO.parseAsync(e),
          r = await this.contractWrapper.getChainID(),
          a = rr(t.currencyContractAddress)
            ? Ru[r].wrapped.address
            : t.currencyContractAddress,
          i = await qt(this.contractWrapper.getProvider(), t.totalPrice, a),
          s = await this.contractWrapper.getCallOverrides();
        return (
          await ei(this.contractWrapper, i, a, s),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "makeOffer",
            args: [
              {
                assetContract: t.assetContractAddress,
                tokenId: t.tokenId,
                quantity: t.quantity,
                currency: a,
                totalPrice: i,
                expirationTimestamp: t.endTimestamp,
              },
            ],
            parse: (o) => ({
              id: this.contractWrapper.parseLogs(
                "NewOffer",
                o == null ? void 0 : o.logs,
              )[0].args.offerId,
              receipt: o,
            }),
          })
        );
      }),
    );
    $(
      this,
      "cancelOffer",
      Y(async (e) =>
        ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "cancelOffer",
          args: [e],
        }),
      ),
    );
    $(
      this,
      "acceptOffer",
      Y(async (e) => {
        const t = await this.validateOffer(O.from(e)),
          { valid: r, error: a } = await this.isStillValidOffer(t);
        if (!r) throw new Error(`Offer ${e} is no longer valid. ${a}`);
        const i = (await this.contractWrapper.getCallOverrides()) || {};
        return (
          await vd(
            this.contractWrapper,
            this.getAddress(),
            t.assetContractAddress,
            t.tokenId,
            await this.contractWrapper.getSignerAddress(),
          ),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "acceptOffer",
            args: [e],
            overrides: i,
          })
        );
      }),
    );
    (this.contractWrapper = e),
      (this.storage = t),
      (this.events = new Xc(this.contractWrapper)),
      (this.encoder = new cf(this.contractWrapper)),
      (this.interceptor = new yf(this.contractWrapper)),
      (this.estimator = new gf(this.contractWrapper));
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getTotalCount() {
    return await this.contractWrapper.readContract.totalOffers();
  }
  async getAll(e) {
    const t = await this.getTotalCount(),
      r = O.from((e == null ? void 0 : e.start) || 0).toNumber(),
      a = t.toNumber();
    if (a === 0) throw new Error("No offers exist on the contract.");
    let i = [];
    i = (await zs(r, a, this.contractWrapper.readContract.getAllOffers)).flat();
    const o = await this.applyFilter(i, e);
    return await Promise.all(o.map((c) => this.mapOffer(c)));
  }
  async getAllValid(e) {
    const t = await this.getTotalCount(),
      r = O.from((e == null ? void 0 : e.start) || 0).toNumber(),
      a = t.toNumber();
    if (a === 0) throw new Error("No offers exist on the contract.");
    let i = [];
    i = (
      await zs(r, a, this.contractWrapper.readContract.getAllValidOffers)
    ).flat();
    const o = await this.applyFilter(i, e);
    return await Promise.all(o.map((c) => this.mapOffer(c)));
  }
  async getOffer(e) {
    const t = await this.contractWrapper.readContract.getOffer(e);
    return await this.mapOffer(t);
  }
  async validateOffer(e) {
    try {
      return await this.getOffer(e);
    } catch (t) {
      throw (console.error(`Error getting the offer with id ${e}`), t);
    }
  }
  async mapOffer(e) {
    let t = zt.UNSET;
    const a = (await this.contractWrapper.getProvider().getBlock("latest"))
      .timestamp;
    switch (e.status) {
      case 1:
        t = O.from(e.expirationTimestamp).lt(a) ? zt.Expired : zt.Active;
        break;
      case 2:
        t = zt.Completed;
        break;
      case 3:
        t = zt.Cancelled;
        break;
    }
    return {
      id: e.offerId.toString(),
      offerorAddress: e.offeror,
      assetContractAddress: e.assetContract,
      currencyContractAddress: e.currency,
      tokenId: e.tokenId.toString(),
      quantity: e.quantity.toString(),
      totalPrice: e.totalPrice.toString(),
      currencyValue: await Xn(
        this.contractWrapper.getProvider(),
        e.currency,
        e.totalPrice,
      ),
      asset: await mf(
        e.assetContract,
        this.contractWrapper.getProvider(),
        e.tokenId,
        this.storage,
      ),
      endTimeInSeconds: O.from(e.expirationTimestamp).toNumber(),
      status: t,
    };
  }
  async isStillValidOffer(e) {
    if (O.from(Math.floor(Date.now() / 1e3)).gt(e.endTimeInSeconds))
      return { valid: !1, error: `Offer with ID ${e.id} has expired` };
    const r = await this.contractWrapper.getChainID(),
      a = rr(e.currencyContractAddress)
        ? Ru[r].wrapped.address
        : e.currencyContractAddress,
      i = this.contractWrapper.getProvider(),
      s = new Dt(i, a, mn, {}, this.storage);
    return (await s.readContract.balanceOf(e.offerorAddress)).lt(e.totalPrice)
      ? {
          valid: !1,
          error: `Offeror ${e.offerorAddress} doesn't have enough balance of token ${a}`,
        }
      : (
          await s.readContract.allowance(e.offerorAddress, this.getAddress())
        ).lt(e.totalPrice)
      ? {
          valid: !1,
          error: `Offeror ${e.offerorAddress} hasn't approved enough amount of token ${a}`,
        }
      : { valid: !0, error: "" };
  }
  async applyFilter(e, t) {
    let r = [...e];
    if (t) {
      if (t.offeror) {
        const a = await te(t.offeror);
        r = r.filter(
          (i) =>
            i.offeror.toString().toLowerCase() ===
            (a == null ? void 0 : a.toString().toLowerCase()),
        );
      }
      if (t.tokenContract) {
        const a = await te(t.tokenContract);
        r = r.filter(
          (i) =>
            i.assetContract.toString().toLowerCase() ===
            (a == null ? void 0 : a.toString().toLowerCase()),
        );
      }
      t.tokenId !== void 0 &&
        (r = r.filter((a) => {
          var i;
          return (
            a.tokenId.toString() ===
            ((i = t == null ? void 0 : t.tokenId) == null
              ? void 0
              : i.toString())
          );
        }));
    }
    return t != null && t.count && t.count < r.length ? r.slice(0, t.count) : r;
  }
}
class gO {
  constructor(e) {
    $(this, "featureName", Zu.name);
    $(
      this,
      "set",
      Y(async (e) => {
        const t = await nr.parseAsync(e);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setPlatformFeeInfo",
          args: [t.platform_fee_recipient, t.platform_fee_basis_points],
        });
      }),
    );
    this.contractWrapper = e;
  }
  async get() {
    const [e, t] = await this.contractWrapper.readContract.getPlatformFeeInfo();
    return nr.parseAsync({
      platform_fee_recipient: e,
      platform_fee_basis_points: t,
    });
  }
}
function bO(n, e) {
  const r = mt.parse(n || []).filter((i) => i.type === "event"),
    a = [];
  for (const i of r) {
    const s = rv(i.name, e, "events");
    a.push({
      inputs: i.inputs || [],
      outputs: i.outputs || [],
      name: i.name || "unknown",
      comment: s,
    });
  }
  return a;
}
class xO {
  constructor(e, t) {
    (this.contractWrapper = e), (this.storage = t);
  }
  async get() {
    return this._cachedMetadata
      ? this._cachedMetadata
      : ((this._cachedMetadata = await wr(
          this.contractWrapper.readContract.address,
          this.contractWrapper.getProvider(),
          this.storage,
        )),
        this._cachedMetadata);
  }
  async extractFunctions() {
    let e;
    try {
      e = await this.get();
    } catch {}
    return bc(
      mt.parse(this.contractWrapper.abi),
      e == null ? void 0 : e.metadata,
    );
  }
  async extractEvents() {
    let e;
    try {
      e = await this.get();
    } catch {}
    return bO(
      mt.parse(this.contractWrapper.abi),
      e == null ? void 0 : e.metadata,
    );
  }
}
class vO {
  constructor(e) {
    $(this, "featureName", rd.name);
    $(
      this,
      "set",
      Y(async (e) => {
        const t = await te(e);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setOwner",
          args: [t],
        });
      }),
    );
    this.contractWrapper = e;
  }
  async get() {
    return this.contractWrapper.readContract.owner();
  }
}
class bb {
  constructor(e, t, r) {
    $(this, "featureName", nd.name);
    $(
      this,
      "set",
      Y(async (e) =>
        fe(this.contractWrapper, "AppURI")
          ? ne.fromContractWrapper({
              contractWrapper: this.contractWrapper,
              method: "setAppURI",
              args: [e],
            })
          : await this.metadata.update.prepare({ app_uri: e }),
      ),
    );
    (this.contractWrapper = e), (this.metadata = t), (this.storage = r);
  }
  async get() {
    return fe(this.contractWrapper, "AppURI")
      ? await this.contractWrapper.readContract.appURI()
      : x6(
          (await this.metadata.get()).app_uri || "",
          this.storage.getGatewayUrls(),
        );
  }
}
const Ov = En.merge(Bt).merge(ci).merge(It),
  wO = cr.merge(Bt).merge(ci).merge(It),
  TO = Ov.merge(nr).merge(li).merge(Wn),
  Nv = { deploy: TO, output: wO, input: Ov },
  Fv = En.merge(Bt).merge(ci).merge(It),
  CO = cr.merge(Bt).merge(ci).merge(It),
  AO = Fv.merge(nr).merge(li).merge(Wn),
  EO = { deploy: AO, output: CO, input: Fv },
  Lv = En,
  kO = cr,
  _O = Lv.merge(nr).merge(Wn),
  $v = { deploy: _O, output: kO, input: Lv },
  Wv = En.merge(Bt).merge(It),
  SO = cr.merge(Bt).merge(It),
  PO = Wv.merge(nr).merge(Wn),
  IO = { deploy: PO, output: SO, input: Wv },
  Uv = (() =>
    M.object({
      address: at,
      sharesBps: io.gt(0, "Shares must be greater than 0"),
    }))(),
  RO = Uv.extend({ address: at, sharesBps: io }),
  lh = (() =>
    En.extend({
      recipients: M.array(Uv)
        .default([])
        .superRefine((n, e) => {
          const t = {};
          let r = 0;
          for (let a = 0; a < n.length; a++) {
            const i = n[a];
            t[i.address] &&
              e.addIssue({
                code: M.ZodIssueCode.custom,
                message: "Duplicate address.",
                path: [a, "address"],
              }),
              (t[i.address] = !0),
              (r += i.sharesBps),
              r > 1e4 &&
                e.addIssue({
                  code: M.ZodIssueCode.custom,
                  message: "Total shares cannot go over 100%.",
                  path: [a, "sharesBps"],
                });
          }
          r !== 1e4 &&
            e.addIssue({
              code: M.ZodIssueCode.custom,
              message: `Total shares need to add up to 100%. Total shares are currently ${
                r / 100
              }%`,
              path: [],
            });
        }),
    }))(),
  MO = (() => cr.extend({ recipients: M.array(RO) }))(),
  BO = lh.merge(lh).merge(Wn),
  DO = { deploy: BO, output: MO, input: lh },
  jv = En.merge(It),
  OO = cr.merge(It),
  NO = jv.merge(nr).merge(li).merge(Wn),
  FO = { deploy: NO, output: OO, input: jv },
  zv = En.merge(Bt).merge(It),
  LO = cr.merge(Bt).merge(It),
  $O = zv.merge(nr).merge(li).merge(Wn),
  WO = { deploy: $O, output: LO, input: zv },
  Hv = En.merge(Bt).merge(It),
  UO = cr.merge(Bt).merge(It),
  jO = Hv.merge(nr).merge(li).merge(Wn),
  zO = { deploy: jO, output: UO, input: Hv },
  qv = (() =>
    M.object({
      voting_delay_in_blocks: M.number().min(0).default(0),
      voting_period_in_blocks: M.number().min(1).default(1),
      voting_token_address: at,
      voting_quorum_fraction: hk.default(0),
      proposal_token_threshold: _t.default(1),
    }))(),
  HO = qv.extend({ proposal_token_threshold: rn }),
  Vv = En.merge(qv),
  qO = cr.merge(HO),
  VO = Vv.merge(Wn),
  GO = { deploy: VO, output: qO, input: Vv },
  uh = M.object({
    startDate: dm,
    expirationDate: Qc,
    nativeTokenLimitPerTransaction: Cn.default(0),
    approvedCallTargets: M.array(at),
  }),
  KO = M.array(
    M.object({ signer: at, makeAdmin: M.boolean(), permissions: uh }),
  ),
  QO = [
    { name: "signer", type: "address" },
    { name: "approvedTargets", type: "address[]" },
    { name: "nativeTokenLimitPerTransaction", type: "uint256" },
    { name: "permissionStartTimestamp", type: "uint128" },
    { name: "permissionEndTimestamp", type: "uint128" },
    { name: "reqValidityStartTimestamp", type: "uint128" },
    { name: "reqValidityEndTimestamp", type: "uint128" },
    { name: "uid", type: "bytes32" },
  ];
async function YO(n, e) {
  const t = await Tc(n, e);
  return df(t.abi);
}
async function JO(n, e) {
  const t = await Tc(n, e);
  return bc(t.abi, t.metadata);
}
const Gv = En.merge(ci).merge(It),
  XO = cr.merge(ci).merge(It),
  ZO = Gv.merge(nr).merge(li).merge(Wn),
  eN = { deploy: ZO, output: XO, input: Gv },
  Kv = En.merge(Bt).merge(It),
  tN = cr.merge(Bt).merge(It),
  nN = Kv.merge(Wn),
  rN = { deploy: nN, output: tN, input: Kv };
async function aN(n, e) {
  const { extendedMetadata: t } = await Za(n, e);
  return (t == null ? void 0 : t.compositeAbi) || [];
}
function iN(n) {
  const e = n.map((a) => mt.parse(a)).flat(),
    r = GB(
      e,
      (a, i) =>
        a.name === i.name &&
        a.type === i.type &&
        a.inputs.length === i.inputs.length,
    ).filter((a) => a.type !== "constructor");
  return mt.parse(r);
}
async function xb(n, e, t) {
  return (
    await Promise.all(
      n.map((r) =>
        wr(r, e, t).catch(
          (a) => (
            console.error(`Failed to fetch plug-in for ${r}`, a), { abi: [] }
          ),
        ),
      ),
    )
  ).map((r) => r.abi);
}
async function wd(n, e, t, r, a) {
  let i = [];
  try {
    const s = js(mt.parse(e), "PluginRouter");
    if (js(mt.parse(e), "ExtensionRouter")) {
      const u = (await new Dt(t, n, nv, r, a).call("getAllExtensions")).map(
        (d) => d.metadata.implementation,
      );
      i = await xb(u, t, a);
    } else if (s) {
      const u = (await new Dt(t, n, bm, r, a).call("getAllPlugins")).map(
          (f) => f.pluginAddress,
        ),
        d = Array.from(new Set(u));
      i = await xb(d, t, a);
    }
  } catch {}
  return i.length > 0 ? iN([e, ...i]) : e;
}
const sN = ["admin"],
  po = ["admin", "minter", "transfer"],
  Qv = ["admin", "lister", "asset"],
  oN = ["admin", "minter", "asset", "transfer"],
  cN = ["admin", "transfer"],
  lN = ["admin", "transfer", "minter", "unwrap", "asset"],
  _e = {
    vote: "vote",
    token: "token",
    "edition-drop": "edition-drop",
    edition: "edition",
    marketplace: "marketplace",
    "marketplace-v3": "marketplace-v3",
    multiwrap: "multiwrap",
    "nft-collection": "nft-collection",
    "nft-drop": "nft-drop",
    pack: "pack",
    "signature-drop": "signature-drop",
    split: "split",
    "token-drop": "token-drop",
  },
  Fa = {
    name: "DropERC1155",
    contractType: _e["edition-drop"],
    schema: EO,
    roles: po,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          await Fa.getAbi(a, o, i),
          Re(
            () => import("./edition-drop-5134ceb0.browser.esm-47252096.js"),
            [
              "assets/edition-drop-5134ceb0.browser.esm-47252096.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/erc-1155-standard-ab2417d3.browser.esm-7d3533bf.js",
              "assets/thirdweb-checkout-fbd7e98d.browser.esm-ef219347.js",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.EditionDrop(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      if (r) return r;
      const a = await bf(n, e);
      return !a || a.version > 2
        ? (await Re(() => import("./DropERC1155-7c489c6e.js"), [])).default
        : (await Re(() => import("./DropERC1155_V2-2bc5bebe.js"), [])).default;
    },
  },
  Hs = {
    name: "TokenERC1155",
    contractType: _e.edition,
    schema: zO,
    roles: po,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          Hs.getAbi(a, o, i),
          Re(
            () => import("./edition-56659a1f.browser.esm-fd00bd89.js"),
            [
              "assets/edition-56659a1f.browser.esm-fd00bd89.js",
              "assets/erc-1155-standard-ab2417d3.browser.esm-7d3533bf.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.Edition(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      return (
        r || (await Re(() => import("./TokenERC1155-9d3ba872.js"), [])).default
      );
    },
  },
  La = {
    name: "Marketplace",
    contractType: _e.marketplace,
    schema: $v,
    roles: Qv,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          La.getAbi(a, o, i),
          Re(
            () => import("./marketplace-a354ab67.browser.esm-f7a020cf.js"),
            [
              "assets/marketplace-a354ab67.browser.esm-f7a020cf.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.Marketplace(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      return (
        r || (await Re(() => import("./Marketplace-7ee8271b.js"), [])).default
      );
    },
  },
  Si = {
    name: "MarketplaceV3",
    contractType: _e["marketplace-v3"],
    schema: $v,
    roles: Qv,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          Si.getAbi(a, o, i),
          Re(
            () => import("./marketplacev3-eaf870d6.browser.esm-b9a5e61e.js"),
            [
              "assets/marketplacev3-eaf870d6.browser.esm-b9a5e61e.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.MarketplaceV3(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = (await e.getNetwork()).chainId;
      if (r === 280 || r === 324) {
        const o = await Yc("MarketplaceV3");
        return await aN(o, t);
      }
      const i = await Un(n, e, t);
      if (i) return await wd(n, i, e, {}, t);
      const s = (await Re(() => import("./MarketplaceV3-6ed6edc2.js"), []))
        .default;
      return await wd(n, mt.parse(s || []), e, {}, t);
    },
  },
  $a = {
    name: "Multiwrap",
    contractType: _e.multiwrap,
    schema: rN,
    roles: lN,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          $a.getAbi(a, o, i),
          Re(
            () => import("./multiwrap-08315154.browser.esm-d62ed6f6.js"),
            [
              "assets/multiwrap-08315154.browser.esm-d62ed6f6.js",
              "assets/erc-721-standard-961fbe42.browser.esm-01ce6e8c.js",
              "assets/hasERC20Allowance-2a342c3f.browser.esm-7c39a30d.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.Multiwrap(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      return (
        r || (await Re(() => import("./Multiwrap-d21a366b.js"), [])).default
      );
    },
  },
  qs = {
    name: "TokenERC721",
    contractType: _e["nft-collection"],
    schema: WO,
    roles: po,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          qs.getAbi(a, o, i),
          Re(
            () => import("./nft-collection-158cb4d6.browser.esm-63be401a.js"),
            [
              "assets/nft-collection-158cb4d6.browser.esm-63be401a.js",
              "assets/erc-721-standard-961fbe42.browser.esm-01ce6e8c.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.NFTCollection(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      return (
        r || (await Re(() => import("./TokenERC721-803cc182.js"), [])).default
      );
    },
  },
  Wa = {
    name: "DropERC721",
    contractType: _e["nft-drop"],
    schema: Nv,
    roles: po,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          Wa.getAbi(a, o, i),
          Re(
            () => import("./nft-drop-8ee6eb49.browser.esm-66b4557b.js"),
            [
              "assets/nft-drop-8ee6eb49.browser.esm-66b4557b.js",
              "assets/erc-721-standard-961fbe42.browser.esm-01ce6e8c.js",
              "assets/thirdweb-checkout-fbd7e98d.browser.esm-ef219347.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.NFTDrop(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      if (r) return r;
      const a = await bf(n, e);
      return !a || a.version > 3
        ? (await Re(() => import("./DropERC721-cdf08af9.js"), [])).default
        : (await Re(() => import("./DropERC721_V3-9b8de632.js"), [])).default;
    },
  },
  Or = {
    name: "Pack",
    contractType: _e.pack,
    schema: IO,
    roles: oN,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          Or.getAbi(a, o, i),
          Re(
            () => import("./pack-3084df39.browser.esm-1362953c.js"),
            [
              "assets/pack-3084df39.browser.esm-1362953c.js",
              "assets/erc-1155-standard-ab2417d3.browser.esm-7d3533bf.js",
              "assets/index-35d0d874.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-e651aa00.css",
              "assets/hasERC20Allowance-2a342c3f.browser.esm-7c39a30d.js",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.Pack(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      return (
        r ||
        mt.parse(
          (await Re(() => import("./Pack-b5661456.js"), [])).default || [],
        )
      );
    },
  },
  Ua = {
    name: "SignatureDrop",
    contractType: _e["signature-drop"],
    schema: Nv,
    roles: po,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          Ua.getAbi(a, o, i),
          Re(
            () => import("./signature-drop-8b239d1a.browser.esm-5800e025.js"),
            [
              "assets/signature-drop-8b239d1a.browser.esm-5800e025.js",
              "assets/erc-721-standard-961fbe42.browser.esm-01ce6e8c.js",
              "assets/thirdweb-checkout-fbd7e98d.browser.esm-ef219347.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.SignatureDrop(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      if (r) return r;
      const a = await bf(n, e);
      return !a || a.version > 4
        ? (await Re(() => import("./SignatureDrop-6946e035.js"), [])).default
        : (await Re(() => import("./SignatureDrop_V4-909bda11.js"), []))
            .default;
    },
  },
  ja = {
    name: "Split",
    contractType: _e.split,
    schema: DO,
    roles: sN,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          ja.getAbi(a, o, i),
          Re(
            () => import("./split-a5c2337a.browser.esm-d9c5d966.js"),
            [
              "assets/split-a5c2337a.browser.esm-d9c5d966.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.Split(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      return r || (await Re(() => import("./Split-691026f6.js"), [])).default;
    },
  },
  Vs = {
    name: "DropERC20",
    contractType: _e["token-drop"],
    schema: eN,
    roles: cN,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          Vs.getAbi(a, o, i),
          Re(
            () => import("./token-drop-2deb6946.browser.esm-84b90df1.js"),
            [
              "assets/token-drop-2deb6946.browser.esm-84b90df1.js",
              "assets/erc-20-standard-4ea47ba3.browser.esm-a05127e0.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.TokenDrop(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      if (r) return r;
      const a = await bf(n, e);
      return !a || a.version > 2
        ? (await Re(() => import("./DropERC20-78777b33.js"), [])).default
        : (await Re(() => import("./DropERC20_V2-5c36962c.js"), [])).default;
    },
  },
  za = {
    name: "TokenERC20",
    contractType: _e.token,
    schema: FO,
    roles: po,
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          za.getAbi(a, o, i),
          Re(
            () => import("./token-e6359ba9.browser.esm-bb34a9d3.js"),
            [
              "assets/token-e6359ba9.browser.esm-bb34a9d3.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/erc-20-standard-4ea47ba3.browser.esm-a05127e0.js",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.Token(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      return (
        r || (await Re(() => import("./TokenERC20-501d9d62.js"), [])).default
      );
    },
  },
  Ha = {
    name: "VoteERC20",
    contractType: _e.vote,
    schema: GO,
    roles: [],
    initialize: async function () {
      for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
      let [r, a, i, s] = e;
      const [, o] = Vt(r, s),
        [c, l, u] = await Promise.all([
          Ha.getAbi(a, o, i),
          Re(
            () => import("./vote-84e0f92b.browser.esm-aefb6efc.js"),
            [
              "assets/vote-84e0f92b.browser.esm-aefb6efc.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          o.getNetwork(),
        ]);
      return new l.Vote(r, a, i, s, c, u.chainId);
    },
    getAbi: async (n, e, t) => {
      const r = await Un(n, e, t);
      return (
        r || (await Re(() => import("./VoteERC20-a8a1e974.js"), [])).default
      );
    },
  };
async function bf(n, e) {
  try {
    return await _m(n, e);
  } catch {
    return;
  }
}
const Ps = {
    [_e["edition-drop"]]: Fa,
    [_e.edition]: Hs,
    [_e.marketplace]: La,
    [_e["marketplace-v3"]]: Si,
    [_e.multiwrap]: $a,
    [_e["nft-collection"]]: qs,
    [_e["nft-drop"]]: Wa,
    [_e.pack]: Or,
    [_e["signature-drop"]]: Ua,
    [_e.split]: ja,
    [_e["token-drop"]]: Vs,
    [_e.token]: za,
    [_e.vote]: Ha,
  },
  uN = {
    [_e["edition-drop"]]:
      "ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk",
    [_e.edition]: "",
    [_e.marketplace]:
      "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html",
    [_e["marketplace-v3"]]:
      "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html",
    [_e.multiwrap]: "",
    [_e["nft-collection"]]: "",
    [_e["nft-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
    [_e.pack]: "",
    [_e["signature-drop"]]:
      "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
    [_e.split]: "",
    [_e["token-drop"]]:
      "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html",
    [_e.token]: "",
    [_e.vote]: "",
  },
  vb = { name: "SmartContract", contractType: "custom", schema: {}, roles: Ev },
  Yv = { ...Ps, [vb.contractType]: vb };
function dN(n) {
  var e;
  return (
    ((e = Object.values(Yv).find((t) => t.name === n)) == null
      ? void 0
      : e.contractType) || "custom"
  );
}
function Jv(n) {
  var e;
  return (e = Object.values(Yv).find((t) => t.contractType === n)) == null
    ? void 0
    : e.name;
}
class fN {
  constructor(e) {
    $(this, "featureName", gc.name);
    $(
      this,
      "grantAdminPermissions",
      Y(async (e) => {
        const t = await te(e);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setAdmin",
          args: [t, !0],
        });
      }),
    );
    $(
      this,
      "revokeAdminPermissions",
      Y(async (e) => {
        const t = await te(e);
        return ne.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setAdmin",
          args: [t, !1],
        });
      }),
    );
    $(
      this,
      "grantPermissions",
      Y(async (e, t) => {
        const r = await te(e),
          a = await uh.parseAsync(t);
        if (await this.isAdmin(r))
          throw new Error(
            "Signer is already an admin. Cannot grant permissions to an existing admin.",
          );
        if (await this.isSigner(r))
          throw new Error(
            "Signer already has permissions. Cannot grant permissions to an existing signer. You can update permissions using `updatePermissions`.",
          );
        return await this.sendSignerPermissionRequest(r, a);
      }),
    );
    $(
      this,
      "updatePermissions",
      Y(async (e, t) => {
        const r = await te(e),
          a = await uh.parseAsync(t);
        if (await this.isAdmin(r))
          throw new Error(
            "Signer is already an admin. Cannot update permissions of an existing admin.",
          );
        if (!(await this.isSigner(r)))
          throw new Error(
            "Signer does not already have permissions. You can grant permissions using `grantPermissions`.",
          );
        return await this.sendSignerPermissionRequest(r, a);
      }),
    );
    $(
      this,
      "revokeAccess",
      Y(async (e) => {
        const t = await te(e);
        if (await this.isAdmin(t))
          throw new Error(
            "Signer is already an admin. Cannot revoke permissions of an admin.",
          );
        if (!(await this.isSigner(t)))
          throw new Error(
            "Signer does not already have permissions. You can grant permissions using `grantPermissions`.",
          );
        return await this.sendSignerPermissionRequest(t, {
          startDate: O.from(0),
          expirationDate: O.from(0),
          approvedCallTargets: [],
          nativeTokenLimitPerTransaction: "0",
        });
      }),
    );
    $(
      this,
      "approveTargetForSigner",
      Y(async (e, t) => {
        const r = await te(e),
          a = await te(t);
        if (await this.isAdmin(r))
          throw new Error(
            "Signer is already an admin. Cannot approve targets for an admin.",
          );
        if (!(await this.isSigner(r)))
          throw new Error(
            "Signer does not already have permissions. You can grant permissions using `grantPermissions`.",
          );
        const i =
          await this.contractWrapper.readContract.getPermissionsForSigner(r);
        if (i.approvedTargets.includes(t))
          throw new Error("Target is already approved");
        const s = [...i.approvedTargets, a];
        return await this.sendSignerPermissionRequest(r, {
          startDate: O.from(i.startTimestamp),
          expirationDate: O.from(i.endTimestamp),
          approvedCallTargets: s,
          nativeTokenLimitPerTransaction:
            i.nativeTokenLimitPerTransaction.toString(),
        });
      }),
    );
    $(
      this,
      "disapproveTargetForSigner",
      Y(async (e, t) => {
        const r = await te(e),
          a = await te(t);
        if (await this.isAdmin(r))
          throw new Error(
            "Signer is already an admin. Cannot approve targets for an admin.",
          );
        if (!(await this.isSigner(r)))
          throw new Error(
            "Signer does not already have permissions. You can grant permissions using `grantPermissions`.",
          );
        const i =
          await this.contractWrapper.readContract.getPermissionsForSigner(r);
        if (!i.approvedTargets.includes(a))
          throw new Error("Target is currently not approved");
        const s = i.approvedTargets.filter((o) => ht(o) !== ht(a));
        return await this.sendSignerPermissionRequest(r, {
          startDate: O.from(i.startTimestamp),
          expirationDate: O.from(i.endTimestamp),
          approvedCallTargets: s,
          nativeTokenLimitPerTransaction:
            i.nativeTokenLimitPerTransaction.toString(),
        });
      }),
    );
    $(
      this,
      "resetAllPermissions",
      Y(async (e) => {
        const t = await KO.parseAsync(e);
        if (this.hasDuplicateSigners(t))
          throw new Error("Duplicate signers found in input.");
        const r = [],
          a = [],
          i = [],
          s = [],
          o = await this.getAllAdmins(),
          c = t.filter((f) => f.makeAdmin).map((f) => f.signer);
        o.forEach((f) => {
          c.includes(f) ||
            a.push(
              this.contractWrapper.writeContract.interface.encodeFunctionData(
                "setAdmin",
                [f, !1],
              ),
            );
        });
        const l = await this.getAllSigners(),
          u = t.filter((f) => !f.makeAdmin).map((f) => f.signer);
        await Promise.all(
          l.map(async (f) => {
            if (!u.includes(f.signer)) {
              const p = await this.buildSignerPermissionRequest(f.signer, {
                startDate: O.from(0),
                expirationDate: O.from(0),
                approvedCallTargets: [],
                nativeTokenLimitPerTransaction: "0",
              });
              s.push(p);
            }
          }),
        );
        for (const f of t)
          if (f.makeAdmin)
            r.push(
              this.contractWrapper.writeContract.interface.encodeFunctionData(
                "setAdmin",
                [f.signer, !0],
              ),
            );
          else {
            const p = await this.buildSignerPermissionRequest(
              f.signer,
              f.permissions,
            );
            i.push(p);
          }
        const d = [];
        return (
          a.forEach((f) => {
            d.push(f);
          }),
          s.forEach((f) => {
            d.push(f);
          }),
          i.forEach((f) => {
            d.push(f);
          }),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [d],
          })
        );
      }),
    );
    this.contractWrapper = e;
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  hasDuplicateSigners(e) {
    const t = {},
      r = e.map((a) => a.signer);
    for (const a of r)
      if (!t[a]) t[a] = !0;
      else return !0;
    return !1;
  }
  parseSignerPermissionsStruct(e) {
    return {
      startDate: new Date(parseInt(e.startTimestamp.toString()) * 1e3),
      expirationDate: new Date(parseInt(e.endTimestamp.toString()) * 1e3),
      nativeTokenLimitPerTransaction: O.from(e.nativeTokenLimitPerTransaction),
      approvedCallTargets: e.approvedTargets,
    };
  }
  async sendSignerPermissionRequest(e, t) {
    const { payload: r, signature: a } = await this.generatePayload(e, t),
      { success: i } =
        await this.contractWrapper.readContract.verifySignerPermissionRequest(
          r,
          a,
        );
    if (!i) throw new Error("Invalid signature.");
    return ne.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "setPermissionsForSigner",
      args: [r, a],
    });
  }
  async buildSignerPermissionRequest(e, t) {
    const { payload: r, signature: a } = await this.generatePayload(e, t);
    if (
      !(await this.contractWrapper.readContract.verifySignerPermissionRequest(
        r,
        a,
      ))
    )
      throw new Error("Invalid signature.");
    return this.contractWrapper.writeContract.interface.encodeFunctionData(
      "setPermissionsForSigner",
      [r, a],
    );
  }
  async generatePayload(e, t) {
    const r = {
        signer: e,
        approvedTargets: t.approvedCallTargets,
        nativeTokenLimitPerTransaction: zh(t.nativeTokenLimitPerTransaction),
        permissionStartTimestamp: t.startDate,
        permissionEndTimestamp: t.expirationDate,
        reqValidityStartTimestamp: 0,
        reqValidityEndTimestamp: O.from(
          Math.floor(new Date(Date.now() + 31536e7).getTime() / 1e3),
        ),
        uid: Q6(void 0),
      },
      a = await this.contractWrapper.getChainID(),
      i = this.contractWrapper.getSigner();
    ce(i, "No signer available");
    const s = await this.contractWrapper.signTypedData(
      i,
      {
        name: "Account",
        version: "1",
        chainId: a,
        verifyingContract: this.getAddress(),
      },
      { SignerPermissionRequest: QO },
      r,
    );
    return { payload: r, signature: s };
  }
  async isAdmin(e) {
    const t = await te(e);
    return await this.contractWrapper.readContract.isAdmin(t);
  }
  async isSigner(e) {
    const t = await te(e);
    return await this.contractWrapper.readContract.isActiveSigner(t);
  }
  async getAllAdmins() {
    return await this.contractWrapper.readContract.getAllAdmins();
  }
  async getAllSigners() {
    const e = await this.contractWrapper.readContract.getAllActiveSigners();
    return await Promise.all(
      e.map(async (t) => {
        const r = t.signer,
          a = this.parseSignerPermissionsStruct(t);
        return { signer: r, permissions: a };
      }),
    );
  }
}
class pN {
  constructor(e) {
    $(this, "featureName", yc.name);
    $(
      this,
      "createAccount",
      Y(async (e, t) => {
        if (await this.isAccountDeployed(e, t))
          throw new Error(`Account already deployed for admin: ${e}`);
        let r = Ne("");
        return (
          t && (r = t),
          ne.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "createAccount",
            args: [e, r],
            parse: (a) => ({
              address: this.contractWrapper.parseLogs(
                "AccountCreated",
                a == null ? void 0 : a.logs,
              )[0].args.account,
              receipt: a,
            }),
          })
        );
      }),
    );
    (this.contractWrapper = e), (this.events = new Xc(this.contractWrapper));
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async predictAccountAddress(e, t) {
    let r = Ne("");
    return t && (r = t), this.contractWrapper.readContract.getAddress(e, r);
  }
  async getAssociatedAccounts(e) {
    return this.contractWrapper.readContract.getAccountsOfSigner(e);
  }
  async getAllAccounts() {
    return await this.contractWrapper.readContract.getAllAccounts();
  }
  async isAccountDeployed(e, t) {
    const r = await this.predictAccountAddress(e, t);
    return ua(r, this.contractWrapper.getProvider());
  }
}
class hN {
  get royalties() {
    return xe(this.detectRoyalties(), Ju);
  }
  get roles() {
    return xe(this.detectRoles(), ed);
  }
  get sales() {
    return xe(this.detectPrimarySales(), Xu);
  }
  get platformFees() {
    return xe(this.detectPlatformFees(), Zu);
  }
  get owner() {
    return xe(this.detectOwnable(), rd);
  }
  get erc20() {
    return xe(this.detectErc20(), Ou);
  }
  get erc721() {
    return xe(this.detectErc721(), qu);
  }
  get erc1155() {
    return xe(this.detectErc1155(), Yu);
  }
  get app() {
    return xe(this.detectApp(), nd);
  }
  get directListings() {
    return xe(this.detectDirectListings(), ad);
  }
  get englishAuctions() {
    return xe(this.detectEnglishAuctions(), id);
  }
  get offers() {
    return xe(this.detectOffers(), sd);
  }
  get accountFactory() {
    return xe(this.detectAccountFactory(), yc);
  }
  get account() {
    return xe(this.detectAccount(), gc);
  }
  get chainId() {
    return this._chainId;
  }
  constructor(e, t, r, a) {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {},
      s = arguments.length > 5 ? arguments[5] : void 0,
      o =
        arguments.length > 6 && arguments[6] !== void 0
          ? arguments[6]
          : new Dt(e, t, r, i, a);
    (this._chainId = s),
      (this.storage = a),
      (this.contractWrapper = o),
      (this.abi = mt.parse(r || [])),
      (this.events = new Xc(this.contractWrapper)),
      (this.encoder = new cf(this.contractWrapper)),
      (this.interceptor = new yf(this.contractWrapper)),
      (this.estimator = new gf(this.contractWrapper)),
      (this.publishedMetadata = new xO(this.contractWrapper, this.storage)),
      (this.metadata = new _s(this.contractWrapper, Es, this.storage));
  }
  onNetworkUpdated(e) {
    this.contractWrapper.updateSignerOrProvider(e);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  prepare(e, t, r) {
    return ne.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: e,
      args: t,
      overrides: r,
    });
  }
  async call(e, t, r) {
    return this.contractWrapper.call(e, t, r);
  }
  detectRoyalties() {
    if (fe(this.contractWrapper, "Royalty")) {
      const e = new _s(this.contractWrapper, Es, this.storage);
      return new xD(this.contractWrapper, e);
    }
  }
  detectRoles() {
    if (fe(this.contractWrapper, "Permissions"))
      return new bD(this.contractWrapper, Ev);
  }
  detectPrimarySales() {
    if (fe(this.contractWrapper, "PrimarySale"))
      return new vD(this.contractWrapper);
  }
  detectPlatformFees() {
    if (fe(this.contractWrapper, "PlatformFee"))
      return new gO(this.contractWrapper);
  }
  detectErc20() {
    if (fe(this.contractWrapper, "ERC20"))
      return new FD(this.contractWrapper, this.storage, this.chainId);
  }
  detectErc721() {
    if (fe(this.contractWrapper, "ERC721"))
      return new eO(this.contractWrapper, this.storage, this.chainId);
  }
  detectErc1155() {
    if (fe(this.contractWrapper, "ERC1155"))
      return new uO(this.contractWrapper, this.storage, this.chainId);
  }
  detectOwnable() {
    if (fe(this.contractWrapper, "Ownable"))
      return new vO(this.contractWrapper);
  }
  detectApp() {
    const e = new _s(this.contractWrapper, Es, this.storage);
    if (fe(this.contractWrapper, "AppURI"))
      return new bb(this.contractWrapper, e, this.storage);
    if (fe(this.contractWrapper, "ContractMetadata"))
      return new bb(this.contractWrapper, e, this.storage);
  }
  detectDirectListings() {
    if (fe(this.contractWrapper, "DirectListings"))
      return new fO(this.contractWrapper, this.storage);
  }
  detectEnglishAuctions() {
    if (fe(this.contractWrapper, "EnglishAuctions"))
      return new hO(this.contractWrapper, this.storage);
  }
  detectOffers() {
    if (fe(this.contractWrapper, "Offers"))
      return new yO(this.contractWrapper, this.storage);
  }
  detectAccountFactory() {
    if (fe(this.contractWrapper, yc.name)) return new pN(this.contractWrapper);
  }
  detectAccount() {
    if (fe(this.contractWrapper, gc.name)) return new fN(this.contractWrapper);
  }
}
class mN extends fo {
  constructor(t, r, a) {
    super(t, r);
    $(
      this,
      "updatePublisherProfile",
      Y(async (t) => {
        const r = this.getSigner();
        ce(r, "A signer is required");
        const a = await r.getAddress(),
          i = await this.storage.upload(t);
        return ne.fromContractWrapper({
          contractWrapper: this.publisher,
          method: "setPublisherProfileUri",
          args: [a, i],
        });
      }),
    );
    $(
      this,
      "publish",
      Y(async (t, r) => {
        var m;
        const a = this.getSigner();
        ce(a, "A signer is required");
        const i = await a.getAddress(),
          s = await mv(t, this.storage);
        if (
          (m = r.factoryDeploymentData) != null &&
          m.implementationAddresses
        ) {
          const h = Object.entries(
              r.factoryDeploymentData.implementationAddresses,
            ).find((w) => {
              let [, T] = w;
              return T !== "";
            }),
            [g, v] = h || [];
          if (g && v)
            try {
              const w = await ud(s.metadataUri, this.storage),
                T = await wd(
                  v,
                  w.abi,
                  Ln(parseInt(g), {
                    clientId: this.options.clientId,
                    secretKey: this.options.secretKey,
                  }),
                  {},
                  this.storage,
                );
              r.compositeAbi = mt.parse(T);
            } catch {}
        }
        const o = await this.getLatest(i, s.name);
        if (o && o.metadataUri) {
          const h = (await this.fetchPublishedContractInfo(o)).publishedMetadata
            .version;
          if (!SM(h, r.version))
            throw Error(`Version ${r.version} is not greater than ${h}`);
        }
        const c = await (await this.storage.download(s.bytecodeUri)).text(),
          l = c.startsWith("0x") ? c : `0x${c}`,
          u = er(["bytes"], [l]),
          d = s.name,
          f = uB.parse({
            ...r,
            metadataUri: s.metadataUri,
            bytecodeUri: s.bytecodeUri,
            name: s.name,
            analytics: s.analytics,
            publisher: i,
          }),
          p = await this.storage.upload(f);
        return ne.fromContractWrapper({
          contractWrapper: this.publisher,
          method: "publishContract",
          args: [i, d, p, s.metadataUri, u, Ie],
          parse: (y) => {
            const h = this.publisher.parseLogs("ContractPublished", y.logs);
            if (h.length < 1)
              throw new Error("No ContractPublished event found");
            const g = h[0].args.publishedContract;
            return {
              receipt: y,
              data: async () => this.toPublishedContract(g),
            };
          },
        });
      }),
    );
    $(
      this,
      "unpublish",
      Y(async (t, r) => {
        const a = await te(t);
        return ne.fromContractWrapper({
          contractWrapper: this.publisher,
          method: "unpublishContract",
          args: [a, r],
        });
      }),
    );
    (this.storage = a), (this.publisher = new Dt(t, wm(), om, r, a));
  }
  updateSignerOrProvider(t) {
    super.updateSignerOrProvider(t), this.publisher.updateSignerOrProvider(t);
  }
  async extractConstructorParams(t) {
    return YO(t, this.storage);
  }
  async extractFunctions(t) {
    return JO(t, this.storage);
  }
  async fetchCompilerMetadataFromPredeployURI(t) {
    return Tc(t, this.storage);
  }
  async fetchPrePublishMetadata(t, r) {
    const a = await Tc(t, this.storage),
      i = r ? await this.getLatest(r, a.name) : void 0,
      s = i ? await this.fetchPublishedContractInfo(i) : void 0;
    return { preDeployMetadata: a, latestPublishedContractMetadata: s };
  }
  async fetchCompilerMetadataFromAddress(t) {
    const r = await te(t);
    return wr(r, this.getProvider(), this.storage);
  }
  async fetchPublishedContractInfo(t) {
    return {
      name: t.id,
      publishedTimestamp: t.timestamp,
      publishedMetadata: await this.fetchFullPublishMetadata(t.metadataUri),
    };
  }
  async fetchFullPublishMetadata(t) {
    return Tm(t, this.storage);
  }
  async resolvePublishMetadataFromCompilerMetadata(t) {
    const r =
      await this.publisher.readContract.getPublishedUriFromCompilerUri(t);
    if (r.length === 0)
      throw Error(`Could not resolve published metadata URI from ${t}`);
    return await Promise.all(
      r
        .filter((a) => a.length > 0)
        .map((a) => this.fetchFullPublishMetadata(a)),
    );
  }
  async resolveContractUriFromAddress(t) {
    const r = await te(t),
      a = await vc(r, this.getProvider());
    return ce(a, "Could not resolve contract URI from address"), a;
  }
  async fetchContractSourcesFromAddress(t) {
    const r = await te(t),
      a = await this.fetchCompilerMetadataFromAddress(r);
    return await uf(a, this.storage);
  }
  async getPublisherProfile(t) {
    const r = await te(t),
      a = await this.publisher.readContract.getPublisherProfileUri(r);
    return !a || a.length === 0
      ? {}
      : pB.parse(await this.storage.downloadJSON(a));
  }
  async getAll(t) {
    const r = await te(t),
      i = (
        await this.publisher.readContract.getAllPublishedContracts(r)
      ).reduce((s, o) => ((s[o.contractId] = o), s), {});
    return Object.entries(i).map((s) => {
      let [, o] = s;
      return this.toPublishedContract(o);
    });
  }
  async getAllVersions(t, r) {
    const a = await te(t),
      i = await this.publisher.readContract.getPublishedContractVersions(a, r);
    if (i.length === 0) throw Error("Not found");
    return i.map((s) => this.toPublishedContract(s));
  }
  async getVersion(t, r) {
    let a =
      arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
    const i = await te(t);
    if (a === "latest") return this.getLatest(i, r);
    const s = await this.getAllVersions(i, r),
      c = (
        await Promise.all(s.map((l) => this.fetchPublishedContractInfo(l)))
      ).find((l) => l.publishedMetadata.version === a);
    return (
      ce(c, "Contract version not found"),
      s.find((l) => l.timestamp === c.publishedTimestamp)
    );
  }
  async getLatest(t, r) {
    const a = await te(t),
      i = await this.publisher.readContract.getPublishedContract(a, r);
    if (i && i.publishMetadataUri) return this.toPublishedContract(i);
  }
  toPublishedContract(t) {
    return hB.parse({
      id: t.contractId,
      timestamp: t.publishTimestamp,
      metadataUri: t.publishMetadataUri,
    });
  }
}
const yN = [
    {
      inputs: [
        { internalType: "address", name: "_pluginMap", type: "address" },
        {
          internalType: "address[]",
          name: "_trustedForwarders",
          type: "address[]",
        },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "pluginAddress",
          type: "address",
        },
      ],
      name: "PluginAdded",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "pluginAddress",
          type: "address",
        },
      ],
      name: "PluginRemoved",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4",
        },
        {
          indexed: !0,
          internalType: "string",
          name: "functionSignature",
          type: "string",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "pluginAddress",
          type: "address",
        },
      ],
      name: "PluginSet",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "oldPluginAddress",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newPluginAddress",
          type: "address",
        },
      ],
      name: "PluginUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    { stateMutability: "payable", type: "fallback" },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "_selector", type: "bytes4" }],
      name: "_getPluginForFunction",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "bytes4",
              name: "functionSelector",
              type: "bytes4",
            },
            {
              internalType: "string",
              name: "functionSignature",
              type: "string",
            },
            { internalType: "address", name: "pluginAddress", type: "address" },
          ],
          internalType: "struct IPluginMap.Plugin",
          name: "_plugin",
          type: "tuple",
        },
      ],
      name: "addPlugin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_pluginAddress", type: "address" },
      ],
      name: "getAllFunctionsOfPlugin",
      outputs: [
        { internalType: "bytes4[]", name: "registered", type: "bytes4[]" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getAllPlugins",
      outputs: [
        {
          components: [
            {
              internalType: "bytes4",
              name: "functionSelector",
              type: "bytes4",
            },
            {
              internalType: "string",
              name: "functionSignature",
              type: "string",
            },
            { internalType: "address", name: "pluginAddress", type: "address" },
          ],
          internalType: "struct IPluginMap.Plugin[]",
          name: "registered",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "_selector", type: "bytes4" }],
      name: "getPluginForFunction",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "getRoleAdmin",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "uint256", name: "index", type: "uint256" },
      ],
      name: "getRoleMember",
      outputs: [{ internalType: "address", name: "member", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "getRoleMemberCount",
      outputs: [{ internalType: "uint256", name: "count", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "hasRole",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "hasRoleWithSwitch",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "forwarder", type: "address" }],
      name: "isTrustedForwarder",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "multicall",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "pluginMap",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "_selector", type: "bytes4" }],
      name: "removePlugin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "bytes4",
              name: "functionSelector",
              type: "bytes4",
            },
            {
              internalType: "string",
              name: "functionSignature",
              type: "string",
            },
            { internalType: "address", name: "pluginAddress", type: "address" },
          ],
          internalType: "struct IPluginMap.Plugin",
          name: "_plugin",
          type: "tuple",
        },
      ],
      name: "updatePlugin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    { stateMutability: "payable", type: "receive" },
  ],
  wb = {},
  gN = [
    {
      inputs: [
        { internalType: "address", name: "_trustedForwarder", type: "address" },
        { internalType: "address", name: "_registry", type: "address" },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "address",
          name: "implementation",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "contractType",
          type: "bytes32",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "version",
          type: "uint256",
        },
      ],
      name: "ImplementationAdded",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "address",
          name: "implementation",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "isApproved", type: "bool" },
      ],
      name: "ImplementationApproved",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "implementation",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "proxy",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "deployer",
          type: "address",
        },
      ],
      name: "ProxyDeployed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "FACTORY_ROLE",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_implementation", type: "address" },
      ],
      name: "addImplementation",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "approval",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_implementation", type: "address" },
        { internalType: "bool", name: "_toApprove", type: "bool" },
      ],
      name: "approveImplementation",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      name: "currentVersion",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "_type", type: "bytes32" },
        { internalType: "bytes", name: "_data", type: "bytes" },
      ],
      name: "deployProxy",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_implementation", type: "address" },
        { internalType: "bytes", name: "_data", type: "bytes" },
        { internalType: "bytes32", name: "_salt", type: "bytes32" },
      ],
      name: "deployProxyByImplementation",
      outputs: [
        { internalType: "address", name: "deployedProxy", type: "address" },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "_type", type: "bytes32" },
        { internalType: "bytes", name: "_data", type: "bytes" },
        { internalType: "bytes32", name: "_salt", type: "bytes32" },
      ],
      name: "deployProxyDeterministic",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "", type: "address" }],
      name: "deployer",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "_type", type: "bytes32" },
        { internalType: "uint256", name: "_version", type: "uint256" },
      ],
      name: "getImplementation",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "_type", type: "bytes32" }],
      name: "getLatestImplementation",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "getRoleAdmin",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "uint256", name: "index", type: "uint256" },
      ],
      name: "getRoleMember",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "getRoleMemberCount",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "hasRole",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "", type: "bytes32" },
        { internalType: "uint256", name: "", type: "uint256" },
      ],
      name: "implementation",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "forwarder", type: "address" }],
      name: "isTrustedForwarder",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "multicall",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "registry",
      outputs: [
        { internalType: "contract TWRegistry", name: "", type: "address" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  bN = [
    {
      inputs: [
        { internalType: "address", name: "_trustedForwarder", type: "address" },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "deployer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "deployment",
          type: "address",
        },
      ],
      name: "Added",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "deployer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "deployment",
          type: "address",
        },
      ],
      name: "Deleted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "role", type: "bytes32" },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "OPERATOR_ROLE",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_deployer", type: "address" },
        { internalType: "address", name: "_deployment", type: "address" },
      ],
      name: "add",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_deployer", type: "address" }],
      name: "count",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_deployer", type: "address" }],
      name: "getAll",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "getRoleAdmin",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "uint256", name: "index", type: "uint256" },
      ],
      name: "getRoleMember",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
      name: "getRoleMemberCount",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "hasRole",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "forwarder", type: "address" }],
      name: "isTrustedForwarder",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "multicall",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "_deployer", type: "address" },
        { internalType: "address", name: "_deployment", type: "address" },
      ],
      name: "remove",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "role", type: "bytes32" },
        { internalType: "address", name: "account", type: "address" },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
  ];
let Tb = !1;
function Xv(n, e, t) {
  Tb || ((Tb = !0), !(e || t) && console.warn(n));
}
function Cb(n, e) {
  const t = mt.parse(n || []);
  for (const r of t)
    if (r.type === "function" && r.name === e) return r.inputs || [];
  return [];
}
function Zv(n, e) {
  if (n)
    for (const t in n) {
      const r = n[t];
      r.enabled && e.push(r), Zv(r.features, e);
    }
}
function Ab(n) {
  const e = [];
  return Zv(xm(n), e), e.map((t) => t.name);
}
async function Sm(n, e) {
  var s;
  let t = [];
  const { compilerMetadata: r, extendedMetadata: a } = await Za(n, e);
  if (
    js(mt.parse(r.abi), "PluginRouter") &&
    a &&
    (s = a.factoryDeploymentData) != null &&
    s.implementationAddresses
  ) {
    const o = Object.entries(a.factoryDeploymentData.implementationAddresses);
    try {
      const c = o.find((d) => {
          let [, f] = d;
          return f !== "";
        }),
        [l, u] = c || [];
      if (l && u) {
        const d = Ln(parseInt(l), {}),
          m = (await new Dt(d, u, bm, {}, e).call("getAllPlugins")).map(
            (v) => v.pluginAddress,
          ),
          y = Array.from(new Set(m)),
          h = (await Promise.all(y.map(async (v) => wr(v, d, e)))).map(
            (v) => v.name,
          ),
          g = await Promise.all(h.map((v) => Yc(v)));
        t = (await Promise.all(g.map(async (v) => Za(v, e)))).map(
          (v) => v.compilerMetadata,
        );
      }
    } catch {}
  }
  return t;
}
function ew(n) {
  return (
    "(" +
    n.map((e) => (e.type === "tuple" ? ew(e.components) : e.type)).join(",") +
    ")"
  );
}
function xN(n, e) {
  const t = new ec(e),
    r = [];
  for (const a of Object.values(t.functions)) {
    const i = t.getFunction(a.name);
    i.name.includes("_") ||
      r.push({
        functionSelector: t.getSighash(i),
        functionSignature: i.name + ew(i.inputs),
        pluginAddress: n,
      });
  }
  return r;
}
async function Td(n, e, t, r) {
  kr.deploymentPresets = {};
  const a = r || (await Qi(t)),
    i = {},
    s = [],
    { compilerMetadata: o } = await Za(n, e),
    c = await Sm(n, e);
  if (c.length > 0) {
    const d = await Promise.all(
        c.map(async (m) => await xr("plugin", t, e, a, { metadata: m })),
      ),
      f = [];
    c.forEach((m, y) => {
      const h = xN(d[y].transaction.predictedAddress, m.abi);
      f.push(...h);
    });
    const p = await xr("plugin", t, e, a, {
      contractName: "PluginMap",
      constructorParams: { _pluginsToAdd: { value: f } },
    });
    (i._pluginMap = { value: p.transaction.predictedAddress }), s.push(...d, p);
  }
  const l = await xr("implementation", t, e, a, {
      metadata: o,
      constructorParams: i,
    }),
    u = await xr("infra", t, e, a, { contractName: "TWCloneFactory" });
  return (
    s.push(u), s.push(...Object.values(kr.deploymentPresets)), s.push(l), s
  );
}
async function vN(n, e, t, r, a, i) {
  var f;
  const s = Ln(e, { clientId: r, secretKey: a }),
    o = await Yc(n),
    c = await Za(o, t),
    l = await Qi(s);
  ce(l, "Thirdweb stack not found");
  const u = await Sm(o, t);
  let d;
  return (
    u.length > 0
      ? (d =
          (f = (await Td(o, t, s, l)).find(
            (m) => m.type === "implementation",
          )) == null
            ? void 0
            : f.encodedArgs)
      : (d = await gv(c.compilerMetadata, s, t, l, i)),
    d
  );
}
async function wN(n, e, t, r, a) {
  var u;
  const i = Ln(e, { clientId: r, secretKey: a }),
    s = await Yc(n),
    o = await Qi(i);
  if ((ce(o, "Thirdweb stack not found"), (await Sm(s, t)).length > 0)) {
    const f =
      (u = (await Td(s, t, i, o)).find((p) => p.type === "implementation")) ==
      null
        ? void 0
        : u.transaction.predictedAddress;
    return ce(f, "Error computing address for plugin router"), f;
  }
  return (await xr("implementation", i, t, o, { contractName: n })).transaction
    .predictedAddress;
}
async function TN(n, e, t, r, a) {
  const i = Ln(e, { clientId: r, secretKey: a }),
    s = await wN(n, e, t, r, a),
    o = await ua(s, i);
  return ce(o, "Contract not deployed yet"), s;
}
const CN = {
    FAILED: "Fail - Unable to verify",
    SUCCESS: "Pass - Verified",
    PENDING: "Pending in queue",
    ALREADY_VERIFIED: "Contract source code already verified",
    AUTOMATICALLY_VERIFIED: "Already Verified",
  },
  tw = { OK: "1", NOTOK: "0" };
async function AN(n, e, t, r, a, i, s, o) {
  const c = await TN(n, e, a, i, s),
    l = await vN(n, e, a, i, s, o);
  return (
    console.info(`Verifying ${n} at address ${c}`),
    await nw(c, e, t, r, a, l == null ? void 0 : l.toString().replace("0x", ""))
  );
}
async function nw(n, e, t, r, a, i) {
  try {
    const s = Ln(e, {}),
      o = await wr(n, s, a),
      c = o.metadata.compiler.version,
      l = await uf(o, a),
      u = o.metadata.sources,
      d = {};
    for (const A of Object.keys(u)) {
      const E = l.find((_) => A === _.filename);
      if (!E) throw new Error(`Could not find source file for ${A}`);
      d[A] = { content: E.source };
    }
    const f = {
        language: "Solidity",
        sources: d,
        settings: {
          optimizer: o.metadata.settings.optimizer,
          evmVersion: o.metadata.settings.evmVersion,
          remappings: o.metadata.settings.remappings,
          outputSelection: {
            "*": {
              "*": [
                "abi",
                "evm.bytecode",
                "evm.deployedBytecode",
                "evm.methodIdentifiers",
                "metadata",
              ],
              "": ["ast"],
            },
          },
        },
      },
      p = o.metadata.settings.compilationTarget,
      y = Object.keys(p)[0],
      h = i || (await EN(t, r, n, o.abi, s, a)),
      g = {
        apikey: r,
        module: "contract",
        action: "verifysourcecode",
        contractaddress: n,
        sourceCode: JSON.stringify(f),
        codeformat: "solidity-standard-json-input",
        contractname: `${y}:${o.name}`,
        compilerversion: `v${c}`,
        constructorArguements: h,
      },
      v = new URLSearchParams({ ...g }),
      T = await (
        await la(t, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: v.toString(),
        })
      ).json();
    if (T.status === tw.OK) return T.result;
    throw new Error(`${T.result}`);
  } catch (s) {
    throw new Error(s.toString());
  }
}
async function Eb(n, e, t) {
  const r = `${n}?module=contract&action=checkverifystatus&guid=${t}&apikey=${e}"`;
  return new Promise((a, i) => {
    const s = setInterval(async () => {
      try {
        const c = await (await la(r, { method: "GET" })).json();
        (c == null ? void 0 : c.result) !== CN.PENDING &&
          (clearInterval(s), a(c));
      } catch (o) {
        clearInterval(s), i(o);
      }
    }, 3e3);
  });
}
async function EN(n, e, t, r, a, i) {
  const s = df(r);
  if (s.length === 0) return "";
  const o = {
      apiKey: e,
      module: "account",
      action: "txlist",
      address: t,
      page: "1",
      sort: "asc",
      offset: "1",
    },
    c = new URLSearchParams({ ...o }),
    u = await (
      await la(n, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: c.toString(),
      })
    ).json();
  if (u && u.status === tw.OK && u.result[0] !== void 0) {
    const d = new ec(r),
      f = u.result[0].input;
    let p = "";
    if (d.deploy.inputs.length === 0) return "";
    try {
      const m = await kN(t, a, i);
      if (m) {
        const y = m.startsWith("0x") ? m : `0x${m}`;
        p = f.substring(y.length);
      }
    } catch {}
    if (!p) {
      const m = [...f.matchAll(/(64736f6c6343[\w]{6}[\w]{4})(?!.*\1)(.*)$/g)];
      m.length > 0 && (p = m[0][2]);
    }
    if (!p) {
      const m = s.length * 64;
      p = f.substring(f.length - m);
    }
    try {
      Ga.decode(d.deploy.inputs, `0x${p}`);
    } catch {
      throw new Error(
        "Verifying this contract requires it to be published. Run `npx thirdweb publish` to publish this contract, then try again.",
      );
    }
    return p;
  } else return "";
}
async function kN(n, e, t) {
  const r = await vc(n, e);
  if (r) {
    const i = await new Pe(
      wm(),
      om,
      Ln("polygon", {}),
    ).getPublishedUriFromCompilerUri(r);
    if (i.length === 0)
      throw Error(`Could not resolve published metadata URI from ${r}`);
    const s = await Promise.all(
      i.filter((o) => o.length > 0).map((o) => Tm(o, t)),
    );
    return s.length > 0
      ? await (await t.download(s[0].bytecodeUri)).text()
      : void 0;
  }
}
async function _N(n, e, t) {
  return (
    t || (t = await Qi(n)),
    (await xr("infra", n, e, t, { contractName: "TWCloneFactory" })).transaction
      .predictedAddress
  );
}
async function SN(n, e) {
  var c, l;
  if ((ce(n.provider, "No provider"), await ua(dd, n.provider))) return dd;
  const r = await hv(n.provider),
    a = (await n.provider.getNetwork()).chainId,
    i = r ? a : 0;
  console.debug(`ChainId ${a} enforces EIP155: ${r}`);
  const s = xs[a] ? fd(i, xs[a].gasPrice) : fd(i);
  if (!(await ua(s.deployment, n.provider))) {
    const u = xs[a] ? O.from(xs[a].gasPrice).mul(1e5) : Dv("0.01");
    (await n.provider.getBalance(s.signer)).lt(u) &&
      (await (await n.sendTransaction({ to: s.signer, value: u })).wait());
    try {
      console.debug(`deploying CREATE2 factory at: ${s.deployment}`),
        (c = e == null ? void 0 : e.notifier) == null ||
          c.call(e, "deploying", "create2Factory"),
        await (await n.provider.sendTransaction(s.transaction)).wait(),
        (l = e == null ? void 0 : e.notifier) == null ||
          l.call(e, "deployed", "create2Factory");
    } catch (d) {
      throw new Error(`Couldn't deploy CREATE2 factory: ${JSON.stringify(d)}`);
    }
  }
  return s.deployment;
}
function K0(n, e) {
  if (n.length !== e.length)
    throw Error(
      `Passed the wrong number of constructor arguments: ${e.length}, expected ${n.length}`,
    );
  return n.map((t, r) =>
    t === "tuple" || t.endsWith("[]")
      ? typeof e[r] == "string"
        ? JSON.parse(e[r])
        : e[r]
      : t === "bytes32"
      ? (ce(
          Ve(e[r]),
          `Could not parse bytes32 value. Expected valid hex string but got "${e[r]}".`,
        ),
        Ue(e[r], 32))
      : t.startsWith("bytes")
      ? (ce(
          Ve(e[r]),
          `Could not parse bytes value. Expected valid hex string but got "${e[r]}".`,
        ),
        e[r])
      : t.startsWith("uint") || t.startsWith("int")
      ? O.from(e[r].toString())
      : e[r],
  );
}
async function PN(n, e, t) {
  var i, s;
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 7e6;
  if (
    (ce(n.provider, "Provider required"),
    !(await ua(e.predictedAddress, n.provider)))
  ) {
    console.debug(
      `deploying contract via create2 factory at: ${e.predictedAddress}`,
    );
    const o = { to: e.to, data: e.data };
    try {
      await n.estimateGas(o);
    } catch (c) {
      console.debug("error estimating gas while deploying prebuilt: ", c),
        (o.gasLimit = O.from(r));
    }
    (i = t == null ? void 0 : t.notifier) == null ||
      i.call(t, "deploying", "preset"),
      await (await n.sendTransaction(o)).wait(),
      (s = t == null ? void 0 : t.notifier) == null ||
        s.call(t, "deployed", "preset");
  }
}
function IN(n) {
  let e =
    ae(n)
      .map((t) => (t === 0 ? 4 : 16))
      .reduce((t, r) => t + r) +
    (200 * n.length) / 2 +
    6 * Math.ceil(n.length / 64) +
    32e3 +
    21e3;
  return (e = Math.floor((e * 64) / 63)), e;
}
function rw(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : XB;
  if (((n = n.filter((i) => i.data.length > 0)), n.length === 0)) return [];
  const t = [];
  let r = 0,
    a = [];
  return (
    n.forEach((i) => {
      const s = IN(i.data);
      r + s > e
        ? a.length === 0
          ? t.push([i])
          : (t.push(a), (r = s), (a = [i]))
        : ((r += s), a.push(i));
    }),
    a.length > 0 && t.push(a),
    t
  );
}
async function RN(n, e, t) {
  var i, s;
  const r = rw(e);
  if (r.length === 0) return;
  (i = t == null ? void 0 : t.notifier) == null ||
    i.call(t, "deploying", "infra");
  const a = await Promise.all(
    r.map((o) => new Ix(eD, ZB).connect(n).deploy(o)),
  );
  await Promise.all(a.map((o) => o.deployed())),
    (s = t == null ? void 0 : t.notifier) == null ||
      s.call(t, "deployed", "infra");
}
const aw = [
  oe.Mainnet,
  oe.Goerli,
  oe.Polygon,
  oe.Mumbai,
  oe.Fantom,
  oe.FantomTestnet,
  oe.Avalanche,
  oe.AvalancheFujiTestnet,
  oe.Optimism,
  oe.OptimismGoerli,
  oe.Arbitrum,
  oe.ArbitrumGoerli,
  oe.BinanceSmartChainMainnet,
  oe.BinanceSmartChainTestnet,
  oe.Hardhat,
  oe.Localhost,
];
function Pm(n) {
  const e = aw.find((a) => a === n),
    t = e ? Fi[e].biconomyForwarder : Ye;
  return [e ? Fi[e].openzeppelinForwarder : Ye, t].filter((a) => a !== Ye);
}
async function iw(n, e, t, r, a) {
  const i = await r.getChainId(),
    s = await r.getAddress(),
    o = aw.find((l) => l === i);
  let c = [];
  switch (
    (o
      ? (c = n === Or.contractType ? [] : Pm(i))
      : (c = [await Cm(r.provider, a)]),
    e.trusted_forwarders &&
      e.trusted_forwarders.length > 0 &&
      c.push(...e.trusted_forwarders),
    n)
  ) {
    case Wa.contractType:
    case qs.contractType:
      const l = await Wa.schema.deploy.parseAsync(e);
      return [
        s,
        l.name,
        l.symbol,
        t,
        c,
        l.primary_sale_recipient,
        l.fee_recipient,
        l.seller_fee_basis_points,
        l.platform_fee_basis_points,
        l.platform_fee_recipient,
      ];
    case Ua.contractType:
      const u = await Ua.schema.deploy.parseAsync(e);
      return [
        s,
        u.name,
        u.symbol,
        t,
        c,
        u.primary_sale_recipient,
        u.fee_recipient,
        u.seller_fee_basis_points,
        u.platform_fee_basis_points,
        u.platform_fee_recipient,
      ];
    case $a.contractType:
      const d = await $a.schema.deploy.parseAsync(e);
      return [
        s,
        d.name,
        d.symbol,
        t,
        c,
        d.fee_recipient,
        d.seller_fee_basis_points,
      ];
    case Fa.contractType:
    case Hs.contractType:
      const f = await Fa.schema.deploy.parseAsync(e);
      return [
        s,
        f.name,
        f.symbol,
        t,
        c,
        f.primary_sale_recipient,
        f.fee_recipient,
        f.seller_fee_basis_points,
        f.platform_fee_basis_points,
        f.platform_fee_recipient,
      ];
    case Vs.contractType:
    case za.contractType:
      const p = await za.schema.deploy.parseAsync(e);
      return [
        s,
        p.name,
        p.symbol,
        t,
        c,
        p.primary_sale_recipient,
        p.platform_fee_recipient,
        p.platform_fee_basis_points,
      ];
    case Ha.contractType:
      const m = await Ha.schema.deploy.parseAsync(e);
      return [
        m.name,
        t,
        c,
        m.voting_token_address,
        m.voting_delay_in_blocks,
        m.voting_period_in_blocks,
        O.from(m.proposal_token_threshold),
        m.voting_quorum_fraction,
      ];
    case ja.contractType:
      const y = await ja.schema.deploy.parseAsync(e);
      return [
        s,
        t,
        c,
        y.recipients.map((v) => v.address),
        y.recipients.map((v) => O.from(v.sharesBps)),
      ];
    case La.contractType:
    case Si.contractType:
      const h = await La.schema.deploy.parseAsync(e);
      return [s, t, c, h.platform_fee_recipient, h.platform_fee_basis_points];
    case Or.contractType:
      const g = await Or.schema.deploy.parseAsync(e);
      return [
        s,
        g.name,
        g.symbol,
        t,
        c,
        g.fee_recipient,
        g.seller_fee_basis_points,
      ];
    default:
      return [];
  }
}
const MN = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
class xf {
  constructor(e, t, r) {
    $(this, "events", new Iu());
    (this.connection = new fo(e, t)),
      (this.options = t),
      (this.events = new Iu()),
      (this.storage = r);
  }
  connect(e) {
    this.connection.updateSignerOrProvider(e),
      this.events.emit("signerChanged", this.connection.getSigner());
  }
  async transfer(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : an;
    const a = await te(e),
      i = await te(r),
      s = this.requireWallet(),
      o = await qt(this.connection.getProvider(), t, r);
    if (rr(i)) {
      const c = await s.getAddress();
      return {
        receipt: await (
          await s.sendTransaction({ from: c, to: a, value: o })
        ).wait(),
      };
    } else
      return {
        receipt: await this.createErc20(i).sendTransaction("transfer", [a, o]),
      };
  }
  async balance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : an;
    this.requireWallet();
    const t = await te(e),
      r = this.connection.getProvider();
    let a;
    return (
      rr(t)
        ? (a = await r.getBalance(await this.getAddress()))
        : (a = await this.createErc20(t).readContract.balanceOf(
            await this.getAddress(),
          )),
      await Xn(r, t, a)
    );
  }
  async getAddress() {
    return await this.requireWallet().getAddress();
  }
  async getChainId() {
    return await this.requireWallet().getChainId();
  }
  async getNonce(e) {
    return await this.connection
      .getProvider()
      .getTransactionCount(await this.getAddress(), e);
  }
  isConnected() {
    try {
      return this.requireWallet(), !0;
    } catch {
      return !1;
    }
  }
  async sign(e) {
    return await this.requireWallet().signMessage(e);
  }
  async signTypedData(e, t, r) {
    return await Cc(this.requireWallet(), e, t, r);
  }
  recoverAddress(e, t) {
    const r = Od(e),
      a = ae(r);
    return Uc(a, t);
  }
  async sendRawTransaction(e) {
    return {
      receipt: await (await this.requireWallet().sendTransaction(e)).wait(),
    };
  }
  async requestFunds(e) {
    const t = await this.getChainId();
    if (t === oe.Localhost || t === oe.Hardhat)
      return new xf(
        new Ia(MN, Ln(t, this.options)),
        this.options,
        this.storage,
      ).transfer(await this.getAddress(), e);
    throw new Error(`Requesting funds is not supported on chain: '${t}'.`);
  }
  requireWallet() {
    const e = this.connection.getSigner();
    return (
      ce(
        e,
        "This action requires a connected wallet. Please pass a valid signer to the SDK.",
      ),
      e
    );
  }
  createErc20(e) {
    return new Dt(
      this.connection.getSignerOrProvider(),
      e,
      mn,
      this.options,
      this.storage,
    );
  }
}
function BN(n, e) {
  return (
    n ||
    (e != null && e.gatewayUrls
      ? new tg({
          gatewayUrls: e.gatewayUrls,
          clientId: e.clientId,
          secretKey: e.secretKey,
        })
      : new tg({
          clientId: e == null ? void 0 : e.clientId,
          secretKey: e == null ? void 0 : e.secretKey,
        }))
  );
}
class DN {
  constructor(e, t) {
    $(
      this,
      "addContract",
      Y(async (e) => await this.addContracts.prepare([e])),
    );
    $(
      this,
      "addContracts",
      Y(async (e) => {
        const t = await this.registryRouter.getSignerAddress(),
          r = [];
        return (
          e.forEach((a) => {
            r.push(
              this.registryLogic.readContract.interface.encodeFunctionData(
                "add",
                [t, a.address, a.chainId, a.metadataURI || ""],
              ),
            );
          }),
          ne.fromContractWrapper({
            contractWrapper: this.registryRouter,
            method: "multicall",
            args: [r],
          })
        );
      }),
    );
    $(
      this,
      "removeContract",
      Y(async (e) => await this.removeContracts.prepare([e])),
    );
    $(
      this,
      "removeContracts",
      Y(async (e) => {
        const t = await this.registryRouter.getSignerAddress(),
          r = await Promise.all(
            e.map(async (a) =>
              this.registryLogic.readContract.interface.encodeFunctionData(
                "remove",
                [t, await te(a.address), a.chainId],
              ),
            ),
          );
        return ne.fromContractWrapper({
          contractWrapper: this.registryRouter,
          method: "multicall",
          args: [r],
        });
      }),
    );
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    (this.storage = t),
      (this.registryLogic = new Dt(e, oh(), P6, r, t)),
      (this.registryRouter = new Dt(e, oh(), yN, r, t));
  }
  async updateSigner(e) {
    this.registryLogic.updateSignerOrProvider(e),
      this.registryRouter.updateSignerOrProvider(e);
  }
  async getContractMetadataURI(e, t) {
    return await this.registryLogic.readContract.getMetadataUri(e, await te(t));
  }
  async getContractMetadata(e, t) {
    const r = await this.getContractMetadataURI(e, t);
    if (!r)
      throw new Error(`No metadata URI found for contract ${t} on chain ${e}`);
    return await this.storage.downloadJSON(r);
  }
  async getContractAddresses(e) {
    return (await this.registryLogic.readContract.getAll(await te(e)))
      .filter(
        (t) =>
          Lc(t.deploymentAddress) && t.deploymentAddress.toLowerCase() !== Ie,
      )
      .map((t) => ({
        address: t.deploymentAddress,
        chainId: t.chainId.toNumber(),
      }));
  }
}
class ON extends fo {
  constructor(e, t, r) {
    super(e, t), (this.storage = r);
  }
  updateSignerOrProvider(e) {
    super.updateSignerOrProvider(e);
  }
  async verifyThirdwebContract(e, t, r, a) {
    const i = (await this.getProvider().getNetwork()).chainId,
      s = await AN(
        e,
        i,
        t,
        r,
        this.storage,
        this.options.clientId,
        this.options.secretKey,
        a,
      );
    console.info("Checking verification status...");
    const o = await Eb(t, r, s);
    console.info(o);
  }
  async verifyContract(e, t, r, a) {
    const i = (await this.getProvider().getNetwork()).chainId;
    let s;
    if (a) {
      const l = Object.values(a).map(
          (d) => (ce(d.type, "Param type is required"), d.type),
        ),
        u = Object.values(a).map((d) => d.value);
      s = Ga.encode(l, u);
    }
    const o = await nw(e, i, t, r, this.storage, s);
    console.info("Checking verification status...");
    const c = await Eb(t, r, o);
    console.info(c);
  }
}
const kb = {
  [oe.Mainnet]: {
    "nft-drop": "0x60fF9952e0084A6DEac44203838cDC91ABeC8736",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "signature-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
  },
  [oe.Polygon]: {
    "nft-drop": "0xB96508050Ba0925256184103560EBADA912Fcc69",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "signature-drop": "0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5",
  },
  [oe.Fantom]: {
    "nft-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "edition-drop": "0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B",
    "token-drop": "0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa",
    "signature-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
  },
  [oe.Avalanche]: {
    "nft-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "edition-drop": "0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766",
    "token-drop": "0xca0B071899E575BA86495D46c5066971b6f3A901",
    "signature-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3",
  },
  [oe.Optimism]: {
    "nft-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "edition-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "token-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "signature-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD",
  },
  [oe.Arbitrum]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7",
  },
  [oe.BinanceSmartChainMainnet]: {
    "nft-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "edition-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "token-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "signature-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
  },
  [oe.Goerli]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "token-drop": "0x5680933221B752EB443654a014f88B101F868d50",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
  },
  [oe.Mumbai]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7",
  },
  [oe.FantomTestnet]: {
    "nft-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD",
    "edition-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "token-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "signature-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
  },
  [oe.AvalancheFujiTestnet]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "token-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "signature-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
  },
  [oe.OptimismGoerli]: {
    "nft-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "edition-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "token-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
  },
  [oe.ArbitrumGoerli]: {
    "nft-drop": "0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6",
    "edition-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "token-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3",
    "signature-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
  },
  [oe.BinanceSmartChainTestnet]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": "",
  },
  [oe.Hardhat]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": "",
  },
  [oe.Localhost]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": "",
  },
};
function NN(n, e) {
  if (n in kb) {
    const t = kb[n];
    if (e in t) return t[e];
  }
  return null;
}
class _b extends Dt {
  constructor(t, r, a, i) {
    super(r, t, gN, i, a);
    $(this, "DEFAULT_VERSION_MAP", {
      [Wa.contractType]: 3,
      [qs.contractType]: 1,
      [Ua.contractType]: 4,
      [$a.contractType]: 1,
      [Fa.contractType]: 2,
      [Hs.contractType]: 1,
      [Vs.contractType]: 2,
      [za.contractType]: 1,
      [Ha.contractType]: 1,
      [ja.contractType]: 1,
      [La.contractType]: 2,
      [Si.contractType]: 1,
      [Or.contractType]: 2,
    });
    $(
      this,
      "deploy",
      Y(async (t, r, a, i, s, o) => {
        const c = Ps[t],
          l = await c.schema.deploy.parseAsync(r),
          u = await this.storage.upload(l),
          d = (await this.getImplementation(c, i)) || void 0;
        if (!d || d === Ie) throw new Error(`No implementation found for ${t}`);
        const f = await c.getAbi(d, this.getProvider(), this.storage),
          p = this.getSigner();
        ce(p, "A signer is required to deploy contracts");
        const m = await iw(t, l, u, p, this.storage),
          y = Pe.getInterface(f).encodeFunctionData("initialize", m),
          h = await this.getProvider().getBlockNumber(),
          g =
            s != null && s.saltForProxyDeploy
              ? wn(s.saltForProxyDeploy)
              : ol(h.toString());
        return ne.fromContractWrapper({
          contractWrapper: this,
          method: "deployProxyByImplementation",
          args: [d, y, g],
          parse: (v) => {
            o && o();
            const w = this.parseLogs("ProxyDeployed", v.logs);
            if (w.length < 1) throw new Error("No ProxyDeployed event found");
            const T = w[0].args.proxy;
            return (
              a.emit("contractDeployed", {
                status: "completed",
                contractAddress: T,
                transactionHash: v.transactionHash,
              }),
              T
            );
          },
        });
      }),
    );
    $(
      this,
      "deployProxyByImplementation",
      Y(async (t, r, a, i, s, o, c) => {
        const l = Pe.getInterface(r).encodeFunctionData(a, i),
          u = await this.getProvider().getBlockNumber(),
          d = o ? wn(o) : ol(u.toString());
        return ne.fromContractWrapper({
          contractWrapper: this,
          method: "deployProxyByImplementation",
          args: [t, l, d],
          parse: (f) => {
            c && c();
            const p = this.parseLogs("ProxyDeployed", f.logs);
            if (p.length < 1) throw new Error("No ProxyDeployed event found");
            const m = p[0].args.proxy;
            return (
              s.emit("contractDeployed", {
                status: "completed",
                contractAddress: m,
                transactionHash: f.transactionHash,
              }),
              m
            );
          },
        });
      }),
    );
    this.storage = a;
  }
  async getDeployArguments(t, r, a) {
    let i =
      t === Or.contractType ? [] : await this.getDefaultTrustedForwarders();
    switch (
      (r.trusted_forwarders &&
        r.trusted_forwarders.length > 0 &&
        (i = r.trusted_forwarders),
      t)
    ) {
      case Wa.contractType:
      case qs.contractType:
        const s = await Wa.schema.deploy.parseAsync(r);
        return [
          await this.getSignerAddress(),
          s.name,
          s.symbol,
          a,
          i,
          s.primary_sale_recipient,
          s.fee_recipient,
          s.seller_fee_basis_points,
          s.platform_fee_basis_points,
          s.platform_fee_recipient,
        ];
      case Ua.contractType:
        const o = await Ua.schema.deploy.parseAsync(r);
        return [
          await this.getSignerAddress(),
          o.name,
          o.symbol,
          a,
          i,
          o.primary_sale_recipient,
          o.fee_recipient,
          o.seller_fee_basis_points,
          o.platform_fee_basis_points,
          o.platform_fee_recipient,
        ];
      case $a.contractType:
        const c = await $a.schema.deploy.parseAsync(r);
        return [
          await this.getSignerAddress(),
          c.name,
          c.symbol,
          a,
          i,
          c.fee_recipient,
          c.seller_fee_basis_points,
        ];
      case Fa.contractType:
      case Hs.contractType:
        const l = await Fa.schema.deploy.parseAsync(r);
        return [
          await this.getSignerAddress(),
          l.name,
          l.symbol,
          a,
          i,
          l.primary_sale_recipient,
          l.fee_recipient,
          l.seller_fee_basis_points,
          l.platform_fee_basis_points,
          l.platform_fee_recipient,
        ];
      case Vs.contractType:
      case za.contractType:
        const u = await za.schema.deploy.parseAsync(r);
        return [
          await this.getSignerAddress(),
          u.name,
          u.symbol,
          a,
          i,
          u.primary_sale_recipient,
          u.platform_fee_recipient,
          u.platform_fee_basis_points,
        ];
      case Ha.contractType:
        const d = await Ha.schema.deploy.parseAsync(r);
        return [
          d.name,
          a,
          i,
          d.voting_token_address,
          d.voting_delay_in_blocks,
          d.voting_period_in_blocks,
          O.from(d.proposal_token_threshold),
          d.voting_quorum_fraction,
        ];
      case ja.contractType:
        const f = await ja.schema.deploy.parseAsync(r);
        return [
          await this.getSignerAddress(),
          a,
          i,
          f.recipients.map((h) => h.address),
          f.recipients.map((h) => O.from(h.sharesBps)),
        ];
      case La.contractType:
        const p = await La.schema.deploy.parseAsync(r);
        return [
          await this.getSignerAddress(),
          a,
          i,
          p.platform_fee_recipient,
          p.platform_fee_basis_points,
        ];
      case Si.contractType:
        const m = await Si.schema.deploy.parseAsync(r);
        return [
          await this.getSignerAddress(),
          a,
          i,
          m.platform_fee_recipient,
          m.platform_fee_basis_points,
        ];
      case Or.contractType:
        const y = await Or.schema.deploy.parseAsync(r);
        return [
          await this.getSignerAddress(),
          y.name,
          y.symbol,
          a,
          i,
          y.fee_recipient,
          y.seller_fee_basis_points,
        ];
      default:
        return [];
    }
  }
  async getDefaultTrustedForwarders() {
    const t = await this.getChainID();
    return Pm(t);
  }
  async getImplementation(t, r) {
    const a = ol(t.name),
      i = await this.getChainID(),
      s = NN(i, t.contractType);
    return s && s.length > 0 && r === void 0
      ? s
      : this.readContract.getImplementation(
          a,
          r !== void 0 ? r : this.DEFAULT_VERSION_MAP[t.contractType],
        );
  }
  async getLatestVersion(t) {
    const r = Jv(t);
    if (!r) throw new Error(`Invalid contract type ${t}`);
    const a = ol(r);
    return this.readContract.currentVersion(a);
  }
}
class FN extends Dt {
  constructor(t, r, a, i) {
    super(r, t, bN, i, a);
    $(
      this,
      "addContract",
      Y(async (t) => await this.addContracts.prepare([t])),
    );
    $(
      this,
      "addContracts",
      Y(async (t) => {
        const r = await this.getSignerAddress(),
          a = await Promise.all(
            t.map(async (i) =>
              this.readContract.interface.encodeFunctionData("add", [
                r,
                await te(i),
              ]),
            ),
          );
        return ne.fromContractWrapper({
          contractWrapper: this,
          method: "multicall",
          args: [a],
        });
      }),
    );
    $(
      this,
      "removeContract",
      Y(async (t) => await this.removeContracts.prepare([t])),
    );
    $(
      this,
      "removeContracts",
      Y(async (t) => {
        const r = await this.getSignerAddress(),
          a = await Promise.all(
            t.map(async (i) =>
              this.readContract.interface.encodeFunctionData("remove", [
                r,
                await te(i),
              ]),
            ),
          );
        return ne.fromContractWrapper({
          contractWrapper: this,
          method: "multicall",
          args: [a],
        });
      }),
    );
  }
  async getContractAddresses(t) {
    return (await this.readContract.getAll(await te(t))).filter(
      (r) => Lc(r) && r.toLowerCase() !== Ie,
    );
  }
}
const LN = En.merge(Bt).merge(It),
  $N = LN.merge(nr).merge(li).merge(Wn);
class Da extends fo {
  constructor(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      a = arguments.length > 2 ? arguments[2] : void 0;
    const i = "clientId";
    Xv(
      `No ${i} provided in ThirdwebSDK. You will have limited access to thirdweb's services for storage, RPC, and account abstraction. You can get a ${i} from https://thirdweb.com/create-api-key`,
      r.clientId,
      r.secretKey,
    ),
      um(t) &&
        (r = { ...r, supportedChains: [t, ...(r.supportedChains || [])] });
    super(t, r);
    $(this, "contractCache", new Map());
    LM(r == null ? void 0 : r.supportedChains);
    const s = BN(a, r);
    (this.storage = s),
      (this.storageHandler = s),
      (this.wallet = new xf(t, r, s)),
      (this.deployer = new WN(t, r, s)),
      (this.verifier = new ON(t, r, s)),
      (this.multiChainRegistry = new DN(t, this.storageHandler, this.options)),
      (this._publisher = new mN(t, this.options, this.storageHandler));
  }
  static async fromWallet(t, r) {
    let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      i = arguments.length > 3 ? arguments[3] : void 0;
    const s = await t.getSigner();
    return Da.fromSigner(s, r, a, i);
  }
  static fromSigner(t, r) {
    let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      i = arguments.length > 3 ? arguments[3] : void 0,
      s = t;
    if (r && !t.provider) {
      const c = Ln(r, a);
      s = t.connect(c);
    }
    const o = new Da(r || s, a, i);
    return o.updateSignerOrProvider(s), o;
  }
  static fromPrivateKey(t, r) {
    let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      i = arguments.length > 3 ? arguments[3] : void 0;
    const s = Ln(r, a),
      o = new Ia(t, s);
    return new Da(o, a, i);
  }
  get auth() {
    throw new Error(`The sdk.auth namespace has been moved to the @thirdweb-dev/auth package and is no longer available after @thirdweb-dev/sdk >= 3.7.0.
      Please visit https://portal.thirdweb.com/auth for instructions on how to switch to using the new auth package (@thirdweb-dev/auth@3.0.0).

      If you still want to use the old @thirdweb-dev/auth@2.0.0 package, you can downgrade the SDK to version 3.6.0.`);
  }
  async getNFTDrop(t) {
    return await this.getContract(t, "nft-drop");
  }
  async getSignatureDrop(t) {
    return await this.getContract(t, "signature-drop");
  }
  async getNFTCollection(t) {
    return await this.getContract(t, "nft-collection");
  }
  async getEditionDrop(t) {
    return await this.getContract(t, "edition-drop");
  }
  async getEdition(t) {
    return await this.getContract(t, "edition");
  }
  async getTokenDrop(t) {
    return await this.getContract(t, "token-drop");
  }
  async getToken(t) {
    return await this.getContract(t, "token");
  }
  async getVote(t) {
    return await this.getContract(t, "vote");
  }
  async getSplit(t) {
    return await this.getContract(t, "split");
  }
  async getMarketplace(t) {
    return await this.getContract(t, "marketplace");
  }
  async getMarketplaceV3(t) {
    return await this.getContract(t, "marketplace-v3");
  }
  async getPack(t) {
    return await this.getContract(t, "pack");
  }
  async getMultiwrap(t) {
    return await this.getContract(t, "multiwrap");
  }
  async getContract(t, r) {
    const a = await te(t);
    if (this.contractCache.has(a)) return this.contractCache.get(a);
    if (a in wb) return await this.getContractFromAbi(a, wb[a]);
    let i;
    if (!r || r === "custom")
      try {
        const s = await this.getPublisher().fetchCompilerMetadataFromAddress(a);
        i = await this.getContractFromAbi(a, s.abi);
      } catch {
        const o = await this.resolveContractType(t);
        if (o && o !== "custom") {
          const c = await Ps[o].getAbi(t, this.getProvider(), this.storage);
          i = await this.getContractFromAbi(t, c);
        } else {
          const c = (await this.getProvider().getNetwork()).chainId;
          throw new Error(
            `No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${c}/${a}`,
          );
        }
      }
    else
      typeof r == "string" && r in Ps
        ? (i = await Ps[r].initialize(
            this.getSignerOrProvider(),
            a,
            this.storage,
            this.options,
          ))
        : (i = await this.getContractFromAbi(a, r));
    return this.contractCache.set(a, i), i;
  }
  async getBuiltInContract(t, r) {
    return await this.getContract(t, r);
  }
  async resolveContractType(t) {
    try {
      const r = new Pe(await te(t), S6, this.getProvider()),
        a = zi(await r.contractType()).replace(/\x00/g, "");
      return dN(a);
    } catch {
      return "custom";
    }
  }
  async getContractList(t) {
    var i;
    const r =
        (await ((i = await this.deployer.getRegistry()) == null
          ? void 0
          : i.getContractAddresses(await te(t)))) || [],
      a = (await this.getProvider().getNetwork()).chainId;
    return await Promise.all(
      r.map(async (s) => ({
        address: s,
        chainId: a,
        contractType: () => this.resolveContractType(s),
        metadata: async () => (await this.getContract(s)).metadata.get(),
        extensions: async () => Ab((await this.getContract(s)).abi),
      })),
    );
  }
  async getMultichainContractList(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : oi;
    const a = await this.multiChainRegistry.getContractAddresses(t),
      i = r.reduce((o, c) => ((o[c.chainId] = c), o), {}),
      s = {};
    return a.map((o) => {
      let { address: c, chainId: l } = o;
      if (!i[l])
        return {
          address: c,
          chainId: l,
          contractType: async () => "custom",
          metadata: async () => ({ name: "" }),
          extensions: async () => [],
        };
      try {
        let u = s[l];
        return (
          u ||
            ((u = new Da(l, {
              ...this.options,
              readonlySettings: void 0,
              supportedChains: r,
            })),
            (s[l] = u)),
          {
            address: c,
            chainId: l,
            contractType: () => u.resolveContractType(c),
            metadata: async () => (await u.getContract(c)).metadata.get(),
            extensions: async () => Ab((await u.getContract(c)).abi),
          }
        );
      } catch {
        return {
          address: c,
          chainId: l,
          contractType: async () => "custom",
          metadata: async () => ({ name: "" }),
          extensions: async () => [],
        };
      }
    });
  }
  updateSignerOrProvider(t) {
    super.updateSignerOrProvider(t), this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    this.wallet.connect(this.getSignerOrProvider()),
      this.deployer.updateSignerOrProvider(this.getSignerOrProvider()),
      this._publisher.updateSignerOrProvider(this.getSignerOrProvider()),
      this.multiChainRegistry.updateSigner(this.getSignerOrProvider()),
      this.verifier.updateSignerOrProvider(this.getSignerOrProvider());
    for (const [, t] of this.contractCache)
      t.onNetworkUpdated(this.getSignerOrProvider());
  }
  async getContractFromAbi(t, r) {
    const a = await te(t);
    if (this.contractCache.has(a)) return this.contractCache.get(a);
    const [, i] = Vt(this.getSignerOrProvider(), this.options),
      s = typeof r == "string" ? JSON.parse(r) : r,
      o = new hN(
        this.getSignerOrProvider(),
        a,
        await wd(a, mt.parse(s), i, this.options, this.storage),
        this.storageHandler,
        this.options,
        (await i.getNetwork()).chainId,
      );
    return this.contractCache.set(a, o), o;
  }
  async getBalance(t) {
    return Xn(
      this.getProvider(),
      an,
      await this.getProvider().getBalance(await te(t)),
    );
  }
  getPublisher() {
    return this._publisher;
  }
}
const Sb = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
class WN extends fo {
  constructor(t, r, a) {
    super(t, r);
    $(this, "transactionListener", (t) => {
      t.status === "submitted" &&
        this.events.emit("contractDeployed", {
          status: "submitted",
          transactionHash: t.transactionHash,
        });
    });
    $(
      this,
      "deployNFTCollection",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            qs.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployNFTDrop",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            Wa.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployLoyaltyCard",
      yt(async (t, r) => {
        var u;
        const a = await $N.parseAsync(t),
          i = await this.storage.upload(a),
          s = (await this.getProvider().getNetwork()).chainId,
          o = Pm(s);
        t.trusted_forwarders &&
          t.trusted_forwarders.length > 0 &&
          o.push(...t.trusted_forwarders);
        const l = [
          await ((u = this.getSigner()) == null ? void 0 : u.getAddress()),
          a.name,
          a.symbol,
          i,
          o,
          a.primary_sale_recipient,
          a.fee_recipient,
          a.seller_fee_basis_points,
          a.platform_fee_basis_points,
          a.platform_fee_recipient,
        ];
        return await this.deployReleasedContract.prepare(
          Sb,
          "LoyaltyCard",
          l,
          r,
        );
      }),
    );
    $(
      this,
      "deploySignatureDrop",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            Ua.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployMultiwrap",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            $a.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployEdition",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            Hs.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployEditionDrop",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            Fa.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployToken",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            za.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployTokenDrop",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            Vs.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployMarketplace",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            La.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployMarketplaceV3",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            Si.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployPack",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            Or.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deploySplit",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            ja.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployVote",
      yt(
        async (t, r) =>
          await this.deployBuiltInContract.prepare(
            Ha.contractType,
            t,
            "latest",
            r,
          ),
      ),
    );
    $(
      this,
      "deployBuiltInContract",
      yt(
        (() => {
          var t = this;
          return async function (r, a) {
            let i =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : "latest",
              s = arguments.length > 3 ? arguments[3] : void 0;
            const o = t.getSigner();
            ce(o, "A signer is required to deploy contracts");
            const c = {
              app_uri: uN[r],
              ...(await Ps[r].schema.deploy.parseAsync(a)),
            };
            if (t.hasLocalFactory()) {
              let p;
              try {
                (p = parseInt(i)), isNaN(p) && (p = void 0);
              } catch {
                p = void 0;
              }
              const m = await t.getFactory();
              if (!m) throw new Error("Factory not found");
              return (
                m.on(Bn.Transaction, t.transactionListener),
                m.deploy.prepare(r, c, t.events, p, s, () => {
                  m.off(Bn.Transaction, t.transactionListener);
                })
              );
            }
            const l = Jv(r);
            ce(l, "Contract name not found");
            const u = await t.storage.upload(c),
              d = await iw(r, c, u, o, t.storage),
              f = await t.fetchPublishedContractFromPolygon(Sb, l, i);
            return t.deployContractFromUri.prepare(f.metadataUri, d, s);
          };
        })(),
      ),
    );
    $(
      this,
      "deployReleasedContract",
      yt(
        (() => {
          var t = this;
          return async function (r, a, i) {
            let s =
                arguments.length > 3 && arguments[3] !== void 0
                  ? arguments[3]
                  : "latest",
              o = arguments.length > 4 ? arguments[4] : void 0;
            const c = await t.fetchPublishedContractFromPolygon(r, a, s);
            return await t.deployContractFromUri.prepare(c.metadataUri, i, o);
          };
        })(),
      ),
    );
    $(
      this,
      "deployViaFactory",
      Y(async (t, r, a, i, s, o) => {
        const c = await te(t),
          l = await te(r),
          u = this.getSigner();
        ce(u, "signer is required");
        const d = new _b(
          c,
          this.getSignerOrProvider(),
          this.storage,
          this.options,
        );
        return (
          d.on(Bn.Transaction, this.transactionListener),
          await d.deployProxyByImplementation.prepare(
            l,
            a,
            i,
            s,
            this.events,
            o,
            () => {
              d.off(Bn.Transaction, this.transactionListener);
            },
          )
        );
      }),
    );
    $(
      this,
      "deployProxy",
      yt(async (t, r, a, i) => {
        const s = await te(t),
          o = Pe.getInterface(r).encodeFunctionData(a, i),
          { TWProxy__factory: c } = await Re(
            () =>
              import(
                "./thirdweb-dev-contracts-js-factories-TWProxy__factory.browser.esm-b4afd54e.js"
              ),
            [
              "assets/thirdweb-dev-contracts-js-factories-TWProxy__factory.browser.esm-b4afd54e.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          );
        return this.deployContractWithAbi.prepare(c.abi, c.bytecode, [s, o]);
      }),
    );
    $(
      this,
      "deployViaAutoFactory",
      yt(async (t, r, a, i, s, o) => {
        var g, v, w;
        const c = await SN(a, o),
          l = await Td(t, this.storage, this.getProvider(), c),
          u =
            (g = l.find((T) => T.type === "implementation")) == null
              ? void 0
              : g.transaction.predictedAddress,
          d = l.filter(
            (T) => T.transaction.data && T.transaction.data.length > 0,
          ),
          f = d.filter((T) => T.type !== "infra").map((T) => T.transaction),
          p = d.filter((T) => T.type === "infra").map((T) => T.transaction);
        await RN(a, p, o), await Promise.all(f.map((T) => PN(a, T, o)));
        const m = await te(u),
          y = await _N(this.getProvider(), this.storage, c);
        (v = o == null ? void 0 : o.notifier) == null ||
          v.call(o, "deploying", "proxy");
        const h = await this.deployViaFactory.prepare(
          y,
          m,
          r.compilerMetadata.abi,
          i,
          s,
          o == null ? void 0 : o.saltForProxyDeploy,
        );
        return (
          (w = o == null ? void 0 : o.notifier) == null ||
            w.call(o, "deployed", "proxy"),
          h
        );
      }),
    );
    $(
      this,
      "deployViaCustomFactory",
      yt(async (t, r, a, i) => {
        var p, m, y, h, g, v;
        const s =
            (y =
              (m =
                (p = r.extendedMetadata) == null
                  ? void 0
                  : p.factoryDeploymentData) == null
                ? void 0
                : m.customFactoryInput) == null
              ? void 0
              : y.customFactoryAddresses[i],
          o = await te(s);
        ce(o, `customFactoryAddress not found for chainId '${i}'`),
          ce(
            (v =
              (g =
                (h = r.extendedMetadata) == null
                  ? void 0
                  : h.factoryDeploymentData) == null
                ? void 0
                : g.customFactoryInput) == null
              ? void 0
              : v.factoryFunction,
            "customFactoryFunction not set'",
          );
        const c = await wr(o, this.getProvider(), this.storage),
          l = Cb(
            c.abi,
            r.extendedMetadata.factoryDeploymentData.customFactoryInput
              .factoryFunction,
          ).map((w) => w.type),
          u = K0(l, t);
        let d;
        const f = await ne.fromContractInfo({
          contractAddress: o,
          contractAbi: c.abi,
          provider: this.getProvider(),
          signer: a,
          method:
            r.extendedMetadata.factoryDeploymentData.customFactoryInput
              .factoryFunction,
          args: u,
          parse: () => d,
          storage: this.storage,
        });
        return (d = await f.simulate()), f;
      }),
    );
    $(
      this,
      "deployContractFromUri",
      yt(async (t, r, a) => {
        var m, y;
        const i = this.getSigner();
        ce(i, "A signer is required");
        const { compilerMetadata: s, extendedMetadata: o } = await Za(
            t,
            this.storage,
          ),
          c = (a == null ? void 0 : a.forceDirectDeploy) || !1,
          l = (await this.getProvider().getNetwork()).chainId,
          u =
            ((m = o == null ? void 0 : o.networksForDeployment) == null
              ? void 0
              : m.networksEnabled.includes(l)) ||
            ((y = o == null ? void 0 : o.networksForDeployment) == null
              ? void 0
              : y.allNetworks);
        if (o != null && o.networksForDeployment && !u)
          throw new Error(
            `Deployments disabled on this network, with chainId: ${l}`,
          );
        if (
          o &&
          o.factoryDeploymentData &&
          (o.isDeployableViaProxy ||
            o.isDeployableViaFactory ||
            (o.deployType && o.deployType !== "standard")) &&
          !c
        ) {
          if (o.deployType === "customFactory")
            return await this.deployViaCustomFactory.prepare(
              r,
              { compilerMetadata: s, extendedMetadata: o },
              i,
              l,
            );
          {
            ce(
              o.factoryDeploymentData.implementationInitializerFunction,
              "implementationInitializerFunction not set'",
            );
            const h = Cb(
                s.abi,
                o.factoryDeploymentData.implementationInitializerFunction,
              ).map((T) => T.type),
              g = K0(h, r),
              v = o.factoryDeploymentData.implementationAddresses[l];
            if (!v || o.deployType === "autoFactory")
              return await this.deployViaAutoFactory.prepare(
                t,
                { compilerMetadata: s, extendedMetadata: o },
                i,
                o.factoryDeploymentData.implementationInitializerFunction,
                g,
                a,
              );
            const w = await te(v);
            if (
              (ce(w, `implementationAddress not found for chainId '${l}'`),
              o.isDeployableViaFactory)
            ) {
              ce(
                o.factoryDeploymentData.factoryAddresses,
                "isDeployableViaFactory is true so factoryAddresses is required",
              );
              const T = o.factoryDeploymentData.factoryAddresses[l];
              ce(
                T,
                `isDeployableViaFactory is true and factoryAddress not found for chainId '${l}'`,
              );
              const A = await te(T);
              return await this.deployViaFactory.prepare(
                A,
                w,
                s.abi,
                o.factoryDeploymentData.implementationInitializerFunction,
                g,
                a == null ? void 0 : a.saltForProxyDeploy,
              );
            } else if (o.isDeployableViaProxy)
              return await this.deployProxy.prepare(
                w,
                s.abi,
                o.factoryDeploymentData.implementationInitializerFunction,
                g,
              );
          }
        }
        const d = s.bytecode.startsWith("0x") ? s.bytecode : `0x${s.bytecode}`;
        if (!Ve(d))
          throw new Error(`Contract bytecode is invalid.

${d}`);
        const f = df(s.abi).map((h) => h.type),
          p = K0(f, r);
        return this.deployContractWithAbi.prepare(s.abi, d, p);
      }),
    );
    $(
      this,
      "deployContractWithAbi",
      yt(async (t, r, a) => {
        const i = this.getSigner(),
          s = this.getProvider();
        ce(i, "Signer is required to deploy contracts");
        const o = new Ix(t, r).connect(i);
        return new fD({
          args: a,
          provider: s,
          signer: i,
          factory: o,
          storage: this.storage,
          events: this.events,
        });
      }),
    );
    (this.storage = a),
      (this.events = new Iu()),
      this.getFactory(),
      this.getRegistry();
  }
  async getLatestBuiltInContractVersion(t) {
    const r = await this.getFactory();
    if (!r) throw new Error("Factory not found");
    return await r.getLatestVersion(t);
  }
  async getRegistry() {
    return this._registry
      ? this._registry
      : (this._registry = this.getProvider()
          .getNetwork()
          .then(async (t) => {
            let { chainId: r } = t;
            const a = hd(r, "twRegistry");
            if (a)
              return new FN(
                a,
                this.getSignerOrProvider(),
                this.storage,
                this.options,
              );
          }));
  }
  async getFactory() {
    return this._factory
      ? this._factory
      : (this._factory = this.getProvider()
          .getNetwork()
          .then(async (t) => {
            let { chainId: r } = t;
            const a = hd(r, "twFactory");
            return a
              ? new _b(
                  a,
                  this.getSignerOrProvider(),
                  this.storage,
                  this.options,
                )
              : void 0;
          }));
  }
  updateSignerOrProvider(t) {
    super.updateSignerOrProvider(t), this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    var t, r;
    (t = this._factory) == null ||
      t
        .then((a) => {
          a == null || a.updateSignerOrProvider(this.getSignerOrProvider());
        })
        .catch(() => {}),
      (r = this._registry) == null ||
        r
          .then((a) => {
            a == null || a.updateSignerOrProvider(this.getSignerOrProvider());
          })
          .catch(() => {});
  }
  async getTransactionsForDeploy(t, r) {
    let a = [];
    const i = this.getProvider();
    ce(i, "A provider is required");
    const { extendedMetadata: s } = await Za(t, this.storage),
      o = (r == null ? void 0 : r.forceDirectDeploy) || !1;
    if (
      s &&
      s.factoryDeploymentData &&
      (s.isDeployableViaProxy ||
        s.isDeployableViaFactory ||
        s.deployType === "autoFactory") &&
      !o
    ) {
      const c = (await this.getProvider().getNetwork()).chainId;
      if (
        !s.factoryDeploymentData.implementationAddresses[c] ||
        s.deployType === "autoFactory"
      ) {
        const u = await Qi(this.getProvider());
        a.push({ contractType: "create2Factory", addresses: [u] });
        const f = (await Td(t, this.storage, this.getProvider(), u)).filter(
          (h) => h.transaction.data && h.transaction.data.length > 0,
        );
        f.filter((h) => h.type !== "infra")
          .map((h) => h.transaction)
          .forEach((h) => {
            a.push({ contractType: "preset", addresses: [h.predictedAddress] });
          });
        const m = f.filter((h) => h.type === "infra").map((h) => h.transaction);
        rw(m).forEach((h) => {
          const g = h.map((v) => v.predictedAddress);
          a.push({ contractType: "infra", addresses: g });
        });
      }
      (a = (
        await Promise.all(
          a.map(async (u) =>
            (
              await Promise.all(
                u.addresses.map(async (f) => ((await ua(f, i)) ? null : f)),
              )
            ).filter(Boolean).length > 0
              ? u
              : null,
          ),
        )
      ).filter(Boolean)),
        a.push({ contractType: "proxy", addresses: [] });
    } else a.push({ contractType: "custom", addresses: [] });
    return a;
  }
  addDeployListener(t) {
    this.events.on("contractDeployed", t);
  }
  removeDeployListener(t) {
    this.events.off("contractDeployed", t);
  }
  removeAllDeployListeners() {
    this.events.removeAllListeners("contractDeployed");
  }
  async fetchPublishedContractFromPolygon(t, r, a) {
    const i = await te(t),
      s = await new Da("polygon").getPublisher().getVersion(i, r, a);
    if (!s)
      throw new Error(
        `No published contract found for '${r}' at version '${a}' by '${i}'`,
      );
    return s;
  }
  hasLocalFactory() {
    return !!wc("factoryAddress");
  }
}
function sw(n, e) {
  if (e.has(n))
    throw new TypeError(
      "Cannot initialize the same private elements twice on an object",
    );
}
function Xr(n, e, t) {
  sw(n, e), e.set(n, t);
}
function UN(n, e) {
  return e.get ? e.get.call(n) : e.value;
}
function ow(n, e, t) {
  if (!e.has(n))
    throw new TypeError("attempted to " + t + " private field on non-instance");
  return e.get(n);
}
function Je(n, e) {
  var t = ow(n, e, "get");
  return UN(n, t);
}
function jN(n, e, t) {
  if (e.set) e.set.call(n, t);
  else {
    if (!e.writable)
      throw new TypeError("attempted to set read only private field");
    e.value = t;
  }
}
function Ql(n, e, t) {
  var r = ow(n, e, "set");
  return jN(n, r, t), t;
}
function Cd(n, e) {
  sw(n, e), e.add(n);
}
function Gs(n, e, t) {
  if (!e.has(n))
    throw new TypeError("attempted to get private field on non-instance");
  return t;
}
function zN(n, e) {
  if (typeof n != "object" || n === null) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function HN(n) {
  var e = zN(n, "string");
  return typeof e == "symbol" ? e : String(e);
}
function Ji(n, e, t) {
  return (
    (e = HN(e)),
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
var cw = { exports: {} };
(function (n) {
  var e = Object.prototype.hasOwnProperty,
    t = "~";
  function r() {}
  Object.create &&
    ((r.prototype = Object.create(null)), new r().__proto__ || (t = !1));
  function a(c, l, u) {
    (this.fn = c), (this.context = l), (this.once = u || !1);
  }
  function i(c, l, u, d, f) {
    if (typeof u != "function")
      throw new TypeError("The listener must be a function");
    var p = new a(u, d || c, f),
      m = t ? t + l : l;
    return (
      c._events[m]
        ? c._events[m].fn
          ? (c._events[m] = [c._events[m], p])
          : c._events[m].push(p)
        : ((c._events[m] = p), c._eventsCount++),
      c
    );
  }
  function s(c, l) {
    --c._eventsCount === 0 ? (c._events = new r()) : delete c._events[l];
  }
  function o() {
    (this._events = new r()), (this._eventsCount = 0);
  }
  (o.prototype.eventNames = function () {
    var l = [],
      u,
      d;
    if (this._eventsCount === 0) return l;
    for (d in (u = this._events)) e.call(u, d) && l.push(t ? d.slice(1) : d);
    return Object.getOwnPropertySymbols
      ? l.concat(Object.getOwnPropertySymbols(u))
      : l;
  }),
    (o.prototype.listeners = function (l) {
      var u = t ? t + l : l,
        d = this._events[u];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, p = d.length, m = new Array(p); f < p; f++)
        m[f] = d[f].fn;
      return m;
    }),
    (o.prototype.listenerCount = function (l) {
      var u = t ? t + l : l,
        d = this._events[u];
      return d ? (d.fn ? 1 : d.length) : 0;
    }),
    (o.prototype.emit = function (l, u, d, f, p, m) {
      var y = t ? t + l : l;
      if (!this._events[y]) return !1;
      var h = this._events[y],
        g = arguments.length,
        v,
        w;
      if (h.fn) {
        switch ((h.once && this.removeListener(l, h.fn, void 0, !0), g)) {
          case 1:
            return h.fn.call(h.context), !0;
          case 2:
            return h.fn.call(h.context, u), !0;
          case 3:
            return h.fn.call(h.context, u, d), !0;
          case 4:
            return h.fn.call(h.context, u, d, f), !0;
          case 5:
            return h.fn.call(h.context, u, d, f, p), !0;
          case 6:
            return h.fn.call(h.context, u, d, f, p, m), !0;
        }
        for (w = 1, v = new Array(g - 1); w < g; w++) v[w - 1] = arguments[w];
        h.fn.apply(h.context, v);
      } else {
        var T = h.length,
          A;
        for (w = 0; w < T; w++)
          switch (
            (h[w].once && this.removeListener(l, h[w].fn, void 0, !0), g)
          ) {
            case 1:
              h[w].fn.call(h[w].context);
              break;
            case 2:
              h[w].fn.call(h[w].context, u);
              break;
            case 3:
              h[w].fn.call(h[w].context, u, d);
              break;
            case 4:
              h[w].fn.call(h[w].context, u, d, f);
              break;
            default:
              if (!v)
                for (A = 1, v = new Array(g - 1); A < g; A++)
                  v[A - 1] = arguments[A];
              h[w].fn.apply(h[w].context, v);
          }
      }
      return !0;
    }),
    (o.prototype.on = function (l, u, d) {
      return i(this, l, u, d, !1);
    }),
    (o.prototype.once = function (l, u, d) {
      return i(this, l, u, d, !0);
    }),
    (o.prototype.removeListener = function (l, u, d, f) {
      var p = t ? t + l : l;
      if (!this._events[p]) return this;
      if (!u) return s(this, p), this;
      var m = this._events[p];
      if (m.fn)
        m.fn === u && (!f || m.once) && (!d || m.context === d) && s(this, p);
      else {
        for (var y = 0, h = [], g = m.length; y < g; y++)
          (m[y].fn !== u || (f && !m[y].once) || (d && m[y].context !== d)) &&
            h.push(m[y]);
        h.length ? (this._events[p] = h.length === 1 ? h[0] : h) : s(this, p);
      }
      return this;
    }),
    (o.prototype.removeAllListeners = function (l) {
      var u;
      return (
        l
          ? ((u = t ? t + l : l), this._events[u] && s(this, u))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      );
    }),
    (o.prototype.off = o.prototype.removeListener),
    (o.prototype.addListener = o.prototype.on),
    (o.prefixed = t),
    (o.EventEmitter = o),
    (n.exports = o);
})(cw);
var qN = cw.exports;
const lw = ir(qN),
  VN = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "spender", type: "address" },
      ],
      name: "allowance",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "spender", type: "address" },
        { internalType: "uint256", name: "value", type: "uint256" },
      ],
      name: "approve",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "who", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "value", type: "uint256" },
      ],
      name: "transfer",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "value", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
    },
  ];
function Pb(n, e) {
  return new Pe(e, VN, n);
}
function GN(n, e) {
  return `https://${n}.rpc.thirdweb.com${e ? `/${e}` : ""}${
    typeof globalThis < "u" && "APP_BUNDLE_ID" in globalThis
      ? `?bundleId=${globalThis.APP_BUNDLE_ID}`
      : ""
  }`;
}
const KN = [
    "function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)",
  ],
  QN = "0x1626ba7e";
async function YN(n, e, t, r) {
  const a = new Ya(GN(r)),
    i = new Pe(t, KN, a),
    s = Od(n);
  try {
    return (await i.isValidSignature(s, e)) === QN;
  } catch {
    return !1;
  }
}
class JN extends lw {
  constructor() {
    super(...arguments), Ji(this, "type", "evm");
  }
  async getAddress() {
    return (await this.getSigner()).getAddress();
  }
  async getBalance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : an;
    const t = await this.getSigner(),
      r = await this.getAddress();
    if (!t.provider) throw new Error("Please connect a provider");
    let a;
    return (
      rr(e)
        ? (a = await t.provider.getBalance(r))
        : (a = await Pb(t, e).balanceOf(r)),
      await Xn(t.provider, e, a)
    );
  }
  async getChainId() {
    return (await this.getSigner()).getChainId();
  }
  async transfer(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : an;
    const a = await this.getSigner(),
      i = await this.getAddress();
    if (!a.provider) throw new Error("Please connect a provider");
    const s = await qt(a.provider, t, r);
    return rr(r)
      ? {
          receipt: await (
            await a.sendTransaction({ from: i, to: e, value: s })
          ).wait(),
        }
      : { receipt: await (await Pb(a, r).transfer(e, s)).wait() };
  }
  async signMessage(e) {
    return await (await this.getSigner()).signMessage(e);
  }
  async verifySignature(e, t, r, a) {
    try {
      const i = Od(e),
        s = ae(i);
      if (Uc(s, t) === r) return !0;
    } catch {}
    if (a !== void 0)
      try {
        return await YN(e, t, r, a || 1);
      } catch {}
    return !1;
  }
}
const Q0 = "__TW__";
class XN {
  constructor(e) {
    this.name = e;
  }
  getItem(e) {
    return new Promise((t) => {
      t(localStorage.getItem(`${Q0}/${this.name}/${e}`));
    });
  }
  setItem(e, t) {
    return new Promise((r, a) => {
      try {
        localStorage.setItem(`${Q0}/${this.name}/${e}`, t), r();
      } catch (i) {
        a(i);
      }
    });
  }
  removeItem(e) {
    return new Promise((t) => {
      localStorage.removeItem(`${Q0}/${this.name}/${e}`), t();
    });
  }
}
function uw(n) {
  return new XN(n);
}
const ZN = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: !0,
};
var Y0 = new WeakMap(),
  J0 = new WeakSet(),
  dw = new WeakSet();
class Im extends JN {
  getMeta() {
    return this.constructor.meta;
  }
  constructor(e, t) {
    super(),
      Cd(this, dw),
      Cd(this, J0),
      Xr(this, Y0, { writable: !0, value: void 0 }),
      (this.walletId = e),
      (this.options = t),
      (this.chains = ((t == null ? void 0 : t.chains) || oi).map((r) =>
        vu(r, t == null ? void 0 : t.clientId),
      )),
      (this.dappMetadata = (t == null ? void 0 : t.dappMetadata) || ZN),
      (this.walletStorage =
        (t == null ? void 0 : t.walletStorage) || uw(this.walletId));
  }
  async autoConnect(e) {
    const t = e ? { ...e, chainId: void 0 } : void 0;
    return Gs(this, J0, Ib).call(this, !0, t);
  }
  async connect(e) {
    Ql(this, Y0, e);
    const t = await Gs(this, J0, Ib).call(this, !1, e);
    if (!t) throw new Error("Failed to connect to the wallet.");
    return t;
  }
  getConnectParams() {
    return Je(this, Y0);
  }
  async getSigner() {
    const e = await this.getConnector();
    if (!e) throw new Error("Wallet not connected");
    return await e.getSigner();
  }
  async disconnect() {
    const e = await this.getConnector();
    e &&
      (await e.disconnect(), this.emit("disconnect"), e.removeAllListeners());
  }
  async switchChain(e) {
    const t = await this.getConnector();
    if (!t) throw new Error("Wallet not connected");
    if (!t.switchChain)
      throw new Error("Wallet does not support switching chains");
    return await t.switchChain(e);
  }
  async updateChains(e) {
    (this.chains = e.map((r) => {
      var a;
      return vu(r, (a = this.options) == null ? void 0 : a.clientId);
    })),
      (await this.getConnector()).updateChains(this.chains);
  }
  getPersonalWallet() {}
}
async function Ib(n, e) {
  const t = await this.getConnector();
  if ((Gs(this, dw, eF).call(this, t), await t.isConnected())) {
    const a = await t.getAddress();
    return (
      t.setupListeners(),
      e != null &&
        e.chainId &&
        (await t.switchChain(e == null ? void 0 : e.chainId)),
      this.emit("connect", { address: a, chainId: await this.getChainId() }),
      a
    );
  }
  if (n) throw new Error("Failed to auto connect to the wallet.");
  try {
    return await t.connect(e);
  } catch (a) {
    throw new Error(a.message);
  }
}
async function eF(n) {
  n.on("connect", (e) => {
    var t;
    this.emit("connect", {
      address: e.account,
      chainId: (t = e.chain) == null ? void 0 : t.id,
    });
  }),
    n.on("change", (e) => {
      var t;
      this.emit("change", {
        address: e.account,
        chainId: (t = e.chain) == null ? void 0 : t.id,
      });
    }),
    n.on("message", (e) => {
      this.emit("message", e);
    }),
    n.on("disconnect", async () => {
      this.emit("disconnect");
    }),
    n.on("error", (e) => this.emit("error", e));
}
const $i = {
  coinbase: "coinbase",
  frame: "frame",
  metamask: "metamask",
  localWallet: "localWallet",
  smartWallet: "smartWallet",
  safe: "safe",
  trust: "trust",
  walletConnectV1: "walletConnectV1",
  walletConnect: "walletConnect",
  magicLink: "magicLink",
  paper: "paper",
  blocto: "blocto",
};
var Rb =
    (globalThis && globalThis.__spreadArray) ||
    function (n, e, t) {
      if (t || arguments.length === 2)
        for (var r = 0, a = e.length, i; r < a; r++)
          (i || !(r in e)) &&
            (i || (i = Array.prototype.slice.call(e, 0, r)), (i[r] = e[r]));
      return n.concat(i || Array.prototype.slice.call(e));
    },
  tF = (function () {
    function n(e, t, r) {
      (this.name = e),
        (this.version = t),
        (this.os = r),
        (this.type = "browser");
    }
    return n;
  })(),
  nF = (function () {
    function n(e) {
      (this.version = e),
        (this.type = "node"),
        (this.name = "node"),
        (this.os = process.platform);
    }
    return n;
  })(),
  rF = (function () {
    function n(e, t, r, a) {
      (this.name = e),
        (this.version = t),
        (this.os = r),
        (this.bot = a),
        (this.type = "bot-device");
    }
    return n;
  })(),
  aF = (function () {
    function n() {
      (this.type = "bot"),
        (this.bot = !0),
        (this.name = "bot"),
        (this.version = null),
        (this.os = null);
    }
    return n;
  })(),
  iF = (function () {
    function n() {
      (this.type = "react-native"),
        (this.name = "react-native"),
        (this.version = null),
        (this.os = null);
    }
    return n;
  })(),
  sF =
    /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
  oF =
    /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
  Mb = 3,
  cF = [
    ["aol", /AOLShield\/([0-9\._]+)/],
    ["edge", /Edge\/([0-9\._]+)/],
    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
    ["silk", /\bSilk\/([0-9._-]+)\b/],
    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
    [
      "chromium-webview",
      /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
    ["fxios", /FxiOS\/([0-9\.]+)/],
    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
    ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    [
      "pie",
      /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/,
    ],
    ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ["ie", /MSIE\s(7\.0)/],
    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ["android", /Android\s([0-9\.]+)/],
    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ["safari", /Version\/([0-9\._]+).*Safari/],
    ["facebook", /FB[AS]V\/([0-9\.]+)/],
    ["instagram", /Instagram\s([0-9\.]+)/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ["curl", /^curl\/([0-9\.]+)$/],
    ["searchbot", sF],
  ],
  Bb = [
    ["iOS", /iP(hone|od|ad)/],
    ["Android OS", /Android/],
    ["BlackBerry OS", /BlackBerry|BB10/],
    ["Windows Mobile", /IEMobile/],
    ["Amazon OS", /Kindle/],
    ["Windows 3.11", /Win16/],
    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
    ["Windows 98", /(Windows 98)|(Win98)/],
    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
    ["Windows Server 2003", /(Windows NT 5.2)/],
    ["Windows Vista", /(Windows NT 6.0)/],
    ["Windows 7", /(Windows NT 6.1)/],
    ["Windows 8", /(Windows NT 6.2)/],
    ["Windows 8.1", /(Windows NT 6.3)/],
    ["Windows 10", /(Windows NT 10.0)/],
    ["Windows ME", /Windows ME/],
    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ["Open BSD", /OpenBSD/],
    ["Sun OS", /SunOS/],
    ["Chrome OS", /CrOS/],
    ["Linux", /(Linux)|(X11)/],
    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
    ["QNX", /QNX/],
    ["BeOS", /BeOS/],
    ["OS/2", /OS\/2/],
  ];
function lF(n) {
  return n
    ? Db(n)
    : typeof document > "u" &&
      typeof navigator < "u" &&
      navigator.product === "ReactNative"
    ? new iF()
    : typeof navigator < "u"
    ? Db(navigator.userAgent)
    : fF();
}
function uF(n) {
  return (
    n !== "" &&
    cF.reduce(function (e, t) {
      var r = t[0],
        a = t[1];
      if (e) return e;
      var i = a.exec(n);
      return !!i && [r, i];
    }, !1)
  );
}
function Db(n) {
  var e = uF(n);
  if (!e) return null;
  var t = e[0],
    r = e[1];
  if (t === "searchbot") return new aF();
  var a = r[1] && r[1].split(".").join("_").split("_").slice(0, 3);
  a
    ? a.length < Mb && (a = Rb(Rb([], a, !0), pF(Mb - a.length), !0))
    : (a = []);
  var i = a.join("."),
    s = dF(n),
    o = oF.exec(n);
  return o && o[1] ? new rF(t, i, s, o[1]) : new tF(t, i, s);
}
function dF(n) {
  for (var e = 0, t = Bb.length; e < t; e++) {
    var r = Bb[e],
      a = r[0],
      i = r[1],
      s = i.exec(n);
    if (s) return a;
  }
  return null;
}
function fF() {
  var n = typeof process < "u" && process.version;
  return n ? new nF(process.version.slice(1)) : null;
}
function pF(n) {
  for (var e = [], t = 0; t < n; t++) e.push("0");
  return e;
}
const fw = "145769e410f16970a79ff77b2d89a1e0";
class hF extends lw {}
class Ad extends hF {
  constructor(e) {
    super(), (this.wagmiConnector = e);
  }
  async connect(e) {
    return (
      this.setupConnectorListeners(),
      (await this.wagmiConnector.connect(e)).account
    );
  }
  disconnect() {
    return (
      this.wagmiConnector.removeAllListeners("connect"),
      this.wagmiConnector.removeAllListeners("change"),
      this.wagmiConnector.disconnect()
    );
  }
  isConnected() {
    return this.wagmiConnector.isAuthorized();
  }
  getAddress() {
    return this.wagmiConnector.getAccount();
  }
  getSigner() {
    return this.wagmiConnector.getSigner();
  }
  getProvider() {
    return this.wagmiConnector.getProvider();
  }
  async switchChain(e) {
    if (!this.wagmiConnector.switchChain)
      throw new Error("Switch chain not supported");
    await this.wagmiConnector.switchChain(e);
  }
  setupConnectorListeners() {
    this.wagmiConnector.addListener("connect", (e) => {
      this.emit("connect", e);
    }),
      this.wagmiConnector.addListener("change", (e) => {
        this.emit("change", e);
      }),
      this.wagmiConnector.addListener("disconnect", () => {
        this.emit("disconnect");
      });
  }
  async setupListeners() {
    this.setupConnectorListeners(), await this.wagmiConnector.setupListeners();
  }
  updateChains(e) {
    this.wagmiConnector.updateChains(e);
  }
}
function pw(n) {
  return typeof n < "u" && !!n && "ethereum" in n;
}
function hw() {
  var e;
  function n(t) {
    if (
      t != null &&
      t.isMetaMask &&
      !(t.isBraveWallet && !t._events && !t._state) &&
      !t.isPhantom &&
      !t.isAvalanche &&
      !t.isBitKeep &&
      !t.isMathWallet &&
      !t.isZerion &&
      !t.isKuCoinWallet &&
      !t.isPortal &&
      !t.isTokenPocket &&
      !t.isTokenary
    )
      return t;
  }
  if (pw(globalThis.window))
    return (e = globalThis.window.ethereum) != null && e.providers
      ? globalThis.window.ethereum.providers.find(n)
      : n(globalThis.window.ethereum);
}
window.Buffer = Gc.Buffer;
class Ks extends Im {
  get walletName() {
    return "Coinbase Wallet";
  }
  constructor(e) {
    super(Ks.id, e),
      (this.headlessMode = (e == null ? void 0 : e.headlessMode) || !1),
      (this.theme =
        (e != null && e.theme) || this.dappMetadata.isDarkMode === !1
          ? "light"
          : "dark");
  }
  async getConnector() {
    if (!this.connector) {
      const { CoinbaseWalletConnector: e } = await Re(
          () =>
            import(
              "./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-68221b11.js"
            ),
          [
            "assets/thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-68221b11.js",
            "assets/index-aff6404b.js",
            "assets/index-6a964d41.css",
            "assets/errors-d961f852.browser.esm-de44b07f.js",
            "assets/normalizeChainId-e4cc0175.browser.esm-196d9c80.js",
            "assets/index-35d0d874.js",
            "assets/index-e651aa00.css",
            "assets/constants-ed7a1b25.js",
            "assets/hoist-non-react-statics.cjs-434f601a.js",
            "assets/Helmet-bfad690c.js",
          ],
        ),
        t = new e({
          chains: this.chains,
          options: {
            appName: this.dappMetadata.name,
            reloadOnDisconnect: !1,
            darkMode: this.theme === "dark",
            headlessMode: this.headlessMode,
          },
        });
      t.on("connect", () => {}),
        (this.coinbaseConnector = t),
        (this.connector = new Ad(t));
    }
    return this.connector;
  }
  async getQrUrl() {
    if ((await this.getConnector(), !this.coinbaseConnector))
      throw new Error("Coinbase connector not initialized");
    return this.coinbaseConnector.getQrUrl();
  }
}
Ji(Ks, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome:
      "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455",
  },
});
Ji(Ks, "id", $i.coinbase);
class Pi extends Im {
  get walletName() {
    return "MetaMask";
  }
  constructor(e) {
    super(Pi.id, e), (this.isInjected = !!hw());
  }
  async getConnector() {
    var e, t, r;
    if (!this.connector)
      if (this.isInjected) {
        const { MetaMaskConnector: a } = await Re(
            () =>
              import(
                "./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-2310e432.js"
              ),
            [
              "assets/thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-2310e432.js",
              "assets/errors-d961f852.browser.esm-de44b07f.js",
              "assets/normalizeChainId-e4cc0175.browser.esm-196d9c80.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          i = new a({
            chains: this.chains,
            connectorStorage: this.walletStorage,
            options: { shimDisconnect: !0 },
          });
        (this.metamaskConnector = i), (this.connector = new Ad(i));
      } else {
        const { WalletConnectConnector: a } = await Re(
            () =>
              import(
                "./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-63e71cf1.js"
              ),
            [
              "assets/thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-63e71cf1.js",
              "assets/index-aff6404b.js",
              "assets/index-6a964d41.css",
              "assets/errors-d961f852.browser.esm-de44b07f.js",
              "assets/index-35d0d874.js",
              "assets/index-e651aa00.css",
              "assets/constants-ed7a1b25.js",
              "assets/hoist-non-react-statics.cjs-434f601a.js",
              "assets/Helmet-bfad690c.js",
            ],
          ),
          i = new a({
            chains: this.chains,
            options: {
              projectId:
                ((e = this.options) == null ? void 0 : e.projectId) || fw,
              storage: this.walletStorage,
              qrcode: (t = this.options) == null ? void 0 : t.qrcode,
              dappMetadata: this.dappMetadata,
              qrModalOptions:
                (r = this.options) == null ? void 0 : r.qrModalOptions,
            },
          });
        i.getProvider().then((s) => {
          s.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        }),
          (this.walletConnectConnector = i),
          (this.connector = new Ad(i));
      }
    return this.connector;
  }
  async connectWithQrCode(e) {
    await this.getConnector();
    const t = this.walletConnectConnector;
    if (!t) throw new Error("WalletConnect connector not found");
    (await t.getProvider()).on("display_uri", (a) => {
      e.onQrCodeUri(a);
    }),
      this.connect({ chainId: e.chainId }).then(e.onConnected);
  }
  async switchAccount() {
    if (!this.metamaskConnector) throw new Error("Can not switch Account");
    await this.metamaskConnector.switchAccount();
  }
}
Ji(Pi, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome:
      "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202",
  },
});
Ji(Pi, "id", $i.metamask);
var pn = new WeakMap(),
  vs = new WeakMap(),
  mF = new WeakMap(),
  Rm = new WeakMap(),
  Mm = new WeakMap(),
  Bm = new WeakMap(),
  Dm = new WeakMap(),
  Om = new WeakMap(),
  Ob = new WeakSet(),
  dh = new WeakSet();
class Ii extends Im {
  get walletName() {
    return "WalletConnect";
  }
  constructor(e) {
    super((e == null ? void 0 : e.walletId) || Ii.id, e),
      Cd(this, dh),
      Cd(this, Ob),
      Xr(this, pn, { writable: !0, value: void 0 }),
      Xr(this, vs, { writable: !0, value: void 0 }),
      Xr(this, mF, {
        writable: !0,
        value: (t) => {
          if (t) throw t;
        },
      }),
      Xr(this, Rm, {
        writable: !0,
        value: (t) => {
          if ((Ql(this, vs, t.provider), !Je(this, vs)))
            throw new Error(
              "WalletConnect provider not found after connecting.",
            );
        },
      }),
      Xr(this, Mm, {
        writable: !0,
        value: () => {
          Gs(this, dh, mw).call(this);
        },
      }),
      Xr(this, Bm, {
        writable: !0,
        value: async (t) => {
          t.chain || t.account;
        },
      }),
      Xr(this, Dm, {
        writable: !0,
        value: (t) => {
          switch (t.type) {
            case "display_uri":
              this.emit("display_uri", t.data);
              break;
          }
        },
      }),
      Xr(this, Om, {
        writable: !0,
        value: () => {
          this.emit("wc_session_request_sent");
        },
      }),
      (this.projectId = (e == null ? void 0 : e.projectId) || fw),
      (this.qrcode = (e == null ? void 0 : e.qrcode) !== !1);
  }
  async getConnector() {
    var e;
    if (!this.connector) {
      const { WalletConnectConnector: t } = await Re(
        () =>
          import(
            "./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-63e71cf1.js"
          ),
        [
          "assets/thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-63e71cf1.js",
          "assets/index-aff6404b.js",
          "assets/index-6a964d41.css",
          "assets/errors-d961f852.browser.esm-de44b07f.js",
          "assets/index-35d0d874.js",
          "assets/index-e651aa00.css",
          "assets/constants-ed7a1b25.js",
          "assets/hoist-non-react-statics.cjs-434f601a.js",
          "assets/Helmet-bfad690c.js",
        ],
      );
      Ql(
        this,
        pn,
        new t({
          chains: this.chains,
          options: {
            qrcode: this.qrcode,
            projectId: this.projectId,
            dappMetadata: this.dappMetadata,
            storage: this.walletStorage,
            qrModalOptions:
              (e = this.options) == null ? void 0 : e.qrModalOptions,
          },
        }),
      ),
        (this.connector = new Ad(Je(this, pn))),
        Ql(this, vs, await Je(this, pn).getProvider()),
        Gs(this, Ob, yF).call(this);
    }
    return this.connector;
  }
  async connectWithQrCode(e) {
    await this.getConnector();
    const t = Je(this, pn);
    if (!t) throw new Error("WalletConnect connector not found");
    (await t.getProvider()).on("display_uri", (a) => {
      e.onQrCodeUri(a);
    }),
      this.connect({ chainId: e.chainId }).then(e.onConnected);
  }
}
function yF() {
  var n;
  Je(this, pn) &&
    (Gs(this, dh, mw).call(this),
    Je(this, pn).on("connect", Je(this, Rm)),
    Je(this, pn).on("disconnect", Je(this, Mm)),
    Je(this, pn).on("change", Je(this, Bm)),
    Je(this, pn).on("message", Je(this, Dm)),
    (n = Je(this, vs)) == null ||
      n.signer.client.on("session_request_sent", Je(this, Om)));
}
function mw() {
  var n;
  Je(this, pn) &&
    (Je(this, pn).removeListener("connect", Je(this, Rm)),
    Je(this, pn).removeListener("disconnect", Je(this, Mm)),
    Je(this, pn).removeListener("change", Je(this, Bm)),
    Je(this, pn).removeListener("message", Je(this, Dm)),
    (n = Je(this, vs)) == null ||
      n.signer.client.removeListener("session_request_sent", Je(this, Om)));
}
Ji(Ii, "id", $i.walletConnect);
Ji(Ii, "meta", {
  name: "WalletConnect",
  iconURL:
    "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg",
});
async function gF(n) {
  if (!n) return;
  const e = n9.getType(n);
  if (e) return e;
  const t = await fetch(n, { method: "HEAD" });
  if (t.ok && t.headers.has("content-type"))
    return t.headers.get("content-type") || void 0;
}
const bF = C.createContext(void 0),
  yw = C.createContext(void 0);
function Nm() {
  return C.useContext(yw);
}
const Ai = "lastConnectedWallet";
let na;
const kl = new Map(),
  gw = C.createContext(void 0);
function xF(n) {
  const [e, t] = C.useState(void 0),
    [r, a] = C.useState("unknown"),
    i = n.autoConnectTimeout || 15e3,
    [s, o] = C.useState(),
    [c, l] = C.useState(),
    [u, d] = C.useState();
  na || (na = n.createWalletStorage("coordinatorStorage"));
  const f = n.autoSwitch ? n.activeChain : void 0,
    p = C.useMemo(
      () => ({
        chains: n.chains,
        dappMetadata: n.dAppMeta,
        chain: n.activeChain || n.chains[0],
        clientId: n.clientId,
      }),
      [n.chains, n.dAppMeta, n.activeChain, n.clientId],
    ),
    m = C.useCallback(
      (E) => {
        const _ = E.create(p);
        return _.walletId === $i.magicLink && l(_), kl.set(_, E), _;
      },
      [p],
    );
  C.useEffect(() => {
    s && s.updateChains(n.chains);
  }, [s, n.chains]);
  const y = C.useCallback(async function (E, _) {
      let S =
        arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      o(E);
      const W = kl.get(E);
      if (!W)
        throw new Error(
          "Wallet config not found for given wallet instance. Do not create a wallet instance manually - use the useCreateWalletInstance() hook instead",
        );
      d(W), a("connected");
      const D = await E.getSigner();
      if ((t(D), S)) return;
      const L = { walletId: W.id, connectParams: _ },
        G = E.getPersonalWallet(),
        q = kl.get(G);
      G &&
        q &&
        (L.connectParams = {
          ...L.connectParams,
          personalWallet: {
            walletId: q.id,
            connectParams: G.getConnectParams(),
          },
        }),
        X0(L);
    }, []),
    h = C.useCallback(async (E) => {
      const _ = await na.getItem(Ai);
      if (_)
        try {
          const S = JSON.parse(_);
          (S.connectParams.chainId = E),
            await na.setItem(Ai, JSON.stringify(S));
        } catch (S) {
          console.error(`Error saving the last active chain: ${S}`);
        }
    }, []),
    g = C.useCallback(
      async (E) => {
        if (!s) throw new Error("No active wallet");
        await s.switchChain(E);
        const _ = await s.getSigner();
        await h(E), t(_);
      },
      [s, h],
    ),
    v = C.useRef(!1);
  C.useEffect(() => {
    if (v.current) return;
    if (n.shouldAutoConnect === !1) {
      a("disconnected");
      return;
    }
    if (s || r !== "unknown") return;
    v.current = !0;
    async function E() {
      var L;
      const _ = await vF();
      if (!_) {
        a("disconnected");
        return;
      }
      const S = n.supportedWallets.find((G) => G.id === _.walletId);
      if (!S) {
        a("disconnected");
        return;
      }
      const W = (L = _.connectParams) == null ? void 0 : L.personalWallet;
      if (W) {
        const q = (S.personalWallets || []).find((N) => N.id === W.walletId);
        if (q) {
          const N = m(q);
          try {
            await Nb(N.autoConnect(W.connectParams), {
              ms: i,
              message: "Failed to Auto connect. Auto connect timed out.",
            });
          } catch (H) {
            console.error(H), a("disconnected");
            return;
          }
          _.connectParams = { ..._.connectParams, personalWallet: N };
        } else {
          a("disconnected");
          return;
        }
      }
      const D = m(S);
      try {
        a("connecting"),
          await Nb(D.autoConnect(_.connectParams), {
            ms: i,
            message: "Failed to Auto connect. Auto connect timed out.",
          }),
          y(D, _.connectParams, !0);
      } catch (G) {
        console.error(G), na.removeItem(Ai), a("disconnected");
      }
    }
    E();
  }, [m, n.supportedWallets, y, n.shouldAutoConnect, s, r, i]);
  const w = C.useCallback(
      async function () {
        for (var E = arguments.length, _ = new Array(E), S = 0; S < E; S++)
          _[S] = arguments[S];
        const [W, D] = _,
          L = { chainId: f == null ? void 0 : f.chainId, ...(D || {}) },
          G = m(W);
        a("connecting");
        try {
          W.id === $i.magicLink && X0({ walletId: W.id, connectParams: L }),
            await G.connect(L),
            y(G, L);
        } catch (q) {
          throw (
            (console.error(`Error connecting to wallet: ${q}`),
            a("disconnected"),
            q)
          );
        }
        return G;
      },
      [m, y, f],
    ),
    T = C.useCallback(async () => {
      await na.removeItem(Ai),
        a("disconnected"),
        t(void 0),
        o(void 0),
        d(void 0);
    }, []),
    A = C.useCallback(async () => {
      if (!s) {
        T();
        return;
      }
      const E = s.getPersonalWallet();
      await s.disconnect(),
        E && (await (E == null ? void 0 : E.disconnect())),
        T();
    }, [s, T]);
  return (
    C.useEffect(() => {
      if (!s) return;
      const E = async () => {
        const _ = await s.getSigner();
        t(_);
      };
      return (
        s.addListener("change", () => {
          E();
        }),
        s.addListener("disconnect", () => {
          T();
        }),
        () => {
          s.removeListener("change"), s.removeListener("disconnect");
        }
      );
    }, [s, T]),
    I.jsx(gw.Provider, {
      value: {
        disconnect: A,
        wallets: n.supportedWallets,
        connect: w,
        signer: e,
        activeWallet: s,
        activeWalletConfig: u,
        connectionStatus: r,
        setConnectionStatus: a,
        createWalletInstance: m,
        createdWalletInstance: c,
        createWalletStorage: n.createWalletStorage,
        switchChain: g,
        setConnectedWallet: y,
        activeChain: n.activeChain,
        chainToConnect: f,
        getWalletConfig: (E) => kl.get(E),
      },
      children: n.children,
    })
  );
}
function Tr() {
  const n = C.useContext(gw);
  if (!n)
    throw new Error(
      "useWalletContext() can only be used inside <ThirdwebProvider />",
    );
  return n;
}
async function vF() {
  const n = await na.getItem(Ai);
  if (!n) return null;
  try {
    return JSON.parse(n);
  } catch {
    return await na.removeItem(Ai), null;
  }
}
async function X0(n) {
  try {
    await na.setItem(Ai, JSON.stringify(n));
  } catch (e) {
    console.error("Error saving the last connected wallet info", e);
  }
}
function Nb(n, e) {
  return new Promise((t, r) => {
    const a = setTimeout(() => {
      r(new Error(e.message));
    }, e.ms);
    n.then(
      (i) => {
        clearTimeout(a), t(i);
      },
      (i) => {
        clearTimeout(a), r(i);
      },
    );
  });
}
function bw() {
  const n = Tr();
  return (
    ce(n, "useWallet() hook must be used within a <ThirdwebProvider/>"),
    n.activeWallet
  );
}
function xw() {
  const n = Tr();
  return (
    ce(n, "useWallets() hook must be used within a <ThirdwebProvider/>"),
    n.wallets
  );
}
function vf() {
  const n = Tr();
  return (
    ce(n, "useConnect() hook must be used within a <ThirdwebProvider/>"),
    n.connect
  );
}
function vw() {
  const n = Tr();
  return (
    ce(n, "useDisconnect() hook must be used within a <ThirdwebProvider/>"),
    n.disconnect
  );
}
function ww() {
  const n = Tr();
  return (
    ce(n, "useConnectionStatus() must be used within a <ThirdwebProvider/>"),
    n.connectionStatus
  );
}
function wF() {
  const n = Tr();
  return (
    ce(n, "useSetConnectionStatus() must be used within a <ThirdwebProvider/>"),
    n.setConnectionStatus
  );
}
function Fm() {
  const n = Tr();
  return (
    ce(
      n,
      "useCreateWalletInstance() must be used within a <ThirdwebProvider/>",
    ),
    n.createWalletInstance
  );
}
function TF() {
  const n = Tr();
  return (
    ce(n, "useSwitchChain() must be used within a <ThirdwebProvider/>"),
    n.setConnectedWallet
  );
}
const Fb = "tw-cache";
function ws(n) {
  return [Fb, ...n.filter((e) => typeof e != "string" || e !== Fb)];
}
function ge() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Ie,
    e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return ws(["contract", n, ...e]);
}
function CF(n, e) {
  return ws(Lm.network.active(e).concat(n));
}
const Lm = {
    auth: { user: () => ws(["user"]) },
    network: { active: (n) => ws(["chainId", n]) },
    wallet: {
      balance: (n, e, t) =>
        ws(CF(ws(["balance", { walletAddress: e, tokenAddress: t }]), n)),
    },
    contract: {
      read: (n, e) => ge(n, ["read", e]),
      type: (n) => ge(n, ["contract-type"]),
      compilerMetadata: (n) => ge(n, ["publish-metadata"]),
      typeAndCompilerMetadata: (n) => ge(n, ["contract-type-and-metadata"]),
      metadata: (n) => ge(n, ["metadata"]),
      extractFunctions: (n) => ge(n, ["extractFunctions"]),
      call: (n, e, t, r) => ge(n, ["call", e, t, r]),
      accountFactory: {
        getAll: (n) => ge(n, ["accountFactory"]),
        isAccountDeployed: (n, e) => ge(n, ["isAccountDeployed", e]),
        getAllForAddress: (n, e) => ge(n, ["getAllForAddress", e]),
      },
      account: { signers: (n) => ge(n, ["account", "signers"]) },
      app: { get: (n) => ge(n, ["appURI"]) },
      events: {
        getEvents: (n, e) => ge(n, ["events", "getEvents", { eventName: e }]),
        getAllEvents: (n) => ge(n, ["events", "getAllEvents"]),
      },
      nft: {
        get: (n, e) => ge(n, ["get", { tokenId: e }]),
        balanceOf: (n, e, t) => ge(n, ["balanceOf", { owner: e, tokenId: t }]),
        query: {
          all: (n, e) => ge(n, e ? ["query", "all", e] : ["query", "all"]),
          totalCirculatingSupply: (n) =>
            ge(n, ["query", "totalCirculatingSupply"]),
          totalCount: (n) => ge(n, ["query", "totalCount"]),
          owned: { all: (n, e) => ge(n, ["query", "owned", "all", e]) },
        },
        sharedMetadata: { get: (n) => ge(n) },
        drop: {
          getAllUnclaimed: (n, e) =>
            ge(n, e ? ["getAllUnclaimed", e] : ["getAllUnclaimed"]),
          getAllClaimed: (n, e) =>
            ge(n, e ? ["getAllClaimed", e] : ["getAllClaimed"]),
          totalUnclaimedSupply: (n) => ge(n, ["totalUnclaimedSupply"]),
          totalClaimedSupply: (n) => ge(n, ["totalClaimedSupply"]),
          revealer: {
            getBatchesToReveal: (n, e) =>
              ge(n, e ? ["getBatchesToReveal", e] : ["getBatchesToReveal"]),
          },
        },
      },
      token: {
        totalSupply: (n) => ge(n, ["totalSupply"]),
        decimals: (n) => ge(n, ["decimals"]),
        balanceOf: (n, e) => ge(n, ["balanceOf", { walletAddress: e }]),
      },
      marketplace: {
        getListing: (n, e) => ge(n, ["getListing", { listingId: e }]),
        getAllListings: (n, e) =>
          ge(n, e ? ["getAllListings", e] : ["getAllListings"]),
        getTotalCount: (n) => ge(n, ["getTotalCount"]),
        getActiveListings: (n, e) =>
          ge(n, e ? ["getActiveListings", e] : ["getActiveListings"]),
        auction: {
          getBidBufferBps: (n, e) =>
            ge(n, ["auction", "getBidBufferBps", { listingId: e }]),
          getWinningBid: (n, e) =>
            ge(n, ["auction", "getWinningBid", { listingId: e }]),
          getMinimumNextBid: (n, e) =>
            ge(n, ["auction", "getMinimumNextBid", { listingId: e }]),
          getWinner: (n, e) =>
            ge(n, ["auction", "getWinner", { listingId: e }]),
        },
        directListings: {
          getAll: (n, e) =>
            ge(
              n,
              e
                ? ["directListings", "getAll", e]
                : ["directListings", "getAll"],
            ),
          getAllValid: (n, e) =>
            ge(
              n,
              e
                ? ["directListings", "getAllValid", e]
                : ["directListings", "getAllValid"],
            ),
          getListing: (n, e) =>
            ge(n, ["directListings", "getListing", { listingId: e }]),
          getTotalCount: (n) => ge(n, ["directListings", "getTotalCount"]),
        },
        englishAuctions: {
          getAll: (n, e) =>
            ge(
              n,
              e
                ? ["englishAuctions", "getAll", e]
                : ["englishAuctions", "getAll"],
            ),
          getAllValid: (n, e) =>
            ge(
              n,
              e
                ? ["englishAuctions", "getAllValid", e]
                : ["englishAuctions", "getAllValid"],
            ),
          getAuction: (n, e) =>
            ge(n, ["englishAuctions", "getAuction", { auctionId: e }]),
          getWinningBid: (n, e) =>
            ge(n, ["englishAuctions", "getWinningBid", { auctionId: e }]),
          getTotalCount: (n) => ge(n, ["englishAuctions", "getTotalCount"]),
        },
      },
    },
    extensions: {
      claimConditions: {
        getActive: (n, e, t) =>
          ge(
            n,
            e
              ? ["claimConditions", "getActive", { tokenId: e }, t]
              : ["claimConditions", "getActive", t],
          ),
        getAll: (n, e, t) =>
          ge(
            n,
            e
              ? ["claimConditions", "getAll", { tokenId: e }, t]
              : ["claimConditions", "getAll", t],
          ),
        getClaimerProofs: (n, e) =>
          ge(
            n,
            e
              ? ["claimConditions", "getClaimerProofs", { tokenId: e }]
              : ["claimConditions", "getClaimerProofs"],
          ),
        getClaimIneligibilityReasons: (n, e, t) =>
          ge(
            n,
            t
              ? [
                  "claimConditions",
                  "getIneligibilityReasons",
                  { tokenId: t },
                  e,
                ]
              : ["claimConditions", "getIneligibilityReasons", e],
          ),
        useActiveClaimConditionForWallet: (n, e, t) =>
          ge(
            n,
            t
              ? [
                  "claimConditions",
                  "useActiveClaimConditionForWallet",
                  { tokenId: t, walletAddress: e },
                  ,
                ]
              : [
                  "claimConditions",
                  "getIneligibilityReasons",
                  { walletAddress: e },
                ],
          ),
      },
      sales: { getRecipient: (n) => ge(n, ["sales"]) },
      royalties: { getDefaultRoyaltyInfo: (n) => ge(n, ["royalties"]) },
      platformFees: { get: (n) => ge(n, ["platformFees"]) },
      metadata: { get: (n) => ge(n, ["metadata"]) },
      roles: {
        getAll: (n) => ge(n, ["roles"]),
        get: (n, e) => ge(n, ["roles", { role: e }]),
      },
    },
  },
  AF = "auth_token_storage_key";
function EF() {
  const n = Hc(),
    e = Nm(),
    t = A5({
      mutationFn: async () => {
        var r;
        ce(e, "Please specify an authConfig in the ThirdwebProvider"),
          ce(e.authUrl, "Please specify an authUrl in the authConfig."),
          await fetch(`${e.authUrl}/logout`, {
            method: "POST",
            credentials: "include",
          }),
          (r = e.secureStorage) == null || r.removeItem(AF),
          n.invalidateQueries(Lm.auth.user());
      },
    });
  return { logout: t.mutateAsync, isLoading: t.isLoading };
}
function kF() {
  const n = Hc(),
    e = Nm(),
    t = A5({
      mutationFn: async (r) => {
        ce(e, "Please specify an authConfig in the ThirdwebProvider"),
          ce(e.authUrl, "Please specify an authUrl in the authConfig."),
          await fetch(`${e.authUrl}/switch-account`, {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ address: r }),
          }),
          n.invalidateQueries(Lm.auth.user());
      },
    });
  return { switchAccount: t.mutateAsync, isLoading: t.isLoading };
}
const _F = (n) => {
  let { value: e, children: t } = n;
  const r = C.useMemo(() => {
    var i;
    return e
      ? {
          ...e,
          authUrl: (i = e.authUrl) == null ? void 0 : i.replace(/\/$/, ""),
        }
      : void 0;
  }, [e]);
  return I.jsxs(yw.Provider, { value: r, children: [t, I.jsx(SF, {})] });
};
function SF() {
  const n = bw(),
    { logout: e } = EF(),
    { switchAccount: t } = kF(),
    r = Nm(),
    a = Hc();
  return (
    C.useEffect(() => {
      const i = async (c) => {
          if (c.address)
            try {
              await t(c.address);
            } catch (l) {
              console.debug(
                `[Auth] Failed to switch account to ${c.address} with error:
`,
                l,
              );
            }
        },
        s = async () => {
          try {
            await e();
          } catch (c) {
            console.debug(
              `[Auth] Failed to logout with error:
`,
              c,
            );
          }
        },
        o = !!n && r && r.authUrl;
      return (
        o &&
          (n.addListener("connect", i),
          n.addListener("change", i),
          n.addListener("disconnect", s)),
        () => {
          o &&
            (n.removeListener("connect", i),
            n.removeListener("change", i),
            n.removeListener("disconnect", s));
        }
      );
    }, [n, a, r, e, t]),
    null
  );
}
function Tw(n, e, t) {
  const r = C.useMemo(() => n.map((i) => vu(i, t)), [n, t]),
    a = C.useMemo(
      () => (!e || typeof e == "string" || typeof e == "number" ? e : vu(e, t)),
      [e, t],
    );
  return [r, a];
}
const Cw = C.createContext({ chains: oi }),
  PF = (n) => {
    let { value: e, children: t } = n;
    return I.jsx(Cw.Provider, { value: e, children: t });
  };
function IF() {
  return C.useContext(Cw);
}
const Aw = C.createContext({});
function RF() {
  const n = C.useContext(Aw);
  return (
    ce(
      n._inProvider,
      "useSDK must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?",
    ),
    n
  );
}
function Ew() {
  const { sdk: n } = RF();
  return n;
}
const fh = { wallet: void 0, address: void 0, chainId: void 0, signer: void 0 },
  kw = C.createContext(fh),
  MF = (n) => {
    var c;
    let { signer: e, children: t } = n;
    const { chains: r, clientId: a } = IF(),
      i = (c = Ew()) == null ? void 0 : c.storage,
      [s, o] = C.useState({ ...fh, signer: e || void 0 });
    return (
      C.useEffect(() => {
        o((l) => ({ ...l, signer: e || void 0 }));
      }, [e]),
      C.useEffect(() => {
        if (!i) return;
        let l = e;
        return (
          e
            ? Promise.all([e.getAddress(), e.getChainId()])
                .then((u) => {
                  let [d, f] = u;
                  const p = r.find((y) => y.chainId === f);
                  let m;
                  if (p)
                    try {
                      m = Vd(p, a)[0];
                    } catch (y) {
                      console.error(y);
                    }
                  if (e === l) {
                    const y = new xf(
                      e,
                      {
                        readonlySettings: m
                          ? { rpcUrl: m, chainId: f }
                          : void 0,
                      },
                      i,
                    );
                    o({ wallet: y, address: d, chainId: f, signer: e });
                  }
                })
                .catch((u) => {})
            : o(fh),
          () => {
            l = void 0;
          }
        );
      }, [e, a]),
      I.jsx(kw.Provider, { value: s, children: t })
    );
  };
function BF() {
  return C.useContext(kw);
}
const DF = (n) => {
    let {
      sdkOptions: e = {},
      storageInterface: t,
      supportedChains: r,
      activeChain: a,
      signer: i,
      children: s,
      clientId: o,
    } = n;
    const c = C.useMemo(() => {
        var d, f;
        return a
          ? typeof a == "number"
            ? a
            : typeof a == "string"
            ? (f = r.find((p) => p.slug === a)) == null
              ? void 0
              : f.chainId
            : a.chainId
          : (d = r[0]) == null
          ? void 0
          : d.chainId;
      }, [a, r]),
      l = C.useMemo(() => {
        let d = c;
        const f = r.find((h) => h.chainId === d);
        !f &&
          d !== void 0 &&
          (console.warn(
            `The chainId ${d} is not in the configured chains, please add it to the ThirdwebProvider`,
          ),
          (d = void 0));
        let p;
        if (f && f.rpc.length > 0)
          try {
            const h = Vd(f, o)[0];
            p = { chainId: f.chainId, rpcUrl: h };
          } catch {}
        const m = { readonlySettings: p, ...e, supportedChains: r };
        let y;
        if ((d && (y = new Da(d, { ...m, clientId: o }, t)), !y))
          if (r.length > 0) (d = r[0].chainId), (y = new Da(d, m, t));
          else {
            console.error(
              "No chains configured, please pass a chain or chains to the ThirdwebProvider",
            );
            return;
          }
        return (y._chainId = d), y;
      }, [c, r, e, t, o]);
    C.useEffect(() => {
      l &&
        l._chainId === c &&
        (i ? l.updateSignerOrProvider(i) : c && l.updateSignerOrProvider(c));
    }, [l, l == null ? void 0 : l._chainId, i, c]);
    const u = C.useMemo(
      () => ({ sdk: l && l._chainId === c ? l : void 0, _inProvider: !0 }),
      [c, l],
    );
    return I.jsx(Aw.Provider, { value: u, children: s });
  },
  OF = (n) => {
    let {
      signer: e,
      children: t,
      queryClient: r,
      supportedChains: a,
      activeChain: i,
      clientId: s,
      ...o
    } = n;
    s ||
      Xv(
        "No clientId provided in ThirdwebSDK. You will have limited access to thirdweb's services for storage, RPC, and account abstraction. You can get a clientId from https://thirdweb.com/create-api-key",
        s,
        void 0,
      );
    const c = a || oi,
      l = C.useMemo(
        () =>
          typeof i == "object" && i !== null
            ? c.find((y) => y.chainId === i.chainId)
              ? c.map((y) => (y.chainId === i.chainId ? i : y))
              : [...c, i]
            : c,
        [c, i],
      ),
      [u, d] = Tw(l, i || l[0], s),
      f = C.useMemo(
        () =>
          !d || typeof d == "string" || typeof d == "number"
            ? u
            : [...u.filter((m) => m.chainId !== d.chainId), d].filter(
                (m, y, h) => y === h.findIndex((g) => g.chainId === m.chainId),
              ),
        [u, d],
      );
    return I.jsx(PF, {
      value: { chains: f, clientId: s },
      children: I.jsx(dk, {
        queryClient: r,
        children: I.jsx(DF, {
          signer: e,
          supportedChains: f,
          clientId: s,
          activeChain: d,
          ...o,
          children: I.jsx(MF, { signer: e, children: t }),
        }),
      }),
    });
  },
  NF = (n) => {
    let { createWalletStorage: e = uw, ...t } = n;
    const { activeChain: r } = t,
      a = t.supportedChains || oi,
      i = C.useMemo(
        () =>
          typeof r == "object" && r !== null
            ? a.find((f) => f.chainId === r.chainId)
              ? a.map((f) => (f.chainId === r.chainId ? r : f))
              : [...a, r]
            : a,
        [a, r],
      ),
      [s, o] = Tw(i, t.activeChain || i[0], t.clientId),
      c = C.useMemo(() => {
        if (typeof o == "number") {
          const u = s.find((d) => d.chainId === o);
          if (!u)
            throw new Error(
              `Invalid chainId: ${o}. It is not one of supportedChains`,
            );
          return u;
        }
        if (typeof o == "string") {
          const u = s.find((d) => d.slug === o);
          if (!u)
            throw new Error(
              `Invalid chain: "${o}". It is not one of supportedChains`,
            );
          return u;
        }
        return o;
      }, [o, s]),
      l = t.dAppMeta;
    return I.jsx(bF.Provider, {
      value: t.theme,
      children: I.jsx(xF, {
        chains: s,
        supportedWallets: t.supportedWallets,
        shouldAutoConnect: t.autoConnect,
        createWalletStorage: e,
        dAppMeta: l,
        activeChain: c,
        autoSwitch: t.autoSwitch,
        autoConnectTimeout: t.autoConnectTimeout,
        clientId: t.clientId,
        children: I.jsx(FF, {
          queryClient: t.queryClient,
          sdkOptions: t.sdkOptions,
          supportedChains: s,
          activeChain: c,
          storageInterface: t.storageInterface,
          authConfig: t.authConfig,
          clientId: t.clientId,
          children: I.jsx(_F, { value: t.authConfig, children: t.children }),
        }),
      }),
    });
  },
  FF = (n) => {
    var a;
    let { children: e, ...t } = n;
    const r = (a = Tr()) == null ? void 0 : a.signer;
    return I.jsx(OF, { signer: r, ...t, children: e });
  };
function LF() {
  return BF().address;
}
function _w() {
  const n = Ew();
  return n == null ? void 0 : n.storage;
}
function $F(n) {
  if (n.sheet) return n.sheet;
  for (var e = 0; e < document.styleSheets.length; e++)
    if (document.styleSheets[e].ownerNode === n) return document.styleSheets[e];
}
function WF(n) {
  var e = document.createElement("style");
  return (
    e.setAttribute("data-emotion", n.key),
    n.nonce !== void 0 && e.setAttribute("nonce", n.nonce),
    e.appendChild(document.createTextNode("")),
    e.setAttribute("data-s", ""),
    e
  );
}
var UF = (function () {
    function n(t) {
      var r = this;
      (this._insertTag = function (a) {
        var i;
        r.tags.length === 0
          ? r.insertionPoint
            ? (i = r.insertionPoint.nextSibling)
            : r.prepend
            ? (i = r.container.firstChild)
            : (i = r.before)
          : (i = r.tags[r.tags.length - 1].nextSibling),
          r.container.insertBefore(a, i),
          r.tags.push(a);
      }),
        (this.isSpeedy = t.speedy === void 0 ? !0 : t.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = t.nonce),
        (this.key = t.key),
        (this.container = t.container),
        (this.prepend = t.prepend),
        (this.insertionPoint = t.insertionPoint),
        (this.before = null);
    }
    var e = n.prototype;
    return (
      (e.hydrate = function (r) {
        r.forEach(this._insertTag);
      }),
      (e.insert = function (r) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 &&
          this._insertTag(WF(this));
        var a = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var i = $F(a);
          try {
            i.insertRule(r, i.cssRules.length);
          } catch {}
        } else a.appendChild(document.createTextNode(r));
        this.ctr++;
      }),
      (e.flush = function () {
        this.tags.forEach(function (r) {
          return r.parentNode && r.parentNode.removeChild(r);
        }),
          (this.tags = []),
          (this.ctr = 0);
      }),
      n
    );
  })(),
  Jt = "-ms-",
  Ed = "-moz-",
  je = "-webkit-",
  Sw = "comm",
  $m = "rule",
  Wm = "decl",
  jF = "@import",
  Pw = "@keyframes",
  zF = "@layer",
  HF = Math.abs,
  wf = String.fromCharCode,
  qF = Object.assign;
function VF(n, e) {
  return Ut(n, 0) ^ 45
    ? (((((((e << 2) ^ Ut(n, 0)) << 2) ^ Ut(n, 1)) << 2) ^ Ut(n, 2)) << 2) ^
        Ut(n, 3)
    : 0;
}
function Iw(n) {
  return n.trim();
}
function GF(n, e) {
  return (n = e.exec(n)) ? n[0] : n;
}
function ze(n, e, t) {
  return n.replace(e, t);
}
function ph(n, e) {
  return n.indexOf(e);
}
function Ut(n, e) {
  return n.charCodeAt(e) | 0;
}
function Ac(n, e, t) {
  return n.slice(e, t);
}
function _r(n) {
  return n.length;
}
function Um(n) {
  return n.length;
}
function _l(n, e) {
  return e.push(n), n;
}
function KF(n, e) {
  return n.map(e).join("");
}
var Tf = 1,
  Qs = 1,
  Rw = 0,
  An = 0,
  Ct = 0,
  ho = "";
function Cf(n, e, t, r, a, i, s) {
  return {
    value: n,
    root: e,
    parent: t,
    type: r,
    props: a,
    children: i,
    line: Tf,
    column: Qs,
    length: s,
    return: "",
  };
}
function Oo(n, e) {
  return qF(Cf("", null, null, "", null, null, 0), n, { length: -n.length }, e);
}
function QF() {
  return Ct;
}
function YF() {
  return (
    (Ct = An > 0 ? Ut(ho, --An) : 0), Qs--, Ct === 10 && ((Qs = 1), Tf--), Ct
  );
}
function Nn() {
  return (
    (Ct = An < Rw ? Ut(ho, An++) : 0), Qs++, Ct === 10 && ((Qs = 1), Tf++), Ct
  );
}
function Wr() {
  return Ut(ho, An);
}
function Yl() {
  return An;
}
function Zc(n, e) {
  return Ac(ho, n, e);
}
function Ec(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Mw(n) {
  return (Tf = Qs = 1), (Rw = _r((ho = n))), (An = 0), [];
}
function Bw(n) {
  return (ho = ""), n;
}
function Jl(n) {
  return Iw(Zc(An - 1, hh(n === 91 ? n + 2 : n === 40 ? n + 1 : n)));
}
function JF(n) {
  for (; (Ct = Wr()) && Ct < 33; ) Nn();
  return Ec(n) > 2 || Ec(Ct) > 3 ? "" : " ";
}
function XF(n, e) {
  for (
    ;
    --e &&
    Nn() &&
    !(Ct < 48 || Ct > 102 || (Ct > 57 && Ct < 65) || (Ct > 70 && Ct < 97));

  );
  return Zc(n, Yl() + (e < 6 && Wr() == 32 && Nn() == 32));
}
function hh(n) {
  for (; Nn(); )
    switch (Ct) {
      case n:
        return An;
      case 34:
      case 39:
        n !== 34 && n !== 39 && hh(Ct);
        break;
      case 40:
        n === 41 && hh(n);
        break;
      case 92:
        Nn();
        break;
    }
  return An;
}
function ZF(n, e) {
  for (; Nn() && n + Ct !== 47 + 10; )
    if (n + Ct === 42 + 42 && Wr() === 47) break;
  return "/*" + Zc(e, An - 1) + "*" + wf(n === 47 ? n : Nn());
}
function eL(n) {
  for (; !Ec(Wr()); ) Nn();
  return Zc(n, An);
}
function tL(n) {
  return Bw(Xl("", null, null, null, [""], (n = Mw(n)), 0, [0], n));
}
function Xl(n, e, t, r, a, i, s, o, c) {
  for (
    var l = 0,
      u = 0,
      d = s,
      f = 0,
      p = 0,
      m = 0,
      y = 1,
      h = 1,
      g = 1,
      v = 0,
      w = "",
      T = a,
      A = i,
      E = r,
      _ = w;
    h;

  )
    switch (((m = v), (v = Nn()))) {
      case 40:
        if (m != 108 && Ut(_, d - 1) == 58) {
          ph((_ += ze(Jl(v), "&", "&\f")), "&\f") != -1 && (g = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        _ += Jl(v);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        _ += JF(m);
        break;
      case 92:
        _ += XF(Yl() - 1, 7);
        continue;
      case 47:
        switch (Wr()) {
          case 42:
          case 47:
            _l(nL(ZF(Nn(), Yl()), e, t), c);
            break;
          default:
            _ += "/";
        }
        break;
      case 123 * y:
        o[l++] = _r(_) * g;
      case 125 * y:
      case 59:
      case 0:
        switch (v) {
          case 0:
          case 125:
            h = 0;
          case 59 + u:
            g == -1 && (_ = ze(_, /\f/g, "")),
              p > 0 &&
                _r(_) - d &&
                _l(
                  p > 32
                    ? $b(_ + ";", r, t, d - 1)
                    : $b(ze(_, " ", "") + ";", r, t, d - 2),
                  c,
                );
            break;
          case 59:
            _ += ";";
          default:
            if (
              (_l((E = Lb(_, e, t, l, u, a, o, w, (T = []), (A = []), d)), i),
              v === 123)
            )
              if (u === 0) Xl(_, e, E, E, T, i, d, o, A);
              else
                switch (f === 99 && Ut(_, 3) === 110 ? 100 : f) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Xl(
                      n,
                      E,
                      E,
                      r && _l(Lb(n, E, E, 0, 0, a, o, w, a, (T = []), d), A),
                      a,
                      A,
                      d,
                      o,
                      r ? T : A,
                    );
                    break;
                  default:
                    Xl(_, E, E, E, [""], A, 0, o, A);
                }
        }
        (l = u = p = 0), (y = g = 1), (w = _ = ""), (d = s);
        break;
      case 58:
        (d = 1 + _r(_)), (p = m);
      default:
        if (y < 1) {
          if (v == 123) --y;
          else if (v == 125 && y++ == 0 && YF() == 125) continue;
        }
        switch (((_ += wf(v)), v * y)) {
          case 38:
            g = u > 0 ? 1 : ((_ += "\f"), -1);
            break;
          case 44:
            (o[l++] = (_r(_) - 1) * g), (g = 1);
            break;
          case 64:
            Wr() === 45 && (_ += Jl(Nn())),
              (f = Wr()),
              (u = d = _r((w = _ += eL(Yl())))),
              v++;
            break;
          case 45:
            m === 45 && _r(_) == 2 && (y = 0);
        }
    }
  return i;
}
function Lb(n, e, t, r, a, i, s, o, c, l, u) {
  for (
    var d = a - 1, f = a === 0 ? i : [""], p = Um(f), m = 0, y = 0, h = 0;
    m < r;
    ++m
  )
    for (var g = 0, v = Ac(n, d + 1, (d = HF((y = s[m])))), w = n; g < p; ++g)
      (w = Iw(y > 0 ? f[g] + " " + v : ze(v, /&\f/g, f[g]))) && (c[h++] = w);
  return Cf(n, e, t, a === 0 ? $m : o, c, l, u);
}
function nL(n, e, t) {
  return Cf(n, e, t, Sw, wf(QF()), Ac(n, 2, -2), 0);
}
function $b(n, e, t, r) {
  return Cf(n, e, t, Wm, Ac(n, 0, r), Ac(n, r + 1, -1), r);
}
function Is(n, e) {
  for (var t = "", r = Um(n), a = 0; a < r; a++) t += e(n[a], a, n, e) || "";
  return t;
}
function rL(n, e, t, r) {
  switch (n.type) {
    case zF:
      if (n.children.length) break;
    case jF:
    case Wm:
      return (n.return = n.return || n.value);
    case Sw:
      return "";
    case Pw:
      return (n.return = n.value + "{" + Is(n.children, r) + "}");
    case $m:
      n.value = n.props.join(",");
  }
  return _r((t = Is(n.children, r)))
    ? (n.return = n.value + "{" + t + "}")
    : "";
}
function aL(n) {
  var e = Um(n);
  return function (t, r, a, i) {
    for (var s = "", o = 0; o < e; o++) s += n[o](t, r, a, i) || "";
    return s;
  };
}
function iL(n) {
  return function (e) {
    e.root || ((e = e.return) && n(e));
  };
}
var Wb = function (e) {
  var t = new WeakMap();
  return function (r) {
    if (t.has(r)) return t.get(r);
    var a = e(r);
    return t.set(r, a), a;
  };
};
function Dw(n) {
  var e = Object.create(null);
  return function (t) {
    return e[t] === void 0 && (e[t] = n(t)), e[t];
  };
}
var sL = function (e, t, r) {
    for (
      var a = 0, i = 0;
      (a = i), (i = Wr()), a === 38 && i === 12 && (t[r] = 1), !Ec(i);

    )
      Nn();
    return Zc(e, An);
  },
  oL = function (e, t) {
    var r = -1,
      a = 44;
    do
      switch (Ec(a)) {
        case 0:
          a === 38 && Wr() === 12 && (t[r] = 1), (e[r] += sL(An - 1, t, r));
          break;
        case 2:
          e[r] += Jl(a);
          break;
        case 4:
          if (a === 44) {
            (e[++r] = Wr() === 58 ? "&\f" : ""), (t[r] = e[r].length);
            break;
          }
        default:
          e[r] += wf(a);
      }
    while ((a = Nn()));
    return e;
  },
  cL = function (e, t) {
    return Bw(oL(Mw(e), t));
  },
  Ub = new WeakMap(),
  lL = function (e) {
    if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
      for (
        var t = e.value,
          r = e.parent,
          a = e.column === r.column && e.line === r.line;
        r.type !== "rule";

      )
        if (((r = r.parent), !r)) return;
      if (
        !(e.props.length === 1 && t.charCodeAt(0) !== 58 && !Ub.get(r)) &&
        !a
      ) {
        Ub.set(e, !0);
        for (
          var i = [], s = cL(t, i), o = r.props, c = 0, l = 0;
          c < s.length;
          c++
        )
          for (var u = 0; u < o.length; u++, l++)
            e.props[l] = i[c] ? s[c].replace(/&\f/g, o[u]) : o[u] + " " + s[c];
      }
    }
  },
  uL = function (e) {
    if (e.type === "decl") {
      var t = e.value;
      t.charCodeAt(0) === 108 &&
        t.charCodeAt(2) === 98 &&
        ((e.return = ""), (e.value = ""));
    }
  };
function Ow(n, e) {
  switch (VF(n, e)) {
    case 5103:
      return je + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return je + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return je + n + Ed + n + Jt + n + n;
    case 6828:
    case 4268:
      return je + n + Jt + n + n;
    case 6165:
      return je + n + Jt + "flex-" + n + n;
    case 5187:
      return (
        je + n + ze(n, /(\w+).+(:[^]+)/, je + "box-$1$2" + Jt + "flex-$1$2") + n
      );
    case 5443:
      return je + n + Jt + "flex-item-" + ze(n, /flex-|-self/, "") + n;
    case 4675:
      return (
        je +
        n +
        Jt +
        "flex-line-pack" +
        ze(n, /align-content|flex-|-self/, "") +
        n
      );
    case 5548:
      return je + n + Jt + ze(n, "shrink", "negative") + n;
    case 5292:
      return je + n + Jt + ze(n, "basis", "preferred-size") + n;
    case 6060:
      return (
        je +
        "box-" +
        ze(n, "-grow", "") +
        je +
        n +
        Jt +
        ze(n, "grow", "positive") +
        n
      );
    case 4554:
      return je + ze(n, /([^-])(transform)/g, "$1" + je + "$2") + n;
    case 6187:
      return (
        ze(
          ze(ze(n, /(zoom-|grab)/, je + "$1"), /(image-set)/, je + "$1"),
          n,
          "",
        ) + n
      );
    case 5495:
    case 3959:
      return ze(n, /(image-set\([^]*)/, je + "$1$`$1");
    case 4968:
      return (
        ze(
          ze(n, /(.+:)(flex-)?(.*)/, je + "box-pack:$3" + Jt + "flex-pack:$3"),
          /s.+-b[^;]+/,
          "justify",
        ) +
        je +
        n +
        n
      );
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return ze(n, /(.+)-inline(.+)/, je + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (_r(n) - 1 - e > 6)
        switch (Ut(n, e + 1)) {
          case 109:
            if (Ut(n, e + 4) !== 45) break;
          case 102:
            return (
              ze(
                n,
                /(.+:)(.+)-([^]+)/,
                "$1" +
                  je +
                  "$2-$3$1" +
                  Ed +
                  (Ut(n, e + 3) == 108 ? "$3" : "$2-$3"),
              ) + n
            );
          case 115:
            return ~ph(n, "stretch")
              ? Ow(ze(n, "stretch", "fill-available"), e) + n
              : n;
        }
      break;
    case 4949:
      if (Ut(n, e + 1) !== 115) break;
    case 6444:
      switch (Ut(n, _r(n) - 3 - (~ph(n, "!important") && 10))) {
        case 107:
          return ze(n, ":", ":" + je) + n;
        case 101:
          return (
            ze(
              n,
              /(.+:)([^;!]+)(;|!.+)?/,
              "$1" +
                je +
                (Ut(n, 14) === 45 ? "inline-" : "") +
                "box$3$1" +
                je +
                "$2$3$1" +
                Jt +
                "$2box$3",
            ) + n
          );
      }
      break;
    case 5936:
      switch (Ut(n, e + 11)) {
        case 114:
          return je + n + Jt + ze(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
          return je + n + Jt + ze(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        case 45:
          return je + n + Jt + ze(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
      return je + n + Jt + n + n;
  }
  return n;
}
var dL = function (e, t, r, a) {
    if (e.length > -1 && !e.return)
      switch (e.type) {
        case Wm:
          e.return = Ow(e.value, e.length);
          break;
        case Pw:
          return Is([Oo(e, { value: ze(e.value, "@", "@" + je) })], a);
        case $m:
          if (e.length)
            return KF(e.props, function (i) {
              switch (GF(i, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return Is(
                    [Oo(e, { props: [ze(i, /:(read-\w+)/, ":" + Ed + "$1")] })],
                    a,
                  );
                case "::placeholder":
                  return Is(
                    [
                      Oo(e, {
                        props: [ze(i, /:(plac\w+)/, ":" + je + "input-$1")],
                      }),
                      Oo(e, { props: [ze(i, /:(plac\w+)/, ":" + Ed + "$1")] }),
                      Oo(e, { props: [ze(i, /:(plac\w+)/, Jt + "input-$1")] }),
                    ],
                    a,
                  );
              }
              return "";
            });
      }
  },
  fL = [dL],
  pL = function (e) {
    var t = e.key;
    if (t === "css") {
      var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(r, function (y) {
        var h = y.getAttribute("data-emotion");
        h.indexOf(" ") !== -1 &&
          (document.head.appendChild(y), y.setAttribute("data-s", ""));
      });
    }
    var a = e.stylisPlugins || fL,
      i = {},
      s,
      o = [];
    (s = e.container || document.head),
      Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + t + ' "]'),
        function (y) {
          for (
            var h = y.getAttribute("data-emotion").split(" "), g = 1;
            g < h.length;
            g++
          )
            i[h[g]] = !0;
          o.push(y);
        },
      );
    var c,
      l = [lL, uL];
    {
      var u,
        d = [
          rL,
          iL(function (y) {
            u.insert(y);
          }),
        ],
        f = aL(l.concat(a, d)),
        p = function (h) {
          return Is(tL(h), f);
        };
      c = function (h, g, v, w) {
        (u = v),
          p(h ? h + "{" + g.styles + "}" : g.styles),
          w && (m.inserted[g.name] = !0);
      };
    }
    var m = {
      key: t,
      sheet: new UF({
        key: t,
        container: s,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint,
      }),
      nonce: e.nonce,
      inserted: i,
      registered: {},
      insert: c,
    };
    return m.sheet.hydrate(o), m;
  };
function ve() {
  return (
    (ve = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    ve.apply(this, arguments)
  );
}
var hL = !0;
function mL(n, e, t) {
  var r = "";
  return (
    t.split(" ").forEach(function (a) {
      n[a] !== void 0 ? e.push(n[a] + ";") : (r += a + " ");
    }),
    r
  );
}
var Nw = function (e, t, r) {
    var a = e.key + "-" + t.name;
    (r === !1 || hL === !1) &&
      e.registered[a] === void 0 &&
      (e.registered[a] = t.styles);
  },
  yL = function (e, t, r) {
    Nw(e, t, r);
    var a = e.key + "-" + t.name;
    if (e.inserted[t.name] === void 0) {
      var i = t;
      do e.insert(t === i ? "." + a : "", i, e.sheet, !0), (i = i.next);
      while (i !== void 0);
    }
  };
function gL(n) {
  for (var e = 0, t, r = 0, a = n.length; a >= 4; ++r, a -= 4)
    (t =
      (n.charCodeAt(r) & 255) |
      ((n.charCodeAt(++r) & 255) << 8) |
      ((n.charCodeAt(++r) & 255) << 16) |
      ((n.charCodeAt(++r) & 255) << 24)),
      (t = (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)),
      (t ^= t >>> 24),
      (e =
        ((t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)) ^
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)));
  switch (a) {
    case 3:
      e ^= (n.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (n.charCodeAt(r + 1) & 255) << 8;
    case 1:
      (e ^= n.charCodeAt(r) & 255),
        (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16));
  }
  return (
    (e ^= e >>> 13),
    (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
    ((e ^ (e >>> 15)) >>> 0).toString(36)
  );
}
var bL = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  xL = /[A-Z]|^ms/g,
  vL = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  Fw = function (e) {
    return e.charCodeAt(1) === 45;
  },
  jb = function (e) {
    return e != null && typeof e != "boolean";
  },
  Z0 = Dw(function (n) {
    return Fw(n) ? n : n.replace(xL, "-$&").toLowerCase();
  }),
  zb = function (e, t) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof t == "string")
          return t.replace(vL, function (r, a, i) {
            return (Sr = { name: a, styles: i, next: Sr }), a;
          });
    }
    return bL[e] !== 1 && !Fw(e) && typeof t == "number" && t !== 0
      ? t + "px"
      : t;
  };
function kc(n, e, t) {
  if (t == null) return "";
  if (t.__emotion_styles !== void 0) return t;
  switch (typeof t) {
    case "boolean":
      return "";
    case "object": {
      if (t.anim === 1)
        return (Sr = { name: t.name, styles: t.styles, next: Sr }), t.name;
      if (t.styles !== void 0) {
        var r = t.next;
        if (r !== void 0)
          for (; r !== void 0; )
            (Sr = { name: r.name, styles: r.styles, next: Sr }), (r = r.next);
        var a = t.styles + ";";
        return a;
      }
      return wL(n, e, t);
    }
    case "function": {
      if (n !== void 0) {
        var i = Sr,
          s = t(n);
        return (Sr = i), kc(n, e, s);
      }
      break;
    }
  }
  if (e == null) return t;
  var o = e[t];
  return o !== void 0 ? o : t;
}
function wL(n, e, t) {
  var r = "";
  if (Array.isArray(t))
    for (var a = 0; a < t.length; a++) r += kc(n, e, t[a]) + ";";
  else
    for (var i in t) {
      var s = t[i];
      if (typeof s != "object")
        e != null && e[s] !== void 0
          ? (r += i + "{" + e[s] + "}")
          : jb(s) && (r += Z0(i) + ":" + zb(i, s) + ";");
      else if (
        Array.isArray(s) &&
        typeof s[0] == "string" &&
        (e == null || e[s[0]] === void 0)
      )
        for (var o = 0; o < s.length; o++)
          jb(s[o]) && (r += Z0(i) + ":" + zb(i, s[o]) + ";");
      else {
        var c = kc(n, e, s);
        switch (i) {
          case "animation":
          case "animationName": {
            r += Z0(i) + ":" + c + ";";
            break;
          }
          default:
            r += i + "{" + c + "}";
        }
      }
    }
  return r;
}
var Hb = /label:\s*([^\s;\n{]+)\s*(;|$)/g,
  Sr,
  Lw = function (e, t, r) {
    if (
      e.length === 1 &&
      typeof e[0] == "object" &&
      e[0] !== null &&
      e[0].styles !== void 0
    )
      return e[0];
    var a = !0,
      i = "";
    Sr = void 0;
    var s = e[0];
    s == null || s.raw === void 0
      ? ((a = !1), (i += kc(r, t, s)))
      : (i += s[0]);
    for (var o = 1; o < e.length; o++) (i += kc(r, t, e[o])), a && (i += s[o]);
    Hb.lastIndex = 0;
    for (var c = "", l; (l = Hb.exec(i)) !== null; ) c += "-" + l[1];
    var u = gL(i) + c;
    return { name: u, styles: i, next: Sr };
  },
  TL = function (e) {
    return e();
  },
  CL = dp["useInsertionEffect"] ? dp["useInsertionEffect"] : !1,
  AL = CL || TL,
  $w = C.createContext(typeof HTMLElement < "u" ? pL({ key: "css" }) : null);
$w.Provider;
var EL = function (e) {
    return C.forwardRef(function (t, r) {
      var a = C.useContext($w);
      return e(t, a, r);
    });
  },
  kd = C.createContext({}),
  kL = function () {
    return C.useContext(kd);
  },
  _L = function (e, t) {
    if (typeof t == "function") {
      var r = t(e);
      return r;
    }
    return ve({}, e, t);
  },
  SL = Wb(function (n) {
    return Wb(function (e) {
      return _L(n, e);
    });
  }),
  Ww = function (e) {
    var t = C.useContext(kd);
    return (
      e.theme !== t && (t = SL(t)(e.theme)),
      C.createElement(kd.Provider, { value: t }, e.children)
    );
  };
function PL() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return Lw(e);
}
var Vr = function () {
    var e = PL.apply(void 0, arguments),
      t = "animation-" + e.name;
    return {
      name: t,
      styles: "@keyframes " + t + "{" + e.styles + "}",
      anim: 1,
      toString: function () {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      },
    };
  },
  IL =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  RL = Dw(function (n) {
    return (
      IL.test(n) ||
      (n.charCodeAt(0) === 111 &&
        n.charCodeAt(1) === 110 &&
        n.charCodeAt(2) < 91)
    );
  }),
  ML = RL,
  BL = function (e) {
    return e !== "theme";
  },
  qb = function (e) {
    return typeof e == "string" && e.charCodeAt(0) > 96 ? ML : BL;
  },
  Vb = function (e, t, r) {
    var a;
    if (t) {
      var i = t.shouldForwardProp;
      a =
        e.__emotion_forwardProp && i
          ? function (s) {
              return e.__emotion_forwardProp(s) && i(s);
            }
          : i;
    }
    return typeof a != "function" && r && (a = e.__emotion_forwardProp), a;
  },
  DL = function (e) {
    var t = e.cache,
      r = e.serialized,
      a = e.isStringTag;
    return (
      Nw(t, r, a),
      AL(function () {
        return yL(t, r, a);
      }),
      null
    );
  },
  OL = function n(e, t) {
    var r = e.__emotion_real === e,
      a = (r && e.__emotion_base) || e,
      i,
      s;
    t !== void 0 && ((i = t.label), (s = t.target));
    var o = Vb(e, t, r),
      c = o || qb(a),
      l = !c("as");
    return function () {
      var u = arguments,
        d =
          r && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
      if (
        (i !== void 0 && d.push("label:" + i + ";"),
        u[0] == null || u[0].raw === void 0)
      )
        d.push.apply(d, u);
      else {
        d.push(u[0][0]);
        for (var f = u.length, p = 1; p < f; p++) d.push(u[p], u[0][p]);
      }
      var m = EL(function (y, h, g) {
        var v = (l && y.as) || a,
          w = "",
          T = [],
          A = y;
        if (y.theme == null) {
          A = {};
          for (var E in y) A[E] = y[E];
          A.theme = C.useContext(kd);
        }
        typeof y.className == "string"
          ? (w = mL(h.registered, T, y.className))
          : y.className != null && (w = y.className + " ");
        var _ = Lw(d.concat(T), h.registered, A);
        (w += h.key + "-" + _.name), s !== void 0 && (w += " " + s);
        var S = l && o === void 0 ? qb(v) : c,
          W = {};
        for (var D in y) (l && D === "as") || (S(D) && (W[D] = y[D]));
        return (
          (W.className = w),
          (W.ref = g),
          C.createElement(
            C.Fragment,
            null,
            C.createElement(DL, {
              cache: h,
              serialized: _,
              isStringTag: typeof v == "string",
            }),
            C.createElement(v, W),
          )
        );
      });
      return (
        (m.displayName =
          i !== void 0
            ? i
            : "Styled(" +
              (typeof a == "string"
                ? a
                : a.displayName || a.name || "Component") +
              ")"),
        (m.defaultProps = e.defaultProps),
        (m.__emotion_real = m),
        (m.__emotion_base = a),
        (m.__emotion_styles = d),
        (m.__emotion_forwardProp = o),
        Object.defineProperty(m, "toString", {
          value: function () {
            return "." + s;
          },
        }),
        (m.withComponent = function (y, h) {
          return n(y, ve({}, t, h, { shouldForwardProp: Vb(m, h, !0) })).apply(
            void 0,
            d,
          );
        }),
        m
      );
    };
  },
  NL = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan",
  ],
  ie = OL.bind();
NL.forEach(function (n) {
  ie[n] = ie(n);
});
const gt = {
    mauve1: "hsl(246, 6.0%, 9.0%)",
    mauve2: "hsl(240, 5.1%, 11.6%)",
    mauve3: "hsl(241, 5.0%, 14.3%)",
    mauve4: "hsl(242, 4.9%, 16.5%)",
    mauve5: "hsl(243, 4.9%, 18.8%)",
    mauve6: "hsl(244, 4.9%, 21.5%)",
    mauve7: "hsl(245, 4.9%, 25.4%)",
    mauve8: "hsl(247, 4.8%, 32.5%)",
    mauve9: "hsl(252, 4.0%, 45.2%)",
    mauve10: "hsl(247, 3.4%, 50.7%)",
    mauve11: "hsl(253, 4.0%, 63.7%)",
    mauve12: "hsl(256, 6.0%, 93.2%)",
  },
  Rs = {
    blue1: "hsl(206, 100%, 99.2%)",
    blue2: "hsl(210, 100%, 98.0%)",
    blue3: "hsl(209, 100%, 96.5%)",
    blue4: "hsl(210, 98.8%, 94.0%)",
    blue5: "hsl(209, 95.0%, 90.1%)",
    blue6: "hsl(209, 81.2%, 84.5%)",
    blue7: "hsl(208, 77.5%, 76.9%)",
    blue8: "hsl(206, 81.9%, 65.3%)",
    blue9: "hsl(206, 100%, 50.0%)",
    blue10: "hsl(208, 100%, 47.3%)",
    blue11: "hsl(211, 100%, 43.2%)",
    blue12: "hsl(211, 100%, 15.0%)",
  },
  Uw = {
    green1: "hsl(136, 50.0%, 98.9%)",
    green2: "hsl(138, 62.5%, 96.9%)",
    green3: "hsl(139, 55.2%, 94.5%)",
    green4: "hsl(140, 48.7%, 91.0%)",
    green5: "hsl(141, 43.7%, 86.0%)",
    green6: "hsl(143, 40.3%, 79.0%)",
    green7: "hsl(146, 38.5%, 69.0%)",
    green8: "hsl(151, 40.2%, 54.1%)",
    green9: "hsl(151, 55.0%, 41.5%)",
    green10: "hsl(152, 57.5%, 37.6%)",
    green11: "hsl(153, 67.0%, 28.5%)",
    green12: "hsl(155, 40.0%, 14.0%)",
  },
  Et = {
    mauve1: "hsl(300, 20.0%, 99.0%)",
    mauve2: "hsl(300, 7.7%, 97.5%)",
    mauve3: "hsl(294, 5.5%, 95.3%)",
    mauve4: "hsl(289, 4.7%, 93.3%)",
    mauve5: "hsl(283, 4.4%, 91.3%)",
    mauve6: "hsl(278, 4.1%, 89.1%)",
    mauve7: "hsl(271, 3.9%, 86.3%)",
    mauve8: "hsl(255, 3.7%, 78.8%)",
    mauve9: "hsl(252, 4.0%, 57.3%)",
    mauve10: "hsl(253, 3.5%, 53.5%)",
    mauve11: "hsl(252, 4.0%, 44.8%)",
    mauve12: "hsl(260, 25.0%, 11.0%)",
  },
  Oa = {
    tomato1: "hsl(10, 100%, 99.4%)",
    tomato2: "hsl(8, 100%, 98.4%)",
    tomato3: "hsl(8, 100%, 96.6%)",
    tomato4: "hsl(8, 100%, 94.3%)",
    tomato5: "hsl(8, 92.8%, 91.0%)",
    tomato6: "hsl(9, 84.7%, 86.3%)",
    tomato7: "hsl(10, 77.3%, 79.5%)",
    tomato8: "hsl(10, 71.6%, 71.0%)",
    tomato9: "hsl(10, 78.0%, 54.0%)",
    tomato10: "hsl(10, 71.5%, 50.0%)",
    tomato11: "hsl(10, 82.0%, 43.5%)",
    tomato12: "hsl(10, 50.0%, 13.5%)",
  },
  jw = {
    overlay: { subdued: "rgba(0, 0, 0, 0.74)" },
    bg: {
      base: gt.mauve1,
      baseHover: gt.mauve2,
      elevated: gt.mauve3,
      elevatedHover: gt.mauve4,
      highlighted: gt.mauve5,
      inverted: gt.mauve12,
      invertedFocused: gt.mauve7,
      danger: Oa.tomato12,
    },
    border: { base: gt.mauve3, elevated: gt.mauve4 },
    badge: { secondary: gt.mauve6 },
    text: {
      neutral: gt.mauve12,
      inverted: gt.mauve1,
      secondary: gt.mauve9,
      danger: Oa.tomato9,
    },
    icon: {
      secondary: gt.mauve11,
      primary: gt.mauve12,
      inverted: gt.mauve1,
      danger: Oa.tomato9,
      success: Uw.green7,
      link: Rs.blue9,
    },
    link: { primary: Rs.blue9, primaryHover: gt.mauve12 },
    input: {
      bg: gt.mauve3,
      bgHover: gt.mauve5,
      outline: gt.mauve5,
      focusRing: Rs.blue9,
      errorRing: Oa.tomato9,
    },
    tooltip: { bg: "black", text: "white" },
  },
  zw = {
    overlay: { subdued: "rgba(0, 0, 0, 0.4)" },
    bg: {
      base: Et.mauve1,
      baseHover: Et.mauve2,
      elevated: Et.mauve3,
      elevatedHover: Et.mauve4,
      highlighted: Et.mauve5,
      inverted: Et.mauve12,
      invertedFocused: Et.mauve7,
      danger: Oa.tomato4,
    },
    border: { base: Et.mauve6, elevated: Et.mauve7 },
    badge: { secondary: Et.mauve1 },
    text: {
      neutral: Et.mauve12,
      inverted: Et.mauve1,
      secondary: Et.mauve10,
      danger: Oa.tomato9,
    },
    icon: {
      secondary: Et.mauve10,
      primary: Et.mauve12,
      inverted: Et.mauve1,
      danger: Oa.tomato9,
      success: Uw.green9,
      link: Rs.blue11,
    },
    link: { primary: Rs.blue11, primaryHover: Et.mauve12 },
    input: {
      bg: Et.mauve3,
      bgHover: gt.mauve5,
      outline: Et.mauve7,
      focusRing: Rs.blue11,
      errorRing: Oa.tomato10,
    },
    tooltip: { bg: "black", text: "white" },
  },
  ke = { xs: "12px", sm: "14px", md: "16px", lg: "20px", xl: "24px" },
  he = {
    xxs: "6px",
    xs: "8px",
    sm: "12px",
    md: "16px",
    lg: "24px",
    xl: "32px",
    xxl: "48px",
  },
  st = { sm: "6px", md: "8px", lg: "12px", xl: "20px", xxl: "32px" },
  qe = { xs: "12", sm: "16", md: "24", lg: "32", xl: "48" },
  gn = { mobile: "@media (max-width: 640px)" },
  Af = {
    sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
    md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
    lg: "0 10px 15px -3px rgb(0 0 0 / 0.07), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
    xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
  },
  Hw = (n) => {
    const e = kL();
    return I.jsx($L, {
      style: { width: qe[n.size], height: qe[n.size] },
      viewBox: "0 0 50 50",
      children: I.jsx(WL, {
        cx: "25",
        cy: "25",
        r: "20",
        fill: "none",
        stroke: e.icon[n.color || "primary"],
        strokeWidth: "4",
      }),
    });
  },
  FL = Vr`
 0% {
    stroke-dasharray: 1, 150;
    stroke-dashoffset: 0;
  }
  50% {
    stroke-dasharray: 90, 150;
    stroke-dashoffset: -35;
  }
  100% {
    stroke-dasharray: 90, 150;
    stroke-dashoffset: -124;
  }
`,
  LL = Vr`
100% {
    transform: rotate(360deg);
  }
`,
  $L = ie.svg`
  animation: ${LL} 2s linear infinite;
  width: 1em;
  height: 1em;
`,
  WL = ie.circle`
  stroke-linecap: round;
  animation: ${FL} 1.5s ease-in-out infinite;
`,
  At = (n) => {
    let { y: e } = n;
    return I.jsx("div", { style: { height: he[e] } });
  },
  jm = ie.button`
  all: unset;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: ${st.md};
  padding: ${he.sm} ${he.sm};
  font-size: ${ke.md};
  font-weight: 500;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  line-height: 1;
  flex-shrink: 0;

  &:focus {
    box-shadow: 0 0 0 3px
      ${(n) => {
        switch (n.variant) {
          case "inverted":
            return n.theme.bg.invertedFocused;
          case "secondary":
            return n.theme.bg.highlighted;
          case "link":
            return "none";
          case "danger":
            return n.theme.text.danger;
        }
      }};
  }

  box-shadow: ${(n) => {
    switch (n.variant) {
      case "danger":
        return `0 0 0 2px ${n.theme.text.danger}`;
      case "link":
        return "none";
      default:
        return "none";
    }
  }};

  background: ${(n) => {
    switch (n.variant) {
      case "inverted":
        return n.theme.bg.inverted;
      case "secondary":
        return n.theme.bg.elevated;
      case "link":
        return "transparent";
      case "danger":
        return "none";
    }
  }};
  color: ${(n) => {
    switch (n.variant) {
      case "inverted":
        return n.theme.text.inverted;
      case "secondary":
        return n.theme.text.neutral;
      case "link":
        return n.theme.link.primary;
      case "danger":
        return n.theme.text.danger;
    }
  }};

  ${(n) => {
    if (n.variant === "link")
      return `
      padding: 0;
      &:hover {
        color: ${n.theme.text.neutral};
      }`;
  }}

  cursor: pointer;

  /* pressed effect */
  &:active {
    transform: translateY(1px);
  }

  &[disabled] {
    cursor: not-allowed;
  }
`,
  zm = ie.button`
  all: unset;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: ${st.sm};
  -webkit-tap-highlight-color: transparent;
  color: ${(n) => {
    switch (n.variant) {
      case "neutral":
        return n.theme.text.neutral;
      case "secondary":
        return n.theme.text.secondary;
    }
  }};
  padding: 2px;
  transition:
    background 0.2s ease,
    color 0.2s ease;
  &:hover {
    background: ${(n) => n.theme.bg.elevated};
    color: ${(n) => n.theme.text.neutral};
  }
`,
  UL = ie.button`
  all: unset;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: ${st.sm};
  padding: ${he.sm};
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  color: ${(n) => n.theme.text.secondary};
  &:hover {
    color: ${(n) => n.theme.text.neutral};
  }
  &[disabled] {
    cursor: not-allowed;
  }
`;
ie.label`
  font-size: ${ke.sm};
  color: ${(n) => n.theme.text.neutral};
  display: block;
`;
const jL = ie.input`
  font-size: ${ke.md};
  display: block;
  padding: ${he.sm};
  box-sizing: border-box;
  width: 100%;
  outline: none;
  border: none;
  border-radius: 6px;
  color: ${(n) => n.theme.text.neutral};
  -webkit-appearance: none;
  appearance: none;
  background: ${(n) => {
    switch (n.variant) {
      case "secondary":
        return n.theme.bg.elevated;
      default:
        return "transparent";
    }
  }};

  &::placeholder {
    color: ${(n) => n.theme.text.secondary};
  }

  box-shadow: 0 0 0 1.5px
    ${(n) => {
      switch (n.variant) {
        case "outline":
          return n.theme.input.outline;
        case "transparent":
          return "transparent";
        case "secondary":
          return n.theme.bg.elevated;
      }
    }};

  /* when browser auto-fills the input  */
  &:-webkit-autofill {
    -webkit-text-fill-color: ${(n) => n.theme.text.neutral};
    -webkit-box-shadow: 0 0 0px 1000px ${(n) =>
      n.theme.bg.elevated} inset !important;
    box-shadow: 0 0 0px 1000px ${(n) => n.theme.bg.elevated} inset !important;
    transition: background-color 5000s ease-in-out 0s;
  }

  &:-webkit-autofill:focus {
    -webkit-box-shadow:
      0 0 0px 1000px ${(n) => n.theme.bg.elevated} inset,
      0 0 0 2px ${(n) => n.theme.input.focusRing} !important;
    box-shadow:
      0 0 0px 1000px ${(n) => n.theme.bg.elevated} inset,
      0 0 0 2px ${(n) => n.theme.input.focusRing} !important;
  }

  &:focus {
    box-shadow: 0 0 0 2px ${(n) => n.theme.input.focusRing};
  }

  /* show overflow ellipsis for long text - but not if it's a type="password"  */
  &:not([type="password"]) {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  &[data-error="true"] {
    box-shadow: 0 0 0 2px ${(n) => n.theme.input.errorRing} !important;
  }

  &[disabled] {
    cursor: not-allowed;
  }
`;
ie.div`
  display: flex;
  border-radius: ${st.sm};
  box-shadow: 0 0 0px 1.5px ${(n) => n.theme.input.outline};

  /* show focus ring on container instead of input  */
  &:focus-within {
    box-shadow: 0 0 0px 2px ${(n) => n.theme.input.focusRing};
  }

  input:focus {
    box-shadow: none;
  }

  /* show error ring on container instead of input  */
  &[data-error="true"] {
    box-shadow: 0 0 0px 2px ${(n) => n.theme.input.errorRing};
  }
`;
ie.p`
  all: unset;
  font-size: ${ke.sm};
  display: block;
  color: ${(n) => n.theme.input.errorRing};
  line-height: 1.5;
`;
ie.div`
  display: flex;
  justify-content: flex-end;
  gap: ${he.sm};
`;
const hr = (n) => {
    const e = _w();
    return I.jsx("img", {
      width: n.width,
      height: n.height,
      src: e
        ? e.resolveScheme(n.src)
        : n.src.replace("ipfs://", "https://ipfs.io/ipfs/"),
      alt: n.alt || "",
      loading: n.loading,
      decoding: "async",
      style: { height: n.height + "px", width: n.width + "px" },
      className: n.className,
    });
  },
  qw = (n) =>
    I.jsxs("div", {
      style: {
        display: "flex",
        flexDirection: n.flexDirection,
        justifyContent: n.justifyContent,
        alignItems: n.alignItems,
        flexWrap: n.wrap,
        gap: n.gap ? he[n.gap] : void 0,
        ...(n.style || {}),
      },
      children: [" ", n.children],
    });
var Ef = {},
  Vw = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4, MODE_KANJI: 8 },
  zL = Vw;
function Gw(n) {
  (this.mode = zL.MODE_8BIT_BYTE), (this.data = n);
}
Gw.prototype = {
  getLength: function (n) {
    return this.data.length;
  },
  write: function (n) {
    for (var e = 0; e < this.data.length; e++)
      n.put(this.data.charCodeAt(e), 8);
  },
};
var HL = Gw,
  Kw = { L: 1, M: 0, Q: 3, H: 2 },
  Sl = Kw;
function Mr(n, e) {
  (this.totalCount = n), (this.dataCount = e);
}
Mr.RS_BLOCK_TABLE = [
  [1, 26, 19],
  [1, 26, 16],
  [1, 26, 13],
  [1, 26, 9],
  [1, 44, 34],
  [1, 44, 28],
  [1, 44, 22],
  [1, 44, 16],
  [1, 70, 55],
  [1, 70, 44],
  [2, 35, 17],
  [2, 35, 13],
  [1, 100, 80],
  [2, 50, 32],
  [2, 50, 24],
  [4, 25, 9],
  [1, 134, 108],
  [2, 67, 43],
  [2, 33, 15, 2, 34, 16],
  [2, 33, 11, 2, 34, 12],
  [2, 86, 68],
  [4, 43, 27],
  [4, 43, 19],
  [4, 43, 15],
  [2, 98, 78],
  [4, 49, 31],
  [2, 32, 14, 4, 33, 15],
  [4, 39, 13, 1, 40, 14],
  [2, 121, 97],
  [2, 60, 38, 2, 61, 39],
  [4, 40, 18, 2, 41, 19],
  [4, 40, 14, 2, 41, 15],
  [2, 146, 116],
  [3, 58, 36, 2, 59, 37],
  [4, 36, 16, 4, 37, 17],
  [4, 36, 12, 4, 37, 13],
  [2, 86, 68, 2, 87, 69],
  [4, 69, 43, 1, 70, 44],
  [6, 43, 19, 2, 44, 20],
  [6, 43, 15, 2, 44, 16],
  [4, 101, 81],
  [1, 80, 50, 4, 81, 51],
  [4, 50, 22, 4, 51, 23],
  [3, 36, 12, 8, 37, 13],
  [2, 116, 92, 2, 117, 93],
  [6, 58, 36, 2, 59, 37],
  [4, 46, 20, 6, 47, 21],
  [7, 42, 14, 4, 43, 15],
  [4, 133, 107],
  [8, 59, 37, 1, 60, 38],
  [8, 44, 20, 4, 45, 21],
  [12, 33, 11, 4, 34, 12],
  [3, 145, 115, 1, 146, 116],
  [4, 64, 40, 5, 65, 41],
  [11, 36, 16, 5, 37, 17],
  [11, 36, 12, 5, 37, 13],
  [5, 109, 87, 1, 110, 88],
  [5, 65, 41, 5, 66, 42],
  [5, 54, 24, 7, 55, 25],
  [11, 36, 12],
  [5, 122, 98, 1, 123, 99],
  [7, 73, 45, 3, 74, 46],
  [15, 43, 19, 2, 44, 20],
  [3, 45, 15, 13, 46, 16],
  [1, 135, 107, 5, 136, 108],
  [10, 74, 46, 1, 75, 47],
  [1, 50, 22, 15, 51, 23],
  [2, 42, 14, 17, 43, 15],
  [5, 150, 120, 1, 151, 121],
  [9, 69, 43, 4, 70, 44],
  [17, 50, 22, 1, 51, 23],
  [2, 42, 14, 19, 43, 15],
  [3, 141, 113, 4, 142, 114],
  [3, 70, 44, 11, 71, 45],
  [17, 47, 21, 4, 48, 22],
  [9, 39, 13, 16, 40, 14],
  [3, 135, 107, 5, 136, 108],
  [3, 67, 41, 13, 68, 42],
  [15, 54, 24, 5, 55, 25],
  [15, 43, 15, 10, 44, 16],
  [4, 144, 116, 4, 145, 117],
  [17, 68, 42],
  [17, 50, 22, 6, 51, 23],
  [19, 46, 16, 6, 47, 17],
  [2, 139, 111, 7, 140, 112],
  [17, 74, 46],
  [7, 54, 24, 16, 55, 25],
  [34, 37, 13],
  [4, 151, 121, 5, 152, 122],
  [4, 75, 47, 14, 76, 48],
  [11, 54, 24, 14, 55, 25],
  [16, 45, 15, 14, 46, 16],
  [6, 147, 117, 4, 148, 118],
  [6, 73, 45, 14, 74, 46],
  [11, 54, 24, 16, 55, 25],
  [30, 46, 16, 2, 47, 17],
  [8, 132, 106, 4, 133, 107],
  [8, 75, 47, 13, 76, 48],
  [7, 54, 24, 22, 55, 25],
  [22, 45, 15, 13, 46, 16],
  [10, 142, 114, 2, 143, 115],
  [19, 74, 46, 4, 75, 47],
  [28, 50, 22, 6, 51, 23],
  [33, 46, 16, 4, 47, 17],
  [8, 152, 122, 4, 153, 123],
  [22, 73, 45, 3, 74, 46],
  [8, 53, 23, 26, 54, 24],
  [12, 45, 15, 28, 46, 16],
  [3, 147, 117, 10, 148, 118],
  [3, 73, 45, 23, 74, 46],
  [4, 54, 24, 31, 55, 25],
  [11, 45, 15, 31, 46, 16],
  [7, 146, 116, 7, 147, 117],
  [21, 73, 45, 7, 74, 46],
  [1, 53, 23, 37, 54, 24],
  [19, 45, 15, 26, 46, 16],
  [5, 145, 115, 10, 146, 116],
  [19, 75, 47, 10, 76, 48],
  [15, 54, 24, 25, 55, 25],
  [23, 45, 15, 25, 46, 16],
  [13, 145, 115, 3, 146, 116],
  [2, 74, 46, 29, 75, 47],
  [42, 54, 24, 1, 55, 25],
  [23, 45, 15, 28, 46, 16],
  [17, 145, 115],
  [10, 74, 46, 23, 75, 47],
  [10, 54, 24, 35, 55, 25],
  [19, 45, 15, 35, 46, 16],
  [17, 145, 115, 1, 146, 116],
  [14, 74, 46, 21, 75, 47],
  [29, 54, 24, 19, 55, 25],
  [11, 45, 15, 46, 46, 16],
  [13, 145, 115, 6, 146, 116],
  [14, 74, 46, 23, 75, 47],
  [44, 54, 24, 7, 55, 25],
  [59, 46, 16, 1, 47, 17],
  [12, 151, 121, 7, 152, 122],
  [12, 75, 47, 26, 76, 48],
  [39, 54, 24, 14, 55, 25],
  [22, 45, 15, 41, 46, 16],
  [6, 151, 121, 14, 152, 122],
  [6, 75, 47, 34, 76, 48],
  [46, 54, 24, 10, 55, 25],
  [2, 45, 15, 64, 46, 16],
  [17, 152, 122, 4, 153, 123],
  [29, 74, 46, 14, 75, 47],
  [49, 54, 24, 10, 55, 25],
  [24, 45, 15, 46, 46, 16],
  [4, 152, 122, 18, 153, 123],
  [13, 74, 46, 32, 75, 47],
  [48, 54, 24, 14, 55, 25],
  [42, 45, 15, 32, 46, 16],
  [20, 147, 117, 4, 148, 118],
  [40, 75, 47, 7, 76, 48],
  [43, 54, 24, 22, 55, 25],
  [10, 45, 15, 67, 46, 16],
  [19, 148, 118, 6, 149, 119],
  [18, 75, 47, 31, 76, 48],
  [34, 54, 24, 34, 55, 25],
  [20, 45, 15, 61, 46, 16],
];
Mr.getRSBlocks = function (n, e) {
  var t = Mr.getRsBlockTable(n, e);
  if (t == null)
    throw new Error(
      "bad rs block @ typeNumber:" + n + "/errorCorrectLevel:" + e,
    );
  for (var r = t.length / 3, a = new Array(), i = 0; i < r; i++)
    for (
      var s = t[i * 3 + 0], o = t[i * 3 + 1], c = t[i * 3 + 2], l = 0;
      l < s;
      l++
    )
      a.push(new Mr(o, c));
  return a;
};
Mr.getRsBlockTable = function (n, e) {
  switch (e) {
    case Sl.L:
      return Mr.RS_BLOCK_TABLE[(n - 1) * 4 + 0];
    case Sl.M:
      return Mr.RS_BLOCK_TABLE[(n - 1) * 4 + 1];
    case Sl.Q:
      return Mr.RS_BLOCK_TABLE[(n - 1) * 4 + 2];
    case Sl.H:
      return Mr.RS_BLOCK_TABLE[(n - 1) * 4 + 3];
    default:
      return;
  }
};
var qL = Mr;
function Qw() {
  (this.buffer = new Array()), (this.length = 0);
}
Qw.prototype = {
  get: function (n) {
    var e = Math.floor(n / 8);
    return ((this.buffer[e] >>> (7 - (n % 8))) & 1) == 1;
  },
  put: function (n, e) {
    for (var t = 0; t < e; t++) this.putBit(((n >>> (e - t - 1)) & 1) == 1);
  },
  getLengthInBits: function () {
    return this.length;
  },
  putBit: function (n) {
    var e = Math.floor(this.length / 8);
    this.buffer.length <= e && this.buffer.push(0),
      n && (this.buffer[e] |= 128 >>> this.length % 8),
      this.length++;
  },
};
var VL = Qw,
  yr = {
    glog: function (n) {
      if (n < 1) throw new Error("glog(" + n + ")");
      return yr.LOG_TABLE[n];
    },
    gexp: function (n) {
      for (; n < 0; ) n += 255;
      for (; n >= 256; ) n -= 255;
      return yr.EXP_TABLE[n];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256),
  };
for (var jt = 0; jt < 8; jt++) yr.EXP_TABLE[jt] = 1 << jt;
for (var jt = 8; jt < 256; jt++)
  yr.EXP_TABLE[jt] =
    yr.EXP_TABLE[jt - 4] ^
    yr.EXP_TABLE[jt - 5] ^
    yr.EXP_TABLE[jt - 6] ^
    yr.EXP_TABLE[jt - 8];
for (var jt = 0; jt < 255; jt++) yr.LOG_TABLE[yr.EXP_TABLE[jt]] = jt;
var Yw = yr,
  yi = Yw;
function Zl(n, e) {
  if (n.length == null) throw new Error(n.length + "/" + e);
  for (var t = 0; t < n.length && n[t] == 0; ) t++;
  this.num = new Array(n.length - t + e);
  for (var r = 0; r < n.length - t; r++) this.num[r] = n[r + t];
}
Zl.prototype = {
  get: function (n) {
    return this.num[n];
  },
  getLength: function () {
    return this.num.length;
  },
  multiply: function (n) {
    for (
      var e = new Array(this.getLength() + n.getLength() - 1), t = 0;
      t < this.getLength();
      t++
    )
      for (var r = 0; r < n.getLength(); r++)
        e[t + r] ^= yi.gexp(yi.glog(this.get(t)) + yi.glog(n.get(r)));
    return new Zl(e, 0);
  },
  mod: function (n) {
    if (this.getLength() - n.getLength() < 0) return this;
    for (
      var e = yi.glog(this.get(0)) - yi.glog(n.get(0)),
        t = new Array(this.getLength()),
        r = 0;
      r < this.getLength();
      r++
    )
      t[r] = this.get(r);
    for (var r = 0; r < n.getLength(); r++)
      t[r] ^= yi.gexp(yi.glog(n.get(r)) + e);
    return new Zl(t, 0).mod(n);
  },
};
var Jw = Zl,
  Hn = Vw,
  Gb = Jw,
  GL = Yw,
  Ea = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7,
  },
  Lt = {
    PATTERN_POSITION_TABLE: [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170],
    ],
    G15: 1335,
    G18: 7973,
    G15_MASK: 21522,
    getBCHTypeInfo: function (n) {
      for (var e = n << 10; Lt.getBCHDigit(e) - Lt.getBCHDigit(Lt.G15) >= 0; )
        e ^= Lt.G15 << (Lt.getBCHDigit(e) - Lt.getBCHDigit(Lt.G15));
      return ((n << 10) | e) ^ Lt.G15_MASK;
    },
    getBCHTypeNumber: function (n) {
      for (var e = n << 12; Lt.getBCHDigit(e) - Lt.getBCHDigit(Lt.G18) >= 0; )
        e ^= Lt.G18 << (Lt.getBCHDigit(e) - Lt.getBCHDigit(Lt.G18));
      return (n << 12) | e;
    },
    getBCHDigit: function (n) {
      for (var e = 0; n != 0; ) e++, (n >>>= 1);
      return e;
    },
    getPatternPosition: function (n) {
      return Lt.PATTERN_POSITION_TABLE[n - 1];
    },
    getMask: function (n, e, t) {
      switch (n) {
        case Ea.PATTERN000:
          return (e + t) % 2 == 0;
        case Ea.PATTERN001:
          return e % 2 == 0;
        case Ea.PATTERN010:
          return t % 3 == 0;
        case Ea.PATTERN011:
          return (e + t) % 3 == 0;
        case Ea.PATTERN100:
          return (Math.floor(e / 2) + Math.floor(t / 3)) % 2 == 0;
        case Ea.PATTERN101:
          return ((e * t) % 2) + ((e * t) % 3) == 0;
        case Ea.PATTERN110:
          return (((e * t) % 2) + ((e * t) % 3)) % 2 == 0;
        case Ea.PATTERN111:
          return (((e * t) % 3) + ((e + t) % 2)) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + n);
      }
    },
    getErrorCorrectPolynomial: function (n) {
      for (var e = new Gb([1], 0), t = 0; t < n; t++)
        e = e.multiply(new Gb([1, GL.gexp(t)], 0));
      return e;
    },
    getLengthInBits: function (n, e) {
      if (1 <= e && e < 10)
        switch (n) {
          case Hn.MODE_NUMBER:
            return 10;
          case Hn.MODE_ALPHA_NUM:
            return 9;
          case Hn.MODE_8BIT_BYTE:
            return 8;
          case Hn.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + n);
        }
      else if (e < 27)
        switch (n) {
          case Hn.MODE_NUMBER:
            return 12;
          case Hn.MODE_ALPHA_NUM:
            return 11;
          case Hn.MODE_8BIT_BYTE:
            return 16;
          case Hn.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + n);
        }
      else if (e < 41)
        switch (n) {
          case Hn.MODE_NUMBER:
            return 14;
          case Hn.MODE_ALPHA_NUM:
            return 13;
          case Hn.MODE_8BIT_BYTE:
            return 16;
          case Hn.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + n);
        }
      else throw new Error("type:" + e);
    },
    getLostPoint: function (n) {
      for (var e = n.getModuleCount(), t = 0, r = 0; r < e; r++)
        for (var a = 0; a < e; a++) {
          for (var i = 0, s = n.isDark(r, a), o = -1; o <= 1; o++)
            if (!(r + o < 0 || e <= r + o))
              for (var c = -1; c <= 1; c++)
                a + c < 0 ||
                  e <= a + c ||
                  (o == 0 && c == 0) ||
                  (s == n.isDark(r + o, a + c) && i++);
          i > 5 && (t += 3 + i - 5);
        }
      for (var r = 0; r < e - 1; r++)
        for (var a = 0; a < e - 1; a++) {
          var l = 0;
          n.isDark(r, a) && l++,
            n.isDark(r + 1, a) && l++,
            n.isDark(r, a + 1) && l++,
            n.isDark(r + 1, a + 1) && l++,
            (l == 0 || l == 4) && (t += 3);
        }
      for (var r = 0; r < e; r++)
        for (var a = 0; a < e - 6; a++)
          n.isDark(r, a) &&
            !n.isDark(r, a + 1) &&
            n.isDark(r, a + 2) &&
            n.isDark(r, a + 3) &&
            n.isDark(r, a + 4) &&
            !n.isDark(r, a + 5) &&
            n.isDark(r, a + 6) &&
            (t += 40);
      for (var a = 0; a < e; a++)
        for (var r = 0; r < e - 6; r++)
          n.isDark(r, a) &&
            !n.isDark(r + 1, a) &&
            n.isDark(r + 2, a) &&
            n.isDark(r + 3, a) &&
            n.isDark(r + 4, a) &&
            !n.isDark(r + 5, a) &&
            n.isDark(r + 6, a) &&
            (t += 40);
      for (var u = 0, a = 0; a < e; a++)
        for (var r = 0; r < e; r++) n.isDark(r, a) && u++;
      var d = Math.abs((100 * u) / e / e - 50) / 5;
      return (t += d * 10), t;
    },
  },
  KL = Lt,
  QL = HL,
  Xw = qL,
  Zw = VL,
  ui = KL,
  YL = Jw;
function Nr(n, e) {
  (this.typeNumber = n),
    (this.errorCorrectLevel = e),
    (this.modules = null),
    (this.moduleCount = 0),
    (this.dataCache = null),
    (this.dataList = []);
}
var jn = Nr.prototype;
jn.addData = function (n) {
  var e = new QL(n);
  this.dataList.push(e), (this.dataCache = null);
};
jn.isDark = function (n, e) {
  if (n < 0 || this.moduleCount <= n || e < 0 || this.moduleCount <= e)
    throw new Error(n + "," + e);
  return this.modules[n][e];
};
jn.getModuleCount = function () {
  return this.moduleCount;
};
jn.make = function () {
  if (this.typeNumber < 1) {
    var n = 1;
    for (n = 1; n < 40; n++) {
      for (
        var e = Xw.getRSBlocks(n, this.errorCorrectLevel),
          t = new Zw(),
          r = 0,
          a = 0;
        a < e.length;
        a++
      )
        r += e[a].dataCount;
      for (var a = 0; a < this.dataList.length; a++) {
        var i = this.dataList[a];
        t.put(i.mode, 4),
          t.put(i.getLength(), ui.getLengthInBits(i.mode, n)),
          i.write(t);
      }
      if (t.getLengthInBits() <= r * 8) break;
    }
    this.typeNumber = n;
  }
  this.makeImpl(!1, this.getBestMaskPattern());
};
jn.makeImpl = function (n, e) {
  (this.moduleCount = this.typeNumber * 4 + 17),
    (this.modules = new Array(this.moduleCount));
  for (var t = 0; t < this.moduleCount; t++) {
    this.modules[t] = new Array(this.moduleCount);
    for (var r = 0; r < this.moduleCount; r++) this.modules[t][r] = null;
  }
  this.setupPositionProbePattern(0, 0),
    this.setupPositionProbePattern(this.moduleCount - 7, 0),
    this.setupPositionProbePattern(0, this.moduleCount - 7),
    this.setupPositionAdjustPattern(),
    this.setupTimingPattern(),
    this.setupTypeInfo(n, e),
    this.typeNumber >= 7 && this.setupTypeNumber(n),
    this.dataCache == null &&
      (this.dataCache = Nr.createData(
        this.typeNumber,
        this.errorCorrectLevel,
        this.dataList,
      )),
    this.mapData(this.dataCache, e);
};
jn.setupPositionProbePattern = function (n, e) {
  for (var t = -1; t <= 7; t++)
    if (!(n + t <= -1 || this.moduleCount <= n + t))
      for (var r = -1; r <= 7; r++)
        e + r <= -1 ||
          this.moduleCount <= e + r ||
          ((0 <= t && t <= 6 && (r == 0 || r == 6)) ||
          (0 <= r && r <= 6 && (t == 0 || t == 6)) ||
          (2 <= t && t <= 4 && 2 <= r && r <= 4)
            ? (this.modules[n + t][e + r] = !0)
            : (this.modules[n + t][e + r] = !1));
};
jn.getBestMaskPattern = function () {
  for (var n = 0, e = 0, t = 0; t < 8; t++) {
    this.makeImpl(!0, t);
    var r = ui.getLostPoint(this);
    (t == 0 || n > r) && ((n = r), (e = t));
  }
  return e;
};
jn.createMovieClip = function (n, e, t) {
  var r = n.createEmptyMovieClip(e, t),
    a = 1;
  this.make();
  for (var i = 0; i < this.modules.length; i++)
    for (var s = i * a, o = 0; o < this.modules[i].length; o++) {
      var c = o * a,
        l = this.modules[i][o];
      l &&
        (r.beginFill(0, 100),
        r.moveTo(c, s),
        r.lineTo(c + a, s),
        r.lineTo(c + a, s + a),
        r.lineTo(c, s + a),
        r.endFill());
    }
  return r;
};
jn.setupTimingPattern = function () {
  for (var n = 8; n < this.moduleCount - 8; n++)
    this.modules[n][6] == null && (this.modules[n][6] = n % 2 == 0);
  for (var e = 8; e < this.moduleCount - 8; e++)
    this.modules[6][e] == null && (this.modules[6][e] = e % 2 == 0);
};
jn.setupPositionAdjustPattern = function () {
  for (var n = ui.getPatternPosition(this.typeNumber), e = 0; e < n.length; e++)
    for (var t = 0; t < n.length; t++) {
      var r = n[e],
        a = n[t];
      if (this.modules[r][a] == null)
        for (var i = -2; i <= 2; i++)
          for (var s = -2; s <= 2; s++)
            i == -2 || i == 2 || s == -2 || s == 2 || (i == 0 && s == 0)
              ? (this.modules[r + i][a + s] = !0)
              : (this.modules[r + i][a + s] = !1);
    }
};
jn.setupTypeNumber = function (n) {
  for (var e = ui.getBCHTypeNumber(this.typeNumber), t = 0; t < 18; t++) {
    var r = !n && ((e >> t) & 1) == 1;
    this.modules[Math.floor(t / 3)][(t % 3) + this.moduleCount - 8 - 3] = r;
  }
  for (var t = 0; t < 18; t++) {
    var r = !n && ((e >> t) & 1) == 1;
    this.modules[(t % 3) + this.moduleCount - 8 - 3][Math.floor(t / 3)] = r;
  }
};
jn.setupTypeInfo = function (n, e) {
  for (
    var t = (this.errorCorrectLevel << 3) | e, r = ui.getBCHTypeInfo(t), a = 0;
    a < 15;
    a++
  ) {
    var i = !n && ((r >> a) & 1) == 1;
    a < 6
      ? (this.modules[a][8] = i)
      : a < 8
      ? (this.modules[a + 1][8] = i)
      : (this.modules[this.moduleCount - 15 + a][8] = i);
  }
  for (var a = 0; a < 15; a++) {
    var i = !n && ((r >> a) & 1) == 1;
    a < 8
      ? (this.modules[8][this.moduleCount - a - 1] = i)
      : a < 9
      ? (this.modules[8][15 - a - 1 + 1] = i)
      : (this.modules[8][15 - a - 1] = i);
  }
  this.modules[this.moduleCount - 8][8] = !n;
};
jn.mapData = function (n, e) {
  for (
    var t = -1,
      r = this.moduleCount - 1,
      a = 7,
      i = 0,
      s = this.moduleCount - 1;
    s > 0;
    s -= 2
  )
    for (s == 6 && s--; ; ) {
      for (var o = 0; o < 2; o++)
        if (this.modules[r][s - o] == null) {
          var c = !1;
          i < n.length && (c = ((n[i] >>> a) & 1) == 1);
          var l = ui.getMask(e, r, s - o);
          l && (c = !c),
            (this.modules[r][s - o] = c),
            a--,
            a == -1 && (i++, (a = 7));
        }
      if (((r += t), r < 0 || this.moduleCount <= r)) {
        (r -= t), (t = -t);
        break;
      }
    }
};
Nr.PAD0 = 236;
Nr.PAD1 = 17;
Nr.createData = function (n, e, t) {
  for (var r = Xw.getRSBlocks(n, e), a = new Zw(), i = 0; i < t.length; i++) {
    var s = t[i];
    a.put(s.mode, 4),
      a.put(s.getLength(), ui.getLengthInBits(s.mode, n)),
      s.write(a);
  }
  for (var o = 0, i = 0; i < r.length; i++) o += r[i].dataCount;
  if (a.getLengthInBits() > o * 8)
    throw new Error(
      "code length overflow. (" + a.getLengthInBits() + ">" + o * 8 + ")",
    );
  for (
    a.getLengthInBits() + 4 <= o * 8 && a.put(0, 4);
    a.getLengthInBits() % 8 != 0;

  )
    a.putBit(!1);
  for (
    ;
    !(
      a.getLengthInBits() >= o * 8 ||
      (a.put(Nr.PAD0, 8), a.getLengthInBits() >= o * 8)
    );

  )
    a.put(Nr.PAD1, 8);
  return Nr.createBytes(a, r);
};
Nr.createBytes = function (n, e) {
  for (
    var t = 0,
      r = 0,
      a = 0,
      i = new Array(e.length),
      s = new Array(e.length),
      o = 0;
    o < e.length;
    o++
  ) {
    var c = e[o].dataCount,
      l = e[o].totalCount - c;
    (r = Math.max(r, c)), (a = Math.max(a, l)), (i[o] = new Array(c));
    for (var u = 0; u < i[o].length; u++) i[o][u] = 255 & n.buffer[u + t];
    t += c;
    var d = ui.getErrorCorrectPolynomial(l),
      f = new YL(i[o], d.getLength() - 1),
      p = f.mod(d);
    s[o] = new Array(d.getLength() - 1);
    for (var u = 0; u < s[o].length; u++) {
      var m = u + p.getLength() - s[o].length;
      s[o][u] = m >= 0 ? p.get(m) : 0;
    }
  }
  for (var y = 0, u = 0; u < e.length; u++) y += e[u].totalCount;
  for (var h = new Array(y), g = 0, u = 0; u < r; u++)
    for (var o = 0; o < e.length; o++) u < i[o].length && (h[g++] = i[o][u]);
  for (var u = 0; u < a; u++)
    for (var o = 0; o < e.length; o++) u < s[o].length && (h[g++] = s[o][u]);
  return h;
};
var JL = Nr,
  Hm = {};
Object.defineProperty(Hm, "__esModule", { value: !0 });
var XL =
    Object.assign ||
    function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
          Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    },
  ZL = E2,
  qn = t4(ZL),
  e4 = C,
  Pl = t4(e4);
function t4(n) {
  return n && n.__esModule ? n : { default: n };
}
function e$(n, e) {
  var t = {};
  for (var r in n)
    e.indexOf(r) >= 0 ||
      (Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]));
  return t;
}
var t$ = {
    bgColor: qn.default.oneOfType([qn.default.object, qn.default.string])
      .isRequired,
    bgD: qn.default.string.isRequired,
    fgColor: qn.default.oneOfType([qn.default.object, qn.default.string])
      .isRequired,
    fgD: qn.default.string.isRequired,
    size: qn.default.number.isRequired,
    title: qn.default.string,
    viewBoxSize: qn.default.number.isRequired,
    xmlns: qn.default.string,
  },
  n$ = { title: void 0, xmlns: "http://www.w3.org/2000/svg" },
  kf = (0, e4.forwardRef)(function (n, e) {
    var t = n.bgColor,
      r = n.bgD,
      a = n.fgD,
      i = n.fgColor,
      s = n.size,
      o = n.title,
      c = n.viewBoxSize,
      l = e$(n, [
        "bgColor",
        "bgD",
        "fgD",
        "fgColor",
        "size",
        "title",
        "viewBoxSize",
      ]);
    return Pl.default.createElement(
      "svg",
      XL({}, l, { height: s, ref: e, viewBox: "0 0 " + c + " " + c, width: s }),
      o ? Pl.default.createElement("title", null, o) : null,
      Pl.default.createElement("path", { d: r, fill: t }),
      Pl.default.createElement("path", { d: a, fill: i }),
    );
  });
kf.displayName = "QRCodeSvg";
kf.propTypes = t$;
kf.defaultProps = n$;
Hm.default = kf;
Object.defineProperty(Ef, "__esModule", { value: !0 });
Ef.QRCode = void 0;
var r$ =
    Object.assign ||
    function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
          Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    },
  a$ = JL,
  i$ = el(a$),
  s$ = Kw,
  o$ = el(s$),
  c$ = E2,
  Jr = el(c$),
  n4 = C,
  l$ = el(n4),
  u$ = Hm,
  d$ = el(u$);
function el(n) {
  return n && n.__esModule ? n : { default: n };
}
function f$(n, e) {
  var t = {};
  for (var r in n)
    e.indexOf(r) >= 0 ||
      (Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]));
  return t;
}
var p$ = {
    bgColor: Jr.default.oneOfType([Jr.default.object, Jr.default.string]),
    fgColor: Jr.default.oneOfType([Jr.default.object, Jr.default.string]),
    level: Jr.default.string,
    size: Jr.default.number,
    value: Jr.default.string.isRequired,
  },
  h$ = { bgColor: "#FFFFFF", fgColor: "#000000", level: "L", size: 256 },
  tl = (0, n4.forwardRef)(function (n, e) {
    var t = n.bgColor,
      r = n.fgColor,
      a = n.level,
      i = n.size,
      s = n.value,
      o = f$(n, ["bgColor", "fgColor", "level", "size", "value"]),
      c = new i$.default(-1, o$.default[a]);
    c.addData(s), c.make();
    var l = c.modules;
    return l$.default.createElement(
      d$.default,
      r$({}, o, {
        bgColor: t,
        bgD: l
          .map(function (u, d) {
            return u
              .map(function (f, p) {
                return f ? "" : "M " + p + " " + d + " l 1 0 0 1 -1 0 Z";
              })
              .join(" ");
          })
          .join(" "),
        fgColor: r,
        fgD: l
          .map(function (u, d) {
            return u
              .map(function (f, p) {
                return f ? "M " + p + " " + d + " l 1 0 0 1 -1 0 Z" : "";
              })
              .join(" ");
          })
          .join(" "),
        ref: e,
        size: i,
        viewBoxSize: l.length,
      }),
    );
  });
Ef.QRCode = tl;
tl.displayName = "QRCode";
tl.propTypes = p$;
tl.defaultProps = h$;
var m$ = (Ef.default = tl);
function Oe(n, e, { checkForDefaultPrevented: t = !0 } = {}) {
  return function (a) {
    if ((n == null || n(a), t === !1 || !a.defaultPrevented))
      return e == null ? void 0 : e(a);
  };
}
function y$(n, e) {
  typeof n == "function" ? n(e) : n != null && (n.current = e);
}
function r4(...n) {
  return (e) => n.forEach((t) => y$(t, e));
}
function sn(...n) {
  return C.useCallback(r4(...n), n);
}
function ya(n, e = []) {
  let t = [];
  function r(i, s) {
    const o = C.createContext(s),
      c = t.length;
    t = [...t, s];
    function l(d) {
      const { scope: f, children: p, ...m } = d,
        y = (f == null ? void 0 : f[n][c]) || o,
        h = C.useMemo(() => m, Object.values(m));
      return C.createElement(y.Provider, { value: h }, p);
    }
    function u(d, f) {
      const p = (f == null ? void 0 : f[n][c]) || o,
        m = C.useContext(p);
      if (m) return m;
      if (s !== void 0) return s;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return (l.displayName = i + "Provider"), [l, u];
  }
  const a = () => {
    const i = t.map((s) => C.createContext(s));
    return function (o) {
      const c = (o == null ? void 0 : o[n]) || i;
      return C.useMemo(() => ({ [`__scope${n}`]: { ...o, [n]: c } }), [o, c]);
    };
  };
  return (a.scopeName = n), [r, g$(a, ...e)];
}
function g$(...n) {
  const e = n[0];
  if (n.length === 1) return e;
  const t = () => {
    const r = n.map((a) => ({ useScope: a(), scopeName: a.scopeName }));
    return function (i) {
      const s = r.reduce((o, { useScope: c, scopeName: l }) => {
        const d = c(i)[`__scope${l}`];
        return { ...o, ...d };
      }, {});
      return C.useMemo(() => ({ [`__scope${e.scopeName}`]: s }), [s]);
    };
  };
  return (t.scopeName = e.scopeName), t;
}
const Ys =
    globalThis != null && globalThis.document ? C.useLayoutEffect : () => {},
  b$ = dp["useId".toString()] || (() => {});
let x$ = 0;
function eu(n) {
  const [e, t] = C.useState(b$());
  return (
    Ys(() => {
      n || t((r) => r ?? String(x$++));
    }, [n]),
    n || (e ? `radix-${e}` : "")
  );
}
function da(n) {
  const e = C.useRef(n);
  return (
    C.useEffect(() => {
      e.current = n;
    }),
    C.useMemo(
      () =>
        (...t) => {
          var r;
          return (r = e.current) === null || r === void 0
            ? void 0
            : r.call(e, ...t);
        },
      [],
    )
  );
}
function a4({ prop: n, defaultProp: e, onChange: t = () => {} }) {
  const [r, a] = v$({ defaultProp: e, onChange: t }),
    i = n !== void 0,
    s = i ? n : r,
    o = da(t),
    c = C.useCallback(
      (l) => {
        if (i) {
          const d = typeof l == "function" ? l(n) : l;
          d !== n && o(d);
        } else a(l);
      },
      [i, n, a, o],
    );
  return [s, c];
}
function v$({ defaultProp: n, onChange: e }) {
  const t = C.useState(n),
    [r] = t,
    a = C.useRef(r),
    i = da(e);
  return (
    C.useEffect(() => {
      a.current !== r && (i(r), (a.current = r));
    }, [r, a, i]),
    t
  );
}
const Wi = C.forwardRef((n, e) => {
  const { children: t, ...r } = n,
    a = C.Children.toArray(t),
    i = a.find(w$);
  if (i) {
    const s = i.props.children,
      o = a.map((c) =>
        c === i
          ? C.Children.count(s) > 1
            ? C.Children.only(null)
            : C.isValidElement(s)
            ? s.props.children
            : null
          : c,
      );
    return C.createElement(
      mh,
      ve({}, r, { ref: e }),
      C.isValidElement(s) ? C.cloneElement(s, void 0, o) : null,
    );
  }
  return C.createElement(mh, ve({}, r, { ref: e }), t);
});
Wi.displayName = "Slot";
const mh = C.forwardRef((n, e) => {
  const { children: t, ...r } = n;
  return C.isValidElement(t)
    ? C.cloneElement(t, { ...T$(r, t.props), ref: e ? r4(e, t.ref) : t.ref })
    : C.Children.count(t) > 1
    ? C.Children.only(null)
    : null;
});
mh.displayName = "SlotClone";
const i4 = ({ children: n }) => C.createElement(C.Fragment, null, n);
function w$(n) {
  return C.isValidElement(n) && n.type === i4;
}
function T$(n, e) {
  const t = { ...e };
  for (const r in e) {
    const a = n[r],
      i = e[r];
    /^on[A-Z]/.test(r)
      ? a && i
        ? (t[r] = (...o) => {
            i(...o), a(...o);
          })
        : a && (t[r] = a)
      : r === "style"
      ? (t[r] = { ...a, ...i })
      : r === "className" && (t[r] = [a, i].filter(Boolean).join(" "));
  }
  return { ...n, ...t };
}
const C$ = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul",
  ],
  kn = C$.reduce((n, e) => {
    const t = C.forwardRef((r, a) => {
      const { asChild: i, ...s } = r,
        o = i ? Wi : e;
      return (
        C.useEffect(() => {
          window[Symbol.for("radix-ui")] = !0;
        }, []),
        C.createElement(o, ve({}, s, { ref: a }))
      );
    });
    return (t.displayName = `Primitive.${e}`), { ...n, [e]: t };
  }, {});
function s4(n, e) {
  n && Sh.flushSync(() => n.dispatchEvent(e));
}
function A$(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = da(n);
  C.useEffect(() => {
    const r = (a) => {
      a.key === "Escape" && t(a);
    };
    return (
      e.addEventListener("keydown", r),
      () => e.removeEventListener("keydown", r)
    );
  }, [t, e]);
}
const yh = "dismissableLayer.update",
  E$ = "dismissableLayer.pointerDownOutside",
  k$ = "dismissableLayer.focusOutside";
let Kb;
const _$ = C.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set(),
  }),
  _f = C.forwardRef((n, e) => {
    var t;
    const {
        disableOutsidePointerEvents: r = !1,
        onEscapeKeyDown: a,
        onPointerDownOutside: i,
        onFocusOutside: s,
        onInteractOutside: o,
        onDismiss: c,
        ...l
      } = n,
      u = C.useContext(_$),
      [d, f] = C.useState(null),
      p =
        (t = d == null ? void 0 : d.ownerDocument) !== null && t !== void 0
          ? t
          : globalThis == null
          ? void 0
          : globalThis.document,
      [, m] = C.useState({}),
      y = sn(e, (S) => f(S)),
      h = Array.from(u.layers),
      [g] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1),
      v = h.indexOf(g),
      w = d ? h.indexOf(d) : -1,
      T = u.layersWithOutsidePointerEventsDisabled.size > 0,
      A = w >= v,
      E = S$((S) => {
        const W = S.target,
          D = [...u.branches].some((L) => L.contains(W));
        !A ||
          D ||
          (i == null || i(S),
          o == null || o(S),
          S.defaultPrevented || c == null || c());
      }, p),
      _ = P$((S) => {
        const W = S.target;
        [...u.branches].some((L) => L.contains(W)) ||
          (s == null || s(S),
          o == null || o(S),
          S.defaultPrevented || c == null || c());
      }, p);
    return (
      A$((S) => {
        w === u.layers.size - 1 &&
          (a == null || a(S),
          !S.defaultPrevented && c && (S.preventDefault(), c()));
      }, p),
      C.useEffect(() => {
        if (d)
          return (
            r &&
              (u.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((Kb = p.body.style.pointerEvents),
                (p.body.style.pointerEvents = "none")),
              u.layersWithOutsidePointerEventsDisabled.add(d)),
            u.layers.add(d),
            Qb(),
            () => {
              r &&
                u.layersWithOutsidePointerEventsDisabled.size === 1 &&
                (p.body.style.pointerEvents = Kb);
            }
          );
      }, [d, p, r, u]),
      C.useEffect(
        () => () => {
          d &&
            (u.layers.delete(d),
            u.layersWithOutsidePointerEventsDisabled.delete(d),
            Qb());
        },
        [d, u],
      ),
      C.useEffect(() => {
        const S = () => m({});
        return (
          document.addEventListener(yh, S),
          () => document.removeEventListener(yh, S)
        );
      }, []),
      C.createElement(
        kn.div,
        ve({}, l, {
          ref: y,
          style: {
            pointerEvents: T ? (A ? "auto" : "none") : void 0,
            ...n.style,
          },
          onFocusCapture: Oe(n.onFocusCapture, _.onFocusCapture),
          onBlurCapture: Oe(n.onBlurCapture, _.onBlurCapture),
          onPointerDownCapture: Oe(
            n.onPointerDownCapture,
            E.onPointerDownCapture,
          ),
        }),
      )
    );
  });
function S$(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = da(n),
    r = C.useRef(!1),
    a = C.useRef(() => {});
  return (
    C.useEffect(() => {
      const i = (o) => {
          if (o.target && !r.current) {
            let l = function () {
              o4(E$, t, c, { discrete: !0 });
            };
            const c = { originalEvent: o };
            o.pointerType === "touch"
              ? (e.removeEventListener("click", a.current),
                (a.current = l),
                e.addEventListener("click", a.current, { once: !0 }))
              : l();
          }
          r.current = !1;
        },
        s = window.setTimeout(() => {
          e.addEventListener("pointerdown", i);
        }, 0);
      return () => {
        window.clearTimeout(s),
          e.removeEventListener("pointerdown", i),
          e.removeEventListener("click", a.current);
      };
    }, [e, t]),
    { onPointerDownCapture: () => (r.current = !0) }
  );
}
function P$(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = da(n),
    r = C.useRef(!1);
  return (
    C.useEffect(() => {
      const a = (i) => {
        i.target &&
          !r.current &&
          o4(k$, t, { originalEvent: i }, { discrete: !1 });
      };
      return (
        e.addEventListener("focusin", a),
        () => e.removeEventListener("focusin", a)
      );
    }, [e, t]),
    {
      onFocusCapture: () => (r.current = !0),
      onBlurCapture: () => (r.current = !1),
    }
  );
}
function Qb() {
  const n = new CustomEvent(yh);
  document.dispatchEvent(n);
}
function o4(n, e, t, { discrete: r }) {
  const a = t.originalEvent.target,
    i = new CustomEvent(n, { bubbles: !1, cancelable: !0, detail: t });
  e && a.addEventListener(n, e, { once: !0 }),
    r ? s4(a, i) : a.dispatchEvent(i);
}
const ep = "focusScope.autoFocusOnMount",
  tp = "focusScope.autoFocusOnUnmount",
  Yb = { bubbles: !1, cancelable: !0 },
  qm = C.forwardRef((n, e) => {
    const {
        loop: t = !1,
        trapped: r = !1,
        onMountAutoFocus: a,
        onUnmountAutoFocus: i,
        ...s
      } = n,
      [o, c] = C.useState(null),
      l = da(a),
      u = da(i),
      d = C.useRef(null),
      f = sn(e, (y) => c(y)),
      p = C.useRef({
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        },
      }).current;
    C.useEffect(() => {
      if (r) {
        let y = function (w) {
            if (p.paused || !o) return;
            const T = w.target;
            o.contains(T) ? (d.current = T) : _a(d.current, { select: !0 });
          },
          h = function (w) {
            if (p.paused || !o) return;
            const T = w.relatedTarget;
            T !== null && (o.contains(T) || _a(d.current, { select: !0 }));
          },
          g = function (w) {
            const T = document.activeElement;
            for (const A of w)
              A.removedNodes.length > 0 &&
                ((o != null && o.contains(T)) || _a(o));
          };
        document.addEventListener("focusin", y),
          document.addEventListener("focusout", h);
        const v = new MutationObserver(g);
        return (
          o && v.observe(o, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", y),
              document.removeEventListener("focusout", h),
              v.disconnect();
          }
        );
      }
    }, [r, o, p.paused]),
      C.useEffect(() => {
        if (o) {
          Xb.add(p);
          const y = document.activeElement;
          if (!o.contains(y)) {
            const g = new CustomEvent(ep, Yb);
            o.addEventListener(ep, l),
              o.dispatchEvent(g),
              g.defaultPrevented ||
                (I$(O$(c4(o)), { select: !0 }),
                document.activeElement === y && _a(o));
          }
          return () => {
            o.removeEventListener(ep, l),
              setTimeout(() => {
                const g = new CustomEvent(tp, Yb);
                o.addEventListener(tp, u),
                  o.dispatchEvent(g),
                  g.defaultPrevented || _a(y ?? document.body, { select: !0 }),
                  o.removeEventListener(tp, u),
                  Xb.remove(p);
              }, 0);
          };
        }
      }, [o, l, u, p]);
    const m = C.useCallback(
      (y) => {
        if ((!t && !r) || p.paused) return;
        const h = y.key === "Tab" && !y.altKey && !y.ctrlKey && !y.metaKey,
          g = document.activeElement;
        if (h && g) {
          const v = y.currentTarget,
            [w, T] = R$(v);
          w && T
            ? !y.shiftKey && g === T
              ? (y.preventDefault(), t && _a(w, { select: !0 }))
              : y.shiftKey &&
                g === w &&
                (y.preventDefault(), t && _a(T, { select: !0 }))
            : g === v && y.preventDefault();
        }
      },
      [t, r, p.paused],
    );
    return C.createElement(
      kn.div,
      ve({ tabIndex: -1 }, s, { ref: f, onKeyDown: m }),
    );
  });
function I$(n, { select: e = !1 } = {}) {
  const t = document.activeElement;
  for (const r of n)
    if ((_a(r, { select: e }), document.activeElement !== t)) return;
}
function R$(n) {
  const e = c4(n),
    t = Jb(e, n),
    r = Jb(e.reverse(), n);
  return [t, r];
}
function c4(n) {
  const e = [],
    t = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const a = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || a
          ? NodeFilter.FILTER_SKIP
          : r.tabIndex >= 0
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_SKIP;
      },
    });
  for (; t.nextNode(); ) e.push(t.currentNode);
  return e;
}
function Jb(n, e) {
  for (const t of n) if (!M$(t, { upTo: e })) return t;
}
function M$(n, { upTo: e }) {
  if (getComputedStyle(n).visibility === "hidden") return !0;
  for (; n; ) {
    if (e !== void 0 && n === e) return !1;
    if (getComputedStyle(n).display === "none") return !0;
    n = n.parentElement;
  }
  return !1;
}
function B$(n) {
  return n instanceof HTMLInputElement && "select" in n;
}
function _a(n, { select: e = !1 } = {}) {
  if (n && n.focus) {
    const t = document.activeElement;
    n.focus({ preventScroll: !0 }), n !== t && B$(n) && e && n.select();
  }
}
const Xb = D$();
function D$() {
  let n = [];
  return {
    add(e) {
      const t = n[0];
      e !== t && (t == null || t.pause()), (n = Zb(n, e)), n.unshift(e);
    },
    remove(e) {
      var t;
      (n = Zb(n, e)), (t = n[0]) === null || t === void 0 || t.resume();
    },
  };
}
function Zb(n, e) {
  const t = [...n],
    r = t.indexOf(e);
  return r !== -1 && t.splice(r, 1), t;
}
function O$(n) {
  return n.filter((e) => e.tagName !== "A");
}
const N$ = C.forwardRef((n, e) => {
  var t;
  const {
    container: r = globalThis == null ||
    (t = globalThis.document) === null ||
    t === void 0
      ? void 0
      : t.body,
    ...a
  } = n;
  return r
    ? I8.createPortal(C.createElement(kn.div, ve({}, a, { ref: e })), r)
    : null;
});
function F$(n, e) {
  return C.useReducer((t, r) => {
    const a = e[t][r];
    return a ?? t;
  }, n);
}
const Xi = (n) => {
  const { present: e, children: t } = n,
    r = L$(e),
    a =
      typeof t == "function" ? t({ present: r.isPresent }) : C.Children.only(t),
    i = sn(r.ref, a.ref);
  return typeof t == "function" || r.isPresent
    ? C.cloneElement(a, { ref: i })
    : null;
};
Xi.displayName = "Presence";
function L$(n) {
  const [e, t] = C.useState(),
    r = C.useRef({}),
    a = C.useRef(n),
    i = C.useRef("none"),
    s = n ? "mounted" : "unmounted",
    [o, c] = F$(s, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    });
  return (
    C.useEffect(() => {
      const l = Il(r.current);
      i.current = o === "mounted" ? l : "none";
    }, [o]),
    Ys(() => {
      const l = r.current,
        u = a.current;
      if (u !== n) {
        const f = i.current,
          p = Il(l);
        n
          ? c("MOUNT")
          : p === "none" || (l == null ? void 0 : l.display) === "none"
          ? c("UNMOUNT")
          : c(u && f !== p ? "ANIMATION_OUT" : "UNMOUNT"),
          (a.current = n);
      }
    }, [n, c]),
    Ys(() => {
      if (e) {
        const l = (d) => {
            const p = Il(r.current).includes(d.animationName);
            d.target === e && p && Sh.flushSync(() => c("ANIMATION_END"));
          },
          u = (d) => {
            d.target === e && (i.current = Il(r.current));
          };
        return (
          e.addEventListener("animationstart", u),
          e.addEventListener("animationcancel", l),
          e.addEventListener("animationend", l),
          () => {
            e.removeEventListener("animationstart", u),
              e.removeEventListener("animationcancel", l),
              e.removeEventListener("animationend", l);
          }
        );
      } else c("ANIMATION_END");
    }, [e, c]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(o),
      ref: C.useCallback((l) => {
        l && (r.current = getComputedStyle(l)), t(l);
      }, []),
    }
  );
}
function Il(n) {
  return (n == null ? void 0 : n.animationName) || "none";
}
let np = 0;
function Vm() {
  C.useEffect(() => {
    var n, e;
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return (
      document.body.insertAdjacentElement(
        "afterbegin",
        (n = t[0]) !== null && n !== void 0 ? n : e2(),
      ),
      document.body.insertAdjacentElement(
        "beforeend",
        (e = t[1]) !== null && e !== void 0 ? e : e2(),
      ),
      np++,
      () => {
        np === 1 &&
          document
            .querySelectorAll("[data-radix-focus-guard]")
            .forEach((r) => r.remove()),
          np--;
      }
    );
  }, []);
}
function e2() {
  const n = document.createElement("span");
  return (
    n.setAttribute("data-radix-focus-guard", ""),
    (n.tabIndex = 0),
    (n.style.cssText =
      "outline: none; opacity: 0; position: fixed; pointer-events: none"),
    n
  );
}
var gh = function (n, e) {
  return (
    (gh =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, r) {
          t.__proto__ = r;
        }) ||
      function (t, r) {
        for (var a in r)
          Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]);
      }),
    gh(n, e)
  );
};
function $$(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Class extends value " + String(e) + " is not a constructor or null",
    );
  gh(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype =
    e === null ? Object.create(e) : ((t.prototype = e.prototype), new t());
}
var gr = function () {
  return (
    (gr =
      Object.assign ||
      function (e) {
        for (var t, r = 1, a = arguments.length; r < a; r++) {
          t = arguments[r];
          for (var i in t)
            Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        }
        return e;
      }),
    gr.apply(this, arguments)
  );
};
function Gm(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(n); a < r.length; a++)
      e.indexOf(r[a]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[a]) &&
        (t[r[a]] = n[r[a]]);
  return t;
}
function W$(n, e, t, r) {
  var a = arguments.length,
    i =
      a < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, t)) : r,
    s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    i = Reflect.decorate(n, e, t, r);
  else
    for (var o = n.length - 1; o >= 0; o--)
      (s = n[o]) && (i = (a < 3 ? s(i) : a > 3 ? s(e, t, i) : s(e, t)) || i);
  return a > 3 && i && Object.defineProperty(e, t, i), i;
}
function U$(n, e) {
  return function (t, r) {
    e(t, r, n);
  };
}
function j$(n, e, t, r, a, i) {
  function s(g) {
    if (g !== void 0 && typeof g != "function")
      throw new TypeError("Function expected");
    return g;
  }
  for (
    var o = r.kind,
      c = o === "getter" ? "get" : o === "setter" ? "set" : "value",
      l = !e && n ? (r.static ? n : n.prototype) : null,
      u = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}),
      d,
      f = !1,
      p = t.length - 1;
    p >= 0;
    p--
  ) {
    var m = {};
    for (var y in r) m[y] = y === "access" ? {} : r[y];
    for (var y in r.access) m.access[y] = r.access[y];
    m.addInitializer = function (g) {
      if (f)
        throw new TypeError(
          "Cannot add initializers after decoration has completed",
        );
      i.push(s(g || null));
    };
    var h = (0, t[p])(o === "accessor" ? { get: u.get, set: u.set } : u[c], m);
    if (o === "accessor") {
      if (h === void 0) continue;
      if (h === null || typeof h != "object")
        throw new TypeError("Object expected");
      (d = s(h.get)) && (u.get = d),
        (d = s(h.set)) && (u.set = d),
        (d = s(h.init)) && a.push(d);
    } else (d = s(h)) && (o === "field" ? a.push(d) : (u[c] = d));
  }
  l && Object.defineProperty(l, r.name, u), (f = !0);
}
function z$(n, e, t) {
  for (var r = arguments.length > 2, a = 0; a < e.length; a++)
    t = r ? e[a].call(n, t) : e[a].call(n);
  return r ? t : void 0;
}
function H$(n) {
  return typeof n == "symbol" ? n : "".concat(n);
}
function q$(n, e, t) {
  return (
    typeof e == "symbol" &&
      (e = e.description ? "[".concat(e.description, "]") : ""),
    Object.defineProperty(n, "name", {
      configurable: !0,
      value: t ? "".concat(t, " ", e) : e,
    })
  );
}
function V$(n, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(n, e);
}
function G$(n, e, t, r) {
  function a(i) {
    return i instanceof t
      ? i
      : new t(function (s) {
          s(i);
        });
  }
  return new (t || (t = Promise))(function (i, s) {
    function o(u) {
      try {
        l(r.next(u));
      } catch (d) {
        s(d);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (d) {
        s(d);
      }
    }
    function l(u) {
      u.done ? i(u.value) : a(u.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
}
function K$(n, e) {
  var t = {
      label: 0,
      sent: function () {
        if (i[0] & 1) throw i[1];
        return i[1];
      },
      trys: [],
      ops: [],
    },
    r,
    a,
    i,
    s;
  return (
    (s = { next: o(0), throw: o(1), return: o(2) }),
    typeof Symbol == "function" &&
      (s[Symbol.iterator] = function () {
        return this;
      }),
    s
  );
  function o(l) {
    return function (u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; s && ((s = 0), l[0] && (t = 0)), t; )
      try {
        if (
          ((r = 1),
          a &&
            (i =
              l[0] & 2
                ? a.return
                : l[0]
                ? a.throw || ((i = a.return) && i.call(a), 0)
                : a.next) &&
            !(i = i.call(a, l[1])).done)
        )
          return i;
        switch (((a = 0), i && (l = [l[0] & 2, i.value]), l[0])) {
          case 0:
          case 1:
            i = l;
            break;
          case 4:
            return t.label++, { value: l[1], done: !1 };
          case 5:
            t.label++, (a = l[1]), (l = [0]);
            continue;
          case 7:
            (l = t.ops.pop()), t.trys.pop();
            continue;
          default:
            if (
              ((i = t.trys),
              !(i = i.length > 0 && i[i.length - 1]) &&
                (l[0] === 6 || l[0] === 2))
            ) {
              t = 0;
              continue;
            }
            if (l[0] === 3 && (!i || (l[1] > i[0] && l[1] < i[3]))) {
              t.label = l[1];
              break;
            }
            if (l[0] === 6 && t.label < i[1]) {
              (t.label = i[1]), (i = l);
              break;
            }
            if (i && t.label < i[2]) {
              (t.label = i[2]), t.ops.push(l);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        l = e.call(n, t);
      } catch (u) {
        (l = [6, u]), (a = 0);
      } finally {
        r = i = 0;
      }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
var Km = Object.create
  ? function (n, e, t, r) {
      r === void 0 && (r = t);
      var a = Object.getOwnPropertyDescriptor(e, t);
      (!a || ("get" in a ? !e.__esModule : a.writable || a.configurable)) &&
        (a = {
          enumerable: !0,
          get: function () {
            return e[t];
          },
        }),
        Object.defineProperty(n, r, a);
    }
  : function (n, e, t, r) {
      r === void 0 && (r = t), (n[r] = e[t]);
    };
function Q$(n, e) {
  for (var t in n)
    t !== "default" &&
      !Object.prototype.hasOwnProperty.call(e, t) &&
      Km(e, n, t);
}
function bh(n) {
  var e = typeof Symbol == "function" && Symbol.iterator,
    t = e && n[e],
    r = 0;
  if (t) return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function () {
        return (
          n && r >= n.length && (n = void 0), { value: n && n[r++], done: !n }
        );
      },
    };
  throw new TypeError(
    e ? "Object is not iterable." : "Symbol.iterator is not defined.",
  );
}
function l4(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t) return n;
  var r = t.call(n),
    a,
    i = [],
    s;
  try {
    for (; (e === void 0 || e-- > 0) && !(a = r.next()).done; ) i.push(a.value);
  } catch (o) {
    s = { error: o };
  } finally {
    try {
      a && !a.done && (t = r.return) && t.call(r);
    } finally {
      if (s) throw s.error;
    }
  }
  return i;
}
function Y$() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(l4(arguments[e]));
  return n;
}
function J$() {
  for (var n = 0, e = 0, t = arguments.length; e < t; e++)
    n += arguments[e].length;
  for (var r = Array(n), a = 0, e = 0; e < t; e++)
    for (var i = arguments[e], s = 0, o = i.length; s < o; s++, a++)
      r[a] = i[s];
  return r;
}
function u4(n, e, t) {
  if (t || arguments.length === 2)
    for (var r = 0, a = e.length, i; r < a; r++)
      (i || !(r in e)) &&
        (i || (i = Array.prototype.slice.call(e, 0, r)), (i[r] = e[r]));
  return n.concat(i || Array.prototype.slice.call(e));
}
function _c(n) {
  return this instanceof _c ? ((this.v = n), this) : new _c(n);
}
function X$(n, e, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = t.apply(n, e || []),
    a,
    i = [];
  return (
    (a = {}),
    s("next"),
    s("throw"),
    s("return"),
    (a[Symbol.asyncIterator] = function () {
      return this;
    }),
    a
  );
  function s(f) {
    r[f] &&
      (a[f] = function (p) {
        return new Promise(function (m, y) {
          i.push([f, p, m, y]) > 1 || o(f, p);
        });
      });
  }
  function o(f, p) {
    try {
      c(r[f](p));
    } catch (m) {
      d(i[0][3], m);
    }
  }
  function c(f) {
    f.value instanceof _c
      ? Promise.resolve(f.value.v).then(l, u)
      : d(i[0][2], f);
  }
  function l(f) {
    o("next", f);
  }
  function u(f) {
    o("throw", f);
  }
  function d(f, p) {
    f(p), i.shift(), i.length && o(i[0][0], i[0][1]);
  }
}
function Z$(n) {
  var e, t;
  return (
    (e = {}),
    r("next"),
    r("throw", function (a) {
      throw a;
    }),
    r("return"),
    (e[Symbol.iterator] = function () {
      return this;
    }),
    e
  );
  function r(a, i) {
    e[a] = n[a]
      ? function (s) {
          return (t = !t) ? { value: _c(n[a](s)), done: !1 } : i ? i(s) : s;
        }
      : i;
  }
}
function eW(n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = n[Symbol.asyncIterator],
    t;
  return e
    ? e.call(n)
    : ((n = typeof bh == "function" ? bh(n) : n[Symbol.iterator]()),
      (t = {}),
      r("next"),
      r("throw"),
      r("return"),
      (t[Symbol.asyncIterator] = function () {
        return this;
      }),
      t);
  function r(i) {
    t[i] =
      n[i] &&
      function (s) {
        return new Promise(function (o, c) {
          (s = n[i](s)), a(o, c, s.done, s.value);
        });
      };
  }
  function a(i, s, o, c) {
    Promise.resolve(c).then(function (l) {
      i({ value: l, done: o });
    }, s);
  }
}
function tW(n, e) {
  return (
    Object.defineProperty
      ? Object.defineProperty(n, "raw", { value: e })
      : (n.raw = e),
    n
  );
}
var nW = Object.create
  ? function (n, e) {
      Object.defineProperty(n, "default", { enumerable: !0, value: e });
    }
  : function (n, e) {
      n.default = e;
    };
function rW(n) {
  if (n && n.__esModule) return n;
  var e = {};
  if (n != null)
    for (var t in n)
      t !== "default" &&
        Object.prototype.hasOwnProperty.call(n, t) &&
        Km(e, n, t);
  return nW(e, n), e;
}
function aW(n) {
  return n && n.__esModule ? n : { default: n };
}
function iW(n, e, t, r) {
  if (t === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !r : !e.has(n))
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it",
    );
  return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n);
}
function sW(n, e, t, r, a) {
  if (r === "m") throw new TypeError("Private method is not writable");
  if (r === "a" && !a)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !a : !e.has(n))
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it",
    );
  return r === "a" ? a.call(n, t) : a ? (a.value = t) : e.set(n, t), t;
}
function oW(n, e) {
  if (e === null || (typeof e != "object" && typeof e != "function"))
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof n == "function" ? e === n : n.has(e);
}
const Aq = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      get __assign() {
        return gr;
      },
      __asyncDelegator: Z$,
      __asyncGenerator: X$,
      __asyncValues: eW,
      __await: _c,
      __awaiter: G$,
      __classPrivateFieldGet: iW,
      __classPrivateFieldIn: oW,
      __classPrivateFieldSet: sW,
      __createBinding: Km,
      __decorate: W$,
      __esDecorate: j$,
      __exportStar: Q$,
      __extends: $$,
      __generator: K$,
      __importDefault: aW,
      __importStar: rW,
      __makeTemplateObject: tW,
      __metadata: V$,
      __param: U$,
      __propKey: H$,
      __read: l4,
      __rest: Gm,
      __runInitializers: z$,
      __setFunctionName: q$,
      __spread: Y$,
      __spreadArray: u4,
      __spreadArrays: J$,
      __values: bh,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);
var tu = "right-scroll-bar-position",
  nu = "width-before-scroll-bar",
  cW = "with-scroll-bars-hidden",
  lW = "--removed-body-scroll-bar-size";
function uW(n, e) {
  return typeof n == "function" ? n(e) : n && (n.current = e), n;
}
function dW(n, e) {
  var t = C.useState(function () {
    return {
      value: n,
      callback: e,
      facade: {
        get current() {
          return t.value;
        },
        set current(r) {
          var a = t.value;
          a !== r && ((t.value = r), t.callback(r, a));
        },
      },
    };
  })[0];
  return (t.callback = e), t.facade;
}
function fW(n, e) {
  return dW(e || null, function (t) {
    return n.forEach(function (r) {
      return uW(r, t);
    });
  });
}
function pW(n) {
  return n;
}
function hW(n, e) {
  e === void 0 && (e = pW);
  var t = [],
    r = !1,
    a = {
      read: function () {
        if (r)
          throw new Error(
            "Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.",
          );
        return t.length ? t[t.length - 1] : n;
      },
      useMedium: function (i) {
        var s = e(i, r);
        return (
          t.push(s),
          function () {
            t = t.filter(function (o) {
              return o !== s;
            });
          }
        );
      },
      assignSyncMedium: function (i) {
        for (r = !0; t.length; ) {
          var s = t;
          (t = []), s.forEach(i);
        }
        t = {
          push: function (o) {
            return i(o);
          },
          filter: function () {
            return t;
          },
        };
      },
      assignMedium: function (i) {
        r = !0;
        var s = [];
        if (t.length) {
          var o = t;
          (t = []), o.forEach(i), (s = t);
        }
        var c = function () {
            var u = s;
            (s = []), u.forEach(i);
          },
          l = function () {
            return Promise.resolve().then(c);
          };
        l(),
          (t = {
            push: function (u) {
              s.push(u), l();
            },
            filter: function (u) {
              return (s = s.filter(u)), t;
            },
          });
      },
    };
  return a;
}
function mW(n) {
  n === void 0 && (n = {});
  var e = hW(null);
  return (e.options = gr({ async: !0, ssr: !1 }, n)), e;
}
var d4 = function (n) {
  var e = n.sideCar,
    t = Gm(n, ["sideCar"]);
  if (!e)
    throw new Error(
      "Sidecar: please provide `sideCar` property to import the right car",
    );
  var r = e.read();
  if (!r) throw new Error("Sidecar medium not found");
  return C.createElement(r, gr({}, t));
};
d4.isSideCarExport = !0;
function yW(n, e) {
  return n.useMedium(e), d4;
}
var f4 = mW(),
  rp = function () {},
  Sf = C.forwardRef(function (n, e) {
    var t = C.useRef(null),
      r = C.useState({
        onScrollCapture: rp,
        onWheelCapture: rp,
        onTouchMoveCapture: rp,
      }),
      a = r[0],
      i = r[1],
      s = n.forwardProps,
      o = n.children,
      c = n.className,
      l = n.removeScrollBar,
      u = n.enabled,
      d = n.shards,
      f = n.sideCar,
      p = n.noIsolation,
      m = n.inert,
      y = n.allowPinchZoom,
      h = n.as,
      g = h === void 0 ? "div" : h,
      v = Gm(n, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
      ]),
      w = f,
      T = fW([t, e]),
      A = gr(gr({}, v), a);
    return C.createElement(
      C.Fragment,
      null,
      u &&
        C.createElement(w, {
          sideCar: f4,
          removeScrollBar: l,
          shards: d,
          noIsolation: p,
          inert: m,
          setCallbacks: i,
          allowPinchZoom: !!y,
          lockRef: t,
        }),
      s
        ? C.cloneElement(C.Children.only(o), gr(gr({}, A), { ref: T }))
        : C.createElement(g, gr({}, A, { className: c, ref: T }), o),
    );
  });
Sf.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
Sf.classNames = { fullWidth: nu, zeroRight: tu };
var t2,
  gW = function () {
    if (t2) return t2;
    if (typeof __webpack_nonce__ < "u") return __webpack_nonce__;
  };
function bW() {
  if (!document) return null;
  var n = document.createElement("style");
  n.type = "text/css";
  var e = gW();
  return e && n.setAttribute("nonce", e), n;
}
function xW(n, e) {
  n.styleSheet
    ? (n.styleSheet.cssText = e)
    : n.appendChild(document.createTextNode(e));
}
function vW(n) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(n);
}
var wW = function () {
    var n = 0,
      e = null;
    return {
      add: function (t) {
        n == 0 && (e = bW()) && (xW(e, t), vW(e)), n++;
      },
      remove: function () {
        n--,
          !n && e && (e.parentNode && e.parentNode.removeChild(e), (e = null));
      },
    };
  },
  TW = function () {
    var n = wW();
    return function (e, t) {
      C.useEffect(
        function () {
          return (
            n.add(e),
            function () {
              n.remove();
            }
          );
        },
        [e && t],
      );
    };
  },
  p4 = function () {
    var n = TW(),
      e = function (t) {
        var r = t.styles,
          a = t.dynamic;
        return n(r, a), null;
      };
    return e;
  },
  CW = { left: 0, top: 0, right: 0, gap: 0 },
  ap = function (n) {
    return parseInt(n || "", 10) || 0;
  },
  AW = function (n) {
    var e = window.getComputedStyle(document.body),
      t = e[n === "padding" ? "paddingLeft" : "marginLeft"],
      r = e[n === "padding" ? "paddingTop" : "marginTop"],
      a = e[n === "padding" ? "paddingRight" : "marginRight"];
    return [ap(t), ap(r), ap(a)];
  },
  EW = function (n) {
    if ((n === void 0 && (n = "margin"), typeof window > "u")) return CW;
    var e = AW(n),
      t = document.documentElement.clientWidth,
      r = window.innerWidth;
    return {
      left: e[0],
      top: e[1],
      right: e[2],
      gap: Math.max(0, r - t + e[2] - e[0]),
    };
  },
  kW = p4(),
  _W = function (n, e, t, r) {
    var a = n.left,
      i = n.top,
      s = n.right,
      o = n.gap;
    return (
      t === void 0 && (t = "margin"),
      `
  .`
        .concat(
          cW,
          ` {
   overflow: hidden `,
        )
        .concat(
          r,
          `;
   padding-right: `,
        )
        .concat(o, "px ")
        .concat(
          r,
          `;
  }
  body {
    overflow: hidden `,
        )
        .concat(
          r,
          `;
    overscroll-behavior: contain;
    `,
        )
        .concat(
          [
            e && "position: relative ".concat(r, ";"),
            t === "margin" &&
              `
    padding-left: `
                .concat(
                  a,
                  `px;
    padding-top: `,
                )
                .concat(
                  i,
                  `px;
    padding-right: `,
                )
                .concat(
                  s,
                  `px;
    margin-left:0;
    margin-top:0;
    margin-right: `,
                )
                .concat(o, "px ")
                .concat(
                  r,
                  `;
    `,
                ),
            t === "padding" &&
              "padding-right: ".concat(o, "px ").concat(r, ";"),
          ]
            .filter(Boolean)
            .join(""),
          `
  }
  
  .`,
        )
        .concat(
          tu,
          ` {
    right: `,
        )
        .concat(o, "px ")
        .concat(
          r,
          `;
  }
  
  .`,
        )
        .concat(
          nu,
          ` {
    margin-right: `,
        )
        .concat(o, "px ")
        .concat(
          r,
          `;
  }
  
  .`,
        )
        .concat(tu, " .")
        .concat(
          tu,
          ` {
    right: 0 `,
        )
        .concat(
          r,
          `;
  }
  
  .`,
        )
        .concat(nu, " .")
        .concat(
          nu,
          ` {
    margin-right: 0 `,
        )
        .concat(
          r,
          `;
  }
  
  body {
    `,
        )
        .concat(lW, ": ")
        .concat(
          o,
          `px;
  }
`,
        )
    );
  },
  SW = function (n) {
    var e = n.noRelative,
      t = n.noImportant,
      r = n.gapMode,
      a = r === void 0 ? "margin" : r,
      i = C.useMemo(
        function () {
          return EW(a);
        },
        [a],
      );
    return C.createElement(kW, { styles: _W(i, !e, a, t ? "" : "!important") });
  },
  xh = !1;
if (typeof window < "u")
  try {
    var Rl = Object.defineProperty({}, "passive", {
      get: function () {
        return (xh = !0), !0;
      },
    });
    window.addEventListener("test", Rl, Rl),
      window.removeEventListener("test", Rl, Rl);
  } catch {
    xh = !1;
  }
var cs = xh ? { passive: !1 } : !1,
  PW = function (n) {
    return n.tagName === "TEXTAREA";
  },
  h4 = function (n, e) {
    var t = window.getComputedStyle(n);
    return (
      t[e] !== "hidden" &&
      !(t.overflowY === t.overflowX && !PW(n) && t[e] === "visible")
    );
  },
  IW = function (n) {
    return h4(n, "overflowY");
  },
  RW = function (n) {
    return h4(n, "overflowX");
  },
  n2 = function (n, e) {
    var t = e;
    do {
      typeof ShadowRoot < "u" && t instanceof ShadowRoot && (t = t.host);
      var r = m4(n, t);
      if (r) {
        var a = y4(n, t),
          i = a[1],
          s = a[2];
        if (i > s) return !0;
      }
      t = t.parentNode;
    } while (t && t !== document.body);
    return !1;
  },
  MW = function (n) {
    var e = n.scrollTop,
      t = n.scrollHeight,
      r = n.clientHeight;
    return [e, t, r];
  },
  BW = function (n) {
    var e = n.scrollLeft,
      t = n.scrollWidth,
      r = n.clientWidth;
    return [e, t, r];
  },
  m4 = function (n, e) {
    return n === "v" ? IW(e) : RW(e);
  },
  y4 = function (n, e) {
    return n === "v" ? MW(e) : BW(e);
  },
  DW = function (n, e) {
    return n === "h" && e === "rtl" ? -1 : 1;
  },
  OW = function (n, e, t, r, a) {
    var i = DW(n, window.getComputedStyle(e).direction),
      s = i * r,
      o = t.target,
      c = e.contains(o),
      l = !1,
      u = s > 0,
      d = 0,
      f = 0;
    do {
      var p = y4(n, o),
        m = p[0],
        y = p[1],
        h = p[2],
        g = y - h - i * m;
      (m || g) && m4(n, o) && ((d += g), (f += m)), (o = o.parentNode);
    } while ((!c && o !== document.body) || (c && (e.contains(o) || e === o)));
    return (
      ((u && ((a && d === 0) || (!a && s > d))) ||
        (!u && ((a && f === 0) || (!a && -s > f)))) &&
        (l = !0),
      l
    );
  },
  Ml = function (n) {
    return "changedTouches" in n
      ? [n.changedTouches[0].clientX, n.changedTouches[0].clientY]
      : [0, 0];
  },
  r2 = function (n) {
    return [n.deltaX, n.deltaY];
  },
  a2 = function (n) {
    return n && "current" in n ? n.current : n;
  },
  NW = function (n, e) {
    return n[0] === e[0] && n[1] === e[1];
  },
  FW = function (n) {
    return `
  .block-interactivity-`
      .concat(
        n,
        ` {pointer-events: none;}
  .allow-interactivity-`,
      )
      .concat(
        n,
        ` {pointer-events: all;}
`,
      );
  },
  LW = 0,
  ls = [];
function $W(n) {
  var e = C.useRef([]),
    t = C.useRef([0, 0]),
    r = C.useRef(),
    a = C.useState(LW++)[0],
    i = C.useState(function () {
      return p4();
    })[0],
    s = C.useRef(n);
  C.useEffect(
    function () {
      s.current = n;
    },
    [n],
  ),
    C.useEffect(
      function () {
        if (n.inert) {
          document.body.classList.add("block-interactivity-".concat(a));
          var y = u4([n.lockRef.current], (n.shards || []).map(a2), !0).filter(
            Boolean,
          );
          return (
            y.forEach(function (h) {
              return h.classList.add("allow-interactivity-".concat(a));
            }),
            function () {
              document.body.classList.remove("block-interactivity-".concat(a)),
                y.forEach(function (h) {
                  return h.classList.remove("allow-interactivity-".concat(a));
                });
            }
          );
        }
      },
      [n.inert, n.lockRef.current, n.shards],
    );
  var o = C.useCallback(function (y, h) {
      if ("touches" in y && y.touches.length === 2)
        return !s.current.allowPinchZoom;
      var g = Ml(y),
        v = t.current,
        w = "deltaX" in y ? y.deltaX : v[0] - g[0],
        T = "deltaY" in y ? y.deltaY : v[1] - g[1],
        A,
        E = y.target,
        _ = Math.abs(w) > Math.abs(T) ? "h" : "v";
      if ("touches" in y && _ === "h" && E.type === "range") return !1;
      var S = n2(_, E);
      if (!S) return !0;
      if ((S ? (A = _) : ((A = _ === "v" ? "h" : "v"), (S = n2(_, E))), !S))
        return !1;
      if (
        (!r.current && "changedTouches" in y && (w || T) && (r.current = A), !A)
      )
        return !0;
      var W = r.current || A;
      return OW(W, h, y, W === "h" ? w : T, !0);
    }, []),
    c = C.useCallback(function (y) {
      var h = y;
      if (!(!ls.length || ls[ls.length - 1] !== i)) {
        var g = "deltaY" in h ? r2(h) : Ml(h),
          v = e.current.filter(function (A) {
            return A.name === h.type && A.target === h.target && NW(A.delta, g);
          })[0];
        if (v && v.should) {
          h.cancelable && h.preventDefault();
          return;
        }
        if (!v) {
          var w = (s.current.shards || [])
              .map(a2)
              .filter(Boolean)
              .filter(function (A) {
                return A.contains(h.target);
              }),
            T = w.length > 0 ? o(h, w[0]) : !s.current.noIsolation;
          T && h.cancelable && h.preventDefault();
        }
      }
    }, []),
    l = C.useCallback(function (y, h, g, v) {
      var w = { name: y, delta: h, target: g, should: v };
      e.current.push(w),
        setTimeout(function () {
          e.current = e.current.filter(function (T) {
            return T !== w;
          });
        }, 1);
    }, []),
    u = C.useCallback(function (y) {
      (t.current = Ml(y)), (r.current = void 0);
    }, []),
    d = C.useCallback(function (y) {
      l(y.type, r2(y), y.target, o(y, n.lockRef.current));
    }, []),
    f = C.useCallback(function (y) {
      l(y.type, Ml(y), y.target, o(y, n.lockRef.current));
    }, []);
  C.useEffect(function () {
    return (
      ls.push(i),
      n.setCallbacks({
        onScrollCapture: d,
        onWheelCapture: d,
        onTouchMoveCapture: f,
      }),
      document.addEventListener("wheel", c, cs),
      document.addEventListener("touchmove", c, cs),
      document.addEventListener("touchstart", u, cs),
      function () {
        (ls = ls.filter(function (y) {
          return y !== i;
        })),
          document.removeEventListener("wheel", c, cs),
          document.removeEventListener("touchmove", c, cs),
          document.removeEventListener("touchstart", u, cs);
      }
    );
  }, []);
  var p = n.removeScrollBar,
    m = n.inert;
  return C.createElement(
    C.Fragment,
    null,
    m ? C.createElement(i, { styles: FW(a) }) : null,
    p ? C.createElement(SW, { gapMode: "margin" }) : null,
  );
}
const WW = yW(f4, $W);
var g4 = C.forwardRef(function (n, e) {
  return C.createElement(Sf, gr({}, n, { ref: e, sideCar: WW }));
});
g4.classNames = Sf.classNames;
const Qm = g4;
var UW = function (n) {
    if (typeof document > "u") return null;
    var e = Array.isArray(n) ? n[0] : n;
    return e.ownerDocument.body;
  },
  us = new WeakMap(),
  Bl = new WeakMap(),
  Dl = {},
  ip = 0,
  b4 = function (n) {
    return n && (n.host || b4(n.parentNode));
  },
  jW = function (n, e) {
    return e
      .map(function (t) {
        if (n.contains(t)) return t;
        var r = b4(t);
        return r && n.contains(r)
          ? r
          : (console.error(
              "aria-hidden",
              t,
              "in not contained inside",
              n,
              ". Doing nothing",
            ),
            null);
      })
      .filter(function (t) {
        return !!t;
      });
  },
  zW = function (n, e, t, r) {
    var a = jW(e, Array.isArray(n) ? n : [n]);
    Dl[t] || (Dl[t] = new WeakMap());
    var i = Dl[t],
      s = [],
      o = new Set(),
      c = new Set(a),
      l = function (d) {
        !d || o.has(d) || (o.add(d), l(d.parentNode));
      };
    a.forEach(l);
    var u = function (d) {
      !d ||
        c.has(d) ||
        Array.prototype.forEach.call(d.children, function (f) {
          if (o.has(f)) u(f);
          else {
            var p = f.getAttribute(r),
              m = p !== null && p !== "false",
              y = (us.get(f) || 0) + 1,
              h = (i.get(f) || 0) + 1;
            us.set(f, y),
              i.set(f, h),
              s.push(f),
              y === 1 && m && Bl.set(f, !0),
              h === 1 && f.setAttribute(t, "true"),
              m || f.setAttribute(r, "true");
          }
        });
    };
    return (
      u(e),
      o.clear(),
      ip++,
      function () {
        s.forEach(function (d) {
          var f = us.get(d) - 1,
            p = i.get(d) - 1;
          us.set(d, f),
            i.set(d, p),
            f || (Bl.has(d) || d.removeAttribute(r), Bl.delete(d)),
            p || d.removeAttribute(t);
        }),
          ip--,
          ip ||
            ((us = new WeakMap()),
            (us = new WeakMap()),
            (Bl = new WeakMap()),
            (Dl = {}));
      }
    );
  },
  Ym = function (n, e, t) {
    t === void 0 && (t = "data-aria-hidden");
    var r = Array.from(Array.isArray(n) ? n : [n]),
      a = e || UW(n);
    return a
      ? (r.push.apply(r, Array.from(a.querySelectorAll("[aria-live]"))),
        zW(r, a, t, "aria-hidden"))
      : function () {
          return null;
        };
  };
const x4 = "Dialog",
  [v4, Eq] = ya(x4),
  [HW, Gr] = v4(x4),
  qW = (n) => {
    const {
        __scopeDialog: e,
        children: t,
        open: r,
        defaultOpen: a,
        onOpenChange: i,
        modal: s = !0,
      } = n,
      o = C.useRef(null),
      c = C.useRef(null),
      [l = !1, u] = a4({ prop: r, defaultProp: a, onChange: i });
    return C.createElement(
      HW,
      {
        scope: e,
        triggerRef: o,
        contentRef: c,
        contentId: eu(),
        titleId: eu(),
        descriptionId: eu(),
        open: l,
        onOpenChange: u,
        onOpenToggle: C.useCallback(() => u((d) => !d), [u]),
        modal: s,
      },
      t,
    );
  },
  VW = "DialogTrigger",
  GW = C.forwardRef((n, e) => {
    const { __scopeDialog: t, ...r } = n,
      a = Gr(VW, t),
      i = sn(e, a.triggerRef);
    return C.createElement(
      kn.button,
      ve(
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": a.open,
          "aria-controls": a.contentId,
          "data-state": Jm(a.open),
        },
        r,
        { ref: i, onClick: Oe(n.onClick, a.onOpenToggle) },
      ),
    );
  }),
  w4 = "DialogPortal",
  [KW, T4] = v4(w4, { forceMount: void 0 }),
  QW = (n) => {
    const { __scopeDialog: e, forceMount: t, children: r, container: a } = n,
      i = Gr(w4, e);
    return C.createElement(
      KW,
      { scope: e, forceMount: t },
      C.Children.map(r, (s) =>
        C.createElement(
          Xi,
          { present: t || i.open },
          C.createElement(N$, { asChild: !0, container: a }, s),
        ),
      ),
    );
  },
  vh = "DialogOverlay",
  YW = C.forwardRef((n, e) => {
    const t = T4(vh, n.__scopeDialog),
      { forceMount: r = t.forceMount, ...a } = n,
      i = Gr(vh, n.__scopeDialog);
    return i.modal
      ? C.createElement(
          Xi,
          { present: r || i.open },
          C.createElement(JW, ve({}, a, { ref: e })),
        )
      : null;
  }),
  JW = C.forwardRef((n, e) => {
    const { __scopeDialog: t, ...r } = n,
      a = Gr(vh, t);
    return C.createElement(
      Qm,
      { as: Wi, allowPinchZoom: !0, shards: [a.contentRef] },
      C.createElement(
        kn.div,
        ve({ "data-state": Jm(a.open) }, r, {
          ref: e,
          style: { pointerEvents: "auto", ...r.style },
        }),
      ),
    );
  }),
  Sc = "DialogContent",
  XW = C.forwardRef((n, e) => {
    const t = T4(Sc, n.__scopeDialog),
      { forceMount: r = t.forceMount, ...a } = n,
      i = Gr(Sc, n.__scopeDialog);
    return C.createElement(
      Xi,
      { present: r || i.open },
      i.modal
        ? C.createElement(ZW, ve({}, a, { ref: e }))
        : C.createElement(eU, ve({}, a, { ref: e })),
    );
  }),
  ZW = C.forwardRef((n, e) => {
    const t = Gr(Sc, n.__scopeDialog),
      r = C.useRef(null),
      a = sn(e, t.contentRef, r);
    return (
      C.useEffect(() => {
        const i = r.current;
        if (i) return Ym(i);
      }, []),
      C.createElement(
        C4,
        ve({}, n, {
          ref: a,
          trapFocus: t.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Oe(n.onCloseAutoFocus, (i) => {
            var s;
            i.preventDefault(),
              (s = t.triggerRef.current) === null || s === void 0 || s.focus();
          }),
          onPointerDownOutside: Oe(n.onPointerDownOutside, (i) => {
            const s = i.detail.originalEvent,
              o = s.button === 0 && s.ctrlKey === !0;
            (s.button === 2 || o) && i.preventDefault();
          }),
          onFocusOutside: Oe(n.onFocusOutside, (i) => i.preventDefault()),
        }),
      )
    );
  }),
  eU = C.forwardRef((n, e) => {
    const t = Gr(Sc, n.__scopeDialog),
      r = C.useRef(!1),
      a = C.useRef(!1);
    return C.createElement(
      C4,
      ve({}, n, {
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          var s;
          if (
            ((s = n.onCloseAutoFocus) === null || s === void 0 || s.call(n, i),
            !i.defaultPrevented)
          ) {
            var o;
            r.current ||
              (o = t.triggerRef.current) === null ||
              o === void 0 ||
              o.focus(),
              i.preventDefault();
          }
          (r.current = !1), (a.current = !1);
        },
        onInteractOutside: (i) => {
          var s, o;
          (s = n.onInteractOutside) === null || s === void 0 || s.call(n, i),
            i.defaultPrevented ||
              ((r.current = !0),
              i.detail.originalEvent.type === "pointerdown" &&
                (a.current = !0));
          const c = i.target;
          ((o = t.triggerRef.current) === null || o === void 0
            ? void 0
            : o.contains(c)) && i.preventDefault(),
            i.detail.originalEvent.type === "focusin" &&
              a.current &&
              i.preventDefault();
        },
      }),
    );
  }),
  C4 = C.forwardRef((n, e) => {
    const {
        __scopeDialog: t,
        trapFocus: r,
        onOpenAutoFocus: a,
        onCloseAutoFocus: i,
        ...s
      } = n,
      o = Gr(Sc, t),
      c = C.useRef(null),
      l = sn(e, c);
    return (
      Vm(),
      C.createElement(
        C.Fragment,
        null,
        C.createElement(
          qm,
          {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: a,
            onUnmountAutoFocus: i,
          },
          C.createElement(
            _f,
            ve(
              {
                role: "dialog",
                id: o.contentId,
                "aria-describedby": o.descriptionId,
                "aria-labelledby": o.titleId,
                "data-state": Jm(o.open),
              },
              s,
              { ref: l, onDismiss: () => o.onOpenChange(!1) },
            ),
          ),
        ),
        !1,
      )
    );
  }),
  tU = "DialogTitle",
  nU = C.forwardRef((n, e) => {
    const { __scopeDialog: t, ...r } = n,
      a = Gr(tU, t);
    return C.createElement(kn.h2, ve({ id: a.titleId }, r, { ref: e }));
  }),
  rU = "DialogClose",
  aU = C.forwardRef((n, e) => {
    const { __scopeDialog: t, ...r } = n,
      a = Gr(rU, t);
    return C.createElement(
      kn.button,
      ve({ type: "button" }, r, {
        ref: e,
        onClick: Oe(n.onClick, () => a.onOpenChange(!1)),
      }),
    );
  });
function Jm(n) {
  return n ? "open" : "closed";
}
const iU = qW,
  sU = GW,
  oU = QW,
  cU = YW,
  lU = XW,
  A4 = nU,
  uU = aU;
function Zi(n, e) {
  if (n == null) return {};
  var t = {},
    r = Object.keys(n),
    a,
    i;
  for (i = 0; i < r.length; i++)
    (a = r[i]), !(e.indexOf(a) >= 0) && (t[a] = n[a]);
  return t;
}
var dU = ["color"],
  fU = C.forwardRef(function (n, e) {
    var t = n.color,
      r = t === void 0 ? "currentColor" : t,
      a = Zi(n, dU);
    return C.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        a,
        { ref: e },
      ),
      C.createElement("path", {
        d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      }),
    );
  }),
  pU = ["color"],
  hU = C.forwardRef(function (n, e) {
    var t = n.color,
      r = t === void 0 ? "currentColor" : t,
      a = Zi(n, pU);
    return C.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        a,
        { ref: e },
      ),
      C.createElement("path", {
        d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      }),
    );
  }),
  mU = ["color"],
  yU = C.forwardRef(function (n, e) {
    var t = n.color,
      r = t === void 0 ? "currentColor" : t,
      a = Zi(n, mU);
    return C.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        a,
        { ref: e },
      ),
      C.createElement("path", {
        d: "M8.84182 3.13514C9.04327 3.32401 9.05348 3.64042 8.86462 3.84188L5.43521 7.49991L8.86462 11.1579C9.05348 11.3594 9.04327 11.6758 8.84182 11.8647C8.64036 12.0535 8.32394 12.0433 8.13508 11.8419L4.38508 7.84188C4.20477 7.64955 4.20477 7.35027 4.38508 7.15794L8.13508 3.15794C8.32394 2.95648 8.64036 2.94628 8.84182 3.13514Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      }),
    );
  }),
  gU = ["color"],
  bU = C.forwardRef(function (n, e) {
    var t = n.color,
      r = t === void 0 ? "currentColor" : t,
      a = Zi(n, gU);
    return C.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        a,
        { ref: e },
      ),
      C.createElement("path", {
        d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      }),
    );
  }),
  xU = ["color"],
  vU = C.forwardRef(function (n, e) {
    var t = n.color,
      r = t === void 0 ? "currentColor" : t,
      a = Zi(n, xU);
    return C.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        a,
        { ref: e },
      ),
      C.createElement("path", {
        d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      }),
    );
  }),
  wU = ["color"],
  TU = C.forwardRef(function (n, e) {
    var t = n.color,
      r = t === void 0 ? "currentColor" : t,
      a = Zi(n, wU);
    return C.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        a,
        { ref: e },
      ),
      C.createElement("path", {
        d: "M10 6.5C10 8.433 8.433 10 6.5 10C4.567 10 3 8.433 3 6.5C3 4.567 4.567 3 6.5 3C8.433 3 10 4.567 10 6.5ZM9.30884 10.0159C8.53901 10.6318 7.56251 11 6.5 11C4.01472 11 2 8.98528 2 6.5C2 4.01472 4.01472 2 6.5 2C8.98528 2 11 4.01472 11 6.5C11 7.56251 10.6318 8.53901 10.0159 9.30884L12.8536 12.1464C13.0488 12.3417 13.0488 12.6583 12.8536 12.8536C12.6583 13.0488 12.3417 13.0488 12.1464 12.8536L9.30884 10.0159Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      }),
    );
  }),
  CU = ["color"],
  AU = C.forwardRef(function (n, e) {
    var t = n.color,
      r = t === void 0 ? "currentColor" : t,
      a = Zi(n, CU);
    return C.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        a,
        { ref: e },
      ),
      C.createElement("path", {
        d: "M7.81825 1.18188C7.64251 1.00615 7.35759 1.00615 7.18185 1.18188L4.18185 4.18188C4.00611 4.35762 4.00611 4.64254 4.18185 4.81828C4.35759 4.99401 4.64251 4.99401 4.81825 4.81828L7.05005 2.58648V9.49996C7.05005 9.74849 7.25152 9.94996 7.50005 9.94996C7.74858 9.94996 7.95005 9.74849 7.95005 9.49996V2.58648L10.1819 4.81828C10.3576 4.99401 10.6425 4.99401 10.8182 4.81828C10.994 4.64254 10.994 4.35762 10.8182 4.18188L7.81825 1.18188ZM2.5 9.99997C2.77614 9.99997 3 10.2238 3 10.5V12C3 12.5538 3.44565 13 3.99635 13H11.0012C11.5529 13 12 12.5528 12 12V10.5C12 10.2238 12.2239 9.99997 12.5 9.99997C12.7761 9.99997 13 10.2238 13 10.5V12C13 13.104 12.1062 14 11.0012 14H3.99635C2.89019 14 2 13.103 2 12V10.5C2 10.2238 2.22386 9.99997 2.5 9.99997Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      }),
    );
  });
const mo = ie(A4)`
  margin: 0;
  font-weight: 600;
  font-size: ${ke.lg};
  color: ${(n) => n.theme.text.neutral};
  text-align: left;
  ${gn.mobile} {
    text-align: ${(n) => (n.centerOnMobile ? "center" : "left")};
  }
`,
  yo = ie.p`
  all: unset;
  display: block;
  font-size: ${(n) => (n.sm ? ke.sm : ke.md)};
  color: ${(n) => n.theme.text.secondary};
  line-height: 1.5;
  ${gn.mobile} {
    text-align: ${(n) => (n.centerOnMobile ? "center" : "left")};
  }
`,
  Xm = (n) =>
    I.jsx(zm, {
      variant: "secondary",
      onClick: n.onClick,
      style: n.style,
      type: "button",
      children: I.jsx(yU, { style: { width: qe.md, height: qe.md } }),
    }),
  Pf = ie.a`
  all: unset;
  cursor: pointer;
  color: ${(n) => n.theme.link.primary};
  font-size: ${(n) => (n.md ? ke.md : ke.sm)};
  text-decoration: none;
  display: block;
  ${gn.mobile} {
    text-align: center;
  }
  &:hover {
    color: ${(n) => n.theme.link.primaryHover};
    text-decoration: none;
  }
`;
function EU(n) {
  return lF(n);
}
function kU() {
  const n = Zm();
  return n ? n.toLowerCase().includes("android") : !1;
}
function _U() {
  const n = Zm();
  return n
    ? n.toLowerCase().includes("ios") ||
        (n.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1)
    : !1;
}
function Zm() {
  const n = EU();
  return n != null && n.os ? n.os : void 0;
}
function Pc() {
  return Zm() ? kU() || _U() : !1;
}
const E4 = (n) =>
    I.jsxs(I.Fragment, {
      children: [
        !n.hideBackButton && I.jsx(Xm, { onClick: n.onBack }),
        I.jsx(PU, {
          children: I.jsx(hr, {
            src: n.walletIconURL,
            width: qe.xl,
            height: qe.xl,
          }),
        }),
        I.jsx(At, { y: "lg" }),
        I.jsxs(SU, {
          children: [
            I.jsx(mo, { children: "Connecting your wallet" }),
            I.jsx(Hw, { size: "md", color: "link" }),
          ],
        }),
        I.jsx(At, { y: "md" }),
        I.jsxs(IU, {
          centerOnMobile: !0,
          children: [
            "Connect your wallet through the ",
            n.walletName,
            " ",
            Pc() ? "application" : "pop-up",
          ],
        }),
        I.jsx(At, { y: "xl" }),
        I.jsxs(Pf, {
          target: "_blank",
          href: n.supportLink,
          children: ["Having troubles connecting to ", n.walletName, "?"],
        }),
      ],
    }),
  SU = ie.div`
  display: flex;
  align-items: center;
  gap: ${he.md};
  ${gn.mobile} {
    flex-direction: column;
    align-items: center;
    gap: ${he.xl};
  }
`,
  PU = ie.div`
  display: flex;
  margin-top: ${he.lg};
  ${gn.mobile} {
    justify-content: center;
    margin-top: 0;
  }
`,
  IU = ie(yo)`
  ${gn.mobile} {
    padding: 0 ${he.lg};
  }
`,
  ey = Vr`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`,
  RU = ie.div`
  animation: ${ey} 0.15s ease-in;
`,
  MU = (n) =>
    I.jsx(DU, {
      gradient: n.gradient,
      style: { height: n.height, width: n.width || "auto" },
    }),
  BU = Vr`
0% {
    background-color: var(--skeleton-c-1);
  }
  100% {
    background-color: var(--skeleton-c-2);
  }
`,
  DU = ie.div`
  background-size: 200% 200%;
  --skeleton-c-1: ${(n) => {
    var e;
    return n.theme.bg[((e = n.gradient) == null ? void 0 : e.c1) || "elevated"];
  }};
  --skeleton-c-2: ${(n) => {
    var e;
    return n.theme.bg[
      ((e = n.gradient) == null ? void 0 : e.c2) || "highlighted"
    ];
  }};
  animation: ${BU} 500ms ease-in-out infinite alternate;
  border-radius: ${st.sm};
`,
  k4 = (n) =>
    I.jsxs("div", {
      style: {
        position: "relative",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      },
      children: [
        n.qrCodeUri
          ? I.jsx(RU, {
              children: I.jsx(NU, {
                children: I.jsx(FU, { value: n.qrCodeUri }),
              }),
            })
          : I.jsx(LU, { height: "200px", width: "200px" }),
        n.QRIcon && I.jsx(OU, { children: n.QRIcon }),
      ],
    }),
  OU = ie.div`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border-radius: ${st.md};
  display: flex;
  justify-content: center;
  align-content: center;
  padding: 4px;
`,
  NU = ie.div`
  background: white;
  padding: ${he.xxs};
  display: flex;
  justify-content: center;
  align-content: center;
  border-radius: ${st.md};
  box-shadow: ${Af.md};
`,
  FU = ie(m$)`
  width: 200px;
  height: 200px;
  border-radius: ${st.md};

  ${gn.mobile} {
    width: 150px;
    height: 150px;
  }
`,
  LU = ie(MU)`
  width: 200px;
  height: 200px;
  border-radius: ${st.md};
  ${gn.mobile} {
    width: 150px;
    height: 150px;
  }
`;
function sp(n) {
  if (n.startsWith("http")) {
    const e = document.createElement("a");
    (e.href = n),
      (e.target = "_blank"),
      (e.rel = "noreferrer noopener"),
      e.click();
  } else window.location.href = n;
}
const i2 =
    "ipfs://Qmcyb1akWqyu8W4DgVWzZUozrCkfES8ow36jNhjs7arwvc/AppleGray.svg",
  $U = "ipfs://QmPu4UKsektZixeZN4ixi8Ji9KbMuwcRKAp3JRK4jrcaMK/Chrome.svg",
  s2 = "ipfs://QmTSu87iXWpfcCgy15DX3Mgp1Rqb8zFAwXdbLNh6WxmpC4/GooglePlay.svg",
  ty = (n) => {
    let {
      walletName: e,
      walletIconURL: t,
      appleStoreLink: r,
      googlePlayStoreLink: a,
      chromeExtensionLink: i,
      header: s,
      footer: o,
      onBack: c,
    } = n;
    const [l, u] = C.useState("base"),
      d = l === "android-scan" || l === "ios-scan";
    return I.jsxs(I.Fragment, {
      children: [
        I.jsx(Xm, {
          style: d ? { position: "absolute", top: he.lg, left: he.lg } : void 0,
          onClick: () => {
            l === "base" ? c() : u("base");
          },
        }),
        l === "android-scan" &&
          a &&
          I.jsx(o2, {
            platformIcon: I.jsx(hr, { src: s2, width: qe.md, height: qe.md }),
            url: a,
            platform: "Google Play",
            walletName: e,
            walletIconURL: t,
          }),
        l === "ios-scan" &&
          r &&
          I.jsx(o2, {
            platformIcon: I.jsx(hr, { width: qe.md, height: qe.md, src: i2 }),
            url: r,
            platform: "App Store",
            walletName: e,
            walletIconURL: t,
          }),
        l === "base" &&
          I.jsxs(I.Fragment, {
            children: [
              I.jsx(At, { y: "lg" }),
              s ||
                I.jsxs(I.Fragment, {
                  children: [
                    I.jsx(hr, { src: t, width: qe.xl, height: qe.xl, alt: "" }),
                    I.jsx(At, { y: "lg" }),
                    I.jsxs(mo, { children: ["Get started with ", e] }),
                    I.jsx(At, { y: "sm" }),
                    I.jsx(yo, {
                      children:
                        "Download your preferred option and refresh this page",
                    }),
                  ],
                }),
              I.jsx(At, { y: "xl" }),
              I.jsxs(qw, {
                flexDirection: "column",
                gap: "xs",
                children: [
                  i &&
                    I.jsxs(op, {
                      onClick: () => {
                        sp(i);
                      },
                      children: [
                        I.jsx(hr, { width: qe.lg, height: qe.lg, src: $U }),
                        I.jsx("span", {
                          children: "Download Chrome Extension",
                        }),
                      ],
                    }),
                  a &&
                    I.jsxs(op, {
                      as: "button",
                      onClick: () => {
                        Pc() ? sp(a) : u("android-scan");
                      },
                      children: [
                        I.jsx(hr, { width: qe.lg, height: qe.lg, src: s2 }),
                        I.jsx("span", { children: "Download on Google Play" }),
                      ],
                    }),
                  r &&
                    I.jsxs(op, {
                      as: "button",
                      onClick: () => {
                        Pc() ? sp(r) : u("ios-scan");
                      },
                      children: [
                        I.jsx(hr, { width: qe.lg, height: qe.lg, src: i2 }),
                        I.jsx("span", { children: "Download on App Store" }),
                      ],
                    }),
                ],
              }),
            ],
          }),
        d &&
          I.jsxs(I.Fragment, {
            children: [
              I.jsx(At, { y: "xl" }),
              I.jsxs(Pf, {
                as: "button",
                onClick: c,
                style: { textAlign: "center", display: "block", width: "100%" },
                children: [
                  "I",
                  "'",
                  "ve finished setting up my ",
                  e,
                  " on mobile",
                ],
              }),
            ],
          }),
        !d && o,
      ],
    });
  },
  o2 = (n) =>
    I.jsxs("div", {
      style: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        textAlign: "center",
      },
      children: [
        I.jsx(k4, {
          qrCodeUri: n.url,
          QRIcon: I.jsx(hr, {
            src: n.walletIconURL,
            width: qe.lg,
            height: qe.lg,
          }),
        }),
        I.jsx(At, { y: "xl" }),
        I.jsxs("div", {
          style: { display: "flex", gap: he.sm, alignItems: "center" },
          children: [
            n.platformIcon,
            I.jsxs(mo, {
              children: ["Install ", n.walletName, " on ", n.platform],
            }),
          ],
        }),
        I.jsx(At, { y: "lg" }),
        I.jsxs(yo, {
          children: [
            "Scan QR with your phone to download ",
            I.jsx("br", {}),
            " ",
            n.walletName,
            " for",
            " ",
            n.platform,
          ],
        }),
      ],
    }),
  op = ie.button`
  all: unset;
  text-decoration: none;
  padding: ${he.sm} ${he.md};
  border-radius: ${st.sm};
  display: flex;
  align-items: center;
  gap: ${he.md};
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  color: ${(n) => n.theme.text.neutral};
  background: ${(n) => n.theme.bg.elevated};
  transition: 100ms ease;
  &:hover {
    background: ${(n) => n.theme.bg.highlighted};
    text-decoration: none;
    color: ${(n) => n.theme.text.neutral};
  }
`,
  _4 = (n) => {
    const e = n.walletName.toLowerCase().includes("wallet")
      ? n.walletName
      : `${n.walletName} wallet`;
    return I.jsxs(I.Fragment, {
      children: [
        !n.hideBackButton &&
          I.jsx(Xm, {
            onClick: n.onBack,
            style: {
              position: "absolute",
              zIndex: 10,
              left: he.lg,
              top: he.lg,
            },
          }),
        I.jsxs("div", {
          style: { textAlign: "center" },
          children: [
            I.jsx(k4, {
              qrCodeUri: n.qrCodeUri,
              QRIcon: I.jsx(hr, {
                width: qe.lg,
                height: qe.lg,
                src: n.walletIconURL,
              }),
            }),
            I.jsx(At, { y: "xl" }),
            I.jsxs(mo, {
              style: { textAlign: "center" },
              children: ["Scan with ", e, " "],
            }),
            I.jsx(At, { y: "md" }),
            I.jsxs(yo, {
              children: [
                "Scan this QR code with your phone ",
                I.jsx("br", {}),
                "camera or ",
                e,
                " to connect",
              ],
            }),
            I.jsx(At, { y: "md" }),
            I.jsx("div", {
              style: { display: "flex", justifyContent: "center" },
              children: I.jsx(Hw, { size: "md", color: "link" }),
            }),
            I.jsx(At, { y: "xl" }),
            I.jsxs(WU, {
              onClick: n.onGetStarted,
              children: ["Don't", " have ", e, "?"],
            }),
          ],
        }),
      ],
    });
  },
  WU = ie.button`
  all: unset;
  color: ${(n) => n.theme.link.primary};
  font-size: ${ke.sm};
  cursor: pointer;
  &:hover {
    color: ${(n) => n.theme.link.primaryHover};
  }
`,
  UU = (n) => {
    let {
      walletConfig: e,
      onConnected: t,
      onGetStarted: r,
      onBack: a,
      hideBackButton: i,
    } = n;
    const s = Fm(),
      [o, c] = C.useState(void 0),
      {
        setConnectedWallet: l,
        chainToConnect: u,
        setConnectionStatus: d,
      } = Tr(),
      f = C.useRef(!1);
    return (
      C.useEffect(() => {
        f.current ||
          ((f.current = !0),
          (async () => {
            const p = s(e),
              m = await p.getQrUrl();
            c(m || void 0), d("connecting");
            try {
              await p.connect({ chainId: u == null ? void 0 : u.chainId }),
                l(p),
                t();
            } catch {
              d("disconnected");
            }
          })());
      }, [s, t, e, u == null ? void 0 : u.chainId, l, d]),
      I.jsx(_4, {
        onBack: a,
        onGetStarted: r,
        qrCodeUri: o,
        walletName: e.meta.name,
        walletIconURL: e.meta.iconURL,
        hideBackButton: i,
      })
    );
  },
  jU = (n) => {
    var d, f, p;
    let { walletConfig: e, close: t, goBack: r, supportedWallets: a } = n;
    const i = vf(),
      { meta: s } = e,
      [o, c] = C.useState("loading"),
      l = a.length === 1,
      u = C.useRef(!1);
    return (
      C.useEffect(() => {
        if (o !== "loading" || u.current) return;
        const m = e.isInstalled ? e.isInstalled() : !1;
        (async () => {
          if (m)
            try {
              (u.current = !0), c("connecting"), await i(e), t();
            } catch (y) {
              r(), console.error(y);
            }
          else Pc() ? i(e) : c("scanning");
        })();
      }, [o, e, t, i, r]),
      o === "connecting" || o === "loading"
        ? I.jsx(E4, {
            hideBackButton: l,
            onBack: r,
            walletName: s.name,
            walletIconURL: s.iconURL,
            supportLink:
              "https://help.coinbase.com/en/wallet/other-topics/troubleshooting-and-tips",
          })
        : o === "get-started"
        ? I.jsx(ty, {
            walletIconURL: s.iconURL,
            walletName: s.name,
            chromeExtensionLink: (d = s.urls) == null ? void 0 : d.chrome,
            googlePlayStoreLink: (f = s.urls) == null ? void 0 : f.android,
            appleStoreLink: (p = s.urls) == null ? void 0 : p.ios,
            onBack: () => {
              c("scanning");
            },
          })
        : o === "scanning"
        ? I.jsx(UU, {
            onBack: r,
            onConnected: t,
            onGetStarted: () => c("get-started"),
            walletConfig: e,
            hideBackButton: l,
          })
        : null
    );
  },
  zU = (n) => {
    const e = (n == null ? void 0 : n.qrmodal) || "custom";
    return {
      id: Ks.id,
      meta: {
        name: "Coinbase Wallet",
        iconURL:
          "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
        urls: {
          chrome:
            "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
          android: "https://play.google.com/store/apps/details?id=org.toshi",
          ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455",
        },
      },
      create(t) {
        return new Ks({ ...t, headlessMode: e === "custom" });
      },
      connectUI: e === "custom" ? jU : HU,
      isInstalled() {
        var r, a, i;
        const t = globalThis == null ? void 0 : globalThis.window;
        return (
          (pw(t) &&
            (((r = t.ethereum) == null ? void 0 : r.isCoinbaseWallet) ||
              ((i = (a = t.ethereum) == null ? void 0 : a.providers) == null
                ? void 0
                : i.some((s) => s.isCoinbaseWallet)))) ||
          !1
        );
      },
    };
  },
  HU = (n) => {
    let {
      close: e,
      walletConfig: t,
      open: r,
      supportedWallets: a,
      theme: i,
    } = n;
    const s = Fm(),
      o = wF(),
      c = TF(),
      l = C.useRef(!1),
      u = a.length === 1;
    return (
      C.useEffect(() => {
        l.current ||
          ((l.current = !0),
          (async () => {
            e();
            const d = s(t);
            (d.theme = i), o("connecting");
            try {
              await d.connect(), c(d);
            } catch (f) {
              o("disconnected"), u || r(), console.error(f);
            }
          })());
      }, [t, e, r, u, s, i, o, c]),
      null
    );
  },
  qU = (n) => {
    let {
      onBack: e,
      onConnected: t,
      onGetStarted: r,
      walletConfig: a,
      hideBackButton: i,
    } = n;
    const s = Fm(),
      [o, c] = C.useState(),
      {
        setConnectedWallet: l,
        chainToConnect: u,
        setConnectionStatus: d,
      } = Tr(),
      f = C.useRef(!1);
    return (
      C.useEffect(() => {
        if (f.current) return;
        f.current = !0;
        const p = s(a);
        d("connecting"),
          p.connectWithQrCode({
            chainId: u == null ? void 0 : u.chainId,
            onQrCodeUri(m) {
              c(m);
            },
            onConnected() {
              l(p), t();
            },
          });
      }, [s, l, u, t, a, d]),
      I.jsx(_4, {
        onBack: e,
        onGetStarted: r,
        qrCodeUri: o,
        walletName: a.meta.name,
        walletIconURL: a.meta.iconURL,
        hideBackButton: i,
      })
    );
  },
  VU = (n) => {
    var l, u, d;
    const [e, t] = C.useState("connecting"),
      { walletConfig: r, close: a } = n,
      i = vf(),
      s = n.supportedWallets.length === 1,
      { goBack: o } = n,
      c = C.useRef(!1);
    return (
      C.useEffect(() => {
        if (c.current) return;
        const f = r.isInstalled ? r.isInstalled() : !1;
        (async () => {
          if (f)
            try {
              (c.current = !0), t("connecting"), await i(r), a();
            } catch {
              o();
            }
          else
            Pc()
              ? window.open(
                  `https://metamask.app.link/dapp/${window.location.toString()}`,
                )
              : t("scanning");
        })();
      }, [r, a, i, o]),
      e === "connecting"
        ? I.jsx(E4, {
            hideBackButton: s,
            onBack: n.goBack,
            walletName: r.meta.name,
            walletIconURL: r.meta.iconURL,
            supportLink:
              "https://support.metamask.io/hc/en-us/articles/4406430256539-User-Guide-Troubleshooting",
          })
        : e === "get-started"
        ? I.jsx(ty, {
            walletIconURL: r.meta.iconURL,
            walletName: r.meta.name,
            chromeExtensionLink: (l = r.meta.urls) == null ? void 0 : l.chrome,
            googlePlayStoreLink: (u = r.meta.urls) == null ? void 0 : u.android,
            appleStoreLink: (d = r.meta.urls) == null ? void 0 : d.ios,
            onBack: () => {
              t("scanning");
            },
          })
        : e === "scanning"
        ? I.jsx(qU, {
            onBack: o,
            onConnected: a,
            onGetStarted: () => {
              t("get-started");
            },
            hideBackButton: s,
            walletConfig: r,
          })
        : null
    );
  },
  S4 = (n) => ({
    id: Pi.id,
    meta: Pi.meta,
    create: (e) =>
      new Pi({ ...e, projectId: n == null ? void 0 : n.projectId, qrcode: !1 }),
    connectUI: VU,
    isInstalled() {
      return !!hw();
    },
  }),
  GU = "145769e410f16970a79ff77b2d89a1e0",
  KU = (n) => {
    const e = (n == null ? void 0 : n.projectId) || GU;
    return {
      id: Ii.id,
      meta: Ii.meta,
      create(t) {
        return new Ii({
          ...t,
          qrcode: !0,
          projectId: e,
          qrModalOptions: n == null ? void 0 : n.qrModalOptions,
        });
      },
    };
  },
  QU = (() => [S4(), zU(), KU()])(),
  P4 = C.createContext(!1),
  I4 = C.createContext(void 0),
  _d = C.createContext({ title: "", theme: "dark", data: void 0 }),
  ny = C.createContext(() => {}),
  YU = (n) => {
    const [e, t] = C.useState(!1),
      [r, a] = C.useState({
        title: "Choose your wallet",
        theme: n.theme || "dark",
        data: void 0,
      });
    return I.jsx(P4.Provider, {
      value: e,
      children: I.jsx(I4.Provider, {
        value: t,
        children: I.jsx(_d.Provider, {
          value: r,
          children: I.jsx(ny.Provider, { value: a, children: n.children }),
        }),
      }),
    });
  },
  JU = () => C.useContext(P4),
  XU = () => {
    const n = C.useContext(I4);
    if (n === void 0)
      throw new Error(
        "useSetWalletModalOpen must be used within a ThirdwebProvider",
      );
    return n;
  },
  ZU = (n) => {
    const e = n.walletConfigs.find((a) => a.id === $i.localWallet),
      t = n.walletConfigs.filter((a) => a.id !== $i.localWallet),
      r = !e && !!n.walletConfigs[0].meta.urls;
    return I.jsxs(I.Fragment, {
      children: [
        I.jsxs(mo, { children: [" ", n.title, " "] }),
        I.jsx(At, { y: "xl" }),
        I.jsx(ej, { walletConfigs: t, selectWallet: n.selectWallet }),
        e &&
          I.jsxs(I.Fragment, {
            children: [
              I.jsx(At, { y: "xl" }),
              I.jsx(qw, {
                justifyContent: "center",
                children: I.jsx(jm, {
                  variant: "link",
                  onClick: () => {
                    n.selectWallet(e);
                  },
                  "data-test": "continue-as-guest-button",
                  children: "Continue as guest",
                }),
              }),
            ],
          }),
        r &&
          I.jsxs(I.Fragment, {
            children: [
              I.jsx(At, { y: "xl" }),
              I.jsx(Pf, {
                as: "button",
                onClick: n.onGetStarted,
                style: { display: "block", width: "100%", textAlign: "center" },
                children: "Need help getting started?",
              }),
            ],
          }),
      ],
    });
  },
  ej = (n) => {
    const e = C.useContext(_d),
      t = C.useContext(ny),
      r = n.walletConfigs
        .sort((a, i) => {
          const s = a.isInstalled ? a.isInstalled() : !1,
            o = i.isInstalled ? i.isInstalled() : !1;
          return s && !o ? -1 : !s && o ? 1 : 0;
        })
        .sort((a, i) =>
          a.selectUI && !i.selectUI ? -1 : !a.selectUI && i.selectUI ? 1 : 0,
        );
    return I.jsx(tj, {
      children: r.map((a) => {
        const i = a.isInstalled ? a.isInstalled() : !1;
        return I.jsx(
          "li",
          {
            children: a.selectUI
              ? I.jsx(a.selectUI, {
                  theme: e.theme,
                  supportedWallets: n.walletConfigs,
                  onSelect: (s) => {
                    n.selectWallet(a), t((o) => ({ ...o, data: s }));
                  },
                  walletConfig: a,
                })
              : I.jsxs(nj, {
                  type: "button",
                  onClick: () => {
                    n.selectWallet(a);
                  },
                  children: [
                    I.jsx(hr, {
                      src: a.meta.iconURL,
                      width: qe.lg,
                      height: qe.lg,
                      loading: "eager",
                    }),
                    I.jsx(aj, { children: a.meta.name }),
                    i && I.jsx(rj, { children: " Installed " }),
                  ],
                }),
          },
          a.id,
        );
      }),
    });
  },
  tj = ie.ul`
  all: unset;
  list-style-type: none;
  display: flex;
  flex-direction: column;
  gap: ${he.xs};
  box-sizing: border-box;
`,
  nj = ie.button`
  all: unset;
  padding: ${he.sm} ${he.md};
  border-radius: ${st.sm};
  display: flex;
  align-items: center;
  gap: ${he.md};
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  color: ${(n) => n.theme.text.neutral};
  background: ${(n) => n.theme.bg.elevated};
  transition: 100ms ease;
  &:hover {
    background: ${(n) => n.theme.bg.highlighted};
  }
`,
  rj = ie.span`
  padding: ${he.xxs} ${he.xs};
  font-size: ${ke.xs};
  background-color: ${(n) => n.theme.badge.secondary};
  border-radius: ${st.lg};
  margin-left: auto;
`,
  aj = ie.span`
  font-size: ${ke.md};
  font-weight: 500;
`,
  ij = (n) => {
    let { close: e, walletConfig: t, open: r, supportedWallets: a } = n;
    const i = vf(),
      s = C.useRef(!1),
      o = a.length === 1;
    return (
      C.useEffect(() => {
        s.current ||
          ((s.current = !0),
          (async () => {
            e();
            try {
              await i(t);
            } catch (c) {
              o || r(), console.error(c);
            }
          })());
      }, [t, i, e, r, o]),
      null
    );
  };
ie.div`
  display: flex;
  align-items: center;
  color: ${(n) => n.theme.text.secondary};
  font-size: ${ke.sm};
  &::before,
  &::after {
    content: "";
    flex: 1;
    border-bottom: 1px solid ${(n) => n.theme.bg.elevated};
  }

  span {
    margin: 0 1rem;
  }
`;
ie(UL)`
  background: ${(n) => n.theme.bg.highlighted};
  border-radius: 50%;
  padding: ${he.xxs};
  color: ${(n) => n.theme.text.neutral};
  position: absolute;
  top: 50%;
  right: ${he.sm};
  transform: translateY(-50%);
  &:hover {
    color: ${(n) => n.theme.text.neutral};
  }
`;
const sj = ["top", "right", "bottom", "left"],
  ti = Math.min,
  Dn = Math.max,
  Sd = Math.round,
  Ol = Math.floor,
  ni = (n) => ({ x: n, y: n }),
  oj = { left: "right", right: "left", bottom: "top", top: "bottom" },
  cj = { start: "end", end: "start" };
function wh(n, e, t) {
  return Dn(n, ti(e, t));
}
function fa(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function pa(n) {
  return n.split("-")[0];
}
function go(n) {
  return n.split("-")[1];
}
function ry(n) {
  return n === "x" ? "y" : "x";
}
function ay(n) {
  return n === "y" ? "height" : "width";
}
function bo(n) {
  return ["top", "bottom"].includes(pa(n)) ? "y" : "x";
}
function iy(n) {
  return ry(bo(n));
}
function lj(n, e, t) {
  t === void 0 && (t = !1);
  const r = go(n),
    a = iy(n),
    i = ay(a);
  let s =
    a === "x"
      ? r === (t ? "end" : "start")
        ? "right"
        : "left"
      : r === "start"
      ? "bottom"
      : "top";
  return e.reference[i] > e.floating[i] && (s = Pd(s)), [s, Pd(s)];
}
function uj(n) {
  const e = Pd(n);
  return [Th(n), e, Th(e)];
}
function Th(n) {
  return n.replace(/start|end/g, (e) => cj[e]);
}
function dj(n, e, t) {
  const r = ["left", "right"],
    a = ["right", "left"],
    i = ["top", "bottom"],
    s = ["bottom", "top"];
  switch (n) {
    case "top":
    case "bottom":
      return t ? (e ? a : r) : e ? r : a;
    case "left":
    case "right":
      return e ? i : s;
    default:
      return [];
  }
}
function fj(n, e, t, r) {
  const a = go(n);
  let i = dj(pa(n), t === "start", r);
  return (
    a && ((i = i.map((s) => s + "-" + a)), e && (i = i.concat(i.map(Th)))), i
  );
}
function Pd(n) {
  return n.replace(/left|right|bottom|top/g, (e) => oj[e]);
}
function pj(n) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...n };
}
function R4(n) {
  return typeof n != "number"
    ? pj(n)
    : { top: n, right: n, bottom: n, left: n };
}
function Id(n) {
  return {
    ...n,
    top: n.y,
    left: n.x,
    right: n.x + n.width,
    bottom: n.y + n.height,
  };
}
function c2(n, e, t) {
  let { reference: r, floating: a } = n;
  const i = bo(e),
    s = iy(e),
    o = ay(s),
    c = pa(e),
    l = i === "y",
    u = r.x + r.width / 2 - a.width / 2,
    d = r.y + r.height / 2 - a.height / 2,
    f = r[o] / 2 - a[o] / 2;
  let p;
  switch (c) {
    case "top":
      p = { x: u, y: r.y - a.height };
      break;
    case "bottom":
      p = { x: u, y: r.y + r.height };
      break;
    case "right":
      p = { x: r.x + r.width, y: d };
      break;
    case "left":
      p = { x: r.x - a.width, y: d };
      break;
    default:
      p = { x: r.x, y: r.y };
  }
  switch (go(e)) {
    case "start":
      p[s] -= f * (t && l ? -1 : 1);
      break;
    case "end":
      p[s] += f * (t && l ? -1 : 1);
      break;
  }
  return p;
}
const hj = async (n, e, t) => {
  const {
      placement: r = "bottom",
      strategy: a = "absolute",
      middleware: i = [],
      platform: s,
    } = t,
    o = i.filter(Boolean),
    c = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let l = await s.getElementRects({ reference: n, floating: e, strategy: a }),
    { x: u, y: d } = c2(l, r, c),
    f = r,
    p = {},
    m = 0;
  for (let y = 0; y < o.length; y++) {
    const { name: h, fn: g } = o[y],
      {
        x: v,
        y: w,
        data: T,
        reset: A,
      } = await g({
        x: u,
        y: d,
        initialPlacement: r,
        placement: f,
        strategy: a,
        middlewareData: p,
        rects: l,
        platform: s,
        elements: { reference: n, floating: e },
      });
    if (
      ((u = v ?? u),
      (d = w ?? d),
      (p = { ...p, [h]: { ...p[h], ...T } }),
      A && m <= 50)
    ) {
      m++,
        typeof A == "object" &&
          (A.placement && (f = A.placement),
          A.rects &&
            (l =
              A.rects === !0
                ? await s.getElementRects({
                    reference: n,
                    floating: e,
                    strategy: a,
                  })
                : A.rects),
          ({ x: u, y: d } = c2(l, f, c))),
        (y = -1);
      continue;
    }
  }
  return { x: u, y: d, placement: f, strategy: a, middlewareData: p };
};
async function Ic(n, e) {
  var t;
  e === void 0 && (e = {});
  const { x: r, y: a, platform: i, rects: s, elements: o, strategy: c } = n,
    {
      boundary: l = "clippingAncestors",
      rootBoundary: u = "viewport",
      elementContext: d = "floating",
      altBoundary: f = !1,
      padding: p = 0,
    } = fa(e, n),
    m = R4(p),
    h = o[f ? (d === "floating" ? "reference" : "floating") : d],
    g = Id(
      await i.getClippingRect({
        element:
          (t = await (i.isElement == null ? void 0 : i.isElement(h))) == null ||
          t
            ? h
            : h.contextElement ||
              (await (i.getDocumentElement == null
                ? void 0
                : i.getDocumentElement(o.floating))),
        boundary: l,
        rootBoundary: u,
        strategy: c,
      }),
    ),
    v = d === "floating" ? { ...s.floating, x: r, y: a } : s.reference,
    w = await (i.getOffsetParent == null
      ? void 0
      : i.getOffsetParent(o.floating)),
    T = (await (i.isElement == null ? void 0 : i.isElement(w)))
      ? (await (i.getScale == null ? void 0 : i.getScale(w))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    A = Id(
      i.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
            rect: v,
            offsetParent: w,
            strategy: c,
          })
        : v,
    );
  return {
    top: (g.top - A.top + m.top) / T.y,
    bottom: (A.bottom - g.bottom + m.bottom) / T.y,
    left: (g.left - A.left + m.left) / T.x,
    right: (A.right - g.right + m.right) / T.x,
  };
}
const l2 = (n) => ({
    name: "arrow",
    options: n,
    async fn(e) {
      const {
          x: t,
          y: r,
          placement: a,
          rects: i,
          platform: s,
          elements: o,
        } = e,
        { element: c, padding: l = 0 } = fa(n, e) || {};
      if (c == null) return {};
      const u = R4(l),
        d = { x: t, y: r },
        f = iy(a),
        p = ay(f),
        m = await s.getDimensions(c),
        y = f === "y",
        h = y ? "top" : "left",
        g = y ? "bottom" : "right",
        v = y ? "clientHeight" : "clientWidth",
        w = i.reference[p] + i.reference[f] - d[f] - i.floating[p],
        T = d[f] - i.reference[f],
        A = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c));
      let E = A ? A[v] : 0;
      (!E || !(await (s.isElement == null ? void 0 : s.isElement(A)))) &&
        (E = o.floating[v] || i.floating[p]);
      const _ = w / 2 - T / 2,
        S = E / 2 - m[p] / 2 - 1,
        W = ti(u[h], S),
        D = ti(u[g], S),
        L = W,
        G = E - m[p] - D,
        q = E / 2 - m[p] / 2 + _,
        N = wh(L, q, G),
        J =
          go(a) != null &&
          q != N &&
          i.reference[p] / 2 - (q < L ? W : D) - m[p] / 2 < 0
            ? q < L
              ? L - q
              : G - q
            : 0;
      return { [f]: d[f] - J, data: { [f]: N, centerOffset: q - N + J } };
    },
  }),
  mj = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        name: "flip",
        options: n,
        async fn(e) {
          var t;
          const {
              placement: r,
              middlewareData: a,
              rects: i,
              initialPlacement: s,
              platform: o,
              elements: c,
            } = e,
            {
              mainAxis: l = !0,
              crossAxis: u = !0,
              fallbackPlacements: d,
              fallbackStrategy: f = "bestFit",
              fallbackAxisSideDirection: p = "none",
              flipAlignment: m = !0,
              ...y
            } = fa(n, e),
            h = pa(r),
            g = pa(s) === s,
            v = await (o.isRTL == null ? void 0 : o.isRTL(c.floating)),
            w = d || (g || !m ? [Pd(s)] : uj(s));
          !d && p !== "none" && w.push(...fj(s, m, p, v));
          const T = [s, ...w],
            A = await Ic(e, y),
            E = [];
          let _ = ((t = a.flip) == null ? void 0 : t.overflows) || [];
          if ((l && E.push(A[h]), u)) {
            const L = lj(r, i, v);
            E.push(A[L[0]], A[L[1]]);
          }
          if (
            ((_ = [..._, { placement: r, overflows: E }]),
            !E.every((L) => L <= 0))
          ) {
            var S, W;
            const L = (((S = a.flip) == null ? void 0 : S.index) || 0) + 1,
              G = T[L];
            if (G)
              return {
                data: { index: L, overflows: _ },
                reset: { placement: G },
              };
            let q =
              (W = _.filter((N) => N.overflows[0] <= 0).sort(
                (N, H) => N.overflows[1] - H.overflows[1],
              )[0]) == null
                ? void 0
                : W.placement;
            if (!q)
              switch (f) {
                case "bestFit": {
                  var D;
                  const N =
                    (D = _.map((H) => [
                      H.placement,
                      H.overflows
                        .filter((J) => J > 0)
                        .reduce((J, de) => J + de, 0),
                    ]).sort((H, J) => H[1] - J[1])[0]) == null
                      ? void 0
                      : D[0];
                  N && (q = N);
                  break;
                }
                case "initialPlacement":
                  q = s;
                  break;
              }
            if (r !== q) return { reset: { placement: q } };
          }
          return {};
        },
      }
    );
  };
function u2(n, e) {
  return {
    top: n.top - e.height,
    right: n.right - e.width,
    bottom: n.bottom - e.height,
    left: n.left - e.width,
  };
}
function d2(n) {
  return sj.some((e) => n[e] >= 0);
}
const yj = function (n) {
  return (
    n === void 0 && (n = {}),
    {
      name: "hide",
      options: n,
      async fn(e) {
        const { rects: t } = e,
          { strategy: r = "referenceHidden", ...a } = fa(n, e);
        switch (r) {
          case "referenceHidden": {
            const i = await Ic(e, { ...a, elementContext: "reference" }),
              s = u2(i, t.reference);
            return {
              data: { referenceHiddenOffsets: s, referenceHidden: d2(s) },
            };
          }
          case "escaped": {
            const i = await Ic(e, { ...a, altBoundary: !0 }),
              s = u2(i, t.floating);
            return { data: { escapedOffsets: s, escaped: d2(s) } };
          }
          default:
            return {};
        }
      },
    }
  );
};
async function gj(n, e) {
  const { placement: t, platform: r, elements: a } = n,
    i = await (r.isRTL == null ? void 0 : r.isRTL(a.floating)),
    s = pa(t),
    o = go(t),
    c = bo(t) === "y",
    l = ["left", "top"].includes(s) ? -1 : 1,
    u = i && c ? -1 : 1,
    d = fa(e, n);
  let {
    mainAxis: f,
    crossAxis: p,
    alignmentAxis: m,
  } = typeof d == "number"
    ? { mainAxis: d, crossAxis: 0, alignmentAxis: null }
    : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d };
  return (
    o && typeof m == "number" && (p = o === "end" ? m * -1 : m),
    c ? { x: p * u, y: f * l } : { x: f * l, y: p * u }
  );
}
const bj = function (n) {
    return (
      n === void 0 && (n = 0),
      {
        name: "offset",
        options: n,
        async fn(e) {
          const { x: t, y: r } = e,
            a = await gj(e, n);
          return { x: t + a.x, y: r + a.y, data: a };
        },
      }
    );
  },
  xj = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        name: "shift",
        options: n,
        async fn(e) {
          const { x: t, y: r, placement: a } = e,
            {
              mainAxis: i = !0,
              crossAxis: s = !1,
              limiter: o = {
                fn: (h) => {
                  let { x: g, y: v } = h;
                  return { x: g, y: v };
                },
              },
              ...c
            } = fa(n, e),
            l = { x: t, y: r },
            u = await Ic(e, c),
            d = bo(pa(a)),
            f = ry(d);
          let p = l[f],
            m = l[d];
          if (i) {
            const h = f === "y" ? "top" : "left",
              g = f === "y" ? "bottom" : "right",
              v = p + u[h],
              w = p - u[g];
            p = wh(v, p, w);
          }
          if (s) {
            const h = d === "y" ? "top" : "left",
              g = d === "y" ? "bottom" : "right",
              v = m + u[h],
              w = m - u[g];
            m = wh(v, m, w);
          }
          const y = o.fn({ ...e, [f]: p, [d]: m });
          return { ...y, data: { x: y.x - t, y: y.y - r } };
        },
      }
    );
  },
  vj = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        options: n,
        fn(e) {
          const { x: t, y: r, placement: a, rects: i, middlewareData: s } = e,
            { offset: o = 0, mainAxis: c = !0, crossAxis: l = !0 } = fa(n, e),
            u = { x: t, y: r },
            d = bo(a),
            f = ry(d);
          let p = u[f],
            m = u[d];
          const y = fa(o, e),
            h =
              typeof y == "number"
                ? { mainAxis: y, crossAxis: 0 }
                : { mainAxis: 0, crossAxis: 0, ...y };
          if (c) {
            const w = f === "y" ? "height" : "width",
              T = i.reference[f] - i.floating[w] + h.mainAxis,
              A = i.reference[f] + i.reference[w] - h.mainAxis;
            p < T ? (p = T) : p > A && (p = A);
          }
          if (l) {
            var g, v;
            const w = f === "y" ? "width" : "height",
              T = ["top", "left"].includes(pa(a)),
              A =
                i.reference[d] -
                i.floating[w] +
                ((T && ((g = s.offset) == null ? void 0 : g[d])) || 0) +
                (T ? 0 : h.crossAxis),
              E =
                i.reference[d] +
                i.reference[w] +
                (T ? 0 : ((v = s.offset) == null ? void 0 : v[d]) || 0) -
                (T ? h.crossAxis : 0);
            m < A ? (m = A) : m > E && (m = E);
          }
          return { [f]: p, [d]: m };
        },
      }
    );
  },
  wj = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        name: "size",
        options: n,
        async fn(e) {
          const { placement: t, rects: r, platform: a, elements: i } = e,
            { apply: s = () => {}, ...o } = fa(n, e),
            c = await Ic(e, o),
            l = pa(t),
            u = go(t),
            d = bo(t) === "y",
            { width: f, height: p } = r.floating;
          let m, y;
          l === "top" || l === "bottom"
            ? ((m = l),
              (y =
                u ===
                ((await (a.isRTL == null ? void 0 : a.isRTL(i.floating)))
                  ? "start"
                  : "end")
                  ? "left"
                  : "right"))
            : ((y = l), (m = u === "end" ? "top" : "bottom"));
          const h = p - c[m],
            g = f - c[y],
            v = !e.middlewareData.shift;
          let w = h,
            T = g;
          if (d) {
            const E = f - c.left - c.right;
            T = u || v ? ti(g, E) : E;
          } else {
            const E = p - c.top - c.bottom;
            w = u || v ? ti(h, E) : E;
          }
          if (v && !u) {
            const E = Dn(c.left, 0),
              _ = Dn(c.right, 0),
              S = Dn(c.top, 0),
              W = Dn(c.bottom, 0);
            d
              ? (T = f - 2 * (E !== 0 || _ !== 0 ? E + _ : Dn(c.left, c.right)))
              : (w =
                  p - 2 * (S !== 0 || W !== 0 ? S + W : Dn(c.top, c.bottom)));
          }
          await s({ ...e, availableWidth: T, availableHeight: w });
          const A = await a.getDimensions(i.floating);
          return f !== A.width || p !== A.height
            ? { reset: { rects: !0 } }
            : {};
        },
      }
    );
  };
function ri(n) {
  return M4(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function Fn(n) {
  var e;
  return (
    (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) ||
    window
  );
}
function ga(n) {
  var e;
  return (e = (M4(n) ? n.ownerDocument : n.document) || window.document) == null
    ? void 0
    : e.documentElement;
}
function M4(n) {
  return n instanceof Node || n instanceof Fn(n).Node;
}
function ha(n) {
  return n instanceof Element || n instanceof Fn(n).Element;
}
function Hr(n) {
  return n instanceof HTMLElement || n instanceof Fn(n).HTMLElement;
}
function f2(n) {
  return typeof ShadowRoot > "u"
    ? !1
    : n instanceof ShadowRoot || n instanceof Fn(n).ShadowRoot;
}
function nl(n) {
  const { overflow: e, overflowX: t, overflowY: r, display: a } = ar(n);
  return (
    /auto|scroll|overlay|hidden|clip/.test(e + r + t) &&
    !["inline", "contents"].includes(a)
  );
}
function Tj(n) {
  return ["table", "td", "th"].includes(ri(n));
}
function sy(n) {
  const e = oy(),
    t = ar(n);
  return (
    t.transform !== "none" ||
    t.perspective !== "none" ||
    (t.containerType ? t.containerType !== "normal" : !1) ||
    (!e && (t.backdropFilter ? t.backdropFilter !== "none" : !1)) ||
    (!e && (t.filter ? t.filter !== "none" : !1)) ||
    ["transform", "perspective", "filter"].some((r) =>
      (t.willChange || "").includes(r),
    ) ||
    ["paint", "layout", "strict", "content"].some((r) =>
      (t.contain || "").includes(r),
    )
  );
}
function Cj(n) {
  let e = Js(n);
  for (; Hr(e) && !If(e); ) {
    if (sy(e)) return e;
    e = Js(e);
  }
  return null;
}
function oy() {
  return typeof CSS > "u" || !CSS.supports
    ? !1
    : CSS.supports("-webkit-backdrop-filter", "none");
}
function If(n) {
  return ["html", "body", "#document"].includes(ri(n));
}
function ar(n) {
  return Fn(n).getComputedStyle(n);
}
function Rf(n) {
  return ha(n)
    ? { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop }
    : { scrollLeft: n.pageXOffset, scrollTop: n.pageYOffset };
}
function Js(n) {
  if (ri(n) === "html") return n;
  const e = n.assignedSlot || n.parentNode || (f2(n) && n.host) || ga(n);
  return f2(e) ? e.host : e;
}
function B4(n) {
  const e = Js(n);
  return If(e)
    ? n.ownerDocument
      ? n.ownerDocument.body
      : n.body
    : Hr(e) && nl(e)
    ? e
    : B4(e);
}
function Rd(n, e) {
  var t;
  e === void 0 && (e = []);
  const r = B4(n),
    a = r === ((t = n.ownerDocument) == null ? void 0 : t.body),
    i = Fn(r);
  return a
    ? e.concat(i, i.visualViewport || [], nl(r) ? r : [])
    : e.concat(r, Rd(r));
}
function D4(n) {
  const e = ar(n);
  let t = parseFloat(e.width) || 0,
    r = parseFloat(e.height) || 0;
  const a = Hr(n),
    i = a ? n.offsetWidth : t,
    s = a ? n.offsetHeight : r,
    o = Sd(t) !== i || Sd(r) !== s;
  return o && ((t = i), (r = s)), { width: t, height: r, $: o };
}
function cy(n) {
  return ha(n) ? n : n.contextElement;
}
function Ms(n) {
  const e = cy(n);
  if (!Hr(e)) return ni(1);
  const t = e.getBoundingClientRect(),
    { width: r, height: a, $: i } = D4(e);
  let s = (i ? Sd(t.width) : t.width) / r,
    o = (i ? Sd(t.height) : t.height) / a;
  return (
    (!s || !Number.isFinite(s)) && (s = 1),
    (!o || !Number.isFinite(o)) && (o = 1),
    { x: s, y: o }
  );
}
const Aj = ni(0);
function O4(n) {
  const e = Fn(n);
  return !oy() || !e.visualViewport
    ? Aj
    : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop };
}
function Ej(n, e, t) {
  return e === void 0 && (e = !1), !t || (e && t !== Fn(n)) ? !1 : e;
}
function Ui(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const a = n.getBoundingClientRect(),
    i = cy(n);
  let s = ni(1);
  e && (r ? ha(r) && (s = Ms(r)) : (s = Ms(n)));
  const o = Ej(i, t, r) ? O4(i) : ni(0);
  let c = (a.left + o.x) / s.x,
    l = (a.top + o.y) / s.y,
    u = a.width / s.x,
    d = a.height / s.y;
  if (i) {
    const f = Fn(i),
      p = r && ha(r) ? Fn(r) : r;
    let m = f.frameElement;
    for (; m && r && p !== f; ) {
      const y = Ms(m),
        h = m.getBoundingClientRect(),
        g = ar(m),
        v = h.left + (m.clientLeft + parseFloat(g.paddingLeft)) * y.x,
        w = h.top + (m.clientTop + parseFloat(g.paddingTop)) * y.y;
      (c *= y.x),
        (l *= y.y),
        (u *= y.x),
        (d *= y.y),
        (c += v),
        (l += w),
        (m = Fn(m).frameElement);
    }
  }
  return Id({ width: u, height: d, x: c, y: l });
}
function kj(n) {
  let { rect: e, offsetParent: t, strategy: r } = n;
  const a = Hr(t),
    i = ga(t);
  if (t === i) return e;
  let s = { scrollLeft: 0, scrollTop: 0 },
    o = ni(1);
  const c = ni(0);
  if (
    (a || (!a && r !== "fixed")) &&
    ((ri(t) !== "body" || nl(i)) && (s = Rf(t)), Hr(t))
  ) {
    const l = Ui(t);
    (o = Ms(t)), (c.x = l.x + t.clientLeft), (c.y = l.y + t.clientTop);
  }
  return {
    width: e.width * o.x,
    height: e.height * o.y,
    x: e.x * o.x - s.scrollLeft * o.x + c.x,
    y: e.y * o.y - s.scrollTop * o.y + c.y,
  };
}
function _j(n) {
  return Array.from(n.getClientRects());
}
function N4(n) {
  return Ui(ga(n)).left + Rf(n).scrollLeft;
}
function Sj(n) {
  const e = ga(n),
    t = Rf(n),
    r = n.ownerDocument.body,
    a = Dn(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth),
    i = Dn(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -t.scrollLeft + N4(n);
  const o = -t.scrollTop;
  return (
    ar(r).direction === "rtl" && (s += Dn(e.clientWidth, r.clientWidth) - a),
    { width: a, height: i, x: s, y: o }
  );
}
function Pj(n, e) {
  const t = Fn(n),
    r = ga(n),
    a = t.visualViewport;
  let i = r.clientWidth,
    s = r.clientHeight,
    o = 0,
    c = 0;
  if (a) {
    (i = a.width), (s = a.height);
    const l = oy();
    (!l || (l && e === "fixed")) && ((o = a.offsetLeft), (c = a.offsetTop));
  }
  return { width: i, height: s, x: o, y: c };
}
function Ij(n, e) {
  const t = Ui(n, !0, e === "fixed"),
    r = t.top + n.clientTop,
    a = t.left + n.clientLeft,
    i = Hr(n) ? Ms(n) : ni(1),
    s = n.clientWidth * i.x,
    o = n.clientHeight * i.y,
    c = a * i.x,
    l = r * i.y;
  return { width: s, height: o, x: c, y: l };
}
function p2(n, e, t) {
  let r;
  if (e === "viewport") r = Pj(n, t);
  else if (e === "document") r = Sj(ga(n));
  else if (ha(e)) r = Ij(e, t);
  else {
    const a = O4(n);
    r = { ...e, x: e.x - a.x, y: e.y - a.y };
  }
  return Id(r);
}
function F4(n, e) {
  const t = Js(n);
  return t === e || !ha(t) || If(t)
    ? !1
    : ar(t).position === "fixed" || F4(t, e);
}
function Rj(n, e) {
  const t = e.get(n);
  if (t) return t;
  let r = Rd(n).filter((o) => ha(o) && ri(o) !== "body"),
    a = null;
  const i = ar(n).position === "fixed";
  let s = i ? Js(n) : n;
  for (; ha(s) && !If(s); ) {
    const o = ar(s),
      c = sy(s);
    !c && o.position === "fixed" && (a = null),
      (
        i
          ? !c && !a
          : (!c &&
              o.position === "static" &&
              !!a &&
              ["absolute", "fixed"].includes(a.position)) ||
            (nl(s) && !c && F4(n, s))
      )
        ? (r = r.filter((u) => u !== s))
        : (a = o),
      (s = Js(s));
  }
  return e.set(n, r), r;
}
function Mj(n) {
  let { element: e, boundary: t, rootBoundary: r, strategy: a } = n;
  const s = [...(t === "clippingAncestors" ? Rj(e, this._c) : [].concat(t)), r],
    o = s[0],
    c = s.reduce(
      (l, u) => {
        const d = p2(e, u, a);
        return (
          (l.top = Dn(d.top, l.top)),
          (l.right = ti(d.right, l.right)),
          (l.bottom = ti(d.bottom, l.bottom)),
          (l.left = Dn(d.left, l.left)),
          l
        );
      },
      p2(e, o, a),
    );
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top,
  };
}
function Bj(n) {
  return D4(n);
}
function Dj(n, e, t) {
  const r = Hr(e),
    a = ga(e),
    i = t === "fixed",
    s = Ui(n, !0, i, e);
  let o = { scrollLeft: 0, scrollTop: 0 };
  const c = ni(0);
  if (r || (!r && !i))
    if (((ri(e) !== "body" || nl(a)) && (o = Rf(e)), r)) {
      const l = Ui(e, !0, i, e);
      (c.x = l.x + e.clientLeft), (c.y = l.y + e.clientTop);
    } else a && (c.x = N4(a));
  return {
    x: s.left + o.scrollLeft - c.x,
    y: s.top + o.scrollTop - c.y,
    width: s.width,
    height: s.height,
  };
}
function h2(n, e) {
  return !Hr(n) || ar(n).position === "fixed"
    ? null
    : e
    ? e(n)
    : n.offsetParent;
}
function L4(n, e) {
  const t = Fn(n);
  if (!Hr(n)) return t;
  let r = h2(n, e);
  for (; r && Tj(r) && ar(r).position === "static"; ) r = h2(r, e);
  return r &&
    (ri(r) === "html" ||
      (ri(r) === "body" && ar(r).position === "static" && !sy(r)))
    ? t
    : r || Cj(n) || t;
}
const Oj = async function (n) {
  let { reference: e, floating: t, strategy: r } = n;
  const a = this.getOffsetParent || L4,
    i = this.getDimensions;
  return {
    reference: Dj(e, await a(t), r),
    floating: { x: 0, y: 0, ...(await i(t)) },
  };
};
function Nj(n) {
  return ar(n).direction === "rtl";
}
const Fj = {
  convertOffsetParentRelativeRectToViewportRelativeRect: kj,
  getDocumentElement: ga,
  getClippingRect: Mj,
  getOffsetParent: L4,
  getElementRects: Oj,
  getClientRects: _j,
  getDimensions: Bj,
  getScale: Ms,
  isElement: ha,
  isRTL: Nj,
};
function Lj(n, e) {
  let t = null,
    r;
  const a = ga(n);
  function i() {
    clearTimeout(r), t && t.disconnect(), (t = null);
  }
  function s(o, c) {
    o === void 0 && (o = !1), c === void 0 && (c = 1), i();
    const { left: l, top: u, width: d, height: f } = n.getBoundingClientRect();
    if ((o || e(), !d || !f)) return;
    const p = Ol(u),
      m = Ol(a.clientWidth - (l + d)),
      y = Ol(a.clientHeight - (u + f)),
      h = Ol(l),
      v = {
        rootMargin: -p + "px " + -m + "px " + -y + "px " + -h + "px",
        threshold: Dn(0, ti(1, c)) || 1,
      };
    let w = !0;
    function T(A) {
      const E = A[0].intersectionRatio;
      if (E !== c) {
        if (!w) return s();
        E
          ? s(!1, E)
          : (r = setTimeout(() => {
              s(!1, 1e-7);
            }, 100));
      }
      w = !1;
    }
    try {
      t = new IntersectionObserver(T, { ...v, root: a.ownerDocument });
    } catch {
      t = new IntersectionObserver(T, v);
    }
    t.observe(n);
  }
  return s(!0), i;
}
function $j(n, e, t, r) {
  r === void 0 && (r = {});
  const {
      ancestorScroll: a = !0,
      ancestorResize: i = !0,
      elementResize: s = typeof ResizeObserver == "function",
      layoutShift: o = typeof IntersectionObserver == "function",
      animationFrame: c = !1,
    } = r,
    l = cy(n),
    u = a || i ? [...(l ? Rd(l) : []), ...Rd(e)] : [];
  u.forEach((g) => {
    a && g.addEventListener("scroll", t, { passive: !0 }),
      i && g.addEventListener("resize", t);
  });
  const d = l && o ? Lj(l, t) : null;
  let f = -1,
    p = null;
  s &&
    ((p = new ResizeObserver((g) => {
      let [v] = g;
      v &&
        v.target === l &&
        p &&
        (p.unobserve(e),
        cancelAnimationFrame(f),
        (f = requestAnimationFrame(() => {
          p && p.observe(e);
        }))),
        t();
    })),
    l && !c && p.observe(l),
    p.observe(e));
  let m,
    y = c ? Ui(n) : null;
  c && h();
  function h() {
    const g = Ui(n);
    y &&
      (g.x !== y.x ||
        g.y !== y.y ||
        g.width !== y.width ||
        g.height !== y.height) &&
      t(),
      (y = g),
      (m = requestAnimationFrame(h));
  }
  return (
    t(),
    () => {
      u.forEach((g) => {
        a && g.removeEventListener("scroll", t),
          i && g.removeEventListener("resize", t);
      }),
        d && d(),
        p && p.disconnect(),
        (p = null),
        c && cancelAnimationFrame(m);
    }
  );
}
const Wj = (n, e, t) => {
    const r = new Map(),
      a = { platform: Fj, ...t },
      i = { ...a.platform, _c: r };
    return hj(n, e, { ...a, platform: i });
  },
  Uj = (n) => {
    function e(t) {
      return {}.hasOwnProperty.call(t, "current");
    }
    return {
      name: "arrow",
      options: n,
      fn(t) {
        const { element: r, padding: a } = typeof n == "function" ? n(t) : n;
        return r && e(r)
          ? r.current != null
            ? l2({ element: r.current, padding: a }).fn(t)
            : {}
          : r
          ? l2({ element: r, padding: a }).fn(t)
          : {};
      },
    };
  };
var ru = typeof document < "u" ? C.useLayoutEffect : C.useEffect;
function Md(n, e) {
  if (n === e) return !0;
  if (typeof n != typeof e) return !1;
  if (typeof n == "function" && n.toString() === e.toString()) return !0;
  let t, r, a;
  if (n && e && typeof n == "object") {
    if (Array.isArray(n)) {
      if (((t = n.length), t != e.length)) return !1;
      for (r = t; r-- !== 0; ) if (!Md(n[r], e[r])) return !1;
      return !0;
    }
    if (((a = Object.keys(n)), (t = a.length), t !== Object.keys(e).length))
      return !1;
    for (r = t; r-- !== 0; ) if (!{}.hasOwnProperty.call(e, a[r])) return !1;
    for (r = t; r-- !== 0; ) {
      const i = a[r];
      if (!(i === "_owner" && n.$$typeof) && !Md(n[i], e[i])) return !1;
    }
    return !0;
  }
  return n !== n && e !== e;
}
function $4(n) {
  return typeof window > "u"
    ? 1
    : (n.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function m2(n, e) {
  const t = $4(n);
  return Math.round(e * t) / t;
}
function y2(n) {
  const e = C.useRef(n);
  return (
    ru(() => {
      e.current = n;
    }),
    e
  );
}
function jj(n) {
  n === void 0 && (n = {});
  const {
      placement: e = "bottom",
      strategy: t = "absolute",
      middleware: r = [],
      platform: a,
      elements: { reference: i, floating: s } = {},
      transform: o = !0,
      whileElementsMounted: c,
      open: l,
    } = n,
    [u, d] = C.useState({
      x: 0,
      y: 0,
      strategy: t,
      placement: e,
      middlewareData: {},
      isPositioned: !1,
    }),
    [f, p] = C.useState(r);
  Md(f, r) || p(r);
  const [m, y] = C.useState(null),
    [h, g] = C.useState(null),
    v = C.useCallback(
      (J) => {
        J != E.current && ((E.current = J), y(J));
      },
      [y],
    ),
    w = C.useCallback(
      (J) => {
        J !== _.current && ((_.current = J), g(J));
      },
      [g],
    ),
    T = i || m,
    A = s || h,
    E = C.useRef(null),
    _ = C.useRef(null),
    S = C.useRef(u),
    W = y2(c),
    D = y2(a),
    L = C.useCallback(() => {
      if (!E.current || !_.current) return;
      const J = { placement: e, strategy: t, middleware: f };
      D.current && (J.platform = D.current),
        Wj(E.current, _.current, J).then((de) => {
          const le = { ...de, isPositioned: !0 };
          G.current &&
            !Md(S.current, le) &&
            ((S.current = le),
            Sh.flushSync(() => {
              d(le);
            }));
        });
    }, [f, e, t, D]);
  ru(() => {
    l === !1 &&
      S.current.isPositioned &&
      ((S.current.isPositioned = !1), d((J) => ({ ...J, isPositioned: !1 })));
  }, [l]);
  const G = C.useRef(!1);
  ru(
    () => (
      (G.current = !0),
      () => {
        G.current = !1;
      }
    ),
    [],
  ),
    ru(() => {
      if ((T && (E.current = T), A && (_.current = A), T && A)) {
        if (W.current) return W.current(T, A, L);
        L();
      }
    }, [T, A, L, W]);
  const q = C.useMemo(
      () => ({ reference: E, floating: _, setReference: v, setFloating: w }),
      [v, w],
    ),
    N = C.useMemo(() => ({ reference: T, floating: A }), [T, A]),
    H = C.useMemo(() => {
      const J = { position: t, left: 0, top: 0 };
      if (!N.floating) return J;
      const de = m2(N.floating, u.x),
        le = m2(N.floating, u.y);
      return o
        ? {
            ...J,
            transform: "translate(" + de + "px, " + le + "px)",
            ...($4(N.floating) >= 1.5 && { willChange: "transform" }),
          }
        : { position: t, left: de, top: le };
    }, [t, o, N.floating, u.x, u.y]);
  return C.useMemo(
    () => ({ ...u, update: L, refs: q, elements: N, floatingStyles: H }),
    [u, L, q, N, H],
  );
}
const zj = C.forwardRef((n, e) => {
    const { children: t, width: r = 10, height: a = 5, ...i } = n;
    return C.createElement(
      kn.svg,
      ve({}, i, {
        ref: e,
        width: r,
        height: a,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
      }),
      n.asChild ? t : C.createElement("polygon", { points: "0,0 30,0 15,10" }),
    );
  }),
  Hj = zj;
function qj(n) {
  const [e, t] = C.useState(void 0);
  return (
    Ys(() => {
      if (n) {
        t({ width: n.offsetWidth, height: n.offsetHeight });
        const r = new ResizeObserver((a) => {
          if (!Array.isArray(a) || !a.length) return;
          const i = a[0];
          let s, o;
          if ("borderBoxSize" in i) {
            const c = i.borderBoxSize,
              l = Array.isArray(c) ? c[0] : c;
            (s = l.inlineSize), (o = l.blockSize);
          } else (s = n.offsetWidth), (o = n.offsetHeight);
          t({ width: s, height: o });
        });
        return r.observe(n, { box: "border-box" }), () => r.unobserve(n);
      } else t(void 0);
    }, [n]),
    e
  );
}
const W4 = "Popper",
  [U4, xo] = ya(W4),
  [kq, Vj] = U4(W4),
  j4 = "PopperContent",
  [Gj, Kj] = U4(j4),
  Qj = C.forwardRef((n, e) => {
    var t, r, a, i, s, o, c, l;
    const {
        __scopePopper: u,
        side: d = "bottom",
        sideOffset: f = 0,
        align: p = "center",
        alignOffset: m = 0,
        arrowPadding: y = 0,
        collisionBoundary: h = [],
        collisionPadding: g = 0,
        sticky: v = "partial",
        hideWhenDetached: w = !1,
        avoidCollisions: T = !0,
        onPlaced: A,
        ...E
      } = n,
      _ = Vj(j4, u),
      [S, W] = C.useState(null),
      D = sn(e, (ot) => W(ot)),
      [L, G] = C.useState(null),
      q = qj(L),
      N = (t = q == null ? void 0 : q.width) !== null && t !== void 0 ? t : 0,
      H = (r = q == null ? void 0 : q.height) !== null && r !== void 0 ? r : 0,
      J = d + (p !== "center" ? "-" + p : ""),
      de =
        typeof g == "number"
          ? g
          : { top: 0, right: 0, bottom: 0, left: 0, ...g },
      le = Array.isArray(h) ? h : [h],
      Z = le.length > 0,
      ue = { padding: de, boundary: le.filter(Zj), altBoundary: Z },
      {
        refs: P,
        floatingStyles: B,
        placement: j,
        isPositioned: F,
        middlewareData: V,
      } = jj({
        strategy: "fixed",
        placement: J,
        whileElementsMounted: $j,
        elements: { reference: _.anchor },
        middleware: [
          bj({ mainAxis: f + H, alignmentAxis: m }),
          T &&
            xj({
              mainAxis: !0,
              crossAxis: !1,
              limiter: v === "partial" ? vj() : void 0,
              ...ue,
            }),
          T && mj({ ...ue }),
          wj({
            ...ue,
            apply: ({
              elements: ot,
              rects: ba,
              availableWidth: Kr,
              availableHeight: Cr,
            }) => {
              const { width: Qr, height: di } = ba.reference,
                _n = ot.floating.style;
              _n.setProperty("--radix-popper-available-width", `${Kr}px`),
                _n.setProperty("--radix-popper-available-height", `${Cr}px`),
                _n.setProperty("--radix-popper-anchor-width", `${Qr}px`),
                _n.setProperty("--radix-popper-anchor-height", `${di}px`);
            },
          }),
          L && Uj({ element: L, padding: y }),
          ez({ arrowWidth: N, arrowHeight: H }),
          w && yj({ strategy: "referenceHidden" }),
        ],
      }),
      [re, we] = z4(j),
      se = da(A);
    Ys(() => {
      F && (se == null || se());
    }, [F, se]);
    const be = (a = V.arrow) === null || a === void 0 ? void 0 : a.x,
      Ke = (i = V.arrow) === null || i === void 0 ? void 0 : i.y,
      dt =
        ((s = V.arrow) === null || s === void 0 ? void 0 : s.centerOffset) !==
        0,
      [cn, wt] = C.useState();
    return (
      Ys(() => {
        S && wt(window.getComputedStyle(S).zIndex);
      }, [S]),
      C.createElement(
        "div",
        {
          ref: P.setFloating,
          "data-radix-popper-content-wrapper": "",
          style: {
            ...B,
            transform: F ? B.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: cn,
            "--radix-popper-transform-origin": [
              (o = V.transformOrigin) === null || o === void 0 ? void 0 : o.x,
              (c = V.transformOrigin) === null || c === void 0 ? void 0 : c.y,
            ].join(" "),
          },
          dir: n.dir,
        },
        C.createElement(
          Gj,
          {
            scope: u,
            placedSide: re,
            onArrowChange: G,
            arrowX: be,
            arrowY: Ke,
            shouldHideArrow: dt,
          },
          C.createElement(
            kn.div,
            ve({ "data-side": re, "data-align": we }, E, {
              ref: D,
              style: {
                ...E.style,
                animation: F ? void 0 : "none",
                opacity:
                  (l = V.hide) !== null && l !== void 0 && l.referenceHidden
                    ? 0
                    : void 0,
              },
            }),
          ),
        ),
      )
    );
  }),
  Yj = "PopperArrow",
  Jj = { top: "bottom", right: "left", bottom: "top", left: "right" },
  Xj = C.forwardRef(function (e, t) {
    const { __scopePopper: r, ...a } = e,
      i = Kj(Yj, r),
      s = Jj[i.placedSide];
    return C.createElement(
      "span",
      {
        ref: i.onArrowChange,
        style: {
          position: "absolute",
          left: i.arrowX,
          top: i.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0",
          }[i.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)",
          }[i.placedSide],
          visibility: i.shouldHideArrow ? "hidden" : void 0,
        },
      },
      C.createElement(
        Hj,
        ve({}, a, { ref: t, style: { ...a.style, display: "block" } }),
      ),
    );
  });
function Zj(n) {
  return n !== null;
}
const ez = (n) => ({
  name: "transformOrigin",
  options: n,
  fn(e) {
    var t, r, a, i, s;
    const { placement: o, rects: c, middlewareData: l } = e,
      d =
        ((t = l.arrow) === null || t === void 0 ? void 0 : t.centerOffset) !==
        0,
      f = d ? 0 : n.arrowWidth,
      p = d ? 0 : n.arrowHeight,
      [m, y] = z4(o),
      h = { start: "0%", center: "50%", end: "100%" }[y],
      g =
        ((r = (a = l.arrow) === null || a === void 0 ? void 0 : a.x) !== null &&
        r !== void 0
          ? r
          : 0) +
        f / 2,
      v =
        ((i = (s = l.arrow) === null || s === void 0 ? void 0 : s.y) !== null &&
        i !== void 0
          ? i
          : 0) +
        p / 2;
    let w = "",
      T = "";
    return (
      m === "bottom"
        ? ((w = d ? h : `${g}px`), (T = `${-p}px`))
        : m === "top"
        ? ((w = d ? h : `${g}px`), (T = `${c.floating.height + p}px`))
        : m === "right"
        ? ((w = `${-p}px`), (T = d ? h : `${v}px`))
        : m === "left" &&
          ((w = `${c.floating.width + p}px`), (T = d ? h : `${v}px`)),
      { data: { x: w, y: T } }
    );
  },
});
function z4(n) {
  const [e, t = "center"] = n.split("-");
  return [e, t];
}
const ly = Qj,
  H4 = Xj,
  q4 = "Popover",
  [V4, _q] = ya(q4, [xo]),
  G4 = xo(),
  [Sq, Mf] = V4(q4),
  tz = "PopoverPortal",
  [Pq, nz] = V4(tz, { forceMount: void 0 }),
  Rc = "PopoverContent",
  rz = C.forwardRef((n, e) => {
    const t = nz(Rc, n.__scopePopover),
      { forceMount: r = t.forceMount, ...a } = n,
      i = Mf(Rc, n.__scopePopover);
    return C.createElement(
      Xi,
      { present: r || i.open },
      i.modal
        ? C.createElement(az, ve({}, a, { ref: e }))
        : C.createElement(iz, ve({}, a, { ref: e })),
    );
  }),
  az = C.forwardRef((n, e) => {
    const t = Mf(Rc, n.__scopePopover),
      r = C.useRef(null),
      a = sn(e, r),
      i = C.useRef(!1);
    return (
      C.useEffect(() => {
        const s = r.current;
        if (s) return Ym(s);
      }, []),
      C.createElement(
        Qm,
        { as: Wi, allowPinchZoom: !0 },
        C.createElement(
          K4,
          ve({}, n, {
            ref: a,
            trapFocus: t.open,
            disableOutsidePointerEvents: !0,
            onCloseAutoFocus: Oe(n.onCloseAutoFocus, (s) => {
              var o;
              s.preventDefault(),
                i.current ||
                  (o = t.triggerRef.current) === null ||
                  o === void 0 ||
                  o.focus();
            }),
            onPointerDownOutside: Oe(
              n.onPointerDownOutside,
              (s) => {
                const o = s.detail.originalEvent,
                  c = o.button === 0 && o.ctrlKey === !0,
                  l = o.button === 2 || c;
                i.current = l;
              },
              { checkForDefaultPrevented: !1 },
            ),
            onFocusOutside: Oe(n.onFocusOutside, (s) => s.preventDefault(), {
              checkForDefaultPrevented: !1,
            }),
          }),
        ),
      )
    );
  }),
  iz = C.forwardRef((n, e) => {
    const t = Mf(Rc, n.__scopePopover),
      r = C.useRef(!1),
      a = C.useRef(!1);
    return C.createElement(
      K4,
      ve({}, n, {
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          var s;
          if (
            ((s = n.onCloseAutoFocus) === null || s === void 0 || s.call(n, i),
            !i.defaultPrevented)
          ) {
            var o;
            r.current ||
              (o = t.triggerRef.current) === null ||
              o === void 0 ||
              o.focus(),
              i.preventDefault();
          }
          (r.current = !1), (a.current = !1);
        },
        onInteractOutside: (i) => {
          var s, o;
          (s = n.onInteractOutside) === null || s === void 0 || s.call(n, i),
            i.defaultPrevented ||
              ((r.current = !0),
              i.detail.originalEvent.type === "pointerdown" &&
                (a.current = !0));
          const c = i.target;
          ((o = t.triggerRef.current) === null || o === void 0
            ? void 0
            : o.contains(c)) && i.preventDefault(),
            i.detail.originalEvent.type === "focusin" &&
              a.current &&
              i.preventDefault();
        },
      }),
    );
  }),
  K4 = C.forwardRef((n, e) => {
    const {
        __scopePopover: t,
        trapFocus: r,
        onOpenAutoFocus: a,
        onCloseAutoFocus: i,
        disableOutsidePointerEvents: s,
        onEscapeKeyDown: o,
        onPointerDownOutside: c,
        onFocusOutside: l,
        onInteractOutside: u,
        ...d
      } = n,
      f = Mf(Rc, t),
      p = G4(t);
    return (
      Vm(),
      C.createElement(
        qm,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: a,
          onUnmountAutoFocus: i,
        },
        C.createElement(
          _f,
          {
            asChild: !0,
            disableOutsidePointerEvents: s,
            onInteractOutside: u,
            onEscapeKeyDown: o,
            onPointerDownOutside: c,
            onFocusOutside: l,
            onDismiss: () => f.onOpenChange(!1),
          },
          C.createElement(
            ly,
            ve(
              { "data-state": oz(f.open), role: "dialog", id: f.contentId },
              p,
              d,
              {
                ref: e,
                style: {
                  ...d.style,
                  "--radix-popover-content-transform-origin":
                    "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width":
                    "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height":
                    "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width":
                    "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height":
                    "var(--radix-popper-anchor-height)",
                },
              },
            ),
          ),
        ),
      )
    );
  }),
  sz = C.forwardRef((n, e) => {
    const { __scopePopover: t, ...r } = n,
      a = G4(t);
    return C.createElement(H4, ve({}, a, r, { ref: e }));
  });
function oz(n) {
  return n ? "open" : "closed";
}
const cz = rz,
  lz = sz,
  uz = C.forwardRef((n, e) =>
    C.createElement(
      kn.span,
      ve({}, n, {
        ref: e,
        style: {
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...n.style,
        },
      }),
    ),
  ),
  dz = uz,
  [Bf, Iq] = ya("Tooltip", [xo]),
  Q4 = xo(),
  fz = "TooltipProvider",
  g2 = "tooltip.open",
  [Rq, pz] = Bf(fz),
  Y4 = "Tooltip",
  [Mq, uy] = Bf(Y4),
  hz = "TooltipPortal",
  [Bq, mz] = Bf(hz, { forceMount: void 0 }),
  Mc = "TooltipContent",
  yz = C.forwardRef((n, e) => {
    const t = mz(Mc, n.__scopeTooltip),
      { forceMount: r = t.forceMount, side: a = "top", ...i } = n,
      s = uy(Mc, n.__scopeTooltip);
    return C.createElement(
      Xi,
      { present: r || s.open },
      s.disableHoverableContent
        ? C.createElement(J4, ve({ side: a }, i, { ref: e }))
        : C.createElement(gz, ve({ side: a }, i, { ref: e })),
    );
  }),
  gz = C.forwardRef((n, e) => {
    const t = uy(Mc, n.__scopeTooltip),
      r = pz(Mc, n.__scopeTooltip),
      a = C.useRef(null),
      i = sn(e, a),
      [s, o] = C.useState(null),
      { trigger: c, onClose: l } = t,
      u = a.current,
      { onPointerInTransitChange: d } = r,
      f = C.useCallback(() => {
        o(null), d(!1);
      }, [d]),
      p = C.useCallback(
        (m, y) => {
          const h = m.currentTarget,
            g = { x: m.clientX, y: m.clientY },
            v = Tz(g, h.getBoundingClientRect()),
            w = Cz(g, v),
            T = Az(y.getBoundingClientRect()),
            A = kz([...w, ...T]);
          o(A), d(!0);
        },
        [d],
      );
    return (
      C.useEffect(() => () => f(), [f]),
      C.useEffect(() => {
        if (c && u) {
          const m = (h) => p(h, u),
            y = (h) => p(h, c);
          return (
            c.addEventListener("pointerleave", m),
            u.addEventListener("pointerleave", y),
            () => {
              c.removeEventListener("pointerleave", m),
                u.removeEventListener("pointerleave", y);
            }
          );
        }
      }, [c, u, p, f]),
      C.useEffect(() => {
        if (s) {
          const m = (y) => {
            const h = y.target,
              g = { x: y.clientX, y: y.clientY },
              v =
                (c == null ? void 0 : c.contains(h)) ||
                (u == null ? void 0 : u.contains(h)),
              w = !Ez(g, s);
            v ? f() : w && (f(), l());
          };
          return (
            document.addEventListener("pointermove", m),
            () => document.removeEventListener("pointermove", m)
          );
        }
      }, [c, u, s, l, f]),
      C.createElement(J4, ve({}, n, { ref: i }))
    );
  }),
  [bz, xz] = Bf(Y4, { isInside: !1 }),
  J4 = C.forwardRef((n, e) => {
    const {
        __scopeTooltip: t,
        children: r,
        "aria-label": a,
        onEscapeKeyDown: i,
        onPointerDownOutside: s,
        ...o
      } = n,
      c = uy(Mc, t),
      l = Q4(t),
      { onClose: u } = c;
    return (
      C.useEffect(
        () => (
          document.addEventListener(g2, u),
          () => document.removeEventListener(g2, u)
        ),
        [u],
      ),
      C.useEffect(() => {
        if (c.trigger) {
          const d = (f) => {
            const p = f.target;
            p != null && p.contains(c.trigger) && u();
          };
          return (
            window.addEventListener("scroll", d, { capture: !0 }),
            () => window.removeEventListener("scroll", d, { capture: !0 })
          );
        }
      }, [c.trigger, u]),
      C.createElement(
        _f,
        {
          asChild: !0,
          disableOutsidePointerEvents: !1,
          onEscapeKeyDown: i,
          onPointerDownOutside: s,
          onFocusOutside: (d) => d.preventDefault(),
          onDismiss: u,
        },
        C.createElement(
          ly,
          ve({ "data-state": c.stateAttribute }, l, o, {
            ref: e,
            style: {
              ...o.style,
              "--radix-tooltip-content-transform-origin":
                "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width":
                "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height":
                "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width":
                "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height":
                "var(--radix-popper-anchor-height)",
            },
          }),
          C.createElement(i4, null, r),
          C.createElement(
            bz,
            { scope: t, isInside: !0 },
            C.createElement(dz, { id: c.contentId, role: "tooltip" }, a || r),
          ),
        ),
      )
    );
  }),
  vz = "TooltipArrow",
  wz = C.forwardRef((n, e) => {
    const { __scopeTooltip: t, ...r } = n,
      a = Q4(t);
    return xz(vz, t).isInside
      ? null
      : C.createElement(H4, ve({}, a, r, { ref: e }));
  });
function Tz(n, e) {
  const t = Math.abs(e.top - n.y),
    r = Math.abs(e.bottom - n.y),
    a = Math.abs(e.right - n.x),
    i = Math.abs(e.left - n.x);
  switch (Math.min(t, r, a, i)) {
    case i:
      return "left";
    case a:
      return "right";
    case t:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function Cz(n, e, t = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push({ x: n.x - t, y: n.y + t }, { x: n.x + t, y: n.y + t });
      break;
    case "bottom":
      r.push({ x: n.x - t, y: n.y - t }, { x: n.x + t, y: n.y - t });
      break;
    case "left":
      r.push({ x: n.x + t, y: n.y - t }, { x: n.x + t, y: n.y + t });
      break;
    case "right":
      r.push({ x: n.x - t, y: n.y - t }, { x: n.x - t, y: n.y + t });
      break;
  }
  return r;
}
function Az(n) {
  const { top: e, right: t, bottom: r, left: a } = n;
  return [
    { x: a, y: e },
    { x: t, y: e },
    { x: t, y: r },
    { x: a, y: r },
  ];
}
function Ez(n, e) {
  const { x: t, y: r } = n;
  let a = !1;
  for (let i = 0, s = e.length - 1; i < e.length; s = i++) {
    const o = e[i].x,
      c = e[i].y,
      l = e[s].x,
      u = e[s].y;
    c > r != u > r && t < ((l - o) * (r - c)) / (u - c) + o && (a = !a);
  }
  return a;
}
function kz(n) {
  const e = n.slice();
  return (
    e.sort((t, r) =>
      t.x < r.x ? -1 : t.x > r.x ? 1 : t.y < r.y ? -1 : t.y > r.y ? 1 : 0,
    ),
    _z(e)
  );
}
function _z(n) {
  if (n.length <= 1) return n.slice();
  const e = [];
  for (let r = 0; r < n.length; r++) {
    const a = n[r];
    for (; e.length >= 2; ) {
      const i = e[e.length - 1],
        s = e[e.length - 2];
      if ((i.x - s.x) * (a.y - s.y) >= (i.y - s.y) * (a.x - s.x)) e.pop();
      else break;
    }
    e.push(a);
  }
  e.pop();
  const t = [];
  for (let r = n.length - 1; r >= 0; r--) {
    const a = n[r];
    for (; t.length >= 2; ) {
      const i = t[t.length - 1],
        s = t[t.length - 2];
      if ((i.x - s.x) * (a.y - s.y) >= (i.y - s.y) * (a.x - s.x)) t.pop();
      else break;
    }
    t.push(a);
  }
  return (
    t.pop(),
    e.length === 1 && t.length === 1 && e[0].x === t[0].x && e[0].y === t[0].y
      ? e
      : e.concat(t)
  );
}
const Sz = yz,
  Pz = wz,
  Iz = Vr`
from {
  opacity: 0;
  transform: translateY(2px);
}
to {
  opacity: 1;
  transform: translateY(0);
}
`;
ie(Sz)`
  background: ${(n) => n.theme.tooltip.bg};
  color: ${(n) => n.theme.tooltip.text};
  border-radius: ${st.sm};
  line-height: 1;
  padding: ${he.sm} ${he.md};
  font-size: ${ke.sm};
  box-shadow: ${Af.sm};
  user-select: none;
  will-change: transform, opacity;
  animation: ${Iz} 200ms cubic-bezier(0.16, 1, 0.3, 1);
  z-index: 999999999999999;
  max-width: 300px;
  line-height: 1.5;
`;
ie(Pz)`
  fill: ${(n) => n.theme.tooltip.bg};
`;
function X4(n) {
  const e = n + "CollectionProvider",
    [t, r] = ya(e),
    [a, i] = t(e, { collectionRef: { current: null }, itemMap: new Map() }),
    s = (p) => {
      const { scope: m, children: y } = p,
        h = Xt.useRef(null),
        g = Xt.useRef(new Map()).current;
      return Xt.createElement(a, { scope: m, itemMap: g, collectionRef: h }, y);
    },
    o = n + "CollectionSlot",
    c = Xt.forwardRef((p, m) => {
      const { scope: y, children: h } = p,
        g = i(o, y),
        v = sn(m, g.collectionRef);
      return Xt.createElement(Wi, { ref: v }, h);
    }),
    l = n + "CollectionItemSlot",
    u = "data-radix-collection-item",
    d = Xt.forwardRef((p, m) => {
      const { scope: y, children: h, ...g } = p,
        v = Xt.useRef(null),
        w = sn(m, v),
        T = i(l, y);
      return (
        Xt.useEffect(
          () => (
            T.itemMap.set(v, { ref: v, ...g }), () => void T.itemMap.delete(v)
          ),
        ),
        Xt.createElement(Wi, { [u]: "", ref: w }, h)
      );
    });
  function f(p) {
    const m = i(n + "CollectionConsumer", p);
    return Xt.useCallback(() => {
      const h = m.collectionRef.current;
      if (!h) return [];
      const g = Array.from(h.querySelectorAll(`[${u}]`));
      return Array.from(m.itemMap.values()).sort(
        (T, A) => g.indexOf(T.ref.current) - g.indexOf(A.ref.current),
      );
    }, [m.collectionRef, m.itemMap]);
  }
  return [{ Provider: s, Slot: c, ItemSlot: d }, f, r];
}
const Rz = C.createContext(void 0);
function Mz(n) {
  const e = C.useContext(Rz);
  return n || e || "ltr";
}
const cp = "rovingFocusGroup.onEntryFocus",
  Bz = { bubbles: !1, cancelable: !0 },
  dy = "RovingFocusGroup",
  [Ch, Z4, Dz] = X4(dy),
  [Oz, Df] = ya(dy, [Dz]),
  [Nz, Fz] = Oz(dy),
  Lz = C.forwardRef((n, e) =>
    C.createElement(
      Ch.Provider,
      { scope: n.__scopeRovingFocusGroup },
      C.createElement(
        Ch.Slot,
        { scope: n.__scopeRovingFocusGroup },
        C.createElement($z, ve({}, n, { ref: e })),
      ),
    ),
  ),
  $z = C.forwardRef((n, e) => {
    const {
        __scopeRovingFocusGroup: t,
        orientation: r,
        loop: a = !1,
        dir: i,
        currentTabStopId: s,
        defaultCurrentTabStopId: o,
        onCurrentTabStopIdChange: c,
        onEntryFocus: l,
        ...u
      } = n,
      d = C.useRef(null),
      f = sn(e, d),
      p = Mz(i),
      [m = null, y] = a4({ prop: s, defaultProp: o, onChange: c }),
      [h, g] = C.useState(!1),
      v = da(l),
      w = Z4(t),
      T = C.useRef(!1),
      [A, E] = C.useState(0);
    return (
      C.useEffect(() => {
        const _ = d.current;
        if (_)
          return _.addEventListener(cp, v), () => _.removeEventListener(cp, v);
      }, [v]),
      C.createElement(
        Nz,
        {
          scope: t,
          orientation: r,
          dir: p,
          loop: a,
          currentTabStopId: m,
          onItemFocus: C.useCallback((_) => y(_), [y]),
          onItemShiftTab: C.useCallback(() => g(!0), []),
          onFocusableItemAdd: C.useCallback(() => E((_) => _ + 1), []),
          onFocusableItemRemove: C.useCallback(() => E((_) => _ - 1), []),
        },
        C.createElement(
          kn.div,
          ve({ tabIndex: h || A === 0 ? -1 : 0, "data-orientation": r }, u, {
            ref: f,
            style: { outline: "none", ...n.style },
            onMouseDown: Oe(n.onMouseDown, () => {
              T.current = !0;
            }),
            onFocus: Oe(n.onFocus, (_) => {
              const S = !T.current;
              if (_.target === _.currentTarget && S && !h) {
                const W = new CustomEvent(cp, Bz);
                if ((_.currentTarget.dispatchEvent(W), !W.defaultPrevented)) {
                  const D = w().filter((H) => H.focusable),
                    L = D.find((H) => H.active),
                    G = D.find((H) => H.id === m),
                    N = [L, G, ...D].filter(Boolean).map((H) => H.ref.current);
                  e8(N);
                }
              }
              T.current = !1;
            }),
            onBlur: Oe(n.onBlur, () => g(!1)),
          }),
        ),
      )
    );
  }),
  Wz = "RovingFocusGroupItem",
  Uz = C.forwardRef((n, e) => {
    const {
        __scopeRovingFocusGroup: t,
        focusable: r = !0,
        active: a = !1,
        tabStopId: i,
        ...s
      } = n,
      o = eu(),
      c = i || o,
      l = Fz(Wz, t),
      u = l.currentTabStopId === c,
      d = Z4(t),
      { onFocusableItemAdd: f, onFocusableItemRemove: p } = l;
    return (
      C.useEffect(() => {
        if (r) return f(), () => p();
      }, [r, f, p]),
      C.createElement(
        Ch.ItemSlot,
        { scope: t, id: c, focusable: r, active: a },
        C.createElement(
          kn.span,
          ve({ tabIndex: u ? 0 : -1, "data-orientation": l.orientation }, s, {
            ref: e,
            onMouseDown: Oe(n.onMouseDown, (m) => {
              r ? l.onItemFocus(c) : m.preventDefault();
            }),
            onFocus: Oe(n.onFocus, () => l.onItemFocus(c)),
            onKeyDown: Oe(n.onKeyDown, (m) => {
              if (m.key === "Tab" && m.shiftKey) {
                l.onItemShiftTab();
                return;
              }
              if (m.target !== m.currentTarget) return;
              const y = Hz(m, l.orientation, l.dir);
              if (y !== void 0) {
                m.preventDefault();
                let g = d()
                  .filter((v) => v.focusable)
                  .map((v) => v.ref.current);
                if (y === "last") g.reverse();
                else if (y === "prev" || y === "next") {
                  y === "prev" && g.reverse();
                  const v = g.indexOf(m.currentTarget);
                  g = l.loop ? qz(g, v + 1) : g.slice(v + 1);
                }
                setTimeout(() => e8(g));
              }
            }),
          }),
        ),
      )
    );
  }),
  jz = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last",
  };
function zz(n, e) {
  return e !== "rtl"
    ? n
    : n === "ArrowLeft"
    ? "ArrowRight"
    : n === "ArrowRight"
    ? "ArrowLeft"
    : n;
}
function Hz(n, e, t) {
  const r = zz(n.key, t);
  if (
    !(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) &&
    !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r))
  )
    return jz[r];
}
function e8(n) {
  const e = document.activeElement;
  for (const t of n)
    if (t === e || (t.focus(), document.activeElement !== e)) return;
}
function qz(n, e) {
  return n.map((t, r) => n[(e + r) % n.length]);
}
const Vz = Lz,
  t8 = Uz,
  n8 = "Tabs",
  [Gz, Dq] = ya(n8, [Df]),
  Kz = Df(),
  [Oq, Qz] = Gz(n8),
  Yz = "TabsTrigger",
  Jz = C.forwardRef((n, e) => {
    const { __scopeTabs: t, value: r, disabled: a = !1, ...i } = n,
      s = Qz(Yz, t),
      o = Kz(t),
      c = Xz(s.baseId, r),
      l = Zz(s.baseId, r),
      u = r === s.value;
    return C.createElement(
      t8,
      ve({ asChild: !0 }, o, { focusable: !a, active: u }),
      C.createElement(
        kn.button,
        ve(
          {
            type: "button",
            role: "tab",
            "aria-selected": u,
            "aria-controls": l,
            "data-state": u ? "active" : "inactive",
            "data-disabled": a ? "" : void 0,
            disabled: a,
            id: c,
          },
          i,
          {
            ref: e,
            onMouseDown: Oe(n.onMouseDown, (d) => {
              !a && d.button === 0 && d.ctrlKey === !1
                ? s.onValueChange(r)
                : d.preventDefault();
            }),
            onKeyDown: Oe(n.onKeyDown, (d) => {
              [" ", "Enter"].includes(d.key) && s.onValueChange(r);
            }),
            onFocus: Oe(n.onFocus, () => {
              const d = s.activationMode !== "manual";
              !u && !a && d && s.onValueChange(r);
            }),
          },
        ),
      ),
    );
  });
function Xz(n, e) {
  return `${n}-trigger-${e}`;
}
function Zz(n, e) {
  return `${n}-content-${e}`;
}
const eH = Jz,
  tH = ["Enter", " "],
  nH = ["ArrowDown", "PageUp", "Home"],
  r8 = ["ArrowUp", "PageDown", "End"],
  rH = [...nH, ...r8],
  Of = "Menu",
  [Ah, aH, iH] = X4(Of),
  [es, a8] = ya(Of, [iH, xo, Df]),
  sH = xo(),
  i8 = Df(),
  [Nq, Nf] = es(Of),
  [Fq, fy] = es(Of),
  oH = "MenuPortal",
  [Lq, cH] = es(oH, { forceMount: void 0 }),
  qa = "MenuContent",
  [lH, s8] = es(qa),
  uH = C.forwardRef((n, e) => {
    const t = cH(qa, n.__scopeMenu),
      { forceMount: r = t.forceMount, ...a } = n,
      i = Nf(qa, n.__scopeMenu),
      s = fy(qa, n.__scopeMenu);
    return C.createElement(
      Ah.Provider,
      { scope: n.__scopeMenu },
      C.createElement(
        Xi,
        { present: r || i.open },
        C.createElement(
          Ah.Slot,
          { scope: n.__scopeMenu },
          s.modal
            ? C.createElement(dH, ve({}, a, { ref: e }))
            : C.createElement(fH, ve({}, a, { ref: e })),
        ),
      ),
    );
  }),
  dH = C.forwardRef((n, e) => {
    const t = Nf(qa, n.__scopeMenu),
      r = C.useRef(null),
      a = sn(e, r);
    return (
      C.useEffect(() => {
        const i = r.current;
        if (i) return Ym(i);
      }, []),
      C.createElement(
        o8,
        ve({}, n, {
          ref: a,
          trapFocus: t.open,
          disableOutsidePointerEvents: t.open,
          disableOutsideScroll: !0,
          onFocusOutside: Oe(n.onFocusOutside, (i) => i.preventDefault(), {
            checkForDefaultPrevented: !1,
          }),
          onDismiss: () => t.onOpenChange(!1),
        }),
      )
    );
  }),
  fH = C.forwardRef((n, e) => {
    const t = Nf(qa, n.__scopeMenu);
    return C.createElement(
      o8,
      ve({}, n, {
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        onDismiss: () => t.onOpenChange(!1),
      }),
    );
  }),
  o8 = C.forwardRef((n, e) => {
    const {
        __scopeMenu: t,
        loop: r = !1,
        trapFocus: a,
        onOpenAutoFocus: i,
        onCloseAutoFocus: s,
        disableOutsidePointerEvents: o,
        onEntryFocus: c,
        onEscapeKeyDown: l,
        onPointerDownOutside: u,
        onFocusOutside: d,
        onInteractOutside: f,
        onDismiss: p,
        disableOutsideScroll: m,
        ...y
      } = n,
      h = Nf(qa, t),
      g = fy(qa, t),
      v = sH(t),
      w = i8(t),
      T = aH(t),
      [A, E] = C.useState(null),
      _ = C.useRef(null),
      S = sn(e, _, h.onContentChange),
      W = C.useRef(0),
      D = C.useRef(""),
      L = C.useRef(0),
      G = C.useRef(null),
      q = C.useRef("right"),
      N = C.useRef(0),
      H = m ? Qm : C.Fragment,
      J = m ? { as: Wi, allowPinchZoom: !0 } : void 0,
      de = (Z) => {
        var ue, P;
        const B = D.current + Z,
          j = T().filter((be) => !be.disabled),
          F = document.activeElement,
          V =
            (ue = j.find((be) => be.ref.current === F)) === null ||
            ue === void 0
              ? void 0
              : ue.textValue,
          re = j.map((be) => be.textValue),
          we = wH(re, B, V),
          se =
            (P = j.find((be) => be.textValue === we)) === null || P === void 0
              ? void 0
              : P.ref.current;
        (function be(Ke) {
          (D.current = Ke),
            window.clearTimeout(W.current),
            Ke !== "" && (W.current = window.setTimeout(() => be(""), 1e3));
        })(B),
          se && setTimeout(() => se.focus());
      };
    C.useEffect(() => () => window.clearTimeout(W.current), []), Vm();
    const le = C.useCallback((Z) => {
      var ue, P;
      return (
        q.current ===
          ((ue = G.current) === null || ue === void 0 ? void 0 : ue.side) &&
        CH(Z, (P = G.current) === null || P === void 0 ? void 0 : P.area)
      );
    }, []);
    return C.createElement(
      lH,
      {
        scope: t,
        searchRef: D,
        onItemEnter: C.useCallback(
          (Z) => {
            le(Z) && Z.preventDefault();
          },
          [le],
        ),
        onItemLeave: C.useCallback(
          (Z) => {
            var ue;
            le(Z) ||
              ((ue = _.current) === null || ue === void 0 || ue.focus(),
              E(null));
          },
          [le],
        ),
        onTriggerLeave: C.useCallback(
          (Z) => {
            le(Z) && Z.preventDefault();
          },
          [le],
        ),
        pointerGraceTimerRef: L,
        onPointerGraceIntentChange: C.useCallback((Z) => {
          G.current = Z;
        }, []),
      },
      C.createElement(
        H,
        J,
        C.createElement(
          qm,
          {
            asChild: !0,
            trapped: a,
            onMountAutoFocus: Oe(i, (Z) => {
              var ue;
              Z.preventDefault(),
                (ue = _.current) === null || ue === void 0 || ue.focus();
            }),
            onUnmountAutoFocus: s,
          },
          C.createElement(
            _f,
            {
              asChild: !0,
              disableOutsidePointerEvents: o,
              onEscapeKeyDown: l,
              onPointerDownOutside: u,
              onFocusOutside: d,
              onInteractOutside: f,
              onDismiss: p,
            },
            C.createElement(
              Vz,
              ve({ asChild: !0 }, w, {
                dir: g.dir,
                orientation: "vertical",
                loop: r,
                currentTabStopId: A,
                onCurrentTabStopIdChange: E,
                onEntryFocus: Oe(c, (Z) => {
                  g.isUsingKeyboardRef.current || Z.preventDefault();
                }),
              }),
              C.createElement(
                ly,
                ve(
                  {
                    role: "menu",
                    "aria-orientation": "vertical",
                    "data-state": bH(h.open),
                    "data-radix-menu-content": "",
                    dir: g.dir,
                  },
                  v,
                  y,
                  {
                    ref: S,
                    style: { outline: "none", ...y.style },
                    onKeyDown: Oe(y.onKeyDown, (Z) => {
                      const P =
                          Z.target.closest("[data-radix-menu-content]") ===
                          Z.currentTarget,
                        B = Z.ctrlKey || Z.altKey || Z.metaKey,
                        j = Z.key.length === 1;
                      P &&
                        (Z.key === "Tab" && Z.preventDefault(),
                        !B && j && de(Z.key));
                      const F = _.current;
                      if (Z.target !== F || !rH.includes(Z.key)) return;
                      Z.preventDefault();
                      const re = T()
                        .filter((we) => !we.disabled)
                        .map((we) => we.ref.current);
                      r8.includes(Z.key) && re.reverse(), xH(re);
                    }),
                    onBlur: Oe(n.onBlur, (Z) => {
                      Z.currentTarget.contains(Z.target) ||
                        (window.clearTimeout(W.current), (D.current = ""));
                    }),
                    onPointerMove: Oe(
                      n.onPointerMove,
                      kh((Z) => {
                        const ue = Z.target,
                          P = N.current !== Z.clientX;
                        if (Z.currentTarget.contains(ue) && P) {
                          const B = Z.clientX > N.current ? "right" : "left";
                          (q.current = B), (N.current = Z.clientX);
                        }
                      }),
                    ),
                  },
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }),
  Eh = "MenuItem",
  b2 = "menu.itemSelect",
  pH = C.forwardRef((n, e) => {
    const { disabled: t = !1, onSelect: r, ...a } = n,
      i = C.useRef(null),
      s = fy(Eh, n.__scopeMenu),
      o = s8(Eh, n.__scopeMenu),
      c = sn(e, i),
      l = C.useRef(!1),
      u = () => {
        const d = i.current;
        if (!t && d) {
          const f = new CustomEvent(b2, { bubbles: !0, cancelable: !0 });
          d.addEventListener(b2, (p) => (r == null ? void 0 : r(p)), {
            once: !0,
          }),
            s4(d, f),
            f.defaultPrevented ? (l.current = !1) : s.onClose();
        }
      };
    return C.createElement(
      hH,
      ve({}, a, {
        ref: c,
        disabled: t,
        onClick: Oe(n.onClick, u),
        onPointerDown: (d) => {
          var f;
          (f = n.onPointerDown) === null || f === void 0 || f.call(n, d),
            (l.current = !0);
        },
        onPointerUp: Oe(n.onPointerUp, (d) => {
          var f;
          l.current ||
            (f = d.currentTarget) === null ||
            f === void 0 ||
            f.click();
        }),
        onKeyDown: Oe(n.onKeyDown, (d) => {
          const f = o.searchRef.current !== "";
          t ||
            (f && d.key === " ") ||
            (tH.includes(d.key) &&
              (d.currentTarget.click(), d.preventDefault()));
        }),
      }),
    );
  }),
  hH = C.forwardRef((n, e) => {
    const { __scopeMenu: t, disabled: r = !1, textValue: a, ...i } = n,
      s = s8(Eh, t),
      o = i8(t),
      c = C.useRef(null),
      l = sn(e, c),
      [u, d] = C.useState(!1),
      [f, p] = C.useState("");
    return (
      C.useEffect(() => {
        const m = c.current;
        if (m) {
          var y;
          p(((y = m.textContent) !== null && y !== void 0 ? y : "").trim());
        }
      }, [i.children]),
      C.createElement(
        Ah.ItemSlot,
        { scope: t, disabled: r, textValue: a ?? f },
        C.createElement(
          t8,
          ve({ asChild: !0 }, o, { focusable: !r }),
          C.createElement(
            kn.div,
            ve(
              {
                role: "menuitem",
                "data-highlighted": u ? "" : void 0,
                "aria-disabled": r || void 0,
                "data-disabled": r ? "" : void 0,
              },
              i,
              {
                ref: l,
                onPointerMove: Oe(
                  n.onPointerMove,
                  kh((m) => {
                    r
                      ? s.onItemLeave(m)
                      : (s.onItemEnter(m),
                        m.defaultPrevented || m.currentTarget.focus());
                  }),
                ),
                onPointerLeave: Oe(
                  n.onPointerLeave,
                  kh((m) => s.onItemLeave(m)),
                ),
                onFocus: Oe(n.onFocus, () => d(!0)),
                onBlur: Oe(n.onBlur, () => d(!1)),
              },
            ),
          ),
        ),
      )
    );
  }),
  mH = "MenuRadioGroup";
es(mH, { value: void 0, onValueChange: () => {} });
const yH = "MenuItemIndicator";
es(yH, { checked: !1 });
const gH = "MenuSub";
es(gH);
function bH(n) {
  return n ? "open" : "closed";
}
function xH(n) {
  const e = document.activeElement;
  for (const t of n)
    if (t === e || (t.focus(), document.activeElement !== e)) return;
}
function vH(n, e) {
  return n.map((t, r) => n[(e + r) % n.length]);
}
function wH(n, e, t) {
  const a = e.length > 1 && Array.from(e).every((l) => l === e[0]) ? e[0] : e,
    i = t ? n.indexOf(t) : -1;
  let s = vH(n, Math.max(i, 0));
  a.length === 1 && (s = s.filter((l) => l !== t));
  const c = s.find((l) => l.toLowerCase().startsWith(a.toLowerCase()));
  return c !== t ? c : void 0;
}
function TH(n, e) {
  const { x: t, y: r } = n;
  let a = !1;
  for (let i = 0, s = e.length - 1; i < e.length; s = i++) {
    const o = e[i].x,
      c = e[i].y,
      l = e[s].x,
      u = e[s].y;
    c > r != u > r && t < ((l - o) * (r - c)) / (u - c) + o && (a = !a);
  }
  return a;
}
function CH(n, e) {
  if (!e) return !1;
  const t = { x: n.clientX, y: n.clientY };
  return TH(t, e);
}
function kh(n) {
  return (e) => (e.pointerType === "mouse" ? n(e) : void 0);
}
const AH = uH,
  EH = pH,
  c8 = "DropdownMenu",
  [kH, $q] = ya(c8, [a8]),
  l8 = a8(),
  [Wq, _H] = kH(c8),
  SH = "DropdownMenuContent",
  PH = C.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...r } = n,
      a = _H(SH, t),
      i = l8(t),
      s = C.useRef(!1);
    return C.createElement(
      AH,
      ve({ id: a.contentId, "aria-labelledby": a.triggerId }, i, r, {
        ref: e,
        onCloseAutoFocus: Oe(n.onCloseAutoFocus, (o) => {
          var c;
          s.current ||
            (c = a.triggerRef.current) === null ||
            c === void 0 ||
            c.focus(),
            (s.current = !1),
            o.preventDefault();
        }),
        onInteractOutside: Oe(n.onInteractOutside, (o) => {
          const c = o.detail.originalEvent,
            l = c.button === 0 && c.ctrlKey === !0,
            u = c.button === 2 || l;
          (!a.modal || u) && (s.current = !0);
        }),
        style: {
          ...n.style,
          "--radix-dropdown-menu-content-transform-origin":
            "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width":
            "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height":
            "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width":
            "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height":
            "var(--radix-popper-anchor-height)",
        },
      }),
    );
  }),
  IH = C.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...r } = n,
      a = l8(t);
    return C.createElement(EH, ve({}, a, r, { ref: e }));
  }),
  RH = PH,
  MH = IH,
  BH = ie.span`
  font-size: ${ke.md};
  color: ${(n) => n.theme.text.secondary};
  margin: 0;
`;
ie.span`
  font-size: ${ke.md};
  color: ${(n) => n.theme.text.neutral};
  margin: 0;
`;
ie.span`
  font-size: ${ke.md};
  color: ${(n) => n.theme.text.danger};
  margin: 0;
`;
ie.p`
  font-size: ${ke.md};
  color: ${(n) => n.theme.text.secondary};
  margin: 0;
`;
ie.div`
  width: 28%;
  height: 28%;
  border-radius: 50%;
  position: absolute;
  top: 60%;
  right: 0px;
  background-color: #00d395;
  box-shadow: 0 0 0 2px ${(n) => n.theme.bg.elevated};
`;
ie(fU)`
  color: ${(n) => n.theme.icon.success};
`;
const u8 = (n) => {
    let { track: e, thumb: t, hover: r } = n;
    return `
&::-webkit-scrollbar {
  width: 6px;
}

&::-webkit-scrollbar-track {
  box-shadow: inset 0 0 5px ${e};
  border-radius: ${st.md};
}

&::-webkit-scrollbar-thumb {
  background: ${t};
  border-radius: ${st.md};
}

&::-webkit-scrollbar-thumb:hover {
  background: ${r};
}`;
  },
  DH = Vr`
 from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`,
  OH = ie.div`
  background-color: ${(n) => n.theme.overlay.subdued};
  z-index: 9999;
  position: fixed;
  inset: 0;
  animation: ${DH} 400ms cubic-bezier(0.16, 1, 0.3, 1);
`,
  NH = (n) =>
    I.jsxs(iU, {
      open: n.open,
      onOpenChange: n.setOpen,
      children: [
        n.trigger && I.jsx(sU, { asChild: !0, children: n.trigger }),
        I.jsxs(oU, {
          children: [
            I.jsx(cU, { asChild: !0, children: I.jsx(OH, {}) }),
            I.jsx(lU, {
              asChild: !0,
              children: I.jsxs(WH, {
                style: n.style,
                children: [
                  n.title && I.jsxs(UH, { children: [" ", n.title] }),
                  n.children,
                  !n.hideCloseIcon &&
                    I.jsx(FH, {
                      children: I.jsx(uU, {
                        asChild: !0,
                        children: I.jsx(zm, {
                          variant: "secondary",
                          type: "button",
                          "aria-label": "Close",
                          children: I.jsx(vU, {
                            style: {
                              width: qe.md,
                              height: qe.md,
                              color: "inherit",
                            },
                          }),
                        }),
                      }),
                    }),
                ],
              }),
            }),
          ],
        }),
      ],
    }),
  FH = ie.div`
  position: absolute;
  top: ${he.lg};
  right: ${he.lg};

  ${gn.mobile} {
    right: ${he.md};
  }
`,
  LH = Vr`
  from {
    opacity: 0;
    transform: translate(-50%, -48%) scale(0.96);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
`,
  $H = Vr`
  from {
    opacity: 0;
    transform: translate(0, 50%);
  }
  to {
    opacity: 1;
    transform: translate(0, 0);
  }
`,
  WH = ie.div`
  z-index: 10000;
  background-color: ${(n) => n.theme.bg.base};
  border-radius: ${st.xl};
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: calc(100vw - 40px);
  box-sizing: border-box;
  overflow-y: auto;
  padding: ${he.lg};
  padding-bottom: ${he.xl};
  animation: ${LH} 200ms ease;
  box-shadow: ${Af.lg};
  line-height: 1;

  &:focus {
    outline: none;
  }

  ${(n) =>
    u8({
      track: "transparent",
      thumb: n.theme.bg.elevated,
      hover: n.theme.bg.highlighted,
    })}

  /* open from bottom on mobile */
  ${gn.mobile} {
    top: auto;
    bottom: 0;
    left: 0;
    right: 0;
    max-width: 100vw;
    transform: none;
    width: 100vw;
    animation: ${$H} 0.35s cubic-bezier(0.15, 1.15, 0.6, 1);
    border-radius: ${st.xxl};
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
    max-width: none !important;
  }

  & *::selection {
    background-color: ${(n) => n.theme.bg.inverted};
    color: ${(n) => n.theme.text.inverted};
  }
`,
  UH = ie(A4)`
  margin: 0;
  font-weight: 500;
  color: ${(n) => n.theme.text.neutral};
  font-size: ${ke.lg};
`;
ie(eH)`
  all: unset;
  font-size: ${ke.md};
  font-weight: 500;
  color: ${(n) => n.theme.text.secondary};
  cursor: pointer;
  padding: ${he.sm} ${he.sm};
  -webkit-tap-highlight-color: transparent;
  border-radius: ${st.lg};
  transition:
    background 0.2s ease,
    color 0.2s ease;
  &[data-state="active"] {
    background: ${(n) => n.theme.bg.elevated};
    color: ${(n) => n.theme.text.neutral};
  }
`;
ie.p`
  font-size: ${ke.sm};
  color: ${(n) => n.theme.text.secondary};
  margin: 0;
`;
ie.div`
  box-sizing: border-box;
  overflow: auto;
  padding-right: 10px;
  padding-bottom: ${he.lg};
  width: calc(100% + 16px);
  -webkit-mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
  mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
  ${(n) =>
    u8({
      track: "transparent",
      thumb: n.theme.bg.elevated,
      hover: n.theme.bg.highlighted,
    })}
`;
ie.ul`
  padding: 0;
  margin: 0;
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: ${he.xs};
  box-sizing: border-box;
`;
ie.button`
  all: unset;
  display: flex;
  width: 100%;
  box-sizing: border-box;
  align-items: center;
  gap: ${he.md};
  padding: ${he.sm} ${he.md};
  border-radius: ${st.md};
  cursor: pointer;
  transition: background 0.2s ease;
  background: ${(n) => n.theme.bg.elevated};
  color: ${(n) => n.theme.text.neutral};
  font-weight: 600;
  font-size: ${ke.md};
  &:hover {
    background: ${(n) => n.theme.bg.highlighted};
  }

  ${gn.mobile} {
    font-size: ${ke.sm};
  }
`;
ie(TU)`
  color: ${(n) => n.theme.text.secondary};
  position: absolute;
  left: 18px;
`;
ie(jL)`
  padding: ${he.sm} ${he.md} ${he.sm} 60px;
`;
ie.div`
  font-size: ${ke.sm};
  color: ${(n) => n.theme.link.primary};
`;
ie.div`
  font-size: ${ke.sm};
  color: ${(n) => n.theme.text.danger};
`;
const jH = Vr`
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
`;
ie(RH)`
  width: 360px;
  box-sizing: border-box;
  max-width: 100%;
  border-radius: ${st.lg};
  padding: ${he.lg};
  animation: ${jH} 400ms cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
  border: 1px solid ${(n) => n.theme.border.base};
  background-color: ${(n) => n.theme.bg.base};
  z-index: 1000000;
  line-height: 1;
`;
ie.button`
  all: unset;
  background: ${(n) => n.theme.bg.base};
  border: 1px solid ${(n) => n.theme.border.base};
  padding: ${he.sm} ${he.sm};
  border-radius: ${st.lg};
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: ${he.md};
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  line-height: 1;
  animation: ${ey} 300ms ease;

  ${gn.mobile} {
    gap: ${he.sm};
    padding: ${he.xs} ${he.sm};
    img {
      width: ${qe.md}px;
      height: ${qe.md}px;
    }
  }

  &:hover {
    transition: background 250ms ease;
    background: ${(n) => n.theme.bg.baseHover};
    border-color: ${(n) => n.theme.bg.highlighted};
  }
`;
ie.span`
  color: ${(n) => n.theme.text.secondary};
  font-size: ${ke.xs};
  font-weight: 500;
`;
ie.div`
  display: flex;
  flex-direction: column;
`;
ie.span`
  color: ${(n) => n.theme.text.neutral};
  font-size: ${ke.sm};
  font-weight: 500;
`;
ie.span`
  font-size: ${ke.md};
  color: ${(n) => n.theme.text.neutral};
  font-weight: 500;
`;
ie.span`
  font-size: ${ke.sm};
  color: ${(n) => n.theme.text.secondary};
  font-weight: 500;
`;
ie.label`
  font-size: ${ke.sm};
  color: ${(n) => n.theme.text.secondary};
  font-weight: 500;
`;
ie.button`
  all: unset;
  padding: ${he.sm} ${he.sm};
  border-radius: ${st.md};
  background-color: ${(n) => n.theme.bg.base};
  border: 1px solid ${(n) => n.theme.border.elevated};
  box-sizing: border-box;
  display: flex;
  align-items: center;
  width: 100%;
  cursor: pointer;
  font-size: ${ke.md};
  font-weight: 500;
  color: ${(n) => n.theme.text.neutral} !important;
  gap: ${he.sm};
  -webkit-tap-highlight-color: transparent;
  line-height: 1.3;

  &:not([disabled]):hover {
    transition:
      box-shadow 250ms ease,
      border-color 250ms ease;
    border: 1px solid ${(n) => n.theme.link.primary};
    box-shadow: 0 0 0 1px ${(n) => n.theme.link.primary};
  }

  &[disabled] {
    cursor: not-allowed;
    svg {
      display: none;
    }
  }

  &[disabled]:hover {
    transition:
      box-shadow 250ms ease,
      border-color 250ms ease;
    border: 1px solid ${(n) => n.theme.text.danger};
    box-shadow: 0 0 0 1px ${(n) => n.theme.text.danger};
  }
`;
ie(MH)`
  outline: none;
`;
ie(bU)`
  color: ${(n) => n.theme.text.secondary};
`;
ie(zm)`
  margin-right: -${he.xxs};
  margin-left: auto;
  color: ${(n) => n.theme.icon.secondary};
  &:hover {
    color: ${(n) => n.theme.icon.danger};
    background: none;
  }
`;
ie.div`
  display: flex;
  align-items: center;
  justify-content: center;
  color: ${(n) => n.theme.icon.secondary};
`;
ie.div`
  display: flex;
  align-items: center;
  gap: ${he.sm};

  ${gn.mobile} {
    justify-content: center;
    flex-direction: column;
    gap: ${he.md};
  }
`;
ie(yo)`
  ${gn.mobile} {
    max-width: 240px;
    margin: 0 auto;
  }
`;
ie.div`
  ${gn.mobile} {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
`;
ie(jm)`
  animation: ${ey} 300ms ease;
`;
let lp;
function zH(n) {
  return !n || !n.startsWith("video/")
    ? ""
    : (lp || (lp = document.createElement("video")), lp.canPlayType(n));
}
function HH(n) {
  return !!zH(n);
}
let up;
function qH(n) {
  return !n || !n.startsWith("audio/")
    ? ""
    : (up || (up = document.createElement("audio")), up.canPlayType(n));
}
function VH(n) {
  return !!qH(n);
}
function d8(n) {
  return (e) => {
    n.forEach((t) => {
      typeof t == "function" ? t(e) : t != null && (t.current = e);
    });
  };
}
const GH = (n) =>
    I.jsxs("svg", {
      width: "1em",
      height: "1em",
      viewBox: "0 0 32 32",
      ...n,
      children: [
        I.jsx("circle", {
          cx: "9",
          cy: "28.5",
          r: "1.5",
          fill: "currentColor",
        }),
        I.jsx("path", {
          fill: "currentColor",
          d: "M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z",
        }),
        I.jsx("path", {
          fill: "currentColor",
          d: "m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z",
        }),
      ],
    }),
  KH = (n) =>
    I.jsxs("svg", {
      width: "1em",
      height: "1em",
      viewBox: "0 0 32 32",
      ...n,
      children: [
        I.jsx("path", {
          fill: "currentColor",
          d: "M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z",
        }),
        I.jsx("path", {
          fill: "currentColor",
          d: "M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z",
        }),
      ],
    }),
  QH = (n) =>
    I.jsx("svg", {
      width: "1em",
      height: "1em",
      viewBox: "0 0 32 32",
      ...n,
      children: I.jsx("path", {
        fill: "currentColor",
        d: "M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z",
      }),
    }),
  YH = (n) =>
    I.jsx("svg", {
      width: "1em",
      height: "1em",
      viewBox: "0 0 32 32",
      ...n,
      children: I.jsx("path", {
        fill: "currentColor",
        d: "M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z",
      }),
    }),
  JH = C.lazy(() =>
    Re(
      () => import("./ModelViewer-fde23dd9.browser.esm-ffbddbe2.js"),
      [
        "assets/ModelViewer-fde23dd9.browser.esm-ffbddbe2.js",
        "assets/lit-element-2aa1acc0.js",
        "assets/index-aff6404b.js",
        "assets/index-6a964d41.css",
      ],
    ),
  ),
  py = (n) => {
    let { onClick: e, isPlaying: t } = n;
    const [r, a] = C.useState(!1),
      i = () => a(!0),
      s = () => a(!1),
      o = () => a(!1),
      c = () => a(!0);
    return I.jsx("button", {
      style: {
        position: "absolute",
        bottom: 0,
        right: 0,
        transform: "translate(-25%, -25%)",
        maxWidth: "32px",
        width: "8%",
        minWidth: "24px",
        aspectRatio: "1",
        zIndex: 3,
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)",
        display: "grid",
        placeItems: "center",
        borderRadius: "50%",
        border: "1px solid rgb(229, 232, 235)",
        cursor: "pointer",
        ...(r
          ? {
              color: "rgb(53, 56, 64)",
              boxShadow: "rgb(4 17 29 / 25%) 0px 0px 8px 0px",
            }
          : {}),
      },
      onClick: e,
      onMouseEnter: i,
      onMouseLeave: s,
      onMouseDown: o,
      onMouseUp: c,
      children: t
        ? I.jsx(QH, { style: { width: "66%", height: "66%" } })
        : I.jsx(YH, { style: { width: "66%", height: "66%" } }),
    });
  },
  f8 = Xt.forwardRef((n, e) => {
    let {
      src: t,
      alt: r,
      poster: a,
      requireInteraction: i,
      style: s,
      width: o,
      height: c,
      controls: l,
      ...u
    } = n;
    const d = C.useRef(null),
      [f, p] = C.useState(!i),
      [m, y] = C.useState(!0);
    return (
      C.useEffect(() => {
        if (d.current)
          if (f)
            try {
              d.current.play();
            } catch (h) {
              console.error("error playing video", h);
            }
          else
            try {
              d.current.pause(), (d.current.currentTime = 0);
            } catch (h) {
              console.error("error pausing video", h);
            }
      }, [f]),
      I.jsxs("div", {
        style: { position: "relative", ...s },
        ...u,
        children: [
          I.jsx("video", {
            ref: d8([d, e]),
            src: t ?? void 0,
            poster: a ?? void 0,
            loop: !0,
            playsInline: !0,
            controlsList: "nodownload",
            muted: m,
            preload: a ? "metadata" : "auto",
            onCanPlay: () => {
              var h;
              f && ((h = d.current) == null || h.play());
            },
            width: o,
            height: c,
            controls: l,
            style: {
              height: "100%",
              width: "100%",
              objectFit: "contain",
              zIndex: 1,
              transition: "opacity .5s",
              opacity: a ? (f ? 1 : 0) : 1,
            },
          }),
          a &&
            I.jsx("img", {
              src: a,
              style: {
                objectFit: "contain",
                pointerEvents: "none",
                position: "absolute",
                width: "100%",
                height: "100%",
                zIndex: 2,
                transition: "opacity .5s",
                opacity: f ? 0 : 1,
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
              },
              alt: r,
            }),
          I.jsx(py, {
            onClick: () => {
              p((h) => !h), y(!1);
            },
            isPlaying: f,
          }),
        ],
      })
    );
  });
f8.displayName = "VideoPlayer";
const p8 = Xt.forwardRef((n, e) => {
  let { src: t, alt: r, poster: a, style: i, height: s, width: o, ...c } = n;
  const l = C.useRef(null),
    [u, d] = C.useState(!1),
    [f, p] = C.useState(!0);
  return (
    C.useEffect(() => {
      l.current &&
        (u
          ? l.current.play()
          : (l.current.pause(), (l.current.currentTime = 0)));
    }, [u]),
    I.jsxs("div", {
      style: { position: "relative", ...i },
      ...c,
      children: [
        a
          ? I.jsx("img", {
              height: s,
              width: o,
              src: a,
              style: {
                height: "100%",
                width: "100%",
                pointerEvents: "none",
                objectFit: "contain",
              },
              alt: r,
            })
          : I.jsx("div", {
              style: {
                width: "100%",
                height: "100%",
                display: "grid",
                placeItems: "center",
                pointerEvents: "none",
                backgroundColor: "#fff",
                color: "rgb(138, 147, 155)",
              },
              children: I.jsx(KH, { style: { height: "64px", width: "64px" } }),
            }),
        I.jsx(py, {
          onClick: () => {
            d((m) => !m), p(!1);
          },
          isPlaying: u,
        }),
        I.jsx("audio", {
          ref: d8([l, e]),
          src: t ?? void 0,
          loop: !0,
          playsInline: !0,
          muted: f,
          preload: "none",
          controlsList: "nodownload",
          style: {
            position: "absolute",
            opacity: 0,
            pointerEvents: "none",
            zIndex: -1,
            visibility: "hidden",
          },
        }),
      ],
    })
  );
});
p8.displayName = "AudioPlayer";
const h8 = Xt.forwardRef((n, e) => {
  let { src: t, alt: r, poster: a, requireInteraction: i, style: s, ...o } = n;
  const [c, l] = C.useState(!i);
  return I.jsxs("div", {
    style: { position: "relative", ...s },
    ...o,
    children: [
      I.jsx("iframe", {
        src: c ? t ?? void 0 : void 0,
        ref: e,
        style: {
          objectFit: "contain",
          zIndex: 1,
          height: "100%",
          width: "100%",
          transition: "opacity .5s",
          opacity: a ? (c ? 1 : 0) : 1,
        },
        sandbox: "allow-scripts",
        allow:
          "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",
      }),
      a &&
        I.jsx("img", {
          src: a,
          style: {
            objectFit: "contain",
            pointerEvents: "none",
            position: "absolute",
            width: "100%",
            height: "100%",
            zIndex: 2,
            transition: "opacity .5s",
            opacity: c ? 0 : 1,
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
          },
          alt: r,
        }),
      I.jsx(py, {
        onClick: () => {
          l((u) => !u);
        },
        isPlaying: c,
      }),
    ],
  });
});
h8.displayName = "IframePlayer";
const m8 = Xt.forwardRef((n, e) => {
  let { src: t, alt: r, style: a, ...i } = n;
  return I.jsx("div", {
    style: { position: "relative", ...a },
    ...i,
    children: I.jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)",
      },
      children: I.jsxs("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          gap: "8px",
          alignItems: "center",
          flexWrap: "nowrap",
        },
        children: [
          I.jsx(GH, {
            style: {
              maxWidth: "128px",
              minWidth: "48px",
              width: "50%",
              aspectRatio: "1",
            },
          }),
          I.jsx("a", {
            rel: "noopener noreferrer",
            style: { textDecoration: "underline", color: "rgb(138, 147, 155)" },
            href: t ?? void 0,
            target: "_blank",
            ref: e,
            children: r || "File",
          }),
        ],
      }),
    }),
  });
});
m8.displayName = "LinkPlayer";
const y8 = Xt.forwardRef((n, e) => {
  let {
    src: t,
    poster: r,
    alt: a,
    gatewayUrl: i,
    requireInteraction: s = !1,
    width: o = "300px",
    height: c = "300px",
    style: l,
    mimeType: u,
    ...d
  } = n;
  const f = { objectFit: "contain", width: o, height: c, ...l },
    p = x2(t ?? void 0, u, i),
    m = x2(r ?? void 0, void 0, i);
  if (p.mimeType) {
    if (p.mimeType.startsWith("text/html"))
      return I.jsx(h8, {
        style: f,
        src: p.url,
        poster: m.url,
        requireInteraction: s,
        ...d,
      });
    if (p.mimeType.startsWith("model"))
      return I.jsx(C.Suspense, {
        fallback: r
          ? I.jsx("img", { style: f, src: r, alt: a, ref: e, ...d })
          : null,
        children: I.jsx(JH, {
          style: f,
          src: p.url || "",
          poster: r,
          alt: a,
          ...d,
        }),
      });
    if (HH(p.mimeType))
      return I.jsx(f8, {
        style: f,
        src: p.url,
        poster: m.url,
        requireInteraction: s,
        ...d,
      });
    if (VH(p.mimeType))
      return I.jsx(p8, {
        style: f,
        src: p.url,
        poster: m.url,
        requireInteraction: s,
        ...d,
      });
    if (p.mimeType.startsWith("image/"))
      return I.jsx("img", { style: f, src: p.url, alt: a, ref: e, ...d });
  } else return I.jsx("img", { style: f, ...d, ref: e, alt: a });
  return I.jsx(m8, { style: f, src: p.url, alt: a, ref: e, ...d });
});
y8.displayName = "MediaRenderer";
function x2(n, e, t) {
  const r = _w(),
    a = C.useMemo(
      () =>
        n
          ? t
            ? n.replace("ipfs://", t)
            : r
            ? r.resolveScheme(n)
            : n.replace("ipfs://", "https://ipfs.io/ipfs/")
          : "",
      [n, r, t],
    ),
    i = q9(["mime-type", a], () => gF(a), {
      enabled: !!a && !e,
      initialData: e,
    });
  return { url: a, mimeType: i.data };
}
const XH = Xt.forwardRef((n, e) => {
  var o;
  let {
    metadata: t,
    width: r = "300px",
    height: a = "300px",
    style: i,
    ...s
  } = n;
  return I.jsx(y8, {
    src: t.animation_url || t.image,
    poster: t.image,
    alt: ((o = t.name) == null ? void 0 : o.toString()) || "",
    ref: e,
    width: r,
    height: a,
    style: { ...i },
    ...s,
  });
});
XH.displayName = "ThirdwebNftMedia";
const ZH = Vr`
from {
    opacity: 0;
    transform: translateY(2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;
ie(cz)`
  border-radius: ${st.sm};
  padding: ${he.sm} ${he.md};
  background-color: ${(n) => n.theme.bg.inverted};
  box-shadow: ${Af.md};
  animation-duration: 400ms;
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
  animation-name: ${ZH};
  color: ${(n) => n.theme.text.inverted};
  font-size: ${ke.md};
`;
ie(lz)`
  fill: ${(n) => n.theme.bg.inverted};
`;
ie.div`
  display: flex;
  align-items: center;
  gap: ${he.sm};
`;
const eq = (n) => {
    var a, i, s;
    let { onBack: e } = n;
    const t = xw(),
      { meta: r } = t[0];
    return I.jsx(ty, {
      onBack: () => {
        e();
      },
      walletIconURL: r.iconURL,
      walletName: r.name,
      appleStoreLink: (a = r.urls) == null ? void 0 : a.ios,
      googlePlayStoreLink: (i = r.urls) == null ? void 0 : i.android,
      chromeExtensionLink: (s = r.urls) == null ? void 0 : s.chrome,
      header: I.jsxs(I.Fragment, {
        children: [
          I.jsx(mo, { children: " Get started with EVM wallets " }),
          I.jsx(At, { y: "md" }),
          I.jsx(yo, {
            children:
              "An EVM Wallet is your gateway to interact with web3 apps on Ethereum and other custom blockchains.",
          }),
          I.jsx(At, { y: "xl" }),
          I.jsxs("div", {
            style: { display: "flex", gap: he.md, alignItems: "center" },
            children: [
              I.jsx(BH, { children: "We recommend" }),
              I.jsxs("div", {
                style: { display: "flex", gap: he.xs, alignItems: "center" },
                children: [
                  I.jsx(hr, { src: r.iconURL, width: qe.md, height: qe.md }),
                  I.jsx(tq, { children: r.name }),
                ],
              }),
            ],
          }),
        ],
      }),
      footer: I.jsxs(I.Fragment, {
        children: [
          I.jsx(At, { y: "xl" }),
          I.jsx(Pf, {
            target: "_blank",
            href: "https://ethereum.org/en/wallets/find-wallet/",
            style: { textAlign: "center" },
            children: "Learn more about wallets",
          }),
          " ",
        ],
      }),
    });
  },
  tq = ie.p`
  font-size: ${ke.md};
  color: ${(n) => n.theme.text.neutral};
  margin: 0;
`,
  Nl = { main: "main", getStarted: "getStarted" },
  nq = () => {
    const { theme: n, title: e } = C.useContext(_d),
      t = xw(),
      r = t.length === 1 && !t[0].selectUI ? t[0] : Nl.main,
      [a, i] = C.useState(r),
      s = JU(),
      o = XU(),
      c = ww(),
      l = bw(),
      u = C.useContext(_d),
      d = C.useContext(ny),
      f = vw(),
      p = C.useCallback(
        function () {
          (arguments.length > 0 && arguments[0] !== void 0
            ? arguments[0]
            : !0) && i(r),
            c === "connecting" && f(),
            o(!1);
        },
        [o, r, c, f],
      ),
      m = C.useCallback(() => {
        i(r);
      }, [i, r]),
      y = !!(l != null && l.getPersonalWallet()),
      h = typeof a != "string" && !!a.personalWallets,
      g = C.useRef(c);
    C.useEffect(() => {
      !y && h && !s && c === "connected" && g.current === "connecting" && o(!0),
        (g.current = c);
    }, [s, c, o, h, y]);
    const v = typeof a != "string" && (a.connectUI || ij);
    return I.jsx(Ww, {
      theme: typeof n == "object" ? n : n === "light" ? zw : jw,
      children: I.jsxs(NH, {
        style: { maxWidth: "480px" },
        open: s,
        setOpen: (w) => {
          o(w), w || i(r), c === "connecting" && f();
        },
        children: [
          a === Nl.main &&
            I.jsx(ZU, {
              title: e,
              walletConfigs: t,
              onGetStarted: () => {
                i(Nl.getStarted);
              },
              selectWallet: i,
            }),
          a === Nl.getStarted && I.jsx(eq, { onBack: m }),
          v &&
            I.jsx(v, {
              supportedWallets: t,
              theme: n,
              goBack: m,
              close: p,
              isOpen: s,
              open: () => {
                o(!0);
              },
              walletConfig: a,
              selectionData: u.data,
              setSelectionData: (w) => {
                d((T) => ({ ...T, data: w }));
              },
            }),
        ],
      }),
    });
  },
  Uq = (n) => {
    let { clientId: e, supportedWallets: t, theme: r, children: a, ...i } = n;
    const s = t || QU;
    return I.jsx(YU, {
      theme: r,
      children: I.jsx(Ww, {
        theme: r === "dark" ? jw : zw,
        children: I.jsxs(NF, {
          theme: r,
          clientId: e,
          supportedWallets: s,
          ...i,
          children: [a, I.jsx(nq, {})],
        }),
      }),
    });
  };
ie.div`
  display: flex;
  align-items: center;
  width: 130px;
  padding: ${he.xs};
`;
ie.div`
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background-color: ${(n) => n.theme.bg.highlighted};
  box-shadow:
    0 0 0 3px ${(n) => n.theme.bg.base},
    0 0 0 5px ${(n) => n.theme.bg.highlighted};

  &[data-active="true"] {
    background-color: ${(n) => n.theme.link.primary};
    box-shadow:
      0 0 0 3px ${(n) => n.theme.bg.base},
      0 0 0 5px ${(n) => n.theme.link.primary};

    position: relative;
    z-index: 2;
  }
`;
ie.div`
  flex-grow: 1;
  height: 4px;
  background-color: ${(n) => n.theme.bg.highlighted};
  &[data-active="true"] {
    background-color: ${(n) => n.theme.link.primary};
  }
`;
ie.p`
  font-size: ${ke.sm};
  color: ${(n) => n.theme.link.primary};
  text-align: right;
`;
ie.select`
  width: 100%;
  padding: ${he.sm};
  box-sizing: border-box;
  outline: none;
  border: none;
  border-radius: 6px;
  color: ${(n) => n.theme.text.neutral};
  background: transparent;
  font-size: ${ke.md};
  box-shadow: 0 0 0 1.5px ${(n) => n.theme.input.outline};
  appearance: none;

  &:focus {
    box-shadow: 0 0 0 2px ${(n) => n.theme.input.focusRing};
  }

  &:invalid {
    color: ${(n) => n.theme.text.secondary};
  }
  &[data-error="true"] {
    box-shadow: 0 0 0 1.5px ${(n) => n.theme.input.errorRing};
  }

  &[disabled] {
    opacity: 1;
    cursor: not-allowed;
  }
`;
ie(hU)`
  color: ${(n) => n.theme.icon.secondary};
`;
ie(jm)`
  display: flex;
  justify-content: flex-start;
  gap: ${he.md};
  font-size: ${ke.md};
  transition: background-color 0.2s ease;
  &:hover {
    background-color: ${(n) => n.theme.bg.elevatedHover};
  }
  &:active {
    box-shadow: none;
  }
`;
ie(AU)`
  color: ${(n) => n.theme.text.secondary};
  transition:
    transform 200ms ease,
    color 200ms ease;
`;
ie.div`
  border: 2px solid ${(n) => n.theme.bg.elevated};
  border-radius: ${st.md};
  padding: ${he.xl} ${he.md};
  display: flex;
  align-items: center;
  flex-direction: column;
  cursor: pointer;
  transition: border-color 200ms ease;

  &:hover,
  &[data-is-dragging="true"] {
    border-color: ${(n) => n.theme.link.primary};
    svg {
      color: ${(n) => n.theme.link.primary};
    }
  }

  &[data-error="true"] {
    border-color: ${(n) => n.theme.input.errorRing};
  }
`;
ie.p`
  color: ${(n) => n.theme.input.errorRing};
  font-size: ${ke.sm};
  margin: 0;
`;
ie.span`
  color: ${(n) => n.theme.text.secondary};
  font-size: ${ke.sm};
`;
ie.p`
  color: ${(n) => n.theme.text.neutral};
  font-size: ${ke.md};
  margin: 0;
  font-weight: 600;
`;
ie.p`
  font-size: ${ke.sm};
  margin: 0;
  color: ${(n) => n.theme.link.primary};
`;
function rq(n) {
  const [e, t] = C.useState([a(), a()]);
  let r = c5();
  function a() {
    return Ba.map((o) => {});
  }
  async function i() {
    let o = "thirdweb";
    n.status === "connected" && n.address && (o = "metamask");
    const c = new o5(o),
      l = n.address ? await s(c, n.address) : a(),
      u = r ? await s(c, r) : a();
    t([l, u]);
  }
  async function s(o, c) {
    const l = Ba.map((d) => d.address);
    return await Promise.all(l.map((d) => o.getBalanceToken(d, c)));
  }
  return (
    C.useEffect(() => {
      i();
    }, [r]),
    { balances: e, fetchBalances: i }
  );
}
function aq(n) {
  const [e, t] = C.useState([r(), r()]);
  function r() {
    return Ba.map((i) => {});
  }
  async function a() {
    let i = "thirdweb";
    n.status === "connected" && n.address && (i = "metamask");
    const s = new s5(i),
      o = Ba.map((l) => [
        l.address ? l.address : s.WETH_CONTRACT_ADDRESS,
        l.decimals,
      ]),
      c = await Promise.all(
        o.map((l) => s.getUSDCPriceForToken(l[0], l[1], 6)),
      );
    t(c);
  }
  return (
    C.useEffect(() => {
      a();
    }, []),
    { prices: e, fetchPrices: a }
  );
}
const jq = ({
    priceUSD: n,
    userId: e,
    info: t,
    transInfoArg: r,
    disabled: a,
  }) => {
    let i = c5();
    const [s, o] = C.useState(""),
      [c, l] = C.useState(-1),
      u = {
        connect: vf(),
        disconnect: vw(),
        config: S4(),
        address: LF(),
        status: ww(),
      };
    console.log("MetaMask status: " + u.status),
      console.log("MetaMask address: " + u.address);
    const { balances: d, fetchBalances: f } = rq(u),
      { prices: p, fetchPrices: m } = aq(u),
      {
        setInfoMessage: y,
        setErrorMessage: h,
        clearMessages: g,
      } = C.useContext(C2),
      v = new A2();
    C.useEffect(() => {
      g();
    }, []),
      C.useEffect(() => {
        m(), f(), u.status === "connected" && u.address && w();
      }, [u.status, u.address]);
    async function w() {
      await v.registerWalletAddress(u.address);
    }
    async function T(A, E) {
      if (!(n > 0)) {
        h("Invalid price!");
        return;
      }
      if (!e) {
        h("Invalid user id!");
        return;
      }
      const _ = Ba[1].address,
        S = 1;
      if (A === "metamask") {
        const W = new o5(A),
          D = await v.getHierarchy(e);
        console.log(D);
        const L = await W.callDepositContract(
          wo(D.sellerAddress),
          wo(D.affiliateAddress),
          wo(D.brokerAddress),
          wo(D.seniorBrokerAddress),
          wo(D.leaderAddress),
          _,
          n,
        );
        if (L) {
          (L.quantity = S), (L.totalPrice = n), W.convertBigIntToString(L);
          const G = await v.setTransactionInfo(L, u.address, r);
          y(
            G
              ? "Transaction successful!"
              : "Transaction successfull but could not send transaction info!",
          );
        } else h("Transaction failed!");
      } else if (A === "internal") {
        const W = await v.makePayment(null, n, S, s, _, r);
        W === "insufficientFunds"
          ? h("Transaction failed! Insufficient funds.")
          : W
          ? y("Transaction successful!")
          : h("Transaction failed!");
      }
    }
    return I.jsxs("div", {
      className: Fe.container,
      children: [
        I.jsx(n5, {}),
        I.jsx("div", { className: Fe.infoWrapper, children: t }),
        a &&
          I.jsx("div", {
            className: `card ${Fe.productBuy}`,
            children: I.jsx("div", {
              className: Fe.body,
              children: I.jsx(Cp, {
                title: "Buy product",
                description: "This product is currently unavailable.",
              }),
            }),
          }),
        !a &&
          I.jsx("div", {
            className: `card ${Fe.productBuy}`,
            children: I.jsxs("div", {
              className: Fe.body,
              children: [
                I.jsx(Cp, {
                  title: "Buy product",
                  description:
                    "You can buy this product using MetaMask or Nefentus Wallet, in case you have a Nefentus account.",
                }),
                I.jsx(d7, {
                  tabIds: ["internal", "metamask"],
                  initActiveTab: "internal",
                  getHeader: (A) => {
                    if (A === "metamask")
                      return I.jsxs(I.Fragment, {
                        children: [
                          I.jsx("img", {
                            src: M7,
                            className: Fe.tabNavLogo,
                            alt: "MetaMask Wallet",
                          }),
                          " ",
                          "MetaMask",
                        ],
                      });
                    if (A === "internal")
                      return I.jsxs(I.Fragment, {
                        children: [
                          I.jsx("img", {
                            src: R7,
                            className: Fe.tabNavLogo,
                            alt: "Nefentus Wallet",
                          }),
                          " ",
                          "Nefentus Wallet",
                        ],
                      });
                  },
                  getBody: (A) => {
                    if (A === "metamask")
                      return I.jsxs("div", {
                        className: Fe.tabContent,
                        children: [
                          u.status === "connected" &&
                            I.jsx("div", {
                              className: Fe.table,
                              children: Ba.map((E, _) =>
                                I.jsx(
                                  v2,
                                  {
                                    currency: E,
                                    balance: d[0][_],
                                    price: p[_],
                                    priceProduct: n,
                                    onClick: () => {
                                      T("metamask");
                                    },
                                  },
                                  E.abbr,
                                ),
                              ),
                            }),
                          u.status === "disconnected" &&
                            I.jsx("div", {
                              className: Fe.center,
                              children: I.jsx(aa, {
                                className: Fe.metamaskConnectButton,
                                onClick: () =>
                                  u.connect(u.config, { chainId: 1 }),
                                children: "Connect to MetaMask",
                              }),
                            }),
                          u.status === "unknown" &&
                            I.jsx("div", {
                              className: Fe.center,
                              children: I.jsx(aa, {
                                className: Fe.metamaskConnectButton,
                                disabled: !0,
                                children: "MetaMask is not available!",
                              }),
                            }),
                          u.status === "connecting" &&
                            I.jsx("div", {
                              className: Fe.center,
                              children: I.jsx(aa, {
                                className: Fe.metamaskConnectButton,
                                disabled: !0,
                                children: "Connecting...",
                              }),
                            }),
                        ],
                      });
                    if (A === "internal")
                      return I.jsxs("div", {
                        className: Fe.tabContent,
                        children: [
                          !i &&
                            I.jsx("div", {
                              className: Fe.center,
                              children: I.jsx(aa, {
                                className: Fe.nefentusLoginButton,
                                onClick: () => {},
                                children: "Login to Nefentus",
                              }),
                            }),
                          i &&
                            I.jsx("div", {
                              className: Fe.table,
                              children: Ba.map((E, _) =>
                                I.jsx(
                                  v2,
                                  {
                                    currency: E,
                                    balance: d[1][_],
                                    price: p[_],
                                    priceProduct: n,
                                    onClick: () => {
                                      l(_);
                                    },
                                  },
                                  E.abbr,
                                ),
                              ),
                            }),
                        ],
                      });
                  },
                  beforeChangeTab: () => {},
                }),
              ],
            }),
          }),
        c >= 0 &&
          I.jsx(iq, {
            price: n,
            currencyAbbr: Ba[c].abbr,
            onClose: () => l(-1),
            onPay: () => T("internal"),
            password: s,
            setPassword: o,
          }),
      ],
    });
  },
  v2 = ({ balance: n, price: e, currency: t, priceProduct: r, onClick: a }) => {
    let i = "loading",
      s = "loading";
    n && ((i = n), e && (s = n * e));
    let o = !1;
    return (
      s && (o = s > r && t.abbr === "ETH"),
      I.jsxs("div", {
        className: Fe.line,
        children: [
          I.jsxs("div", {
            className: Fe.lineLeft,
            children: [
              I.jsx("img", { src: t.icon, className: Fe.icon, alt: "" }),
              I.jsxs("div", {
                children: [
                  I.jsx("p", { className: Fe.name, children: t.name }),
                  I.jsx("p", { className: Fe.abbr, children: t.abbr }),
                ],
              }),
            ],
          }),
          I.jsxs("div", {
            className: Fe.amounts,
            children: [
              I.jsxs("p", {
                className: Fe.dollar,
                children: ["≈ ", R8(s), " USD"],
              }),
              I.jsxs("p", {
                className: Fe.crypto,
                children: [M8(i, t.decimals), " ", t.abbr],
              }),
            ],
          }),
          I.jsx("div", {
            className: Fe.actions,
            children:
              o &&
              I.jsx(aa, {
                className: Fe.buyButton,
                onClick: a,
                color: "white",
                children: "Pay",
              }),
          }),
        ],
      })
    );
  },
  iq = ({
    price: n,
    currencyAbbr: e,
    onClose: t,
    onPay: r,
    password: a,
    setPassword: i,
  }) =>
    I.jsx(I7, {
      children: I.jsxs("div", {
        className: Fe.modal,
        children: [
          I.jsx(n5, {}),
          I.jsx(Cp, {
            title: "Password",
            description:
              "Type in your password to pay with your Nefentus wallet",
          }),
          I.jsx(w7, {
            data: [
              ["Amount:", `${n} USD`],
              ["Currency:", e],
            ],
            colSizes: [1, 3],
          }),
          I.jsx("div", {
            className: Fe.modalInputs,
            children: I.jsx(B8, {
              label: "Password",
              placeholder: "Enter password",
              dashboard: !0,
              value: a,
              setState: i,
              secure: !0,
            }),
          }),
          I.jsxs("div", {
            className: Fe.modalButtons,
            children: [
              I.jsx(aa, { onClick: t, color: "black", children: "Close" }),
              I.jsx(aa, { onClick: r, color: "white", children: "Pay" }),
            ],
          }),
        ],
      }),
    });
export {
  dO as $,
  mt as A,
  ne as B,
  Ix as C,
  EO as D,
  lw as E,
  zO as F,
  gf as G,
  oO as H,
  ec as I,
  vq as J,
  ce as K,
  xq as L,
  te as M,
  po as N,
  Tq as O,
  wq as P,
  vd as Q,
  jq as R,
  qt as S,
  Cp as T,
  ch as U,
  rr as V,
  jh as W,
  ei as X,
  Xn as Y,
  mf as Z,
  Xr as _,
  Uq as a,
  rf as a0,
  ff as a1,
  pf as a2,
  Pt as a3,
  yn as a4,
  Jc as a5,
  Ja as a6,
  Cq as a7,
  On as a8,
  bq as a9,
  oN as aA,
  IO as aB,
  tb as aC,
  VR as aD,
  gq as aE,
  FD as aF,
  Gd as aG,
  _t as aH,
  sf as aI,
  Cn as aJ,
  at as aK,
  sN as aL,
  DO as aM,
  cN as aN,
  eN as aO,
  FO as aP,
  OD as aQ,
  GO as aR,
  wn as aS,
  KS as aT,
  VS as aU,
  YS as aV,
  lF as aW,
  la as aX,
  Gc as aY,
  eT as aZ,
  Aq as a_,
  H0 as aa,
  Qv as ab,
  $v as ac,
  Ko as ad,
  Ru as ae,
  xe as af,
  fe as ag,
  fO as ah,
  hO as ai,
  yO as aj,
  ad as ak,
  id as al,
  sd as am,
  lN as an,
  rN as ao,
  Em as ap,
  WO as aq,
  QD as ar,
  uO as as,
  oe as at,
  eO as au,
  mn as av,
  Nv as aw,
  Mv as ax,
  kv as ay,
  Fu as az,
  Ji as b,
  Ql as c,
  Je as d,
  pw as e,
  Cd as f,
  hw as g,
  Gs as h,
  oi as i,
  Pe as j,
  Dt as k,
  _s as l,
  S4 as m,
  bb as n,
  bD as o,
  xD as p,
  vD as q,
  PD as r,
  Xc as s,
  cf as t,
  gO as u,
  yf as v,
  $i as w,
  vO as x,
  Do as y,
  Y as z,
};
